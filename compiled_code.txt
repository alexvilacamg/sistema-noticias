ESTRUTURA DO DIRETÓRIO:
================================================================================

├── .gitignore
├── README.md
├── background_scrape.php
├── compile_code.py
├── compiled_code.txt
├── composer.json
├── composer.lock
├── config
│   ├── config.php
│   └── scrapers_config.php
├── public
│   ├── api
│   │   ├── force_update.php
│   │   └── news.php
│   ├── assets
│   │   ├── css
│   │   │   ├── cards.css
│   │   │   ├── dark-mode.css
│   │   │   ├── logs.css
│   │   │   ├── main.css
│   │   │   └── table.css
│   │   └── js
│   │       ├── dark-mode.js
│   │       ├── logs.js
│   │       ├── main.js
│   │       ├── scraper.js
│   │       └── view-switcher.js
│   ├── css
│   │   └── style.css
│   ├── index.php
│   └── js
│       └── script.js
├── src
│   └── App
│       ├── Controllers
│       │   └── NewsController.php
│       ├── Factories
│       │   └── ScraperFactory.php
│       ├── Models
│       │   ├── AbstractNewsScraper.php
│       │   ├── FolhaScraper.php
│       │   ├── G1Scraper.php
│       │   ├── NewsScraperInterface.php
│       │   ├── Scraper.php
│       │   └── UOLScraper.php
│       ├── Utils
│       │   └── HttpClient.php
│       └── Views
│           └── index.php
└── vendor
    ├── autoload.php
    ├── composer
    │   ├── ClassLoader.php
    │   ├── InstalledVersions.php
    │   ├── LICENSE
    │   ├── autoload_classmap.php
    │   ├── autoload_files.php
    │   ├── autoload_namespaces.php
    │   ├── autoload_psr4.php
    │   ├── autoload_real.php
    │   ├── autoload_static.php
    │   ├── installed.json
    │   ├── installed.php
    │   └── platform_check.php
    └── predis
        └── predis
            ├── .codespellrc
            ├── .coveralls.yml
            ├── .editorconfig
            ├── .gitattributes
            ├── .github
            │   ├── CODEOWNERS
            │   ├── CODE_OF_CONDUCT.md
            │   ├── FUNDING.yml
            │   ├── ISSUE_TEMPLATE
            │   │   ├── bug_report.md
            │   │   └── feature_request.md
            │   ├── release-drafter-config.yml
            │   └── workflows
            │       ├── README.md
            │       ├── cluster
            │       │   ├── Dockerfile
            │       │   ├── create_cluster.sh
            │       │   ├── docker-compose.yml
            │       │   └── redis.conf
            │       ├── linters.yml
            │       ├── release-drafter.yml
            │       ├── stack.yml
            │       └── tests.yml
            ├── .gitignore
            ├── .php-cs-fixer.dist.php
            ├── CHANGELOG.md
            ├── FAQ.md
            ├── LICENSE
            ├── README.md
            ├── VERSION
            ├── autoload.php
            ├── bin
            │   └── create-command-test
            ├── composer.json
            ├── examples
            │   ├── Commands
            │   │   ├── Json
            │   │   │   └── json_debug_memory.php
            │   │   ├── Search
            │   │   │   ├── ft_aggregate.php
            │   │   │   ├── ft_alter.php
            │   │   │   ├── ft_config_help.php
            │   │   │   ├── ft_config_set_get.php
            │   │   │   ├── ft_cursor_del.php
            │   │   │   ├── ft_cursor_read.php
            │   │   │   ├── ft_explain.php
            │   │   │   ├── ft_profile.php
            │   │   │   ├── ft_spellcheck.php
            │   │   │   ├── ft_sug_add_get_del_len.php
            │   │   │   ├── ft_syndump.php
            │   │   │   ├── ft_synupdate.php
            │   │   │   └── ft_tagvals.php
            │   │   ├── TimeSeries
            │   │   │   ├── ts_add.php
            │   │   │   ├── ts_alter.php
            │   │   │   ├── ts_create.php
            │   │   │   ├── ts_createrule.php
            │   │   │   ├── ts_decrby.php
            │   │   │   ├── ts_del.php
            │   │   │   ├── ts_deleterule.php
            │   │   │   ├── ts_get.php
            │   │   │   ├── ts_incrby.php
            │   │   │   ├── ts_info.php
            │   │   │   ├── ts_madd.php
            │   │   │   ├── ts_mget.php
            │   │   │   ├── ts_mrange.php
            │   │   │   ├── ts_mrevrange.php
            │   │   │   ├── ts_queryindex.php
            │   │   │   ├── ts_range.php
            │   │   │   └── ts_revrange.php
            │   │   ├── acl_dry_run.php
            │   │   ├── acl_get_user.php
            │   │   ├── acl_set_user.php
            │   │   ├── fcall_ro.php
            │   │   └── waitaof.php
            │   ├── custom_cluster_distributor.php
            │   ├── debuggable_connection.php
            │   ├── dispatcher_loop.php
            │   ├── executing_redis_commands.php
            │   ├── key_prefixing.php
            │   ├── lua_scripting_abstraction.php
            │   ├── monitor_consumer.php
            │   ├── pipelining_commands.php
            │   ├── pubsub_consumer.php
            │   ├── redis_collections_iterators.php
            │   ├── relay_compression.php
            │   ├── relay_connection.php
            │   ├── relay_events.php
            │   ├── relay_pubsub_consumer.php
            │   ├── replication_complex.php
            │   ├── replication_sentinel.php
            │   ├── replication_simple.php
            │   ├── session_handler.php
            │   ├── shared.php
            │   └── transaction_using_cas.php
            ├── phpstan-tests.dist.neon
            ├── phpstan.dist.neon
            ├── phpunit.relay.xml
            ├── phpunit.xml.dist
            ├── src
            │   ├── Autoloader.php
            │   ├── Client.php
            │   ├── ClientConfiguration.php
            │   ├── ClientContextInterface.php
            │   ├── ClientException.php
            │   ├── ClientInterface.php
            │   ├── Cluster
            │   │   ├── ClusterStrategy.php
            │   │   ├── Distributor
            │   │   │   ├── DistributorInterface.php
            │   │   │   ├── EmptyRingException.php
            │   │   │   ├── HashRing.php
            │   │   │   └── KetamaRing.php
            │   │   ├── Hash
            │   │   │   ├── CRC16.php
            │   │   │   ├── HashGeneratorInterface.php
            │   │   │   └── PhpiredisCRC16.php
            │   │   ├── PredisStrategy.php
            │   │   ├── RedisStrategy.php
            │   │   ├── SlotMap.php
            │   │   └── StrategyInterface.php
            │   ├── Collection
            │   │   └── Iterator
            │   │       ├── CursorBasedIterator.php
            │   │       ├── HashKey.php
            │   │       ├── Keyspace.php
            │   │       ├── ListKey.php
            │   │       ├── SetKey.php
            │   │       └── SortedSetKey.php
            │   ├── Command
            │   │   ├── Argument
            │   │   │   ├── ArrayableArgument.php
            │   │   │   ├── Geospatial
            │   │   │   │   ├── AbstractBy.php
            │   │   │   │   ├── ByBox.php
            │   │   │   │   ├── ByInterface.php
            │   │   │   │   ├── ByRadius.php
            │   │   │   │   ├── FromInterface.php
            │   │   │   │   ├── FromLonLat.php
            │   │   │   │   └── FromMember.php
            │   │   │   ├── Search
            │   │   │   │   ├── AggregateArguments.php
            │   │   │   │   ├── AlterArguments.php
            │   │   │   │   ├── CommonArguments.php
            │   │   │   │   ├── CreateArguments.php
            │   │   │   │   ├── CursorArguments.php
            │   │   │   │   ├── DropArguments.php
            │   │   │   │   ├── ExplainArguments.php
            │   │   │   │   ├── ProfileArguments.php
            │   │   │   │   ├── SchemaFields
            │   │   │   │   │   ├── AbstractField.php
            │   │   │   │   │   ├── FieldInterface.php
            │   │   │   │   │   ├── GeoField.php
            │   │   │   │   │   ├── GeoShapeField.php
            │   │   │   │   │   ├── NumericField.php
            │   │   │   │   │   ├── TagField.php
            │   │   │   │   │   ├── TextField.php
            │   │   │   │   │   └── VectorField.php
            │   │   │   │   ├── SearchArguments.php
            │   │   │   │   ├── SpellcheckArguments.php
            │   │   │   │   ├── SugAddArguments.php
            │   │   │   │   ├── SugGetArguments.php
            │   │   │   │   └── SynUpdateArguments.php
            │   │   │   ├── Server
            │   │   │   │   ├── LimitInterface.php
            │   │   │   │   ├── LimitOffsetCount.php
            │   │   │   │   └── To.php
            │   │   │   └── TimeSeries
            │   │   │       ├── AddArguments.php
            │   │   │       ├── AlterArguments.php
            │   │   │       ├── CommonArguments.php
            │   │   │       ├── CreateArguments.php
            │   │   │       ├── DecrByArguments.php
            │   │   │       ├── GetArguments.php
            │   │   │       ├── IncrByArguments.php
            │   │   │       ├── InfoArguments.php
            │   │   │       ├── MGetArguments.php
            │   │   │       ├── MRangeArguments.php
            │   │   │       └── RangeArguments.php
            │   │   ├── Command.php
            │   │   ├── CommandInterface.php
            │   │   ├── Factory.php
            │   │   ├── FactoryInterface.php
            │   │   ├── PrefixableCommandInterface.php
            │   │   ├── Processor
            │   │   │   ├── KeyPrefixProcessor.php
            │   │   │   ├── ProcessorChain.php
            │   │   │   └── ProcessorInterface.php
            │   │   ├── RawCommand.php
            │   │   ├── RawFactory.php
            │   │   ├── Redis
            │   │   │   ├── ACL.php
            │   │   │   ├── APPEND.php
            │   │   │   ├── AUTH.php
            │   │   │   ├── AbstractCommand
            │   │   │   │   └── BZPOPBase.php
            │   │   │   ├── BGREWRITEAOF.php
            │   │   │   ├── BGSAVE.php
            │   │   │   ├── BITCOUNT.php
            │   │   │   ├── BITFIELD.php
            │   │   │   ├── BITOP.php
            │   │   │   ├── BITPOS.php
            │   │   │   ├── BLMOVE.php
            │   │   │   ├── BLMPOP.php
            │   │   │   ├── BLPOP.php
            │   │   │   ├── BRPOP.php
            │   │   │   ├── BRPOPLPUSH.php
            │   │   │   ├── BZMPOP.php
            │   │   │   ├── BZPOPMAX.php
            │   │   │   ├── BZPOPMIN.php
            │   │   │   ├── BloomFilter
            │   │   │   │   ├── BFADD.php
            │   │   │   │   ├── BFEXISTS.php
            │   │   │   │   ├── BFINFO.php
            │   │   │   │   ├── BFINSERT.php
            │   │   │   │   ├── BFLOADCHUNK.php
            │   │   │   │   ├── BFMADD.php
            │   │   │   │   ├── BFMEXISTS.php
            │   │   │   │   ├── BFRESERVE.php
            │   │   │   │   └── BFSCANDUMP.php
            │   │   │   ├── CLIENT.php
            │   │   │   ├── CLUSTER.php
            │   │   │   ├── COMMAND.php
            │   │   │   ├── CONFIG.php
            │   │   │   ├── COPY.php
            │   │   │   ├── Container
            │   │   │   │   ├── ACL.php
            │   │   │   │   ├── AbstractContainer.php
            │   │   │   │   ├── CLUSTER.php
            │   │   │   │   ├── ContainerFactory.php
            │   │   │   │   ├── ContainerInterface.php
            │   │   │   │   ├── FunctionContainer.php
            │   │   │   │   ├── Json
            │   │   │   │   │   └── JSONDEBUG.php
            │   │   │   │   └── Search
            │   │   │   │       ├── FTCONFIG.php
            │   │   │   │       └── FTCURSOR.php
            │   │   │   ├── CountMinSketch
            │   │   │   │   ├── CMSINCRBY.php
            │   │   │   │   ├── CMSINFO.php
            │   │   │   │   ├── CMSINITBYDIM.php
            │   │   │   │   ├── CMSINITBYPROB.php
            │   │   │   │   ├── CMSMERGE.php
            │   │   │   │   └── CMSQUERY.php
            │   │   │   ├── CuckooFilter
            │   │   │   │   ├── CFADD.php
            │   │   │   │   ├── CFADDNX.php
            │   │   │   │   ├── CFCOUNT.php
            │   │   │   │   ├── CFDEL.php
            │   │   │   │   ├── CFEXISTS.php
            │   │   │   │   ├── CFINFO.php
            │   │   │   │   ├── CFINSERT.php
            │   │   │   │   ├── CFINSERTNX.php
            │   │   │   │   ├── CFLOADCHUNK.php
            │   │   │   │   ├── CFMEXISTS.php
            │   │   │   │   ├── CFRESERVE.php
            │   │   │   │   └── CFSCANDUMP.php
            │   │   │   ├── DBSIZE.php
            │   │   │   ├── DECR.php
            │   │   │   ├── DECRBY.php
            │   │   │   ├── DEL.php
            │   │   │   ├── DISCARD.php
            │   │   │   ├── DUMP.php
            │   │   │   ├── ECHO_.php
            │   │   │   ├── EVALSHA.php
            │   │   │   ├── EVALSHA_RO.php
            │   │   │   ├── EVAL_.php
            │   │   │   ├── EVAL_RO.php
            │   │   │   ├── EXEC.php
            │   │   │   ├── EXISTS.php
            │   │   │   ├── EXPIRE.php
            │   │   │   ├── EXPIREAT.php
            │   │   │   ├── EXPIRETIME.php
            │   │   │   ├── FAILOVER.php
            │   │   │   ├── FCALL.php
            │   │   │   ├── FCALL_RO.php
            │   │   │   ├── FLUSHALL.php
            │   │   │   ├── FLUSHDB.php
            │   │   │   ├── FUNCTIONS.php
            │   │   │   ├── GEOADD.php
            │   │   │   ├── GEODIST.php
            │   │   │   ├── GEOHASH.php
            │   │   │   ├── GEOPOS.php
            │   │   │   ├── GEORADIUS.php
            │   │   │   ├── GEORADIUSBYMEMBER.php
            │   │   │   ├── GEOSEARCH.php
            │   │   │   ├── GEOSEARCHSTORE.php
            │   │   │   ├── GET.php
            │   │   │   ├── GETBIT.php
            │   │   │   ├── GETDEL.php
            │   │   │   ├── GETEX.php
            │   │   │   ├── GETRANGE.php
            │   │   │   ├── GETSET.php
            │   │   │   ├── HDEL.php
            │   │   │   ├── HEXISTS.php
            │   │   │   ├── HEXPIRE.php
            │   │   │   ├── HEXPIREAT.php
            │   │   │   ├── HEXPIRETIME.php
            │   │   │   ├── HGET.php
            │   │   │   ├── HGETALL.php
            │   │   │   ├── HINCRBY.php
            │   │   │   ├── HINCRBYFLOAT.php
            │   │   │   ├── HKEYS.php
            │   │   │   ├── HLEN.php
            │   │   │   ├── HMGET.php
            │   │   │   ├── HMSET.php
            │   │   │   ├── HPERSIST.php
            │   │   │   ├── HPEXPIRE.php
            │   │   │   ├── HPEXPIREAT.php
            │   │   │   ├── HPEXPIRETIME.php
            │   │   │   ├── HPTTL.php
            │   │   │   ├── HRANDFIELD.php
            │   │   │   ├── HSCAN.php
            │   │   │   ├── HSET.php
            │   │   │   ├── HSETNX.php
            │   │   │   ├── HSTRLEN.php
            │   │   │   ├── HTTL.php
            │   │   │   ├── HVALS.php
            │   │   │   ├── INCR.php
            │   │   │   ├── INCRBY.php
            │   │   │   ├── INCRBYFLOAT.php
            │   │   │   ├── INFO.php
            │   │   │   ├── Json
            │   │   │   │   ├── JSONARRAPPEND.php
            │   │   │   │   ├── JSONARRINDEX.php
            │   │   │   │   ├── JSONARRINSERT.php
            │   │   │   │   ├── JSONARRLEN.php
            │   │   │   │   ├── JSONARRPOP.php
            │   │   │   │   ├── JSONARRTRIM.php
            │   │   │   │   ├── JSONCLEAR.php
            │   │   │   │   ├── JSONDEBUG.php
            │   │   │   │   ├── JSONDEL.php
            │   │   │   │   ├── JSONFORGET.php
            │   │   │   │   ├── JSONGET.php
            │   │   │   │   ├── JSONMERGE.php
            │   │   │   │   ├── JSONMGET.php
            │   │   │   │   ├── JSONMSET.php
            │   │   │   │   ├── JSONNUMINCRBY.php
            │   │   │   │   ├── JSONOBJKEYS.php
            │   │   │   │   ├── JSONOBJLEN.php
            │   │   │   │   ├── JSONRESP.php
            │   │   │   │   ├── JSONSET.php
            │   │   │   │   ├── JSONSTRAPPEND.php
            │   │   │   │   ├── JSONSTRLEN.php
            │   │   │   │   ├── JSONTOGGLE.php
            │   │   │   │   └── JSONTYPE.php
            │   │   │   ├── KEYS.php
            │   │   │   ├── LASTSAVE.php
            │   │   │   ├── LCS.php
            │   │   │   ├── LINDEX.php
            │   │   │   ├── LINSERT.php
            │   │   │   ├── LLEN.php
            │   │   │   ├── LMOVE.php
            │   │   │   ├── LMPOP.php
            │   │   │   ├── LPOP.php
            │   │   │   ├── LPUSH.php
            │   │   │   ├── LPUSHX.php
            │   │   │   ├── LRANGE.php
            │   │   │   ├── LREM.php
            │   │   │   ├── LSET.php
            │   │   │   ├── LTRIM.php
            │   │   │   ├── MGET.php
            │   │   │   ├── MIGRATE.php
            │   │   │   ├── MONITOR.php
            │   │   │   ├── MOVE.php
            │   │   │   ├── MSET.php
            │   │   │   ├── MSETNX.php
            │   │   │   ├── MULTI.php
            │   │   │   ├── OBJECT_.php
            │   │   │   ├── PERSIST.php
            │   │   │   ├── PEXPIRE.php
            │   │   │   ├── PEXPIREAT.php
            │   │   │   ├── PEXPIRETIME.php
            │   │   │   ├── PFADD.php
            │   │   │   ├── PFCOUNT.php
            │   │   │   ├── PFMERGE.php
            │   │   │   ├── PING.php
            │   │   │   ├── PSETEX.php
            │   │   │   ├── PSUBSCRIBE.php
            │   │   │   ├── PTTL.php
            │   │   │   ├── PUBLISH.php
            │   │   │   ├── PUBSUB.php
            │   │   │   ├── PUNSUBSCRIBE.php
            │   │   │   ├── QUIT.php
            │   │   │   ├── RANDOMKEY.php
            │   │   │   ├── RENAME.php
            │   │   │   ├── RENAMENX.php
            │   │   │   ├── RESTORE.php
            │   │   │   ├── RPOP.php
            │   │   │   ├── RPOPLPUSH.php
            │   │   │   ├── RPUSH.php
            │   │   │   ├── RPUSHX.php
            │   │   │   ├── SADD.php
            │   │   │   ├── SAVE.php
            │   │   │   ├── SCAN.php
            │   │   │   ├── SCARD.php
            │   │   │   ├── SCRIPT.php
            │   │   │   ├── SDIFF.php
            │   │   │   ├── SDIFFSTORE.php
            │   │   │   ├── SELECT.php
            │   │   │   ├── SENTINEL.php
            │   │   │   ├── SET.php
            │   │   │   ├── SETBIT.php
            │   │   │   ├── SETEX.php
            │   │   │   ├── SETNX.php
            │   │   │   ├── SETRANGE.php
            │   │   │   ├── SHUTDOWN.php
            │   │   │   ├── SINTER.php
            │   │   │   ├── SINTERCARD.php
            │   │   │   ├── SINTERSTORE.php
            │   │   │   ├── SISMEMBER.php
            │   │   │   ├── SLAVEOF.php
            │   │   │   ├── SLOWLOG.php
            │   │   │   ├── SMEMBERS.php
            │   │   │   ├── SMISMEMBER.php
            │   │   │   ├── SMOVE.php
            │   │   │   ├── SORT.php
            │   │   │   ├── SORT_RO.php
            │   │   │   ├── SPOP.php
            │   │   │   ├── SRANDMEMBER.php
            │   │   │   ├── SREM.php
            │   │   │   ├── SSCAN.php
            │   │   │   ├── STRLEN.php
            │   │   │   ├── SUBSCRIBE.php
            │   │   │   ├── SUBSTR.php
            │   │   │   ├── SUNION.php
            │   │   │   ├── SUNIONSTORE.php
            │   │   │   ├── Search
            │   │   │   │   ├── FTAGGREGATE.php
            │   │   │   │   ├── FTALIASADD.php
            │   │   │   │   ├── FTALIASDEL.php
            │   │   │   │   ├── FTALIASUPDATE.php
            │   │   │   │   ├── FTALTER.php
            │   │   │   │   ├── FTCONFIG.php
            │   │   │   │   ├── FTCREATE.php
            │   │   │   │   ├── FTCURSOR.php
            │   │   │   │   ├── FTDICTADD.php
            │   │   │   │   ├── FTDICTDEL.php
            │   │   │   │   ├── FTDICTDUMP.php
            │   │   │   │   ├── FTDROPINDEX.php
            │   │   │   │   ├── FTEXPLAIN.php
            │   │   │   │   ├── FTINFO.php
            │   │   │   │   ├── FTPROFILE.php
            │   │   │   │   ├── FTSEARCH.php
            │   │   │   │   ├── FTSPELLCHECK.php
            │   │   │   │   ├── FTSUGADD.php
            │   │   │   │   ├── FTSUGDEL.php
            │   │   │   │   ├── FTSUGGET.php
            │   │   │   │   ├── FTSUGLEN.php
            │   │   │   │   ├── FTSYNDUMP.php
            │   │   │   │   ├── FTSYNUPDATE.php
            │   │   │   │   └── FTTAGVALS.php
            │   │   │   ├── TDigest
            │   │   │   │   ├── TDIGESTADD.php
            │   │   │   │   ├── TDIGESTBYRANK.php
            │   │   │   │   ├── TDIGESTBYREVRANK.php
            │   │   │   │   ├── TDIGESTCDF.php
            │   │   │   │   ├── TDIGESTCREATE.php
            │   │   │   │   ├── TDIGESTINFO.php
            │   │   │   │   ├── TDIGESTMAX.php
            │   │   │   │   ├── TDIGESTMERGE.php
            │   │   │   │   ├── TDIGESTMIN.php
            │   │   │   │   ├── TDIGESTQUANTILE.php
            │   │   │   │   ├── TDIGESTRANK.php
            │   │   │   │   ├── TDIGESTRESET.php
            │   │   │   │   ├── TDIGESTREVRANK.php
            │   │   │   │   └── TDIGESTTRIMMED_MEAN.php
            │   │   │   ├── TIME.php
            │   │   │   ├── TOUCH.php
            │   │   │   ├── TTL.php
            │   │   │   ├── TYPE.php
            │   │   │   ├── TimeSeries
            │   │   │   │   ├── TSADD.php
            │   │   │   │   ├── TSALTER.php
            │   │   │   │   ├── TSCREATE.php
            │   │   │   │   ├── TSCREATERULE.php
            │   │   │   │   ├── TSDECRBY.php
            │   │   │   │   ├── TSDEL.php
            │   │   │   │   ├── TSDELETERULE.php
            │   │   │   │   ├── TSGET.php
            │   │   │   │   ├── TSINCRBY.php
            │   │   │   │   ├── TSINFO.php
            │   │   │   │   ├── TSMADD.php
            │   │   │   │   ├── TSMGET.php
            │   │   │   │   ├── TSMRANGE.php
            │   │   │   │   ├── TSMREVRANGE.php
            │   │   │   │   ├── TSQUERYINDEX.php
            │   │   │   │   ├── TSRANGE.php
            │   │   │   │   └── TSREVRANGE.php
            │   │   │   ├── TopK
            │   │   │   │   ├── TOPKADD.php
            │   │   │   │   ├── TOPKINCRBY.php
            │   │   │   │   ├── TOPKINFO.php
            │   │   │   │   ├── TOPKLIST.php
            │   │   │   │   ├── TOPKQUERY.php
            │   │   │   │   └── TOPKRESERVE.php
            │   │   │   ├── UNSUBSCRIBE.php
            │   │   │   ├── UNWATCH.php
            │   │   │   ├── WAITAOF.php
            │   │   │   ├── WATCH.php
            │   │   │   ├── XADD.php
            │   │   │   ├── XDEL.php
            │   │   │   ├── XLEN.php
            │   │   │   ├── XRANGE.php
            │   │   │   ├── XREAD.php
            │   │   │   ├── XREVRANGE.php
            │   │   │   ├── XTRIM.php
            │   │   │   ├── ZADD.php
            │   │   │   ├── ZCARD.php
            │   │   │   ├── ZCOUNT.php
            │   │   │   ├── ZDIFF.php
            │   │   │   ├── ZDIFFSTORE.php
            │   │   │   ├── ZINCRBY.php
            │   │   │   ├── ZINTER.php
            │   │   │   ├── ZINTERCARD.php
            │   │   │   ├── ZINTERSTORE.php
            │   │   │   ├── ZLEXCOUNT.php
            │   │   │   ├── ZMPOP.php
            │   │   │   ├── ZMSCORE.php
            │   │   │   ├── ZPOPMAX.php
            │   │   │   ├── ZPOPMIN.php
            │   │   │   ├── ZRANDMEMBER.php
            │   │   │   ├── ZRANGE.php
            │   │   │   ├── ZRANGEBYLEX.php
            │   │   │   ├── ZRANGEBYSCORE.php
            │   │   │   ├── ZRANGESTORE.php
            │   │   │   ├── ZRANK.php
            │   │   │   ├── ZREM.php
            │   │   │   ├── ZREMRANGEBYLEX.php
            │   │   │   ├── ZREMRANGEBYRANK.php
            │   │   │   ├── ZREMRANGEBYSCORE.php
            │   │   │   ├── ZREVRANGE.php
            │   │   │   ├── ZREVRANGEBYLEX.php
            │   │   │   ├── ZREVRANGEBYSCORE.php
            │   │   │   ├── ZREVRANK.php
            │   │   │   ├── ZSCAN.php
            │   │   │   ├── ZSCORE.php
            │   │   │   ├── ZUNION.php
            │   │   │   └── ZUNIONSTORE.php
            │   │   ├── RedisFactory.php
            │   │   ├── ScriptCommand.php
            │   │   ├── Strategy
            │   │   │   ├── ContainerCommands
            │   │   │   │   └── Functions
            │   │   │   │       ├── DeleteStrategy.php
            │   │   │   │       ├── DumpStrategy.php
            │   │   │   │       ├── FlushStrategy.php
            │   │   │   │       ├── KillStrategy.php
            │   │   │   │       ├── ListStrategy.php
            │   │   │   │       ├── LoadStrategy.php
            │   │   │   │       ├── RestoreStrategy.php
            │   │   │   │       └── StatsStrategy.php
            │   │   │   ├── StrategyResolverInterface.php
            │   │   │   ├── SubcommandStrategyInterface.php
            │   │   │   └── SubcommandStrategyResolver.php
            │   │   └── Traits
            │   │       ├── Aggregate.php
            │   │       ├── BitByte.php
            │   │       ├── BloomFilters
            │   │       │   ├── BucketSize.php
            │   │       │   ├── Capacity.php
            │   │       │   ├── Error.php
            │   │       │   ├── Expansion.php
            │   │       │   ├── Items.php
            │   │       │   ├── MaxIterations.php
            │   │       │   └── NoCreate.php
            │   │       ├── By
            │   │       │   ├── ByArgument.php
            │   │       │   ├── ByLexByScore.php
            │   │       │   └── GeoBy.php
            │   │       ├── Count.php
            │   │       ├── DB.php
            │   │       ├── Expire
            │   │       │   └── ExpireOptions.php
            │   │       ├── From
            │   │       │   └── GeoFrom.php
            │   │       ├── Get
            │   │       │   └── Get.php
            │   │       ├── Json
            │   │       │   ├── Indent.php
            │   │       │   ├── Newline.php
            │   │       │   ├── NxXxArgument.php
            │   │       │   └── Space.php
            │   │       ├── Keys.php
            │   │       ├── LeftRight.php
            │   │       ├── Limit
            │   │       │   ├── Limit.php
            │   │       │   └── LimitObject.php
            │   │       ├── MinMaxModifier.php
            │   │       ├── Replace.php
            │   │       ├── Rev.php
            │   │       ├── Sorting.php
            │   │       ├── Storedist.php
            │   │       ├── Timeout.php
            │   │       ├── To
            │   │       │   └── ServerTo.php
            │   │       ├── Weights.php
            │   │       └── With
            │   │           ├── WithCoord.php
            │   │           ├── WithDist.php
            │   │           ├── WithHash.php
            │   │           ├── WithScores.php
            │   │           └── WithValues.php
            │   ├── CommunicationException.php
            │   ├── Configuration
            │   │   ├── Option
            │   │   │   ├── Aggregate.php
            │   │   │   ├── CRC16.php
            │   │   │   ├── Cluster.php
            │   │   │   ├── Commands.php
            │   │   │   ├── Connections.php
            │   │   │   ├── Exceptions.php
            │   │   │   ├── Prefix.php
            │   │   │   └── Replication.php
            │   │   ├── OptionInterface.php
            │   │   ├── Options.php
            │   │   └── OptionsInterface.php
            │   ├── Connection
            │   │   ├── AbstractConnection.php
            │   │   ├── AggregateConnectionInterface.php
            │   │   ├── Cluster
            │   │   │   ├── ClusterInterface.php
            │   │   │   ├── PredisCluster.php
            │   │   │   └── RedisCluster.php
            │   │   ├── CompositeConnectionInterface.php
            │   │   ├── CompositeStreamConnection.php
            │   │   ├── ConnectionException.php
            │   │   ├── ConnectionInterface.php
            │   │   ├── Factory.php
            │   │   ├── FactoryInterface.php
            │   │   ├── NodeConnectionInterface.php
            │   │   ├── Parameters.php
            │   │   ├── ParametersInterface.php
            │   │   ├── PhpiredisSocketConnection.php
            │   │   ├── PhpiredisStreamConnection.php
            │   │   ├── RelayConnection.php
            │   │   ├── RelayMethods.php
            │   │   ├── Replication
            │   │   │   ├── MasterSlaveReplication.php
            │   │   │   ├── ReplicationInterface.php
            │   │   │   └── SentinelReplication.php
            │   │   ├── StreamConnection.php
            │   │   └── WebdisConnection.php
            │   ├── Monitor
            │   │   └── Consumer.php
            │   ├── NotSupportedException.php
            │   ├── Pipeline
            │   │   ├── Atomic.php
            │   │   ├── ConnectionErrorProof.php
            │   │   ├── FireAndForget.php
            │   │   ├── Pipeline.php
            │   │   ├── RelayAtomic.php
            │   │   └── RelayPipeline.php
            │   ├── PredisException.php
            │   ├── Protocol
            │   │   ├── ProtocolException.php
            │   │   ├── ProtocolProcessorInterface.php
            │   │   ├── RequestSerializerInterface.php
            │   │   ├── ResponseReaderInterface.php
            │   │   └── Text
            │   │       ├── CompositeProtocolProcessor.php
            │   │       ├── Handler
            │   │       │   ├── BulkResponse.php
            │   │       │   ├── ErrorResponse.php
            │   │       │   ├── IntegerResponse.php
            │   │       │   ├── MultiBulkResponse.php
            │   │       │   ├── ResponseHandlerInterface.php
            │   │       │   ├── StatusResponse.php
            │   │       │   └── StreamableMultiBulkResponse.php
            │   │       ├── ProtocolProcessor.php
            │   │       ├── RequestSerializer.php
            │   │       └── ResponseReader.php
            │   ├── PubSub
            │   │   ├── AbstractConsumer.php
            │   │   ├── Consumer.php
            │   │   ├── DispatcherLoop.php
            │   │   └── RelayConsumer.php
            │   ├── Replication
            │   │   ├── MissingMasterException.php
            │   │   ├── ReplicationStrategy.php
            │   │   └── RoleException.php
            │   ├── Response
            │   │   ├── Error.php
            │   │   ├── ErrorInterface.php
            │   │   ├── Iterator
            │   │   │   ├── MultiBulk.php
            │   │   │   ├── MultiBulkIterator.php
            │   │   │   └── MultiBulkTuple.php
            │   │   ├── ResponseInterface.php
            │   │   ├── ServerException.php
            │   │   └── Status.php
            │   ├── Session
            │   │   └── Handler.php
            │   └── Transaction
            │       ├── AbortedMultiExecException.php
            │       ├── MultiExec.php
            │       └── MultiExecState.php
            └── tests
                ├── .editorconfig
                ├── PHPUnit
                │   ├── ArrayHasSameValuesConstraint.php
                │   ├── AssertSameWithPrecisionConstraint.php
                │   ├── OneOfConstraint.php
                │   ├── PredisCommandTestCase.php
                │   ├── PredisConnectionTestCase.php
                │   ├── PredisDistributorTestCase.php
                │   ├── PredisTestCase.php
                │   └── RedisCommandConstraint.php
                ├── Predis
                │   ├── ClientExceptionTest.php
                │   ├── ClientTest.php
                │   ├── Cluster
                │   │   ├── Distributor
                │   │   │   ├── EmptyRingExceptionTest.php
                │   │   │   ├── HashRingTest.php
                │   │   │   └── KetamaRingTest.php
                │   │   ├── Hash
                │   │   │   ├── CRC16Test.php
                │   │   │   └── PhpiredisCRC16Test.php
                │   │   ├── PredisStrategyTest.php
                │   │   ├── RedisStrategyTest.php
                │   │   └── SlotMapTest.php
                │   ├── Collection
                │   │   └── Iterator
                │   │       ├── HashKeyTest.php
                │   │       ├── KeyspaceTest.php
                │   │       ├── ListKeyTest.php
                │   │       ├── SetKeyTest.php
                │   │       └── SortedSetKeyTest.php
                │   ├── Command
                │   │   ├── Argument
                │   │   │   ├── Search
                │   │   │   │   ├── AggregateArgumentsTest.php
                │   │   │   │   ├── CommonArgumentsTest.php
                │   │   │   │   ├── CreateArgumentsTest.php
                │   │   │   │   ├── CursorArgumentsTest.php
                │   │   │   │   ├── DropArgumentsTest.php
                │   │   │   │   ├── ProfileArgumentsTest.php
                │   │   │   │   ├── SchemaFields
                │   │   │   │   │   ├── GeoFieldTest.php
                │   │   │   │   │   ├── GeoShapeFieldTest.php
                │   │   │   │   │   ├── NumericFieldTest.php
                │   │   │   │   │   ├── TagFieldTest.php
                │   │   │   │   │   ├── TextFieldTest.php
                │   │   │   │   │   └── VectorFieldTest.php
                │   │   │   │   ├── SearchArgumentsTest.php
                │   │   │   │   ├── SpellcheckArgumentsTest.php
                │   │   │   │   ├── SugAddArgumentsTest.php
                │   │   │   │   └── SugGetArgumentsTest.php
                │   │   │   └── TimeSeries
                │   │   │       ├── AddArgumentsTest.php
                │   │   │       ├── CommonArgumentsTest.php
                │   │   │       ├── CreateArgumentsTest.php
                │   │   │       ├── IncrByArgumentsTest.php
                │   │   │       ├── InfoArgumentsTest.php
                │   │   │       ├── MRangeArgumentsTest.php
                │   │   │       └── RangeArgumentsTest.php
                │   │   ├── CommandTest.php
                │   │   ├── Processor
                │   │   │   ├── KeyPrefixProcessorTest.php
                │   │   │   └── ProcessorChainTest.php
                │   │   ├── RawCommandTest.php
                │   │   ├── RawFactoryTest.php
                │   │   ├── Redis
                │   │   │   ├── ACL_Test.php
                │   │   │   ├── APPEND_Test.php
                │   │   │   ├── AUTH_Test.php
                │   │   │   ├── AbstractCommand
                │   │   │   │   └── BZPOPBaseTest.php
                │   │   │   ├── BGREWRITEAOF_Test.php
                │   │   │   ├── BGSAVE_Test.php
                │   │   │   ├── BITCOUNT_Test.php
                │   │   │   ├── BITFIELD_Test.php
                │   │   │   ├── BITOP_Test.php
                │   │   │   ├── BITPOS_Test.php
                │   │   │   ├── BLMOVE_Test.php
                │   │   │   ├── BLMPOP_Test.php
                │   │   │   ├── BLPOP_Test.php
                │   │   │   ├── BRPOPLPUSH_Test.php
                │   │   │   ├── BRPOP_Test.php
                │   │   │   ├── BZMPOP_Test.php
                │   │   │   ├── BZPOPMAX_Test.php
                │   │   │   ├── BZPOPMIN_Test.php
                │   │   │   ├── BloomFilter
                │   │   │   │   ├── BFADD_Test.php
                │   │   │   │   ├── BFEXISTS_Test.php
                │   │   │   │   ├── BFINFO_Test.php
                │   │   │   │   ├── BFINSERT_Test.php
                │   │   │   │   ├── BFLOADCHUNK_Test.php
                │   │   │   │   ├── BFMADD_Test.php
                │   │   │   │   ├── BFMEXISTS_Test.php
                │   │   │   │   ├── BFRESERVE_Test.php
                │   │   │   │   └── BFSCANDUMP_Test.php
                │   │   │   ├── CLIENT_Test.php
                │   │   │   ├── CLUSTER_Test.php
                │   │   │   ├── COMMAND_Test.php
                │   │   │   ├── CONFIG_Test.php
                │   │   │   ├── COPY_Test.php
                │   │   │   ├── Container
                │   │   │   │   ├── AbstractContainerTest.php
                │   │   │   │   ├── CLUSTER_Test.php
                │   │   │   │   └── ContainerFactoryTest.php
                │   │   │   ├── CountMinSketch
                │   │   │   │   ├── CMSINCRBY_Test.php
                │   │   │   │   ├── CMSINFO_Test.php
                │   │   │   │   ├── CMSINITBYDIM_Test.php
                │   │   │   │   ├── CMSINITBYPROB_Test.php
                │   │   │   │   ├── CMSMERGE_Test.php
                │   │   │   │   └── CMSQUERY_Test.php
                │   │   │   ├── CuckooFilter
                │   │   │   │   ├── CFADDNX_Test.php
                │   │   │   │   ├── CFADD_Test.php
                │   │   │   │   ├── CFCOUNT_Test.php
                │   │   │   │   ├── CFDEL_Test.php
                │   │   │   │   ├── CFEXISTS_Test.php
                │   │   │   │   ├── CFINFO_Test.php
                │   │   │   │   ├── CFINSERTNX_Test.php
                │   │   │   │   ├── CFINSERT_Test.php
                │   │   │   │   ├── CFLOADCHUNK_Test.php
                │   │   │   │   ├── CFMEXISTS_Test.php
                │   │   │   │   ├── CFRESERVE_Test.php
                │   │   │   │   └── CFSCANDUMP_Test.php
                │   │   │   ├── DBSIZE_Test.php
                │   │   │   ├── DECRBY_Test.php
                │   │   │   ├── DECR_Test.php
                │   │   │   ├── DEL_Test.php
                │   │   │   ├── DISCARD_Test.php
                │   │   │   ├── DUMP_Test.php
                │   │   │   ├── ECHO_Test.php
                │   │   │   ├── EVALSHA_RO_Test.php
                │   │   │   ├── EVALSHA_Test.php
                │   │   │   ├── EVAL_RO_Test.php
                │   │   │   ├── EVAL_Test.php
                │   │   │   ├── EXEC_Test.php
                │   │   │   ├── EXISTS_Test.php
                │   │   │   ├── EXPIREAT_Test.php
                │   │   │   ├── EXPIRETIME_Test.php
                │   │   │   ├── EXPIRE_Test.php
                │   │   │   ├── FAILOVER_Test.php
                │   │   │   ├── FCALL_RO_Test.php
                │   │   │   ├── FCALL_Test.php
                │   │   │   ├── FLUSHALL_Test.php
                │   │   │   ├── FLUSHDB_Test.php
                │   │   │   ├── FUNCTIONS_Test.php
                │   │   │   ├── GEOADD_Test.php
                │   │   │   ├── GEODIST_Test.php
                │   │   │   ├── GEOHASH_Test.php
                │   │   │   ├── GEOPOS_Test.php
                │   │   │   ├── GEORADIUSBYMEMBER_Test.php
                │   │   │   ├── GEORADIUS_Test.php
                │   │   │   ├── GEOSEARCHSTORE_Test.php
                │   │   │   ├── GEOSEARCH_Test.php
                │   │   │   ├── GETBIT_Test.php
                │   │   │   ├── GETDEL_Test.php
                │   │   │   ├── GETEX_Test.php
                │   │   │   ├── GETRANGE_Test.php
                │   │   │   ├── GETSET_Test.php
                │   │   │   ├── GET_Test.php
                │   │   │   ├── HDEL_Test.php
                │   │   │   ├── HEXISTS_Test.php
                │   │   │   ├── HEXPIREAT_Test.php
                │   │   │   ├── HEXPIRETIME_Test.php
                │   │   │   ├── HEXPIRE_Test.php
                │   │   │   ├── HGETALL_Test.php
                │   │   │   ├── HGET_Test.php
                │   │   │   ├── HINCRBYFLOAT_Test.php
                │   │   │   ├── HINCRBY_Test.php
                │   │   │   ├── HKEYS_Test.php
                │   │   │   ├── HLEN_Test.php
                │   │   │   ├── HMGET_Test.php
                │   │   │   ├── HMSET_Test.php
                │   │   │   ├── HPERSIST_Test.php
                │   │   │   ├── HPEXPIREAT_Test.php
                │   │   │   ├── HPEXPIRETIME_Test.php
                │   │   │   ├── HPEXPIRE_Test.php
                │   │   │   ├── HPTTL_Test.php
                │   │   │   ├── HRANDFIELD_Test.php
                │   │   │   ├── HSCAN_Test.php
                │   │   │   ├── HSETNX_Test.php
                │   │   │   ├── HSET_Test.php
                │   │   │   ├── HSTRLEN_Test.php
                │   │   │   ├── HTTL_Test.php
                │   │   │   ├── HVALS_Test.php
                │   │   │   ├── INCRBYFLOAT_Test.php
                │   │   │   ├── INCRBY_Test.php
                │   │   │   ├── INCR_Test.php
                │   │   │   ├── INFO_Test.php
                │   │   │   ├── Json
                │   │   │   │   ├── JSONARRAPPEND_Test.php
                │   │   │   │   ├── JSONARRINDEX_Test.php
                │   │   │   │   ├── JSONARRINSERT_Test.php
                │   │   │   │   ├── JSONARRLEN_Test.php
                │   │   │   │   ├── JSONARRPOP_Test.php
                │   │   │   │   ├── JSONARRTRIM_Test.php
                │   │   │   │   ├── JSONCLEAR_Test.php
                │   │   │   │   ├── JSONDEBUG_Test.php
                │   │   │   │   ├── JSONDEL_Test.php
                │   │   │   │   ├── JSONFORGET_Test.php
                │   │   │   │   ├── JSONGET_Test.php
                │   │   │   │   ├── JSONMERGE_Test.php
                │   │   │   │   ├── JSONMGET_Test.php
                │   │   │   │   ├── JSONMSET_Test.php
                │   │   │   │   ├── JSONNUMINCRBY_Test.php
                │   │   │   │   ├── JSONOBJKEYS_Test.php
                │   │   │   │   ├── JSONOBJLEN_Test.php
                │   │   │   │   ├── JSONRESP_Test.php
                │   │   │   │   ├── JSONSET_Test.php
                │   │   │   │   ├── JSONSTRAPPEND_Test.php
                │   │   │   │   ├── JSONSTRLEN_Test.php
                │   │   │   │   ├── JSONTOGGLE_Test.php
                │   │   │   │   └── JSONTYPE_Test.php
                │   │   │   ├── KEYS_Test.php
                │   │   │   ├── LASTSAVE_Test.php
                │   │   │   ├── LCS_Test.php
                │   │   │   ├── LINDEX_Test.php
                │   │   │   ├── LINSERT_Test.php
                │   │   │   ├── LLEN_Test.php
                │   │   │   ├── LMOVE_Test.php
                │   │   │   ├── LMPOP_Test.php
                │   │   │   ├── LPOP_Test.php
                │   │   │   ├── LPUSHX_Test.php
                │   │   │   ├── LPUSH_Test.php
                │   │   │   ├── LRANGE_Test.php
                │   │   │   ├── LREM_Test.php
                │   │   │   ├── LSET_Test.php
                │   │   │   ├── LTRIM_Test.php
                │   │   │   ├── MGET_Test.php
                │   │   │   ├── MIGRATE_Test.php
                │   │   │   ├── MONITOR_Test.php
                │   │   │   ├── MOVE_Test.php
                │   │   │   ├── MSETNX_Test.php
                │   │   │   ├── MSET_Test.php
                │   │   │   ├── MULTI_Test.php
                │   │   │   ├── OBJECT_Test.php
                │   │   │   ├── PERSIST_Test.php
                │   │   │   ├── PEXPIREAT_Test.php
                │   │   │   ├── PEXPIRETIME_Test.php
                │   │   │   ├── PEXPIRE_Test.php
                │   │   │   ├── PFADD_Test.php
                │   │   │   ├── PFCOUNT_Test.php
                │   │   │   ├── PFMERGE_Test.php
                │   │   │   ├── PING_Test.php
                │   │   │   ├── PSETEX_Test.php
                │   │   │   ├── PSUBSCRIBE_Test.php
                │   │   │   ├── PTTL_Test.php
                │   │   │   ├── PUBLISH_Test.php
                │   │   │   ├── PUBSUB_Test.php
                │   │   │   ├── PUNSUBSCRIBE_Test.php
                │   │   │   ├── QUIT_Test.php
                │   │   │   ├── RANDOMKEY_Test.php
                │   │   │   ├── RENAMENX_Test.php
                │   │   │   ├── RENAME_Test.php
                │   │   │   ├── RESTORE_Test.php
                │   │   │   ├── RPOPLPUSH_Test.php
                │   │   │   ├── RPOP_Test.php
                │   │   │   ├── RPUSHX_Test.php
                │   │   │   ├── RPUSH_Test.php
                │   │   │   ├── SADD_Test.php
                │   │   │   ├── SAVE_Test.php
                │   │   │   ├── SCAN_Test.php
                │   │   │   ├── SCARD_Test.php
                │   │   │   ├── SCRIPT_Test.php
                │   │   │   ├── SDIFFSTORE_Test.php
                │   │   │   ├── SDIFF_Test.php
                │   │   │   ├── SELECT_Test.php
                │   │   │   ├── SENTINEL_Test.php
                │   │   │   ├── SETBIT_Test.php
                │   │   │   ├── SETEX_Test.php
                │   │   │   ├── SETNX_Test.php
                │   │   │   ├── SETRANGE_Test.php
                │   │   │   ├── SET_Test.php
                │   │   │   ├── SHUTDOWN_Test.php
                │   │   │   ├── SINTERCARD_Test.php
                │   │   │   ├── SINTERSTORE_Test.php
                │   │   │   ├── SINTER_Test.php
                │   │   │   ├── SISMEMBER_Test.php
                │   │   │   ├── SLAVEOF_Test.php
                │   │   │   ├── SLOWLOG_Test.php
                │   │   │   ├── SMEMBERS_Test.php
                │   │   │   ├── SMISMEMBER_Test.php
                │   │   │   ├── SMOVE_Test.php
                │   │   │   ├── SORT_RO_Test.php
                │   │   │   ├── SORT_Test.php
                │   │   │   ├── SPOP_Test.php
                │   │   │   ├── SRANDMEMBER_Test.php
                │   │   │   ├── SREM_Test.php
                │   │   │   ├── SSCAN_Test.php
                │   │   │   ├── STRLEN_Test.php
                │   │   │   ├── SUBSCRIBE_Test.php
                │   │   │   ├── SUBSTR_Test.php
                │   │   │   ├── SUNIONSTORE_Test.php
                │   │   │   ├── SUNION_Test.php
                │   │   │   ├── Search
                │   │   │   │   ├── FTAGGREGATE_Test.php
                │   │   │   │   ├── FTALIASADD_Test.php
                │   │   │   │   ├── FTALIASDEL_Test.php
                │   │   │   │   ├── FTALIASUPDATE_Test.php
                │   │   │   │   ├── FTALTER_Test.php
                │   │   │   │   ├── FTCONFIG_Test.php
                │   │   │   │   ├── FTCREATE_Test.php
                │   │   │   │   ├── FTCURSOR_Test.php
                │   │   │   │   ├── FTDICTADD_Test.php
                │   │   │   │   ├── FTDICTDEL_Test.php
                │   │   │   │   ├── FTDICTDUMP_Test.php
                │   │   │   │   ├── FTDROPINDEX_Test.php
                │   │   │   │   ├── FTEXPLAIN_Test.php
                │   │   │   │   ├── FTINFO_Test.php
                │   │   │   │   ├── FTPROFILE_Test.php
                │   │   │   │   ├── FTSEARCH_Test.php
                │   │   │   │   ├── FTSPELLCHECK_Test.php
                │   │   │   │   ├── FTSUGADD_Test.php
                │   │   │   │   ├── FTSUGDEL_Test.php
                │   │   │   │   ├── FTSUGGET_Test.php
                │   │   │   │   ├── FTSUGLEN_Test.php
                │   │   │   │   ├── FTSYNDUMP_Test.php
                │   │   │   │   ├── FTSYNUPDATE_Test.php
                │   │   │   │   └── FTTAGVALS_Test.php
                │   │   │   ├── TDigest
                │   │   │   │   ├── TDIGESTADD_Test.php
                │   │   │   │   ├── TDIGESTBYRANK_Test.php
                │   │   │   │   ├── TDIGESTBYREVRANK_Test.php
                │   │   │   │   ├── TDIGESTCDF_Test.php
                │   │   │   │   ├── TDIGESTCREATE_Test.php
                │   │   │   │   ├── TDIGESTINFO_Test.php
                │   │   │   │   ├── TDIGESTMAX_Test.php
                │   │   │   │   ├── TDIGESTMERGE_Test.php
                │   │   │   │   ├── TDIGESTMIN_Test.php
                │   │   │   │   ├── TDIGESTQUANTILE_Test.php
                │   │   │   │   ├── TDIGESTRANK_Test.php
                │   │   │   │   ├── TDIGESTRESET_Test.php
                │   │   │   │   ├── TDIGESTREVRANK_Test.php
                │   │   │   │   └── TDIGESTTRIMMED_MEAN_Test.php
                │   │   │   ├── TIME_Test.php
                │   │   │   ├── TOUCH_Test.php
                │   │   │   ├── TTL_Test.php
                │   │   │   ├── TYPE_Test.php
                │   │   │   ├── TimeSeries
                │   │   │   │   ├── TSADD_Test.php
                │   │   │   │   ├── TSALTER_Test.php
                │   │   │   │   ├── TSCREATERULE_Test.php
                │   │   │   │   ├── TSCREATE_Test.php
                │   │   │   │   ├── TSDECRBY_Test.php
                │   │   │   │   ├── TSDELETERULE_Test.php
                │   │   │   │   ├── TSDEL_Test.php
                │   │   │   │   ├── TSGET_Test.php
                │   │   │   │   ├── TSINCRBY_Test.php
                │   │   │   │   ├── TSINFO_Test.php
                │   │   │   │   ├── TSMADD_Test.php
                │   │   │   │   ├── TSMGET_Test.php
                │   │   │   │   ├── TSMRANGE_Test.php
                │   │   │   │   ├── TSMREVRANGE_Test.php
                │   │   │   │   ├── TSQUERYINDEX_Test.php
                │   │   │   │   ├── TSRANGE_Test.php
                │   │   │   │   └── TSREVRANGE_Test.php
                │   │   │   ├── TopK
                │   │   │   │   ├── TOPKADD_Test.php
                │   │   │   │   ├── TOPKINCRBY_Test.php
                │   │   │   │   ├── TOPKINFO_Test.php
                │   │   │   │   ├── TOPKLIST_Test.php
                │   │   │   │   ├── TOPKQUERY_Test.php
                │   │   │   │   └── TOPKRESERVE_Test.php
                │   │   │   ├── UNSUBSCRIBE_Test.php
                │   │   │   ├── UNWATCH_Test.php
                │   │   │   ├── WAITAOF_Test.php
                │   │   │   ├── WATCH_Test.php
                │   │   │   ├── XADD_Test.php
                │   │   │   ├── XDEL_Test.php
                │   │   │   ├── XLEN_Test.php
                │   │   │   ├── XRANGE_Test.php
                │   │   │   ├── XREAD_Test.php
                │   │   │   ├── XREVRANGE_Test.php
                │   │   │   ├── XTRIM_Test.php
                │   │   │   ├── ZADD_Test.php
                │   │   │   ├── ZCARD_Test.php
                │   │   │   ├── ZCOUNT_Test.php
                │   │   │   ├── ZDIFFSTORE_Test.php
                │   │   │   ├── ZDIFF_test.php
                │   │   │   ├── ZINCRBY_Test.php
                │   │   │   ├── ZINTERCARD_Test.php
                │   │   │   ├── ZINTERSTORE_Test.php
                │   │   │   ├── ZINTER_Test.php
                │   │   │   ├── ZLEXCOUNT_Test.php
                │   │   │   ├── ZMPOP_Test.php
                │   │   │   ├── ZMSCORE_Test.php
                │   │   │   ├── ZPOPMAX_Test.php
                │   │   │   ├── ZPOPMIN_Test.php
                │   │   │   ├── ZRANDMEMBER_test.php
                │   │   │   ├── ZRANGEBYLEX_Test.php
                │   │   │   ├── ZRANGEBYSCORE_Test.php
                │   │   │   ├── ZRANGESTORE_Test.php
                │   │   │   ├── ZRANGE_Test.php
                │   │   │   ├── ZRANK_Test.php
                │   │   │   ├── ZREMRANGEBYLEX_Test.php
                │   │   │   ├── ZREMRANGEBYRANK_Test.php
                │   │   │   ├── ZREMRANGEBYSCORE_Test.php
                │   │   │   ├── ZREM_Test.php
                │   │   │   ├── ZREVRANGEBYLEX_Test.php
                │   │   │   ├── ZREVRANGEBYSCORE_Test.php
                │   │   │   ├── ZREVRANGE_Test.php
                │   │   │   ├── ZREVRANK_Test.php
                │   │   │   ├── ZSCAN_Test.php
                │   │   │   ├── ZSCORE_Test.php
                │   │   │   ├── ZUNIONSTORE_Test.php
                │   │   │   └── ZUNION_Test.php
                │   │   ├── RedisFactoryTest.php
                │   │   ├── ScriptCommandTest.php
                │   │   ├── Strategy
                │   │   │   ├── ContainerCommands
                │   │   │   │   └── Functions
                │   │   │   │       ├── DeleteStrategyTest.php
                │   │   │   │       ├── DumpStrategyTest.php
                │   │   │   │       ├── FlushStrategyTest.php
                │   │   │   │       ├── KillStrategyTest.php
                │   │   │   │       ├── ListStrategyTest.php
                │   │   │   │       ├── LoadStrategyTest.php
                │   │   │   │       ├── RestoreStrategyTest.php
                │   │   │   │       └── StatsStrategyTest.php
                │   │   │   └── SubcommandStrategyResolverTest.php
                │   │   └── Traits
                │   │       ├── AggregateTest.php
                │   │       ├── BitByteTest.php
                │   │       ├── BloomFilters
                │   │       │   ├── BucketSizeTest.php
                │   │       │   ├── CapacityTest.php
                │   │       │   ├── ErrorTest.php
                │   │       │   ├── ExpansionTest.php
                │   │       │   ├── ItemsTest.php
                │   │       │   ├── MaxIterationsTest.php
                │   │       │   └── NoCreateTest.php
                │   │       ├── By
                │   │       │   ├── ByArgumentTest.php
                │   │       │   └── GeoByTest.php
                │   │       ├── ByLexByScoreTest.php
                │   │       ├── CountTest.php
                │   │       ├── DbTest.php
                │   │       ├── From
                │   │       │   └── GeoFromTest.php
                │   │       ├── Get
                │   │       │   └── GetTest.php
                │   │       ├── Json
                │   │       │   ├── IndentTest.php
                │   │       │   ├── NewlineTest.php
                │   │       │   ├── NxXxArgumentTest.php
                │   │       │   └── SpaceTest.php
                │   │       ├── KeysTest.php
                │   │       ├── LeftRightTest.php
                │   │       ├── Limit
                │   │       │   ├── LimitObjectTest.php
                │   │       │   └── LimitTest.php
                │   │       ├── MinMaxModifierTest.php
                │   │       ├── ReplaceTest.php
                │   │       ├── RevTest.php
                │   │       ├── StoredistTest.php
                │   │       ├── TimeoutTest.php
                │   │       ├── To
                │   │       │   └── ServerToTest.php
                │   │       ├── WeightsTest.php
                │   │       └── With
                │   │           ├── WithCoordTest.php
                │   │           ├── WithDistTest.php
                │   │           ├── WithHashTest.php
                │   │           └── WithScoresTest.php
                │   ├── CommunicationExceptionTest.php
                │   ├── Configuration
                │   │   ├── Option
                │   │   │   ├── AggregateTest.php
                │   │   │   ├── CRC16Test.php
                │   │   │   ├── ClusterTest.php
                │   │   │   ├── CommandsTest.php
                │   │   │   ├── ConnectionsTest.php
                │   │   │   ├── ExceptionsTest.php
                │   │   │   ├── PrefixTest.php
                │   │   │   └── ReplicationTest.php
                │   │   └── OptionsTest.php
                │   ├── Connection
                │   │   ├── Cluster
                │   │   │   ├── PredisClusterTest.php
                │   │   │   └── RedisClusterTest.php
                │   │   ├── CompositeStreamConnectionTest.php
                │   │   ├── ConnectionExceptionTest.php
                │   │   ├── FactoryTest.php
                │   │   ├── ParametersTest.php
                │   │   ├── PhpiredisSocketConnectionTest.php
                │   │   ├── PhpiredisStreamConnectionTest.php
                │   │   ├── RelayConnectionTest.php
                │   │   ├── Replication
                │   │   │   ├── MasterSlaveReplicationTest.php
                │   │   │   └── SentinelReplicationTest.php
                │   │   ├── StreamConnectionTest.php
                │   │   └── WebdisConnectionTest.php
                │   ├── Monitor
                │   │   └── ConsumerTest.php
                │   ├── Pipeline
                │   │   ├── AtomicTest.php
                │   │   ├── FireAndForgetTest.php
                │   │   └── PipelineTest.php
                │   ├── PredisExceptionTest.php
                │   ├── Protocol
                │   │   ├── ProtocolExceptionTest.php
                │   │   └── Text
                │   │       ├── CompositeProtocolProcessorTest.php
                │   │       ├── Handler
                │   │       │   ├── BulkResponseTest.php
                │   │       │   ├── ErrorResponseTest.php
                │   │       │   ├── IntegerResponseTest.php
                │   │       │   ├── MultiBulkResponseTest.php
                │   │       │   ├── StatusResponseTest.php
                │   │       │   └── StreamableMultiBulkResponseTest.php
                │   │       ├── ProtocolProcessorTest.php
                │   │       ├── RequestSerializerTest.php
                │   │       └── ResponseReaderTest.php
                │   ├── PubSub
                │   │   ├── ConsumerTest.php
                │   │   └── DispatcherLoopTest.php
                │   ├── Replication
                │   │   └── ReplicationStrategyTest.php
                │   ├── Response
                │   │   ├── ErrorTest.php
                │   │   ├── Iterator
                │   │   │   ├── MultiBulkTest.php
                │   │   │   └── MultiBulkTupleTest.php
                │   │   ├── ServerExceptionTest.php
                │   │   └── StatusTest.php
                │   └── Transaction
                │       ├── AbortedMultiExecExceptionTest.php
                │       ├── MultiExecStateTest.php
                │       └── MultiExecTest.php
                ├── README.md
                └── bootstrap.php

================================================================================
CONTEÚDO DOS ARQUIVOS:
================================================================================

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\background_scrape.php
================================================================================

<?php
// background_scrape.php

// Carrega o autoloader do Composer
require_once __DIR__ . '/vendor/autoload.php';

use App\Models\Scraper;

$scraper = new Scraper();
$articles = $scraper->getAllPoliticalNews();

$cacheFile = __DIR__ . '/cache/all_news.json';
if (!is_dir(__DIR__ . '/cache')) {
    mkdir(__DIR__ . '/cache', 0777, true);
}

file_put_contents($cacheFile, json_encode($articles));
echo "Scraping concluído com sucesso!";
?>


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\composer.json
================================================================================

{
    "name": "alexa/sistema-noticias",
    "description": "Sistema de agregação de notícias políticas",
    "type": "project",
    "require": {
        "php": ">=7.4",
        "predis/predis": "^2.3"
    },
    "autoload": {
        "psr-4": {
            "App\\": "src/App/"
        },
        "files": [
            "config/config.php"
        ]
    },
    "authors": [
        {
            "name": "Alex Vilaça",
            "email": "alexandrevilaca.jor@gmail.com"
        }
    ]
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\config\config.php
================================================================================

<?php
date_default_timezone_set('America/Sao_Paulo');
define('CACHE_DIR', __DIR__ . '/../cache');
define('LOG_DIR', __DIR__ . '/../logs');
if (!is_dir(LOG_DIR)) {
    mkdir(LOG_DIR, 0777, true);
}
define('LOG_FILE', LOG_DIR . '/debug.log');

// Define constantes para níveis de log apenas se não estiverem definidas
if (!defined('LOG_INFO'))    define('LOG_INFO', 'INFO');
if (!defined('LOG_WARNING')) define('LOG_WARNING', 'WARNING');
if (!defined('LOG_ERROR'))   define('LOG_ERROR', 'ERROR');
if (!defined('LOG_DEBUG'))   define('LOG_DEBUG', 'DEBUG');

/**
 * Função aprimorada de log com suporte a níveis
 * 
 * @param string $message Mensagem a ser registrada
 * @param string $level Nível do log (INFO, WARNING, ERROR, DEBUG)
 * @param string $context Contexto opcional para o log
 * @return bool Sucesso da operação
 */
function debug_log($message, $level = 'INFO', $context = '') {
    $date = date("Y-m-d H:i:s");
    $contextInfo = $context ? "[$context]" : "";
    // Formato corrigido: [DATA][NÍVEL]mensagem (sem quebras de linha no nível)
    $entry = "[$date][$level]$contextInfo $message" . PHP_EOL;
    return file_put_contents(LOG_FILE, $entry, FILE_APPEND);
}

/**
 * Funções auxiliares para simplificar os logs em diferentes níveis
 * Cada função é definida apenas se não existir
 */
if (!function_exists('log_info')) {
    function log_info($message, $context = '') {
        return debug_log($message, LOG_INFO, $context);
    }
}

if (!function_exists('log_warning')) {
    function log_warning($message, $context = '') {
        return debug_log($message, LOG_WARNING, $context);
    }
}

if (!function_exists('log_error')) {
    function log_error($message, $context = '') {
        return debug_log($message, LOG_ERROR, $context);
    }
}

if (!function_exists('log_debug')) {
    function log_debug($message, $context = '') {
        return debug_log($message, LOG_DEBUG, $context);
    }
}
?>


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\config\scrapers_config.php
================================================================================

<?php
/**
 * Lista de classes que representam cada portal.
 * Apenas o nome da classe, sem namespace.
 * O namespace App\Models\ será adicionado automaticamente.
 */
return [
    'G1Scraper',
    'UOLScraper',
    'FolhaScraper',    
    // Adicione aqui novos scrapers, ex: 'PortalXYZScraper',
];


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\index.php
================================================================================

<?php
// filepath: c:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\index.php

// Carrega o autoloader do Composer
require_once __DIR__ . '/../vendor/autoload.php';

// Usa o namespace correto para o controller
use App\Controllers\NewsController;

// Instancia o controller
$controller = new NewsController();
$controller->index();
?>


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\api\force_update.php
================================================================================

<?php
// Desabilitar o limite de tempo de execução do script
set_time_limit(0);

// Configurações iniciais para garantir que a saída seja enviada corretamente
ini_set('output_buffering', 'off');
ini_set('zlib.output_compression', false);

// Headers específicos para Server-Sent Events
header('Content-Type: text/event-stream');
header('Cache-Control: no-cache');
header('Connection: keep-alive');
header('X-Accel-Buffering: no'); // Para servidores Nginx

// Desativa qualquer buffer de saída para garantir envio imediato
@ob_end_clean();
if (ob_get_level() == 0) ob_start();

// Carrega o autoloader do Composer
require_once __DIR__ . '/../../vendor/autoload.php';

// Usa o namespace correto
use App\Models\Scraper;

// Função para enviar evento para o cliente
function sendEvent($message, $type = "progress") {
    echo "event: {$type}\n";
    echo "data: " . json_encode($message) . "\n\n";
    ob_flush();
    flush();
}

// Envia um heartbeat a cada 15 segundos para manter a conexão viva
function startHeartbeat() {
    ignore_user_abort(true); // continua executando mesmo se o cliente desconectar
    
    register_shutdown_function(function() {
        // Envia um evento de erro se o script terminar inesperadamente
        sendEvent(['status' => 'error', 'message' => 'O servidor finalizou a conexão inesperadamente'], 'error');
    });
    
    // Inicia o heartbeat
    $lastHeartbeat = time();
    return $lastHeartbeat;
}

// Inicia o heartbeat
$lastHeartbeat = startHeartbeat();

try {
    // Envia mensagem inicial
    sendEvent(['status' => 'start', 'message' => 'Iniciando processo de atualização...'], 'start');
    
    // Registra o início do processo para calcular o tempo total
    $startTime = microtime(true);
    
    // Define um callback personalizado para o Scraper que também verifica heartbeat
    $progressCallback = function($message) use (&$lastHeartbeat) {
        // Envia update de progresso
        sendEvent(['status' => 'progress', 'message' => $message]);
        
        // Verifica se precisa enviar heartbeat (a cada 15 segundos)
        $now = time();
        if ($now - $lastHeartbeat >= 15) {
            sendEvent(['status' => 'heartbeat', 'timestamp' => $now], 'heartbeat');
            $lastHeartbeat = $now;
        }
    };
    
    // Instancia o scraper com o callback personalizado
    $scraper = new Scraper($progressCallback);
    
    // Envia mensagem antes de começar o scraping
    sendEvent(['status' => 'progress', 'message' => 'Iniciando scraping dos portais de notícias...']);
    
    // Força a atualização do scraping
    $articles = $scraper->getAllPoliticalNews(true);
    
    // Cria o diretório de cache se não existir
    $cacheDir = __DIR__ . '/../../cache';
    if (!is_dir($cacheDir)) {
        mkdir($cacheDir, 0777, true);
        sendEvent(['status' => 'progress', 'message' => 'Diretório de cache criado']);
    }
    
    // Salva os artigos no cache
    $cacheFile = $cacheDir . '/all_news.json';
    $articlesCount = count($articles);
    sendEvent(['status' => 'progress', 'message' => "Salvando {$articlesCount} artigos no cache..."]);
    file_put_contents($cacheFile, json_encode($articles));
    
    // Calcula estatísticas
    $endTime = microtime(true);
    $executionTime = round($endTime - $startTime, 2);
    
    // Contagem por fonte
    $sourceStats = [];
    foreach ($articles as $article) {
        $source = $article['source'] ?? 'Desconhecido';
        if (!isset($sourceStats[$source])) {
            $sourceStats[$source] = 0;
        }
        $sourceStats[$source]++;
    }
    
    // Envia mensagem de conclusão
    sendEvent([
        'status' => 'success',
        'message' => 'Atualização realizada com sucesso!',
        'articles_count' => $articlesCount,
        'execution_time' => $executionTime,
        'sources' => $sourceStats,
        'cache_size' => filesize($cacheFile),
        'timestamp' => date('Y-m-d H:i:s')
    ], 'complete');
    
} catch (Exception $e) {
    // Captura qualquer exceção e envia como evento de erro
    sendEvent([
        'status' => 'error',
        'message' => 'Erro durante a atualização: ' . $e->getMessage()
    ], 'error');
} finally {
    // Aguarda 1 segundo antes de encerrar a conexão
    sleep(1);
}

// Encerra o script
exit();
?>


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\api\news.php
================================================================================

<?php
header('Content-Type: application/json');

// Define o caminho para o arquivo de cache
$cacheFile = __DIR__ . '/../../cache/all_news.json';

if (file_exists($cacheFile)) {
    echo file_get_contents($cacheFile);
} else {
    echo json_encode([]);
}
?>


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\assets\css\cards.css
================================================================================

/* Estilos para visualização em cards */
.news-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.news-card {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    padding: 15px;
    position: relative;
    transition: transform 0.2s, box-shadow 0.2s;
    animation: fadeIn 0.5s ease-in-out;
}

.news-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.news-source {
    position: absolute;
    top: -10px;
    right: 10px;
    padding: 3px 10px;
    border-radius: 15px;
    font-size: 12px;
    font-weight: bold;
    color: white;
}

.g1 { background-color: #c4170c; }
.uol { background-color: #1e4b9b; }
.folha { background-color: #2661a8; }

.news-title {
    font-size: 18px;
    margin-top: 10px;
    margin-bottom: 8px;
}

.news-title a {
    color: #333;
    text-decoration: none;
}

.news-title a:hover {
    color: #0066cc;
}

.news-description {
    color: #666;
    font-size: 14px;
    line-height: 1.4;
    margin-bottom: 15px;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

.news-meta {
    display: flex;
    justify-content: space-between;
    color: #888;
    font-size: 12px;
    border-top: 1px solid #eee;
    padding-top: 8px;
}

/* Cards no modo escuro */
body.dark-mode .news-card {
    background: #1e1e1e;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}

body.dark-mode .news-title a {
    color: #e0e0e0;
}

body.dark-mode .news-description {
    color: #aaa;
}

body.dark-mode .news-meta {
    border-top-color: #333;
    color: #999;
}

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\assets\css\dark-mode.css
================================================================================

/* Estilos para o modo escuro */
body.dark-mode {
    background-color: #121212;
    color: #e0e0e0;
}

body.dark-mode h1 {
    color: #bb86fc;
    border-bottom-color: #333;
}

/* Botão de toggle do modo escuro */
.dark-mode-toggle {
    position: fixed;
    top: 20px;
    right: 20px;
    background: #f0f0f0;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    cursor: pointer;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transition: background 0.3s;
}

body.dark-mode .dark-mode-toggle {
    background: #333;
    color: #bb86fc;
}

/* Ajustes para controles no modo escuro */
body.dark-mode .btn-primary {
    background: #4a5568;
}

body.dark-mode .btn-primary:hover {
    background: #2d3748;
}

body.dark-mode .view-btn {
    background: #2d3748;
    border-color: #4a5568;
    color: #e2e8f0;
}

body.dark-mode .view-btn:hover, 
body.dark-mode .view-btn.active {
    background: #4a5568;
    border-color: #718096;
}

body.dark-mode .source-filter {
    background: #2d3748;
    border-color: #4a5568;
    color: #e2e8f0;
}

/* Painel de atualização no modo escuro */
body.dark-mode .update-info {
    background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%) !important;
    color: #e2e8f0 !important;
    border: 1px solid #4a5568;
}

body.dark-mode .update-info-icon {
    background-color: #4a5568;
    color: #e2e8f0;
}

body.dark-mode .update-info-content {
    color: #e2e8f0 !important;
}

body.dark-mode .update-data .label {
    color: #a0aec0;
}

body.dark-mode .update-data .value {
    color: #e2e8f0 !important;
}

body.dark-mode .update-empty {
    color: #e2e8f0 !important;
}

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\assets\css\logs.css
================================================================================

/* Estilos para a área de logs */
#debug-container {
    margin-top: 30px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    overflow: hidden;
    transition: all 0.3s ease;
}

#debug-header {
    background: #f1f1f1;
    padding: 15px;
    border-bottom: 1px solid #e1e1e1;
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: space-between;
    align-items: center;
}

#debug-header h3 {
    margin: 0;
    font-size: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.debug-filters {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
    background: rgba(0,0,0,0.03);
    padding: 8px 12px;
    border-radius: 5px;
}

.debug-filters label {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    transition: background 0.2s;
}

.debug-filters label:hover {
    background: rgba(0,0,0,0.05);
}

.debug-search {
    display: flex;
    gap: 5px;
    margin-top: 10px;
    width: 100%;
}

#log-search {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

button#search-btn, button#clear-logs-btn {
    background: #718096;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 8px 15px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s;
}

button#search-btn:hover, button#clear-logs-btn:hover {
    background: #4a5568;
}

button#clear-logs-btn {
    background: #e53e3e;
}

button#clear-logs-btn:hover {
    background: #c53030;
}

/* Log entries */
#debug-log {
    max-height: 300px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 13px;
    line-height: 1.5;
}

.log-container {
    padding: 10px 0;
}

.log-entry {
    padding: 8px 15px;
    margin-bottom: 2px;
    border-left: 4px solid transparent;
    display: flex;
    align-items: center;
    transition: background 0.2s;
}

.log-entry:hover {
    background-color: rgba(0,0,0,0.03);
}

.log-timestamp {
    min-width: 160px;
    color: #718096;
    font-size: 12px;
}

.log-context {
    min-width: 120px;
    color: #0277bd;
    font-weight: bold;
    margin-right: 10px;
}

.log-level {
    min-width: 70px;
    padding: 2px 6px;
    border-radius: 4px;
    text-align: center;
    font-size: 11px;
    font-weight: bold;
    margin-right: 10px;
    color: white !important;
}

/* Níveis de log */
.log-info .log-level {
    background-color: #3182ce;
    color: white !important;
}

.log-warning .log-level {
    background-color: #dd6b20;
    color: white !important;
}

.log-error .log-level {
    background-color: #e53e3e;
    color: white !important;
}

.log-debug .log-level {
    background-color: #718096;
    color: white !important;
}

.log-more {
    text-align: center;
    color: #6c757d;
    font-style: italic;
    padding: 5px;
}

.log-empty {
    padding: 20px;
    text-align: center;
    color: #666;
    font-style: italic;
}

.log-highlight {
    background-color: #ffeb3b;
    color: #000;
}

.log-hidden {
    display: none;
}

/* Logs no modo escuro */
body.dark-mode #debug-container {
    background: #1e1e1e;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

body.dark-mode #debug-header {
    background: #2d2d2d;
    border-color: #444;
}

body.dark-mode .debug-filters {
    background: rgba(255,255,255,0.05);
}

body.dark-mode .debug-filters label:hover {
    background: rgba(255,255,255,0.1);
}

body.dark-mode #log-search {
    background: #2d2d2d;
    border-color: #444;
    color: #e0e0e0;
}

body.dark-mode #debug-log {
    background-color: #1e1e1e;
}

body.dark-mode .log-container {
    background-color: #1e1e1e;
}

body.dark-mode .log-entry {
    background-color: #2d2d2d;
    border-left-color: inherit;
    color: #e0e0e0;
}

body.dark-mode .log-entry:hover {
    background-color: #3a3a3a;
}

body.dark-mode .log-info {
    border-left-color: #4299e1;
}

body.dark-mode .log-warning {
    border-left-color: #ed8936;
    background-color: rgba(237, 137, 54, 0.1);
}

body.dark-mode .log-error {
    border-left-color: #f56565;
    background-color: rgba(245, 101, 101, 0.1);
}

body.dark-mode .log-debug {
    border-left-color: #a0aec0;
}

body.dark-mode .log-timestamp {
    color: #a0aec0;
}

body.dark-mode .log-message {
    color: #e2e8f0;
}

body.dark-mode .log-context {
    color: #63b3ed;
}

body.dark-mode .log-more {
    color: #a0aec0;
}

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\assets\css\main.css
================================================================================

/* Estilos gerais */
body {
    font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
    line-height: 1.5;
    color: #333;
    margin: 0;
    padding: 20px;
    background-color: #f9f9f9;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 15px;
}

h1 {
    font-size: 2.2rem;
    color: #2a2a72;
    margin-bottom: 1rem;
    border-bottom: 2px solid #e7e7e7;
    padding-bottom: 0.5rem;
}

/* Estilo para o painel de atualização */
.update-info {
    background: linear-gradient(135deg, #f5f7fa 0%, #e4e8eb 100%);
    border-radius: 8px;
    margin-bottom: 20px;
    padding: 0;
    display: flex;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    overflow: hidden;
    transition: all 0.3s ease;
}

.update-info-icon {
    background-color: #4299e1;
    color: white;
    font-size: 24px;
    padding: 25px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.update-info-content {
    padding: 15px 20px;
    flex-grow: 1;
}

.update-data {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 10px;
}

.update-data .label {
    font-size: 12px;
    color: #718096;
    display: block;
}

.update-data .value {
    font-size: 14px;
    font-weight: bold;
    color: #2d3748;
    display: block;
}

/* Botões e controles */
.btn {
    padding: 10px 20px;
    border-radius: 5px;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
    border: none;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin: 0 15px;
}

.btn-primary {
    background: #4299e1;
    color: white;
}

.btn-primary:hover {
    background: #3182ce;
    box-shadow: 0 4px 8px rgba(49, 130, 206, 0.2);
}

#force-update-btn:disabled {
    opacity: 0.7;
    cursor: not-allowed;
}

/* Controles de filtro e visualização */
.controls-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
}

.source-filters {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    margin: 15px 0;
}

.filter-title {
    font-weight: bold;
    color: #718096;
}

.source-filter {
    padding: 5px 15px;
    background: #f7fafc;
    border: 1px solid #e2e8f0;
    border-radius: 20px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
}

.source-filter:hover, .source-filter.active {
    background: #4299e1;
    color: white;
    border-color: #4299e1;
}

.source-filter[data-source="g1"].active {
    background: #c4170c;
    border-color: #c4170c;
}

.source-filter[data-source="uol"].active {
    background: #1e4b9b;
    border-color: #1e4b9b;
}

.source-filter[data-source="folha"].active {
    background: #2661a8;
    border-color: #2661a8;
}

/* Controles de visualização */
.view-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-left: auto;
}

.view-btn {
    width: 36px;
    height: 36px;
    background: #f7fafc;
    border: 1px solid #e2e8f0;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
}

.view-btn:hover, .view-btn.active {
    background: #4299e1;
    color: white;
    border-color: #4299e1;
}

/* Animações e efeitos globais */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes rotating {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

#force-update-btn:disabled i {
    animation: rotating 1.5s linear infinite;
}

/* Responsividade */
@media (max-width: 768px) {
    body { padding: 10px; }
    h1 { font-size: 1.8rem; }
    .controls-container {
        flex-direction: column;
        align-items: flex-start;
    }
    .view-controls {
        margin-left: 0;
        margin-top: 10px;
    }
    .source-filters, .view-controls {
        margin: 5px 0;
    }
}

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\assets\css\table.css
================================================================================

/* Estilos para a tabela de notícias */
#newsTable {
    border-collapse: separate;
    border-spacing: 0;
    width: 100%;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    overflow: hidden;
}

#newsTable th {
    background-color: #f7fafc;
    color: #4a5568;
    font-weight: 600;
    text-align: left;
    padding: 12px 15px;
    border-bottom: 2px solid #e2e8f0;
}

#newsTable td {
    padding: 10px 15px;
    border-bottom: 1px solid #e2e8f0;
}

#newsTable tr:last-child td {
    border-bottom: none;
}

.news-link {
    color: #2a4365;
    font-weight: 500;
    text-decoration: none;
}

.news-link:hover {
    text-decoration: underline;
    color: #3182ce;
}

.description-preview {
    font-size: 13px;
    color: #718096;
    margin-top: 5px;
    line-height: 1.4;
}

.source-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 11px;
    color: white;
    font-weight: bold;
}

/* Ajustes para DataTables */
.dataTables_wrapper .dataTables_length,
.dataTables_wrapper .dataTables_filter,
.dataTables_wrapper .dataTables_info,
.dataTables_wrapper .dataTables_processing,
.dataTables_wrapper .dataTables_paginate {
    margin-bottom: 10px;
}

.dataTables_wrapper .dataTables_paginate .paginate_button.current {
    background: #4299e1;
    border-color: #4299e1;
    color: white !important;
}

.dataTables_wrapper .dataTables_paginate .paginate_button:hover {
    background: #3182ce;
    border-color: #3182ce;
}

/* Tabela no modo escuro */
body.dark-mode #newsTable {
    border-color: #4a5568;
}

body.dark-mode #newsTable th {
    background-color: #2d3748;
    color: #e2e8f0;
    border-bottom-color: #4a5568;
}

body.dark-mode #newsTable td {
    border-bottom-color: #4a5568;
    color: #e2e8f0;
}

body.dark-mode .news-link {
    color: #63b3ed;
}

body.dark-mode .news-link:hover {
    color: #90cdf4;
}

body.dark-mode .description-preview {
    color: #a0aec0;
}

/* DataTables no modo escuro */
body.dark-mode .dataTables_wrapper .dataTables_length,
body.dark-mode .dataTables_wrapper .dataTables_filter,
body.dark-mode .dataTables_wrapper .dataTables_info,
body.dark-mode .dataTables_wrapper .dataTables_processing,
body.dark-mode .dataTables_wrapper .dataTables_paginate {
    color: #e2e8f0;
}

body.dark-mode .dataTables_wrapper .dataTables_paginate .paginate_button {
    color: #e2e8f0 !important;
}

body.dark-mode .dataTables_wrapper .dataTables_paginate .paginate_button.current,
body.dark-mode .dataTables_wrapper .dataTables_paginate .paginate_button.current:hover {
    color: #2d3748 !important;
    background: #63b3ed;
    border-color: #63b3ed;
}

body.dark-mode .dataTables_wrapper .dataTables_paginate .paginate_button:hover {
    color: #2d3748 !important;
    background: #4299e1;
    border-color: #4299e1;
}

/* Inputs no modo escuro */
body.dark-mode .dataTables_length select,
body.dark-mode .dataTables_filter input {
    background-color: #2d3748;
    color: #e2e8f0;
    border-color: #4a5568;
}

body.dark-mode .dataTables_length select:focus,
body.dark-mode .dataTables_filter input:focus {
    border-color: #63b3ed;
    outline: none;
    box-shadow: 0 0 0 1px #63b3ed;
}

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\assets\js\dark-mode.js
================================================================================

/**
 * Funcionalidade de alternância do modo escuro
 */
document.addEventListener('DOMContentLoaded', function() {
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    
    // Verifica preferência salva ou sistema
    const currentTheme = localStorage.getItem('theme');
    if (currentTheme === 'dark' || (!currentTheme && prefersDarkScheme.matches)) {
        document.body.classList.add('dark-mode');
    }
    
    // Altera o ícone no botão baseado no modo atual
    updateDarkModeIcon();
    
    darkModeToggle.addEventListener('click', function() {
        document.body.classList.toggle('dark-mode');
        
        // Salva preferência
        if (document.body.classList.contains('dark-mode')) {
            localStorage.setItem('theme', 'dark');
        } else {
            localStorage.setItem('theme', 'light');
        }
        
        updateDarkModeIcon();
    });
    
    // Atualiza o ícone do botão de modo escuro
    function updateDarkModeIcon() {
        const icon = darkModeToggle.querySelector('i');
        if (document.body.classList.contains('dark-mode')) {
            icon.className = 'fas fa-sun';
        } else {
            icon.className = 'fas fa-moon';
        }
    }
});

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\assets\js\logs.js
================================================================================

/**
 * Funcionalidades da área de logs (filtros, busca, etc.)
 */
$(document).ready(function() {
    // Contador de logs inicial
    updateLogCount();
    
    // Filtrar logs por nível
    $('.log-filter').change(function() {
        let activeFilters = [];
        $('.log-filter:checked').each(function() {
            activeFilters.push($(this).val());
        });
        
        $('.log-entry').each(function() {
            const logLevel = $(this).data('level');
            if (!logLevel || activeFilters.includes(logLevel)) {
                $(this).removeClass('log-hidden');
            } else {
                $(this).addClass('log-hidden');
            }
        });
        
        updateLogCount();
    });
    
    // Busca nos logs
    $('#search-btn').click(function() {
        searchLogs();
    });
    
    $('#log-search').keypress(function(e) {
        if (e.which == 13) { // Enter key
            searchLogs();
        }
    });
    
    // Limpar visualização
    $('#clear-logs-btn').click(function() {
        $('.log-container').empty()
            .append('<div class="log-empty">Logs limpos da visualização.</div>');
        updateLogCount();
    });
    
    function searchLogs() {
        const searchText = $('#log-search').val().toLowerCase();
        
        // Remove destacamento anterior
        $('.log-message').find('mark').contents().unwrap();
        
        if (!searchText) {
            return;
        }
        
        let matchCount = 0;
        
        // Para cada entrada de log visível
        $('.log-entry:not(.log-hidden)').each(function() {
            const $message = $(this).find('.log-message');
            const messageText = $message.text();
            
            if (messageText.toLowerCase().includes(searchText)) {
                // Destaca o texto encontrado
                const regex = new RegExp('(' + searchText.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ')', 'gi');
                const highlighted = messageText.replace(regex, '<mark>$1</mark>');
                $message.html(highlighted);
                matchCount++;
            }
        });
        
        // Feedback da busca
        if (matchCount > 0) {
            alert(`Encontradas ${matchCount} ocorrências para "${searchText}"`);
        } else {
            alert(`Nenhuma ocorrência encontrada para "${searchText}"`);
        }
    }
    
    function updateLogCount() {
        const totalLogs = $('.log-entry').length;
        const visibleLogs = $('.log-entry:not(.log-hidden)').length;
        
        if (totalLogs === 0) {
            $('#log-count').text('');
            return;
        }
        
        if (totalLogs === visibleLogs) {
            $('#log-count').text(`${totalLogs} logs`);
        } else {
            $('#log-count').text(`${visibleLogs} de ${totalLogs} logs`);
        }
    }
});

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\assets\js\main.js
================================================================================

/**
 * Inicialização geral e configurações do DataTables
 */
$(document).ready(function() {
    // Inicialização do DataTables
    const newsTable = $('#newsTable').DataTable({
        language: {
            "decimal":        "",
            "emptyTable":     "Nenhuma notícia encontrada",
            "info":           "Mostrando de _START_ até _END_ de _TOTAL_ entradas",
            "infoEmpty":      "Mostrando 0 até 0 de 0 entradas",
            "infoFiltered":   "(filtrado de _MAX_ entradas no total)",
            "thousands":      ".",
            "lengthMenu":     "Mostrar _MENU_ entradas",
            "loadingRecords": "Carregando...",
            "processing":     "Processando...",
            "search":         "Buscar:",
            "zeroRecords":    "Nenhum registro encontrado",
            "paginate": {
                "first":      "Primeiro",
                "last":       "Último",
                "next":       "Próximo",
                "previous":   "Anterior"
            },
            "aria": {
                "sortAscending":  ": ativar para classificar em ordem crescente",
                "sortDescending": ": ativar para classificar em ordem decrescente"
            }
        },
        order: [[0, 'desc']],
        pageLength: 10,
        deferRender: true,
        processing: true
    });

    // Tornar a variável newsTable acessível globalmente
    window.newsTable = newsTable;
});

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\assets\js\scraper.js
================================================================================

/**
 * Lógica para atualização de notícias via Server-Sent Events
 */
$(document).ready(function() {
    // Ao clicar no botão "Forçar Atualização"
    $('#force-update-btn').click(function() {
        // Desabilita o botão durante a atualização
        $(this).prop('disabled', true);
        
        // Remove log anterior se existir
        $('#update-log').remove();
        
        // Cria um div para exibir o log de atualização
        let $updateLog = $('<div id="update-log" style="margin:10px 0; padding:8px; background:#f8f9fa; border:1px solid #ddd; border-radius:4px; font-family:monospace; max-height:300px; overflow-y:auto;"></div>');
        $('#loading-indicator').html('<span>Conectando ao servidor...</span>').after($updateLog);
        
        // Adiciona uma linha ao log de atualização
        function addLogLine(message, className = '') {
            let timestamp = new Date().toLocaleTimeString();
            $updateLog.append(`<div class="${className}">[${timestamp}] ${message}</div>`);
            // Auto-scroll para o final
            $updateLog.scrollTop($updateLog[0].scrollHeight);
        }
        
        // Contador para reconexões
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 3;
        
        // Função para criar e configurar a conexão SSE
        function setupEventSource() {
            // Fecha a conexão existente se houver
            if (window.activeEventSource) {
                window.activeEventSource.close();
            }
            
            // Adiciona um timestamp para evitar cache
            const eventSource = new EventSource('/api/force_update.php?t=' + Date.now());
            window.activeEventSource = eventSource;
            
            // Evento de abertura da conexão
            eventSource.onopen = function() {
                addLogLine("Conexão estabelecida com o servidor", "text-info");
                reconnectAttempts = 0; // Reseta contagem de tentativas
            };
            
            // Evento de início de processo
            eventSource.addEventListener('start', function(e) {
                const data = JSON.parse(e.data);
                $('#loading-indicator').html('<span style="color:#ff6600">Atualizando...</span>');
                addLogLine(data.message, 'text-primary');
            });
            
            // Evento de progresso
            eventSource.addEventListener('progress', function(e) {
                const data = JSON.parse(e.data);
                addLogLine(data.message);
            });
            
            // Evento de heartbeat para manter a conexão
            eventSource.addEventListener('heartbeat', function() {
                console.log("Heartbeat recebido");
            });
            
            // Evento de conclusão
            eventSource.addEventListener('complete', function(e) {
                const data = JSON.parse(e.data);
                
                // Adiciona informação final de sucesso
                addLogLine(`Concluído em ${data.execution_time}s! Total de ${data.articles_count} notícias.`, 'text-success');
                
                // Adiciona estatísticas por fonte
                if (data.sources) {
                    let sourcesText = 'Notícias por fonte: ';
                    Object.entries(data.sources).forEach(([source, count], index, arr) => {
                        sourcesText += `${source} (${count})${index < arr.length - 1 ? ', ' : ''}`;
                    });
                    addLogLine(sourcesText, 'text-info');
                }
                
                // Exibe mensagem de sucesso no indicador principal
                $('#loading-indicator').html(`<span style="color:#228B22">Atualização concluída!</span>`);
                
                // Fecha a conexão SSE
                eventSource.close();
                window.activeEventSource = null;
                
                // Reativa o botão após 1 segundo
                setTimeout(function() {
                    $('#force-update-btn').prop('disabled', false);
                }, 1000);
                
                // Recarrega a página após 5 segundos
                setTimeout(function() {
                    location.reload();
                }, 5000);
            });
            
            // Evento de erro no processo
            eventSource.addEventListener('error', function(e) {
                if (e.data) {
                    try {
                        const data = JSON.parse(e.data);
                        addLogLine(data.message, 'text-danger');
                    } catch (err) {
                        addLogLine("Erro no processamento: " + e.data, 'text-danger');
                    }
                }
            });
            
            // Em caso de erro na conexão
            eventSource.onerror = function(e) {
                // Tenta reconectar algumas vezes
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    reconnectAttempts++;
                    addLogLine(`Tentativa de reconexão ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}...`, 'text-warning');
                    
                    setTimeout(function() {
                        eventSource.close();
                        setupEventSource();
                    }, 2000); // Espera 2 segundos antes de reconectar
                } else {
                    addLogLine("Conexão com o servidor perdida após várias tentativas", 'text-danger');
                    $('#loading-indicator').html(`<span style="color:#d32f2f">Erro de conexão</span>`);
                    
                    eventSource.close();
                    window.activeEventSource = null;
                    $('#force-update-btn').prop('disabled', false);
                }
            };
            
            return eventSource;
        }
        
        // Inicia a conexão SSE
        setupEventSource();
    });
});

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\assets\js\view-switcher.js
================================================================================

/**
 * Alternância entre visualização em cards e tabela
 */
$(document).ready(function() {
    // Script para filtrar notícias por fonte
    $('.source-filter').click(function() {
        const source = $(this).data('source');
        
        // Atualiza classes ativas
        $('.source-filter').removeClass('active');
        $(this).addClass('active');
        
        // Filtro para os cards
        if (source === 'all') {
            $('.news-card').show();
        } else {
            $('.news-card').hide();
            $(`.news-card .news-source.${source}`).parent().show();
        }
        
        // Filtro para a tabela usando DataTables API
        if (window.newsTable) {
            if (source === 'all') {
                window.newsTable.column(2).search('').draw();
            } else {
                window.newsTable.column(2).search(source, false, false).draw();
            }
        }
        
        // Salva a preferência de filtro
        localStorage.setItem('preferred-filter', source);
    });

    // Restaurar preferência de filtro
    const preferredFilter = localStorage.getItem('preferred-filter');
    if (preferredFilter && preferredFilter !== 'all') {
        $(`.source-filter[data-source="${preferredFilter}"]`).click();
    }

    // Alternar entre visualização em cards e tabela
    $('#grid-view-btn').click(function() {
        $(this).addClass('active');
        $('#table-view-btn').removeClass('active');
        $('#grid-view').show();
        $('#table-view').hide();
        localStorage.setItem('preferred-view', 'grid');
    });

    $('#table-view-btn').click(function() {
        $(this).addClass('active');
        $('#grid-view-btn').removeClass('active');
        $('#table-view').show();
        $('#grid-view').hide();
        // Ajusta as colunas da tabela quando ela se torna visível
        if (window.newsTable) {
            window.newsTable.columns.adjust();
        }
        localStorage.setItem('preferred-view', 'table');
    });

    // Restaurar preferência de visualização
    const preferredView = localStorage.getItem('preferred-view');
    if (preferredView === 'table') {
        $('#table-view-btn').click();
    }
});

================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\css\style.css
================================================================================

body {
    font-family: Arial, sans-serif;
    margin: 20px;
}
h1 {
    color: #333;
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\public\js\script.js
================================================================================

// Função que busca as notícias via endpoint JSON
function fetchNews() {
    fetch('/public/api/news.php')
        .then(response => response.json())
        .then(data => updateNews(data))
        .catch(error => console.error('Erro ao buscar notícias:', error));
}

// Atualiza o conteúdo do container com as notícias recebidas
function updateNews(data) {
    const container = document.getElementById('newsContainer');
    if (data && data.length > 0) {
        let html = '<ul>';
        data.forEach(item => {
            html += `<li>
                        <a href="${item.url}" target="_blank">${item.title}</a>
                        <p>${item.description}</p>
                     </li>`;
        });
        html += '</ul>';
        container.innerHTML = html;
    } else {
        container.innerHTML = '<p>Nenhuma notícia encontrada.</p>';
    }
}

// Chamada inicial para carregar as notícias imediatamente
fetchNews();

// Atualiza as notícias a cada 60 segundos (60000 milissegundos)
setInterval(fetchNews, 60000);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Controllers\NewsController.php
================================================================================

<?php
// filepath: c:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Controllers\NewsController.php

namespace App\Controllers;

use App\Models\Scraper;

class NewsController {
    public function index() {
        $scraper = new Scraper();
        $news = $scraper->getAllPoliticalNews();
        require_once __DIR__ . '/../Views/index.php';
    }
}
?>


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Factories\ScraperFactory.php
================================================================================

<?php
// filepath: c:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Factories\ScraperFactory.php

namespace App\Factories;

use App\Models\G1Scraper;
use App\Models\UOLScraper;
use App\Models\FolhaScraper;

class ScraperFactory
{
    /**
     * Lê config/scrapers_config.php e instancia cada classe listada.
     *
     * @return array Array de instâncias de scrapers
     */
    public static function createAllScrapers(): array
    {
        // Carrega o array de nomes de classes do config
        $scraperClasses = require __DIR__ . '/../../../config/scrapers_config.php';

        $scrapers = [];
        foreach ($scraperClasses as $className) {
            // Constrói o nome completo da classe com namespace
            $fullClassName = 'App\\Models\\' . $className;
            
            // Verifica se a classe existe
            if (class_exists($fullClassName)) {
                // Instancia dinamicamente
                $scrapers[] = new $fullClassName();
            }
        }
        return $scrapers;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\AbstractNewsScraper.php
================================================================================

<?php
// filepath: c:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\AbstractNewsScraper.php

namespace App\Models;

use App\Utils\HttpClient;

/**
 * Classe abstrata que cuida de:
 * - Cache (getFromCache / saveToCache)
 * - Obter HTML via HttpClient
 * - Criação de DOMXPath (createDomXPath)
 * - Logging padronizado (log)
 */
abstract class AbstractNewsScraper implements NewsScraperInterface
{
    protected $cacheFile;
    protected $cacheTime;

    public function __construct($cacheFile, $cacheTime = 600)
    {
        $this->cacheFile = $cacheFile;
        $this->cacheTime = $cacheTime;
    }

    /**
     * Tenta recuperar os dados do cache, se válido.
     */
    protected function getFromCache(): ?array
    {
        if (file_exists($this->cacheFile) && ((time() - filemtime($this->cacheFile)) < $this->cacheTime)) {
            $this->log("Utilizando cache do arquivo: " . $this->cacheFile);
            $data = file_get_contents($this->cacheFile);
            $newsItems = json_decode($data, true);
            if (is_array($newsItems)) {
                return $newsItems;
            }
        }
        return null;
    }

    /**
     * Salva os dados no cache.
     */
    protected function saveToCache(array $data): void
    {
        if (!is_dir(dirname($this->cacheFile))) {
            mkdir(dirname($this->cacheFile), 0777, true);
        }
        file_put_contents($this->cacheFile, json_encode($data));
    }

    /**
     * Obtém o HTML de uma URL usando HttpClient.
     */
    protected function getHtml(string $url, array $headers = []): ?string
    {
        $this->log("getHtml: Buscando HTML de " . $url);
        return HttpClient::get($url, $headers);
    }

    /**
     * Cria um DOMDocument e DOMXPath a partir de uma string HTML, já tratando encoding e supressão de erros.
     */
    protected function createDomXPath(string $html): ?\DOMXPath
    {
        // Converter encoding para evitar problemas de caracteres
        $convmap = [0x80, 0x10FFFF, 0, 0x10FFFF];
        $html = mb_encode_numericentity($html, $convmap, 'UTF-8');

        $dom = new \DOMDocument();
        libxml_use_internal_errors(true);
        $dom->loadHTML($html);
        libxml_clear_errors();

        return new \DOMXPath($dom);
    }

    /**
     * Método simples de log, para centralizar prefixos.
     */
    protected function log(string $message, $level = LOG_INFO): void
    {
        debug_log($message, $level, get_class($this));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\FolhaScraper.php
================================================================================

<?php
// filepath: c:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\FolhaScraper.php

namespace App\Models;

require_once 'AbstractNewsScraper.php';

class FolhaScraper extends AbstractNewsScraper
{
    public function __construct()
    {
        $cacheFile = __DIR__ . '/../../../cache/folha_news.json';
        $cacheTime = 600; // 10 minutos
        parent::__construct($cacheFile, $cacheTime);
        $this->log("[Folha] | Inicializado: Cache definido para 10 minutos.");
    }

    public function fetchNews(bool $forceUpdate = false): array
    {
        if (!$forceUpdate) {
            $cached = $this->getFromCache();
            if ($cached !== null) {
                $this->log("[Folha] | Cache: Utilizando dados do cache.");
                return $cached;
            }
        }
        
        $this->log("[Folha] | Scraping: Iniciando scraping da página de listagem.");
        $url = 'https://www1.folha.uol.com.br/poder/';
        $headers = [
            'User-Agent' => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36",
            'Referer'    => "https://www.google.com/"
        ];
        
        $html = $this->getHtml($url, $headers);
        if ($html === null) {
            $this->log("[Folha] | Erro: Falha ao obter HTML da listagem.");
            return [];
        }
        
        $xpath = $this->createDomXPath($html);
        if (!$xpath) {
            $this->log("[Folha] | Erro: Falha ao criar DOMXPath.");
            return [];
        }

        $newsItems = [];
        
        // Seleciona cada bloco <li> com a classe "c-headline c-headline--newslist"
        $nodes = $xpath->query("//li[contains(@class, 'c-headline') and contains(@class, 'c-headline--newslist')]");
        $this->log("[Folha] | Listagem: Nós encontrados = " . $nodes->length, LOG_INFO);
        $this->log("[UOL] | Listagem: Itens encontrados = " . $nodes->length, LOG_INFO);
        
        foreach ($nodes as $node) {
            // Extrai URL do artigo
            $linkNode = $xpath->query(".//div[contains(@class,'c-headline__content')]/a", $node);
            if (!$linkNode || $linkNode->length === 0) {
                continue;
            }
            $articleUrl = $linkNode->item(0)->getAttribute('href');

            // Título (pego da listagem)
            $titleNode = $xpath->query(".//h2[contains(@class,'c-headline__title')]", $node);
            $title = '';
            if ($titleNode && $titleNode->length > 0) {
                $title = trim($titleNode->item(0)->nodeValue);
            }

            // Descrição (pego da listagem)
            $descNode = $xpath->query(".//p[contains(@class,'c-headline__standfirst')]", $node);
            $description = 'Descrição não disponível.';
            if ($descNode && $descNode->length > 0) {
                $description = trim($descNode->item(0)->nodeValue);
            }

            // Data (pego da listagem)
            $timeNode = $xpath->query(".//time[contains(@class,'c-headline__dateline')]", $node);
            $publishedAt = 'Data não informada.';
            if ($timeNode && $timeNode->length > 0) {
                // Primeiro tenta pegar do atributo datetime
                $publishedAtAttr = trim($timeNode->item(0)->getAttribute('datetime'));
                if ($publishedAtAttr) {
                    $publishedAt = $publishedAtAttr;
                } else {
                    // Se não existir, pega o texto dentro de <time>
                    $timeText = trim($timeNode->item(0)->nodeValue);
                    if ($timeText) {
                        $publishedAt = $timeText;
                    }
                }
            }

            // Autor (normalmente não aparece no listing, então vamos buscar na página do artigo)
            $author = 'Não disponível';

            // Agora buscamos dados detalhados no artigo individual
            $articleDetails = $this->scrapeArticle($articleUrl, $headers);
            if ($articleDetails) {
                // Se os detalhes tiverem autor, data ou até título/descrição melhores, use-os
                if (!empty($articleDetails['author'])) {
                    $author = $articleDetails['author'];
                }
                // Se quiser sobrepor título/descrição/data, também pode:
                // if (!empty($articleDetails['title'])) { $title = $articleDetails['title']; }
                // if (!empty($articleDetails['description'])) { $description = $articleDetails['description']; }
                // if (!empty($articleDetails['publishedAt']) && $articleDetails['publishedAt'] !== 'Data não informada.') {
                //    $publishedAt = $articleDetails['publishedAt'];
                // }
            }

            if ($title && $articleUrl) {
                $newsItems[] = [
                    'title'       => $title,
                    'url'         => $articleUrl,
                    'description' => $description,
                    'author'      => $author,
                    'publishedAt' => $publishedAt,
                    'source'      => 'Folha'
                ];
            }
        }
        
        $this->log("[Folha] | Concluído: Scraping finalizado. Artigos encontrados = " . count($newsItems));
        $this->saveToCache($newsItems);
        return $newsItems;
    }

    /**
     * Faz uma segunda requisição para o artigo e extrai autor, data, etc.
     */
    private function scrapeArticle(string $articleUrl, array $headers): ?array
    {
        $this->log("[Folha] | scrapeArticle: Buscando HTML do artigo: " . $articleUrl);
        $html = $this->getHtml($articleUrl, $headers);
        if ($html === null) {
            $this->log("[Folha] | scrapeArticle: Erro ao obter HTML do artigo: " . $articleUrl);
            return null;
        }

        $xpath = $this->createDomXPath($html);
        if (!$xpath) {
            $this->log("[Folha] | scrapeArticle: Falha ao criar DOMXPath no artigo: " . $articleUrl);
            return null;
        }

        // Exemplo de como pegar o autor:
        //   <div class="c-news__wrap">
        //     <div class="c-signature">
        //       <strong class="c-signature__author">
        //         <a href="...">Catia Seabra</a>
        //       </strong>
        //     </div>
        //   </div>
        $authorNodes = $xpath->query("//div[contains(@class, 'c-news__wrap')]//div[contains(@class, 'c-signature')]//strong[contains(@class, 'c-signature__author')]/a");
        $author = ($authorNodes->length > 0)
            ? trim($authorNodes->item(0)->nodeValue)
            : 'Não disponível';

        $this->log("[Folha] | scrapeArticle: Autor extraído = " . $author);

        // Se quiser, pode extrair título, descrição, data daqui também.
        // Exemplo rápido (ajuste se for preciso):
        $titleNodes = $xpath->query("//h1[contains(@class, 'c-content-head__title')]");
        $title = $titleNodes->length > 0 ? trim($titleNodes->item(0)->nodeValue) : '';

        // Retorna só o que for precisar
        return [
            'author' => $author,
            'title'  => $title,
            // 'description' => ...,
            // 'publishedAt' => ...
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\G1Scraper.php
================================================================================

<?php
// filepath: c:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\G1Scraper.php

namespace App\Models;

require_once 'AbstractNewsScraper.php';

class G1Scraper extends AbstractNewsScraper
{
    public function __construct()
    {
        $cacheFile = __DIR__ . '/../../../cache/g1_news.json';
        $cacheTime = 600; // 10 minutos
        parent::__construct($cacheFile, $cacheTime);
        $this->log("[G1] | Inicializado: Cache definido para 10 minutos.");
    }

    public function fetchNews(bool $forceUpdate = false): array
    {
        if (!$forceUpdate) {
            $cached = $this->getFromCache();
            if ($cached !== null) {
                $this->log("[G1] | Cache: Utilizando dados do cache.");
                return $cached;
            }
        }
        
        $this->log("[G1] | Scraping: Iniciando scraping da página de listagem.");
        $url = 'https://g1.globo.com/politica/';
        $headers = [
            'User-Agent' => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36"
        ];

        $html = $this->getHtml($url, $headers);
        if ($html === null) {
            $this->log("[G1] | Erro: Falha ao obter HTML da listagem.");
            return [];
        }
        
        // Em vez do DOMDocument manual, usamos:
        $xpath = $this->createDomXPath($html);
        if (!$xpath) {
            $this->log("[G1] | Erro: Falha ao criar DOMXPath.");
            return [];
        }

        $newsItems = [];
        
        // Seleciona os links dos artigos na página de listagem
        $nodes = $xpath->query("//a[contains(@class, 'feed-post-link')]");
        $this->log("[G1] | Listagem: Nós encontrados = " . $nodes->length, LOG_INFO);
        
        $articleLinks = [];
        foreach ($nodes as $node) {
            if (!$node instanceof \DOMElement) {
                continue;
            }
            $link = $node->getAttribute('href');
            if ($link && !in_array($link, $articleLinks)) {
                $articleLinks[] = $link;
            }
        }
        
        foreach ($articleLinks as $articleUrl) {
            $details = $this->scrapeArticle($articleUrl, $headers);
            if ($details) {
                $newsItems[] = $details;
            }
        }
        
        $this->log("[G1] | Concluído: Scraping finalizado. Artigos encontrados = " . count($newsItems));
        $this->saveToCache($newsItems);
        return $newsItems;
    }
    
    private function scrapeArticle(string $articleUrl, array $headers): ?array
    {
        $html = $this->getHtml($articleUrl, $headers);
        if ($html === null) {
            $this->log("[G1] | Erro: Falha ao obter HTML do artigo: " . $articleUrl);
            return null;
        }
        
        // Cria DOMXPath via método auxiliar
        $xpath = $this->createDomXPath($html);
        if (!$xpath) {
            $this->log("[G1] | Erro: DOMXPath nulo no artigo: " . $articleUrl);
            return null;
        }
        
        // Título
        $titleNodes = $xpath->query("//div[contains(@class, 'mc-article-header')]//h1[@itemprop='headline']");
        $title = $titleNodes->length > 0 ? trim($titleNodes->item(0)->nodeValue) : '';
        
        // Descrição
        $descNodes = $xpath->query("//div[contains(@class, 'mc-article-header')]//h2[contains(@class, 'content-head__subtitle') and @itemprop='alternativeHeadline']");
        $description = $descNodes->length > 0 ? trim($descNodes->item(0)->nodeValue) : 'Descrição não disponível.';

        // Data de publicação
        $timeNodes = $xpath->query("//div[contains(@class, 'mc-article-header')]//time[@itemprop='datePublished']");
        $publishedAt = $timeNodes->length > 0 ? $timeNodes->item(0)->getAttribute('datetime') : 'Data não informada.';
        
        // Autor
        $author = '';
        $authorNodes = $xpath->query("//div[contains(@class, 'mc-article-header')]//p[contains(@class, 'content-publication-data__from')]");
        if ($authorNodes->length > 0) {
            $aNodes = $xpath->query(".//a", $authorNodes->item(0));
            if ($aNodes->length > 0) {
                $author = trim($aNodes->item(0)->nodeValue);
            }
        }
        
        if (!$title) {
            $this->log("[G1] | Alerta: Título não extraído para artigo: " . $articleUrl);
            return null;
        }
        
        return [
            'title'       => $title,
            'url'         => $articleUrl,
            'description' => $description,
            'author'      => $author ?: 'Não disponível',
            'publishedAt' => $publishedAt ?: 'Data não informada.',
            'source'      => 'G1'
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\NewsScraperInterface.php
================================================================================

<?php
// filepath: c:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\NewsScraperInterface.php

namespace App\Models;

interface NewsScraperInterface {
    /**
     * Método para buscar notícias do portal específico.
     *
     * @return array Array de notícias.
     */
    public function fetchNews(): array;
}
?>


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\Scraper.php
================================================================================

<?php
// filepath: c:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\Scraper.php

namespace App\Models;

use App\Factories\ScraperFactory;

class Scraper
{
    private $scrapers = [];
    private $progressCallback = null;

    public function __construct($progressCallback = null)
    {
        // Em vez de instanciar manualmente, carregamos via factory:
        $this->scrapers = ScraperFactory::createAllScrapers();
        // Armazena o callback para reportar progresso
        $this->progressCallback = $progressCallback;
    }

    private function reportProgress($message) {
        if (is_callable($this->progressCallback)) {
            call_user_func($this->progressCallback, $message);
        }
    }

    public function getAllPoliticalNews(bool $forceUpdate = false): array
    {
        $news = [];
        $this->reportProgress("Iniciando coleta de notícias políticas...");
        
        foreach ($this->scrapers as $scraper) {
            $scraperName = get_class($scraper);
            $this->reportProgress("Processando fonte: " . $scraperName);
            
            try {
                // Cada $scraper é algo que herda AbstractNewsScraper e implementa fetchNews()
                $startTime = microtime(true);
                $sourceNews = $scraper->fetchNews($forceUpdate);
                $endTime = microtime(true);
                $timeSpent = round($endTime - $startTime, 2);
                
                $this->reportProgress("Concluído " . $scraperName . ": " . count($sourceNews) . " notícias em " . $timeSpent . "s");
                $news = array_merge($news, $sourceNews);
            } catch (Exception $e) {
                $this->reportProgress("ERRO em " . $scraperName . ": " . $e->getMessage());
            }
        }

        $this->reportProgress("Normalizando datas de " . count($news) . " notícias...");
        // Normaliza datas
        foreach ($news as &$item) {
            if (!empty($item['publishedAt'])) {
                $item['publishedAt'] = $this->normalizeDate($item['publishedAt']);
            }
        }
        
        $this->reportProgress("Processamento completo. Total de notícias: " . count($news));
        return $news;
    }

    private function normalizeDate(string $date): string
    {
        // Aqui segue o código que você já tem
        $date = trim($date);
        if (strpos($date, "T") !== false) {
            try {
                $dt = new DateTime($date);
                return $dt->format('Y-m-d\TH:i:sP');
            } catch (Exception $e) {
                // tenta formatos abaixo
            }
        }
        $dt = DateTime::createFromFormat('Y-m-d H:i:s', $date, new DateTimeZone('America/Sao_Paulo'));
        if ($dt !== false) {
            return $dt->format('Y-m-d\TH:i:sP');
        }
        $dt = DateTime::createFromFormat('d/m/Y H:i:s', $date, new DateTimeZone('America/Sao_Paulo'));
        if ($dt !== false) {
            return $dt->format('Y-m-d\TH:i:sP');
        }
        $dt = DateTime::createFromFormat('d/m/Y H:i', $date, new DateTimeZone('America/Sao_Paulo'));
        if ($dt !== false) {
            return $dt->format('Y-m-d\TH:i:sP');
        }
        if (strtotime($date) !== false) {
            $dt = new DateTime($date);
            return $dt->format('Y-m-d\TH:i:sP');
        }
        return "1970-01-01T00:00:00+00:00";
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\UOLScraper.php
================================================================================

<?php
// filepath: c:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Models\UOLScraper.php

namespace App\Models;

require_once 'AbstractNewsScraper.php';

class UOLScraper extends AbstractNewsScraper
{
    public function __construct()
    {
        $cacheFile = __DIR__ . '/../../../cache/uol_news.json';
        $cacheTime = 600;
        parent::__construct($cacheFile, $cacheTime);
        $this->log("[UOL] | Inicializado: Cache definido para 10 minutos.");
    }

    public function fetchNews(bool $forceUpdate = false): array
    {
        if (!$forceUpdate) {
            $cached = $this->getFromCache();
            if ($cached !== null) {
                $this->log("[UOL] | Cache: Utilizando dados do cache.");
                return $cached;
            }
        }
        
        $this->log("[UOL] | Scraping: Iniciando scraping da página de listagem.");
        $url = 'https://noticias.uol.com.br/politica/';
        $headers = [
            'User-Agent' => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36",
            'Referer'    => "https://www.google.com/"
        ];
        
        $html = $this->getHtml($url, $headers);
        if ($html === null) {
            $this->log("[UOL] | Erro: Falha ao obter HTML da listagem.");
            return [];
        }

        $xpath = $this->createDomXPath($html);
        if (!$xpath) {
            $this->log("[UOL] | Erro: Falha ao criar DOMXPath.");
            return [];
        }
        
        $newsItems = [];
        
        // Busca nós com a classe "thumbnails-item" (excluindo itemAds)
        $nodes = $xpath->query("//div[contains(@class, 'thumbnails-item') and not(contains(@class, 'itemAds'))]");
        $this->log("[UOL] | Listagem: Itens encontrados = " . $nodes->length, LOG_INFO);
        
        foreach ($nodes as $node) {
            if (!$node instanceof \DOMElement) continue;
            $aTag = $node->getElementsByTagName('a')->item(0);
            if (!$aTag) continue;
            $link = $aTag->getAttribute('href');
            
            $titleNodes = $xpath->query(".//h3[contains(@class, 'thumb-title')]", $node);
            $title = ($titleNodes->length > 0) ? trim($titleNodes->item(0)->nodeValue) : 'Sem título';
            
            // Data do listing
            $timeNodes = $xpath->query(".//*[contains(@class, 'thumb-date')]", $node);
            $publishedAt = ($timeNodes->length > 0) ? trim($timeNodes->item(0)->nodeValue) : 'Data não informada';
            
            $details = $this->scrapeArticle($link, $headers);
            if ($details) {
                // Se o artigo tiver data válida, substitui a data do listing
                if (!empty($details['publishedAt']) && $details['publishedAt'] !== 'Data não informada.') {
                    $publishedAt = $details['publishedAt'];
                }
                $newsItems[] = [
                    'title'       => $title,
                    'url'         => $link,
                    'description' => $details['description'] ?? 'Descrição não disponível.',
                    'author'      => $details['author'] ?? 'Não disponível',
                    'publishedAt' => $publishedAt,
                    'source'      => 'UOL'
                ];
            } else {
                $newsItems[] = [
                    'title'       => $title,
                    'url'         => $link,
                    'description' => 'Descrição não disponível.',
                    'author'      => 'Não disponível',
                    'publishedAt' => $publishedAt,
                    'source'      => 'UOL'
                ];
            }
        }
        
        $this->log("[UOL] | Concluído: Scraping finalizado. Artigos encontrados = " . count($newsItems));
        $this->saveToCache($newsItems);
        return $newsItems;
    }
    
    private function scrapeArticle(string $articleUrl, array $headers): ?array
    {
        $html = $this->getHtml($articleUrl, $headers);
        if ($html === null) {
            $this->log("[UOL] | Erro: Falha ao obter HTML do artigo: " . $articleUrl);
            return null;
        }
        
        $xpath = $this->createDomXPath($html);
        if (!$xpath) {
            $this->log("[UOL] | Erro: DOMXPath nulo no artigo: " . $articleUrl);
            return null;
        }
        
        // Primeiro parágrafo do container "jupiter-paragraph-fragment"
        $paraNodes = $xpath->query("//div[contains(@class, 'jupiter-paragraph-fragment')]//p");
        $description = ($paraNodes->length > 0) ? trim($paraNodes->item(0)->nodeValue) : 'Descrição não disponível.';
        
        // Autor
        $authorNodes = $xpath->query("//div[contains(@class, 'solar-author-names')]//a[contains(@class, 'solar-author-name')]");
        $author = ($authorNodes->length > 0) ? trim($authorNodes->item(0)->nodeValue) : 'Não disponível';
        
        // Data
        $timeNodes = $xpath->query("//div[contains(@class, 'solar-date')]//time[@class='date']");
        $publishedAt = ($timeNodes->length > 0) ? trim($timeNodes->item(0)->getAttribute('datetime')) : 'Data não informada.';
        
        return [
            'description' => $description,
            'author'      => $author,
            'publishedAt' => $publishedAt
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Utils\HttpClient.php
================================================================================

<?php
// filepath: c:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Utils\HttpClient.php

namespace App\Utils;

class HttpClient {
    /**
     * Executa uma requisição GET na URL informada com os headers fornecidos.
     */
    public static function get(string $url, array $headers = []): ?string {
        // Ajusta o tempo máximo de execução do script para 15 segundos
        set_time_limit(15);
        
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
        // Define o tempo máximo de execução para o cURL (em segundos)
        curl_setopt($ch, CURLOPT_TIMEOUT, 10);
        // Define o tempo máximo de conexão (em segundos)
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);

        if (!empty($headers)) {
            $formattedHeaders = [];
            foreach ($headers as $key => $value) {
                $formattedHeaders[] = $key . ": " . $value;
            }
            curl_setopt($ch, CURLOPT_HTTPHEADER, $formattedHeaders);
        }
        
        $html = curl_exec($ch);
        if ($html === false) {
            debug_log("[HttpClient] | Erro ao obter HTML de $url: " . curl_error($ch));
            curl_close($ch);
            return null;
        }
        curl_close($ch);
        return $html;
    }
}
?>


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\src\App\Views\index.php
================================================================================

<?php
// app/views/index.php
?>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notícias de Política</title>
    
    <!-- CSS externos -->
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    
    <!-- CSS do sistema -->
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/cards.css">
    <link rel="stylesheet" href="/assets/css/table.css">
    <link rel="stylesheet" href="/assets/css/logs.css">
    <link rel="stylesheet" href="/assets/css/dark-mode.css">
    
    <!-- jQuery e DataTables -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
    
    <!-- JavaScript do sistema -->
    <script src="/assets/js/main.js"></script>
    <script src="/assets/js/dark-mode.js"></script>
    <script src="/assets/js/view-switcher.js"></script>
    <script src="/assets/js/scraper.js"></script>
    <script src="/assets/js/logs.js"></script>
</head>
<body>
    <!-- Adicione este botão no topo da página -->
    <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Alternar modo escuro">
        <i class="fas fa-moon"></i>
    </button>

    <h1>Notícias de Política</h1>
    <?php 
        require_once __DIR__ . '/../../../config/config.php';
        $cacheFile = CACHE_DIR . '/all_news.json';
        $cacheTime = 600; // 10 minutos
    ?>
    <!-- Substitua o div #update-info existente por este -->
    <div id="update-info" class="update-info">
        <div class="update-info-icon">
            <i class="fas fa-sync-alt"></i>
        </div>
        <div class="update-info-content">
            <?php if (file_exists($cacheFile)): ?>
                <div class="update-data">
                    <div>
                        <span class="label">Última atualização:</span>
                        <span class="value"><?php echo date("d/m/Y H:i:s", filemtime($cacheFile)); ?></span>
                    </div>
                    <div>
                        <span class="label">Próxima atualização:</span>
                        <span class="value"><?php echo date("d/m/Y H:i:s", filemtime($cacheFile) + $cacheTime); ?></span>
                    </div>
                    <div>
                        <span class="label">Total de notícias:</span>
                        <span class="value"><?php echo count($news); ?></span>
                    </div>
                </div>
            <?php else: ?>
                <div class="update-empty">Nenhuma atualização realizada</div>
            <?php endif; ?>
        </div>
        <button id="force-update-btn" class="btn btn-primary">
            <i class="fas fa-sync-alt"></i> Forçar Atualização
        </button>
    </div>
    
    <!-- Agrupar filtros e controles de visualização -->
    <div class="controls-container">
        <div class="source-filters">
            <span class="filter-title">Filtrar por fonte:</span>
            <button class="source-filter active" data-source="all">Todas</button>
            <button class="source-filter" data-source="g1">G1</button>
            <button class="source-filter" data-source="uol">UOL</button>
            <button class="source-filter" data-source="folha">Folha</button>
        </div>
        <div class="view-controls">
            <span class="filter-title">Visualização:</span>
            <button id="grid-view-btn" class="view-btn active" title="Visualização em cards">
                <i class="fas fa-th-large"></i>
            </button>
            <button id="table-view-btn" class="view-btn" title="Visualização em tabela">
                <i class="fas fa-table"></i>
            </button>
        </div>
    </div>

    <!-- Substitua o bloco onde mostra as notícias por: -->
    <?php if (isset($news) && is_array($news) && count($news) > 0): ?>
        <!-- Visualização em cards (padrão) -->
        <div class="news-grid" id="grid-view">
            <?php foreach ($news as $item): ?>
                <div class="news-card">
                    <span class="news-source <?php echo strtolower($item['source']); ?>">
                        <?php echo $item['source']; ?>
                    </span>
                    <h3 class="news-title">
                        <a href="<?php echo $item['url']; ?>" target="_blank">
                            <?php echo $item['title'] ?? 'Sem título'; ?>
                        </a>
                    </h3>
                    <p class="news-description"><?php echo $item['description'] ?: 'Descrição não disponível.'; ?></p>
                    <div class="news-meta">
                        <span class="news-date">
                            <?php 
                            if (!empty($item['publishedAt']) && $item['publishedAt'] !== "1970-01-01T00:00:00+00:00") {
                                echo '<i class="fas fa-calendar-alt"></i> ' . date("d/m/Y H:i", strtotime($item['publishedAt']));
                            }
                            ?>
                        </span>
                        <span class="news-author">
                            <?php if ($item['author'] && $item['author'] !== 'Não disponível'): ?>
                                <i class="fas fa-user"></i> <?php echo $item['author']; ?>
                            <?php endif; ?>
                        </span>
                    </div>
                </div>
            <?php endforeach; ?>
        </div>
        
        <!-- Visualização em tabela (inicialmente oculta) -->
        <div id="table-view" style="display: none;">
            <table id="newsTable" class="display" style="width:100%">
                <thead>
                    <tr>
                        <th>Data</th>
                        <th>Título</th>
                        <th>Fonte</th>
                        <th>Autor</th>
                    </tr>
                </thead>
                <tbody>
                    <?php foreach ($news as $item): ?>
                    <tr>
                        <td data-order="<?php echo $item['publishedAt'] ?? ''; ?>">
                            <?php 
                            if (!empty($item['publishedAt']) && $item['publishedAt'] !== "1970-01-01T00:00:00+00:00") {
                                echo date("d/m/Y H:i", strtotime($item['publishedAt']));
                            } else {
                                echo "Data não disponível";
                            }
                            ?>
                        </td>
                        <td>
                            <a href="<?php echo $item['url']; ?>" target="_blank" class="news-link">
                                <?php echo $item['title'] ?? 'Sem título'; ?>
                            </a>
                            <?php if (!empty($item['description'])): ?>
                            <div class="description-preview">
                                <?php echo $item['description']; ?>
                            </div>
                            <?php endif; ?>
                        </td>
                        <td>
                            <span class="source-badge <?php echo strtolower($item['source']); ?>">
                                <?php echo $item['source']; ?>
                            </span>
                        </td>
                        <td><?php echo $item['author'] ?? 'Não disponível'; ?></td>
                    </tr>
                    <?php endforeach; ?>
                </tbody>
            </table>
        </div>
    <?php else: ?>
        <p>Nenhuma notícia encontrada.</p>
    <?php endif; ?>

    <!-- Área para exibir os logs de depuração com melhorias visuais -->
    <div id="debug-container">
        <div id="debug-header">
            <h3>Log do Sistema</h3>
            <div class="debug-filters">
                <label><input type="checkbox" class="log-filter" value="INFO" checked> INFO</label>
                <label><input type="checkbox" class="log-filter" value="WARNING" checked> WARNING</label>
                <label><input type="checkbox" class="log-filter" value="ERROR" checked> ERROR</label>
                <label><input type="checkbox" class="log-filter" value="DEBUG" checked> DEBUG</label>
                <button id="clear-logs-btn" title="Limpa a visualização dos logs (não apaga o arquivo)">Limpar Visualização</button>
                <span id="log-count"></span>
            </div>
            <div class="debug-search">
                <input type="text" id="log-search" placeholder="Buscar nos logs...">
                <button id="search-btn">Buscar</button>
            </div>
        </div>
        <div id="debug-log">
            <div class="log-container">
            <?php 
            if (defined('LOG_FILE') && file_exists(LOG_FILE)) {
                $lines = file(LOG_FILE, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
                $lines = array_reverse($lines); // Mais recentes primeiro
                
                // Limita a exibição aos 100 logs mais recentes para melhor desempenho
                $displayLines = array_slice($lines, 0, 100);
                
                foreach ($displayLines as $line) {
                    // Temos um problema com o formato atual dos logs, vamos tentar extrair as partes importantes
                    
                    // Padrão esperado: [DATA][NÍVEL][CONTEXTO] Mensagem
                    if (preg_match('/\[([\d\- :]+)\]\[(INFO|WARNING|ERROR|DEBUG)\](?:\[(.*?)\])?\s*(.*)/', $line, $matches)) {
                        $timestamp = $matches[1];
                        $logLevel = $matches[2];
                        $context = !empty($matches[3]) ? $matches[3] : '';
                        $logContent = $matches[4];
                    } else {
                        // Fallback para logs antigos ou com formato diferente
                        // Tenta encontrar pelo menos a data e alguma indicação de nível
                        if (preg_match('/\[([\d\- :]+)\]/', $line, $dateMatch)) {
                            $timestamp = $dateMatch[1];
                            
                            // Identifica o nível com base em palavras-chave comuns
                            if (stripos($line, 'erro') !== false || stripos($line, 'falha') !== false) {
                                $logLevel = 'ERROR';
                            } else if (stripos($line, 'aviso') !== false || stripos($line, 'alerta') !== false) {
                                $logLevel = 'WARNING';
                            } else if (stripos($line, 'debug') !== false) {
                                $logLevel = 'DEBUG';
                            } else {
                                $logLevel = 'INFO';
                            }
                            
                            // Extrai o contexto (geralmente entre colchetes após a data)
                            if (preg_match('/\]\[(.*?)\]/', $line, $contextMatch)) {
                                $context = $contextMatch[1];
                            } else {
                                $context = '';
                            }
                            
                            // A mensagem é o resto da linha após os metadados
                            $logContent = preg_replace('/^\[.*?\](\[.*?\])*\s*/', '', $line);
                        } else {
                            // Se não conseguir extrair nada, usa valores padrão
                            $timestamp = '';
                            $logLevel = 'INFO';
                            $context = '';
                            $logContent = $line;
                        }
                    }
                    
                    // Define a classe CSS baseada no nível do log
                    $logClass = 'log-' . strtolower($logLevel);
                    
                    echo "<div class='log-entry $logClass' data-level='$logLevel'>";
                    echo "<span class='log-timestamp'>$timestamp</span>";
                    echo "<span class='log-level'>$logLevel</span>";
                    if ($context) {
                        echo "<span class='log-context'>$context</span>";
                    }
                    echo "<span class='log-message'>" . htmlspecialchars($logContent) . "</span>";
                    echo "</div>";
                }
                
                if ($logCount > 100) {
                    echo "<div class='log-entry log-more'>+ " . ($logCount - 100) . " logs adicionais não exibidos (total: $logCount)</div>";
                }
            } else {
                echo "<div class='log-empty'>Nenhum log encontrado.</div>";
            }
            ?>
            </div>
        </div>
    </div>

    <!-- Exemplos de uso dos novos logs -->
    <?php
    log_info("Usuário fez login", "Auth");
    log_warning("Múltiplas tentativas de login", "Auth");
    log_error("Falha na conexão com o banco de dados", "Database");
    log_debug("Query executada: SELECT * FROM users", "SQL");

    // Ou continue usando a função genérica com nível personalizado
    debug_log("Operação personalizada", "CUSTOM", "Context");
    ?>
</body>
</html>


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\autoload.php
================================================================================

<?php

// autoload.php @generated by Composer

if (PHP_VERSION_ID < 50600) {
    if (!headers_sent()) {
        header('HTTP/1.1 500 Internal Server Error');
    }
    $err = 'Composer 2.3.0 dropped support for autoloading on PHP <5.6 and you are running '.PHP_VERSION.', please upgrade PHP or use Composer 2.2 LTS via "composer self-update --2.2". Aborting.'.PHP_EOL;
    if (!ini_get('display_errors')) {
        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {
            fwrite(STDERR, $err);
        } elseif (!headers_sent()) {
            echo $err;
        }
    }
    throw new RuntimeException($err);
}

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInitfe343a0cfb6e855c626691ea9f86a28e::getLoader();


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\autoload_classmap.php
================================================================================

<?php

// autoload_classmap.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'Composer\\InstalledVersions' => $vendorDir . '/composer/InstalledVersions.php',
);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\autoload_files.php
================================================================================

<?php

// autoload_files.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'b559101259fab2a8411fd5a852b853a6' => $baseDir . '/config/config.php',
);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\autoload_namespaces.php
================================================================================

<?php

// autoload_namespaces.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\autoload_psr4.php
================================================================================

<?php

// autoload_psr4.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'Predis\\' => array($vendorDir . '/predis/predis/src'),
    'App\\' => array($baseDir . '/src/App'),
);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\autoload_real.php
================================================================================

<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInitfe343a0cfb6e855c626691ea9f86a28e
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    /**
     * @return \Composer\Autoload\ClassLoader
     */
    public static function getLoader()
    {
        if (null !== self::$loader) {
            return self::$loader;
        }

        require __DIR__ . '/platform_check.php';

        spl_autoload_register(array('ComposerAutoloaderInitfe343a0cfb6e855c626691ea9f86a28e', 'loadClassLoader'), true, true);
        self::$loader = $loader = new \Composer\Autoload\ClassLoader(\dirname(__DIR__));
        spl_autoload_unregister(array('ComposerAutoloaderInitfe343a0cfb6e855c626691ea9f86a28e', 'loadClassLoader'));

        require __DIR__ . '/autoload_static.php';
        call_user_func(\Composer\Autoload\ComposerStaticInitfe343a0cfb6e855c626691ea9f86a28e::getInitializer($loader));

        $loader->register(true);

        $filesToLoad = \Composer\Autoload\ComposerStaticInitfe343a0cfb6e855c626691ea9f86a28e::$files;
        $requireFile = \Closure::bind(static function ($fileIdentifier, $file) {
            if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
                $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;

                require $file;
            }
        }, null, null);
        foreach ($filesToLoad as $fileIdentifier => $file) {
            $requireFile($fileIdentifier, $file);
        }

        return $loader;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\autoload_static.php
================================================================================

<?php

// autoload_static.php @generated by Composer

namespace Composer\Autoload;

class ComposerStaticInitfe343a0cfb6e855c626691ea9f86a28e
{
    public static $files = array (
        'b559101259fab2a8411fd5a852b853a6' => __DIR__ . '/../..' . '/config/config.php',
    );

    public static $prefixLengthsPsr4 = array (
        'P' => 
        array (
            'Predis\\' => 7,
        ),
        'A' => 
        array (
            'App\\' => 4,
        ),
    );

    public static $prefixDirsPsr4 = array (
        'Predis\\' => 
        array (
            0 => __DIR__ . '/..' . '/predis/predis/src',
        ),
        'App\\' => 
        array (
            0 => __DIR__ . '/../..' . '/src/App',
        ),
    );

    public static $classMap = array (
        'Composer\\InstalledVersions' => __DIR__ . '/..' . '/composer/InstalledVersions.php',
    );

    public static function getInitializer(ClassLoader $loader)
    {
        return \Closure::bind(function () use ($loader) {
            $loader->prefixLengthsPsr4 = ComposerStaticInitfe343a0cfb6e855c626691ea9f86a28e::$prefixLengthsPsr4;
            $loader->prefixDirsPsr4 = ComposerStaticInitfe343a0cfb6e855c626691ea9f86a28e::$prefixDirsPsr4;
            $loader->classMap = ComposerStaticInitfe343a0cfb6e855c626691ea9f86a28e::$classMap;

        }, null, ClassLoader::class);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\ClassLoader.php
================================================================================

<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer\Autoload;

/**
 * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.
 *
 *     $loader = new \Composer\Autoload\ClassLoader();
 *
 *     // register classes with namespaces
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 *     // to enable searching the include path (eg. for PEAR packages)
 *     $loader->setUseIncludePath(true);
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * This class is loosely based on the Symfony UniversalClassLoader.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Jordi Boggiano <j.boggiano@seld.be>
 * @see    https://www.php-fig.org/psr/psr-0/
 * @see    https://www.php-fig.org/psr/psr-4/
 */
class ClassLoader
{
    /** @var \Closure(string):void */
    private static $includeFile;

    /** @var string|null */
    private $vendorDir;

    // PSR-4
    /**
     * @var array<string, array<string, int>>
     */
    private $prefixLengthsPsr4 = array();
    /**
     * @var array<string, list<string>>
     */
    private $prefixDirsPsr4 = array();
    /**
     * @var list<string>
     */
    private $fallbackDirsPsr4 = array();

    // PSR-0
    /**
     * List of PSR-0 prefixes
     *
     * Structured as array('F (first letter)' => array('Foo\Bar (full prefix)' => array('path', 'path2')))
     *
     * @var array<string, array<string, list<string>>>
     */
    private $prefixesPsr0 = array();
    /**
     * @var list<string>
     */
    private $fallbackDirsPsr0 = array();

    /** @var bool */
    private $useIncludePath = false;

    /**
     * @var array<string, string>
     */
    private $classMap = array();

    /** @var bool */
    private $classMapAuthoritative = false;

    /**
     * @var array<string, bool>
     */
    private $missingClasses = array();

    /** @var string|null */
    private $apcuPrefix;

    /**
     * @var array<string, self>
     */
    private static $registeredLoaders = array();

    /**
     * @param string|null $vendorDir
     */
    public function __construct($vendorDir = null)
    {
        $this->vendorDir = $vendorDir;
        self::initializeIncludeClosure();
    }

    /**
     * @return array<string, list<string>>
     */
    public function getPrefixes()
    {
        if (!empty($this->prefixesPsr0)) {
            return call_user_func_array('array_merge', array_values($this->prefixesPsr0));
        }

        return array();
    }

    /**
     * @return array<string, list<string>>
     */
    public function getPrefixesPsr4()
    {
        return $this->prefixDirsPsr4;
    }

    /**
     * @return list<string>
     */
    public function getFallbackDirs()
    {
        return $this->fallbackDirsPsr0;
    }

    /**
     * @return list<string>
     */
    public function getFallbackDirsPsr4()
    {
        return $this->fallbackDirsPsr4;
    }

    /**
     * @return array<string, string> Array of classname => path
     */
    public function getClassMap()
    {
        return $this->classMap;
    }

    /**
     * @param array<string, string> $classMap Class to filename map
     *
     * @return void
     */
    public function addClassMap(array $classMap)
    {
        if ($this->classMap) {
            $this->classMap = array_merge($this->classMap, $classMap);
        } else {
            $this->classMap = $classMap;
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix, either
     * appending or prepending to the ones previously set for this prefix.
     *
     * @param string              $prefix  The prefix
     * @param list<string>|string $paths   The PSR-0 root directories
     * @param bool                $prepend Whether to prepend the directories
     *
     * @return void
     */
    public function add($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            if ($prepend) {
                $this->fallbackDirsPsr0 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr0
                );
            } else {
                $this->fallbackDirsPsr0 = array_merge(
                    $this->fallbackDirsPsr0,
                    $paths
                );
            }

            return;
        }

        $first = $prefix[0];
        if (!isset($this->prefixesPsr0[$first][$prefix])) {
            $this->prefixesPsr0[$first][$prefix] = $paths;

            return;
        }
        if ($prepend) {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $paths,
                $this->prefixesPsr0[$first][$prefix]
            );
        } else {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $this->prefixesPsr0[$first][$prefix],
                $paths
            );
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace, either
     * appending or prepending to the ones previously set for this namespace.
     *
     * @param string              $prefix  The prefix/namespace, with trailing '\\'
     * @param list<string>|string $paths   The PSR-4 base directories
     * @param bool                $prepend Whether to prepend the directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function addPsr4($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            // Register directories for the root namespace.
            if ($prepend) {
                $this->fallbackDirsPsr4 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr4
                );
            } else {
                $this->fallbackDirsPsr4 = array_merge(
                    $this->fallbackDirsPsr4,
                    $paths
                );
            }
        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {
            // Register directories for a new namespace.
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = $paths;
        } elseif ($prepend) {
            // Prepend directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $paths,
                $this->prefixDirsPsr4[$prefix]
            );
        } else {
            // Append directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $this->prefixDirsPsr4[$prefix],
                $paths
            );
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix,
     * replacing any others previously set for this prefix.
     *
     * @param string              $prefix The prefix
     * @param list<string>|string $paths  The PSR-0 base directories
     *
     * @return void
     */
    public function set($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr0 = (array) $paths;
        } else {
            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace,
     * replacing any others previously set for this namespace.
     *
     * @param string              $prefix The prefix/namespace, with trailing '\\'
     * @param list<string>|string $paths  The PSR-4 base directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function setPsr4($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr4 = (array) $paths;
        } else {
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = (array) $paths;
        }
    }

    /**
     * Turns on searching the include path for class files.
     *
     * @param bool $useIncludePath
     *
     * @return void
     */
    public function setUseIncludePath($useIncludePath)
    {
        $this->useIncludePath = $useIncludePath;
    }

    /**
     * Can be used to check if the autoloader uses the include path to check
     * for classes.
     *
     * @return bool
     */
    public function getUseIncludePath()
    {
        return $this->useIncludePath;
    }

    /**
     * Turns off searching the prefix and fallback directories for classes
     * that have not been registered with the class map.
     *
     * @param bool $classMapAuthoritative
     *
     * @return void
     */
    public function setClassMapAuthoritative($classMapAuthoritative)
    {
        $this->classMapAuthoritative = $classMapAuthoritative;
    }

    /**
     * Should class lookup fail if not found in the current class map?
     *
     * @return bool
     */
    public function isClassMapAuthoritative()
    {
        return $this->classMapAuthoritative;
    }

    /**
     * APCu prefix to use to cache found/not-found classes, if the extension is enabled.
     *
     * @param string|null $apcuPrefix
     *
     * @return void
     */
    public function setApcuPrefix($apcuPrefix)
    {
        $this->apcuPrefix = function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN) ? $apcuPrefix : null;
    }

    /**
     * The APCu prefix in use, or null if APCu caching is not enabled.
     *
     * @return string|null
     */
    public function getApcuPrefix()
    {
        return $this->apcuPrefix;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     *
     * @return void
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);

        if (null === $this->vendorDir) {
            return;
        }

        if ($prepend) {
            self::$registeredLoaders = array($this->vendorDir => $this) + self::$registeredLoaders;
        } else {
            unset(self::$registeredLoaders[$this->vendorDir]);
            self::$registeredLoaders[$this->vendorDir] = $this;
        }
    }

    /**
     * Unregisters this instance as an autoloader.
     *
     * @return void
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));

        if (null !== $this->vendorDir) {
            unset(self::$registeredLoaders[$this->vendorDir]);
        }
    }

    /**
     * Loads the given class or interface.
     *
     * @param  string    $class The name of the class
     * @return true|null True if loaded, null otherwise
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            $includeFile = self::$includeFile;
            $includeFile($file);

            return true;
        }

        return null;
    }

    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|false The path if found, false otherwise
     */
    public function findFile($class)
    {
        // class map lookup
        if (isset($this->classMap[$class])) {
            return $this->classMap[$class];
        }
        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
            return false;
        }
        if (null !== $this->apcuPrefix) {
            $file = apcu_fetch($this->apcuPrefix.$class, $hit);
            if ($hit) {
                return $file;
            }
        }

        $file = $this->findFileWithExtension($class, '.php');

        // Search for Hack files if we are running on HHVM
        if (false === $file && defined('HHVM_VERSION')) {
            $file = $this->findFileWithExtension($class, '.hh');
        }

        if (null !== $this->apcuPrefix) {
            apcu_add($this->apcuPrefix.$class, $file);
        }

        if (false === $file) {
            // Remember that this class does not exist.
            $this->missingClasses[$class] = true;
        }

        return $file;
    }

    /**
     * Returns the currently registered loaders keyed by their corresponding vendor directories.
     *
     * @return array<string, self>
     */
    public static function getRegisteredLoaders()
    {
        return self::$registeredLoaders;
    }

    /**
     * @param  string       $class
     * @param  string       $ext
     * @return string|false
     */
    private function findFileWithExtension($class, $ext)
    {
        // PSR-4 lookup
        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

        $first = $class[0];
        if (isset($this->prefixLengthsPsr4[$first])) {
            $subPath = $class;
            while (false !== $lastPos = strrpos($subPath, '\\')) {
                $subPath = substr($subPath, 0, $lastPos);
                $search = $subPath . '\\';
                if (isset($this->prefixDirsPsr4[$search])) {
                    $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);
                    foreach ($this->prefixDirsPsr4[$search] as $dir) {
                        if (file_exists($file = $dir . $pathEnd)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-4 fallback dirs
        foreach ($this->fallbackDirsPsr4 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
                return $file;
            }
        }

        // PSR-0 lookup
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
        } else {
            // PEAR-like class name
            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
        }

        if (isset($this->prefixesPsr0[$first])) {
            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($dirs as $dir) {
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-0 fallback dirs
        foreach ($this->fallbackDirsPsr0 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                return $file;
            }
        }

        // PSR-0 include paths.
        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
            return $file;
        }

        return false;
    }

    /**
     * @return void
     */
    private static function initializeIncludeClosure()
    {
        if (self::$includeFile !== null) {
            return;
        }

        /**
         * Scope isolated include.
         *
         * Prevents access to $this/self from included files.
         *
         * @param  string $file
         * @return void
         */
        self::$includeFile = \Closure::bind(static function($file) {
            include $file;
        }, null, null);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\installed.json
================================================================================

{
    "packages": [
        {
            "name": "predis/predis",
            "version": "v2.3.0",
            "version_normalized": "2.3.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/predis/predis.git",
                "reference": "bac46bfdb78cd6e9c7926c697012aae740cb9ec9"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/predis/predis/zipball/bac46bfdb78cd6e9c7926c697012aae740cb9ec9",
                "reference": "bac46bfdb78cd6e9c7926c697012aae740cb9ec9",
                "shasum": ""
            },
            "require": {
                "php": "^7.2 || ^8.0"
            },
            "require-dev": {
                "friendsofphp/php-cs-fixer": "^3.3",
                "phpstan/phpstan": "^1.9",
                "phpunit/phpunit": "^8.0 || ^9.4"
            },
            "suggest": {
                "ext-relay": "Faster connection with in-memory caching (>=0.6.2)"
            },
            "time": "2024-11-21T20:00:02+00:00",
            "type": "library",
            "installation-source": "source",
            "autoload": {
                "psr-4": {
                    "Predis\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Till Krüss",
                    "homepage": "https://till.im",
                    "role": "Maintainer"
                }
            ],
            "description": "A flexible and feature-complete Redis client for PHP.",
            "homepage": "http://github.com/predis/predis",
            "keywords": [
                "nosql",
                "predis",
                "redis"
            ],
            "support": {
                "issues": "https://github.com/predis/predis/issues",
                "source": "https://github.com/predis/predis/tree/v2.3.0"
            },
            "funding": [
                {
                    "url": "https://github.com/sponsors/tillkruss",
                    "type": "github"
                }
            ],
            "install-path": "../predis/predis"
        }
    ],
    "dev": true,
    "dev-package-names": []
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\installed.php
================================================================================

<?php return array(
    'root' => array(
        'name' => 'alexa/sistema-noticias',
        'pretty_version' => 'dev-master',
        'version' => 'dev-master',
        'reference' => 'df07bfff4b12bcddb41b16957bc38b2ea9505194',
        'type' => 'project',
        'install_path' => __DIR__ . '/../../',
        'aliases' => array(),
        'dev' => true,
    ),
    'versions' => array(
        'alexa/sistema-noticias' => array(
            'pretty_version' => 'dev-master',
            'version' => 'dev-master',
            'reference' => 'df07bfff4b12bcddb41b16957bc38b2ea9505194',
            'type' => 'project',
            'install_path' => __DIR__ . '/../../',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
        'predis/predis' => array(
            'pretty_version' => 'v2.3.0',
            'version' => '2.3.0.0',
            'reference' => 'bac46bfdb78cd6e9c7926c697012aae740cb9ec9',
            'type' => 'library',
            'install_path' => __DIR__ . '/../predis/predis',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
    ),
);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\InstalledVersions.php
================================================================================

<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer;

use Composer\Autoload\ClassLoader;
use Composer\Semver\VersionParser;

/**
 * This class is copied in every Composer installed project and available to all
 *
 * See also https://getcomposer.org/doc/07-runtime.md#installed-versions
 *
 * To require its presence, you can require `composer-runtime-api ^2.0`
 *
 * @final
 */
class InstalledVersions
{
    /**
     * @var string|null if set (by reflection by Composer), this should be set to the path where this class is being copied to
     * @internal
     */
    private static $selfDir = null;

    /**
     * @var mixed[]|null
     * @psalm-var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}|array{}|null
     */
    private static $installed;

    /**
     * @var bool
     */
    private static $installedIsLocalDir;

    /**
     * @var bool|null
     */
    private static $canGetVendors;

    /**
     * @var array[]
     * @psalm-var array<string, array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    private static $installedByVendor = array();

    /**
     * Returns a list of all package names which are present, either by being installed, replaced or provided
     *
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackages()
    {
        $packages = array();
        foreach (self::getInstalled() as $installed) {
            $packages[] = array_keys($installed['versions']);
        }

        if (1 === \count($packages)) {
            return $packages[0];
        }

        return array_keys(array_flip(\call_user_func_array('array_merge', $packages)));
    }

    /**
     * Returns a list of all package names with a specific type e.g. 'library'
     *
     * @param  string   $type
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackagesByType($type)
    {
        $packagesByType = array();

        foreach (self::getInstalled() as $installed) {
            foreach ($installed['versions'] as $name => $package) {
                if (isset($package['type']) && $package['type'] === $type) {
                    $packagesByType[] = $name;
                }
            }
        }

        return $packagesByType;
    }

    /**
     * Checks whether the given package is installed
     *
     * This also returns true if the package name is provided or replaced by another package
     *
     * @param  string $packageName
     * @param  bool   $includeDevRequirements
     * @return bool
     */
    public static function isInstalled($packageName, $includeDevRequirements = true)
    {
        foreach (self::getInstalled() as $installed) {
            if (isset($installed['versions'][$packageName])) {
                return $includeDevRequirements || !isset($installed['versions'][$packageName]['dev_requirement']) || $installed['versions'][$packageName]['dev_requirement'] === false;
            }
        }

        return false;
    }

    /**
     * Checks whether the given package satisfies a version constraint
     *
     * e.g. If you want to know whether version 2.3+ of package foo/bar is installed, you would call:
     *
     *   Composer\InstalledVersions::satisfies(new VersionParser, 'foo/bar', '^2.3')
     *
     * @param  VersionParser $parser      Install composer/semver to have access to this class and functionality
     * @param  string        $packageName
     * @param  string|null   $constraint  A version constraint to check for, if you pass one you have to make sure composer/semver is required by your package
     * @return bool
     */
    public static function satisfies(VersionParser $parser, $packageName, $constraint)
    {
        $constraint = $parser->parseConstraints((string) $constraint);
        $provided = $parser->parseConstraints(self::getVersionRanges($packageName));

        return $provided->matches($constraint);
    }

    /**
     * Returns a version constraint representing all the range(s) which are installed for a given package
     *
     * It is easier to use this via isInstalled() with the $constraint argument if you need to check
     * whether a given version of a package is installed, and not just whether it exists
     *
     * @param  string $packageName
     * @return string Version constraint usable with composer/semver
     */
    public static function getVersionRanges($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            $ranges = array();
            if (isset($installed['versions'][$packageName]['pretty_version'])) {
                $ranges[] = $installed['versions'][$packageName]['pretty_version'];
            }
            if (array_key_exists('aliases', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['aliases']);
            }
            if (array_key_exists('replaced', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['replaced']);
            }
            if (array_key_exists('provided', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['provided']);
            }

            return implode(' || ', $ranges);
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getPrettyVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['pretty_version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['pretty_version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as reference
     */
    public static function getReference($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['reference'])) {
                return null;
            }

            return $installed['versions'][$packageName]['reference'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as install path. Packages of type metapackages also have a null install path.
     */
    public static function getInstallPath($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            return isset($installed['versions'][$packageName]['install_path']) ? $installed['versions'][$packageName]['install_path'] : null;
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @return array
     * @psalm-return array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}
     */
    public static function getRootPackage()
    {
        $installed = self::getInstalled();

        return $installed[0]['root'];
    }

    /**
     * Returns the raw installed.php data for custom implementations
     *
     * @deprecated Use getAllRawData() instead which returns all datasets for all autoloaders present in the process. getRawData only returns the first dataset loaded, which may not be what you expect.
     * @return array[]
     * @psalm-return array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}
     */
    public static function getRawData()
    {
        @trigger_error('getRawData only returns the first dataset loaded, which may not be what you expect. Use getAllRawData() instead which returns all datasets for all autoloaders present in the process.', E_USER_DEPRECATED);

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C') {
                self::$installed = include __DIR__ . '/installed.php';
            } else {
                self::$installed = array();
            }
        }

        return self::$installed;
    }

    /**
     * Returns the raw data of all installed.php which are currently loaded for custom implementations
     *
     * @return array[]
     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    public static function getAllRawData()
    {
        return self::getInstalled();
    }

    /**
     * Lets you reload the static array from another file
     *
     * This is only useful for complex integrations in which a project needs to use
     * this class but then also needs to execute another project's autoloader in process,
     * and wants to ensure both projects have access to their version of installed.php.
     *
     * A typical case would be PHPUnit, where it would need to make sure it reads all
     * the data it needs from this class, then call reload() with
     * `require $CWD/vendor/composer/installed.php` (or similar) as input to make sure
     * the project in which it runs can then also use this class safely, without
     * interference between PHPUnit's dependencies and the project's dependencies.
     *
     * @param  array[] $data A vendor/composer/installed.php data set
     * @return void
     *
     * @psalm-param array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $data
     */
    public static function reload($data)
    {
        self::$installed = $data;
        self::$installedByVendor = array();

        // when using reload, we disable the duplicate protection to ensure that self::$installed data is
        // always returned, but we cannot know whether it comes from the installed.php in __DIR__ or not,
        // so we have to assume it does not, and that may result in duplicate data being returned when listing
        // all installed packages for example
        self::$installedIsLocalDir = false;
    }

    /**
     * @return string
     */
    private static function getSelfDir()
    {
        if (self::$selfDir === null) {
            self::$selfDir = strtr(__DIR__, '\\', '/');
        }

        return self::$selfDir;
    }

    /**
     * @return array[]
     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    private static function getInstalled()
    {
        if (null === self::$canGetVendors) {
            self::$canGetVendors = method_exists('Composer\Autoload\ClassLoader', 'getRegisteredLoaders');
        }

        $installed = array();
        $copiedLocalDir = false;

        if (self::$canGetVendors) {
            $selfDir = self::getSelfDir();
            foreach (ClassLoader::getRegisteredLoaders() as $vendorDir => $loader) {
                $vendorDir = strtr($vendorDir, '\\', '/');
                if (isset(self::$installedByVendor[$vendorDir])) {
                    $installed[] = self::$installedByVendor[$vendorDir];
                } elseif (is_file($vendorDir.'/composer/installed.php')) {
                    /** @var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $required */
                    $required = require $vendorDir.'/composer/installed.php';
                    self::$installedByVendor[$vendorDir] = $required;
                    $installed[] = $required;
                    if (self::$installed === null && $vendorDir.'/composer' === $selfDir) {
                        self::$installed = $required;
                        self::$installedIsLocalDir = true;
                    }
                }
                if (self::$installedIsLocalDir && $vendorDir.'/composer' === $selfDir) {
                    $copiedLocalDir = true;
                }
            }
        }

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C') {
                /** @var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $required */
                $required = require __DIR__ . '/installed.php';
                self::$installed = $required;
            } else {
                self::$installed = array();
            }
        }

        if (self::$installed !== array() && !$copiedLocalDir) {
            $installed[] = self::$installed;
        }

        return $installed;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\composer\platform_check.php
================================================================================

<?php

// platform_check.php @generated by Composer

$issues = array();

if (!(PHP_VERSION_ID >= 70400)) {
    $issues[] = 'Your Composer dependencies require a PHP version ">= 7.4.0". You are running ' . PHP_VERSION . '.';
}

if ($issues) {
    if (!headers_sent()) {
        header('HTTP/1.1 500 Internal Server Error');
    }
    if (!ini_get('display_errors')) {
        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {
            fwrite(STDERR, 'Composer detected issues in your platform:' . PHP_EOL.PHP_EOL . implode(PHP_EOL, $issues) . PHP_EOL.PHP_EOL);
        } elseif (!headers_sent()) {
            echo 'Composer detected issues in your platform:' . PHP_EOL.PHP_EOL . str_replace('You are running '.PHP_VERSION.'.', '', implode(PHP_EOL, $issues)) . PHP_EOL.PHP_EOL;
        }
    }
    trigger_error(
        'Composer detected issues in your platform: ' . implode(' ', $issues),
        E_USER_ERROR
    );
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\.php-cs-fixer.dist.php
================================================================================

<?php

$PREDIS_HEADER = <<<EOS
This file is part of the Predis package.

(c) 2009-2020 Daniele Alessandri
(c) 2021-2024 Till Krüss

For the full copyright and license information, please view the LICENSE
file that was distributed with this source code.
EOS;

return (new PhpCsFixer\Config)
    ->setRules([
        '@PHP71Migration' => true,
        'header_comment' => ['header' => $PREDIS_HEADER],
        '@Symfony' => true,
        'phpdoc_separation' => false,
        'phpdoc_annotation_without_dot' => false,
        'no_superfluous_phpdoc_tags' => false,
        'no_unneeded_curly_braces' => false,
        'no_unneeded_braces' => false,
        'global_namespace_import' => true,
        'yoda_style' => false,
        'single_line_throw' => false,
        'concat_space' => ['spacing' => 'one'],
        'increment_style' => false,
        'trailing_comma_in_multiline' => ['after_heredoc' => true, 'elements' => ['array_destructuring', 'arrays']]
    ])
    ->setFinder(
        PhpCsFixer\Finder::create()
            ->in(__DIR__ . '/bin')
            ->in(__DIR__ . '/examples')
            ->in(__DIR__ . '/src')
            ->in(__DIR__ . '/tests')
    );


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\autoload.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__.'/src/Autoloader.php';

Predis\Autoloader::register();


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\composer.json
================================================================================

{
    "name": "predis/predis",
    "type": "library",
    "description": "A flexible and feature-complete Redis client for PHP.",
    "keywords": ["nosql", "redis", "predis"],
    "homepage": "http://github.com/predis/predis",
    "license": "MIT",
    "support": {
        "issues": "https://github.com/predis/predis/issues"
    },
    "authors": [
        {
            "name": "Till Krüss",
            "homepage": "https://till.im",
            "role": "Maintainer"
        }
    ],
    "funding": [
        {
            "type": "github",
            "url": "https://github.com/sponsors/tillkruss"
        }
    ],
    "require": {
        "php": "^7.2 || ^8.0"
    },
    "require-dev": {
        "friendsofphp/php-cs-fixer": "^3.3",
        "phpstan/phpstan": "^1.9",
        "phpunit/phpunit": "^8.0 || ^9.4"
    },
    "suggest": {
        "ext-relay": "Faster connection with in-memory caching (>=0.6.2)"
    },
    "scripts": {
        "phpstan": "phpstan analyse",
        "style": "php-cs-fixer fix --diff --dry-run",
        "style:fix": "php-cs-fixer fix"
    },
    "autoload": {
        "psr-4": {
            "Predis\\": "src/"
        }
    },
    "config": {
        "sort-packages": true,
        "preferred-install": "dist"
    },
    "minimum-stability": "dev",
    "prefer-stable": true
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\custom_cluster_distributor.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// Developers can implement Predis\Distribution\DistributorInterface to create
// their own distributors used by the client to distribute keys among a cluster
// of servers.

use Predis\Cluster\Distributor\DistributorInterface;
use Predis\Cluster\Hash\HashGeneratorInterface;
use Predis\Cluster\PredisStrategy;
use Predis\Connection\Cluster\PredisCluster;

class NaiveDistributor implements DistributorInterface, HashGeneratorInterface
{
    private $nodes;
    private $nodesCount;

    public function __construct()
    {
        $this->nodes = [];
        $this->nodesCount = 0;
    }

    public function add($node, $weight = null)
    {
        $this->nodes[] = $node;
        ++$this->nodesCount;
    }

    public function remove($node)
    {
        $this->nodes = array_filter($this->nodes, function ($n) use ($node) {
            return $n !== $node;
        });

        $this->nodesCount = count($this->nodes);
    }

    public function getSlot($hash)
    {
        return $this->nodesCount > 1 ? abs($hash % $this->nodesCount) : 0;
    }

    public function getBySlot($slot)
    {
        return $this->nodes[$slot] ?? null;
    }

    public function getByHash($hash)
    {
        if (!$this->nodesCount) {
            throw new RuntimeException('No connections.');
        }

        $slot = $this->getSlot($hash);
        $node = $this->getBySlot($slot);

        return $node;
    }

    public function get($value)
    {
        $hash = $this->hash($value);
        $node = $this->getByHash($hash);

        return $node;
    }

    public function hash($value)
    {
        return crc32($value);
    }

    public function getHashGenerator()
    {
        return $this;
    }
}

$options = [
    'cluster' => function () {
        $distributor = new NaiveDistributor();
        $strategy = new PredisStrategy($distributor);
        $cluster = new PredisCluster($strategy);

        return $cluster;
    },
];

$client = new Predis\Client($multiple_servers, $options);

for ($i = 0; $i < 100; ++$i) {
    $client->set("key:$i", str_pad($i, 4, '0', 0));
    $client->get("key:$i");
}

$server1 = $client->getClientBy('alias', 'first')->info();
$server2 = $client->getClientBy('alias', 'second')->info();

if (isset($server1['Keyspace'], $server2['Keyspace'])) {
    $server1 = $server1['Keyspace'];
    $server2 = $server2['Keyspace'];
}

printf("Server '%s' has %d keys while server '%s' has %d keys.\n",
    'first', $server1['db15']['keys'], 'second', $server2['db15']['keys']
);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\debuggable_connection.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// This is an example of how you can easily extend an existing connection class
// and trace the execution of commands for debugging purposes. This can be quite
// useful as a starting point to understand how your application interacts with
// Redis.

use Predis\Command\CommandInterface;
use Predis\Connection\StreamConnection;

class SimpleDebuggableConnection extends StreamConnection
{
    private $tstart = 0;
    private $debugBuffer = [];

    public function connect()
    {
        $this->tstart = microtime(true);

        parent::connect();
    }

    private function storeDebug(CommandInterface $command, $direction)
    {
        $firtsArg = $command->getArgument(0);
        $timestamp = round(microtime(true) - $this->tstart, 4);

        $debug = $command->getId();
        $debug .= isset($firtsArg) ? " $firtsArg " : ' ';
        $debug .= "$direction $this";
        $debug .= " [{$timestamp}s]";

        $this->debugBuffer[] = $debug;
    }

    public function writeRequest(CommandInterface $command)
    {
        parent::writeRequest($command);

        $this->storeDebug($command, '->');
    }

    public function readResponse(CommandInterface $command)
    {
        $response = parent::readResponse($command);
        $this->storeDebug($command, '<-');

        return $response;
    }

    public function getDebugBuffer()
    {
        return $this->debugBuffer;
    }
}

$options = [
    'connections' => [
        'tcp' => 'SimpleDebuggableConnection',
    ],
];

$client = new Predis\Client($single_server, $options);
$client->set('foo', 'bar');
$client->get('foo');
$client->info();

var_export($client->getConnection()->getDebugBuffer());

/* OUTPUT:
array (
    0 => 'SELECT 15 -> 127.0.0.1:6379 [0.0008s]',
    1 => 'SELECT 15 <- 127.0.0.1:6379 [0.001s]',
    2 => 'SET foo -> 127.0.0.1:6379 [0.001s]',
    3 => 'SET foo <- 127.0.0.1:6379 [0.0011s]',
    4 => 'GET foo -> 127.0.0.1:6379 [0.0013s]',
    5 => 'GET foo <- 127.0.0.1:6379 [0.0015s]',
    6 => 'INFO -> 127.0.0.1:6379 [0.0019s]',
    7 => 'INFO <- 127.0.0.1:6379 [0.0022s]',
)
*/


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\dispatcher_loop.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2023 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// This is a basic example on how to use the Predis\DispatcherLoop class.
//
// To see this example in action you can just use redis-cli and publish some
// messages to the 'events' and 'control' channel, e.g.:

// ./redis-cli
// PUBLISH events first
// PUBLISH events second
// PUBLISH events third
// PUBLISH control terminate_dispatcher

// Create a client and disable r/w timeout on the socket
$client = new Predis\Client($single_server + ['read_write_timeout' => 0]);

// Return an initialized PubSub consumer instance from the client.
$pubsub = $client->pubSubLoop();

// Create a dispatcher loop instance and attach a bunch of callbacks.
$dispatcher = new Predis\PubSub\DispatcherLoop($pubsub);

// Demonstrate how to use a callable class as a callback for the dispatcher loop.
class EventsListener implements Countable
{
    private $events;

    public function __construct()
    {
        $this->events = [];
    }

    public function count()
    {
        return count($this->events);
    }

    public function getEvents()
    {
        return $this->events;
    }

    public function __invoke($payload, $dispatcher)
    {
        $this->events[] = $payload;
    }
}

// Attach our callable class to the dispatcher.
$dispatcher->attachCallback('events', $events = new EventsListener());

// Attach a function to control the dispatcher loop termination with a message.
$dispatcher->attachCallback('control', function ($payload, $dispatcher) {
    if ($payload === 'terminate_dispatcher') {
        $dispatcher->stop();
    }
});

// Run the dispatcher loop until the callback attached to the 'control' channel
// receives 'terminate_dispatcher' as a message.
$dispatcher->run();

// Display our achievements!
echo "We received {$events->count()} messages!", PHP_EOL;

// Say goodbye :-)
$version = redis_version($client->info());
echo "Goodbye from Redis $version!", PHP_EOL;


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\executing_redis_commands.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

$client = new Predis\Client($single_server);

// Plain old SET and GET example...
$client->set('library', 'predis');
$response = $client->get('library');

var_export($response);
echo PHP_EOL;
/* OUTPUT: 'predis' */

// Redis has the MSET and MGET commands to set or get multiple keys in one go,
// cases like this Predis accepts arguments for variadic commands both as a list
// of arguments or an array containing all of the keys and/or values.
$mkv = [
    'uid:0001' => '1st user',
    'uid:0002' => '2nd user',
    'uid:0003' => '3rd user',
];

$client->mset($mkv);
$response = $client->mget(array_keys($mkv));

var_export($response);
echo PHP_EOL;
/* OUTPUT:
array (
    0 => '1st user',
    1 => '2nd user',
    2 => '3rd user',
)
*/

// Predis can also send "raw" commands to Redis. The difference between sending
// commands to Redis the usual way and the "raw" way is that in the latter case
// their arguments are not filtered nor responses coming from Redis are parsed.

$response = $client->executeRaw([
    'MGET', 'uid:0001', 'uid:0002', 'uid:0003',
]);

var_export($response);
echo PHP_EOL;
/* OUTPUT:
array (
    0 => '1st user',
    1 => '2nd user',
    2 => '3rd user',
)
*/


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\key_prefixing.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// Predis can prefix keys found in commands arguments before sending commands to
// Redis, even for complex commands such as SORT, ZUNIONSTORE and ZINTERSTORE.
// Prefixing keys can be useful to create user-level namespaces for you keyspace
// thus reducing the need for separate logical databases in certain scenarios.

$client = new Predis\Client($single_server, ['prefix' => 'nrk:']);

$client->mset(['foo' => 'bar', 'lol' => 'wut']);
var_export($client->mget('foo', 'lol'));
/*
array (
    0 => 'bar',
    1 => 'wut',
)
*/

var_export($client->keys('*'));
/*
array (
    0 => 'nrk:foo',
    1 => 'nrk:lol',
)
*/


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\lua_scripting_abstraction.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// This example will not work with versions of Redis < 2.6.
//
// Additionally to the EVAL command, the Predis\Command\ScriptCommand class can
// be used to leverage an higher level abstraction for Lua scripting that makes
// scripts appear just like any other command on the client-side. This is basic
// example on how a script-based INCREX command can be defined:

use Predis\Command\ScriptCommand;

class IncrementExistingKeysBy extends ScriptCommand
{
    public function getKeysCount()
    {
        // Tell Predis to use all the arguments but the last one as arguments
        // for KEYS. The last one will be used to populate ARGV.
        return -1;
    }

    public function getScript()
    {
        return <<<LUA
local cmd, insert = redis.call, table.insert
local increment, results = ARGV[1], { }

for idx, key in ipairs(KEYS) do
    if cmd('exists', key) == 1 then
        insert(results, idx, cmd('incrby', key, increment))
    else
        insert(results, idx, false)
    end
end

return results
LUA;
    }
}

$client = new Predis\Client($single_server, [
    'commands' => [
        'increxby' => 'IncrementExistingKeysBy',
    ],
]);

$client->mset('foo', 10, 'foobar', 100);

var_export($client->increxby('foo', 'foofoo', 'foobar', 50));

/*
array (
    0 => 60,
    1 => NULL,
    2 => 150,
)
*/


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\monitor_consumer.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// This is a basic example on how to use the Predis\Monitor\Consumer class. You
// can use redis-cli to send commands to the same Redis instance your client is
// connected to, and then type "ECHO QUIT_MONITOR" in redis-cli when you want to
// exit the monitor loop and terminate this script in a graceful way.

// Create a client and disable r/w timeout on the socket.
$client = new Predis\Client($single_server + ['read_write_timeout' => 0]);

// Use only one instance of DateTime, we will update the timestamp later.
$timestamp = new DateTime();

foreach (($monitor = $client->monitor()) as $event) {
    $timestamp->setTimestamp((int) $event->timestamp);

    // If we notice a ECHO command with the message QUIT_MONITOR, we stop the
    // monitor consumer and then break the loop.
    if ($event->command === 'ECHO' && $event->arguments === '"QUIT_MONITOR"') {
        echo 'Exiting the monitor loop...', PHP_EOL;
        $monitor->stop();
        break;
    }

    echo "* Received {$event->command} on DB {$event->database} at {$timestamp->format(DateTime::W3C)}", PHP_EOL;
    if (isset($event->arguments)) {
        echo "    Arguments: {$event->arguments}", PHP_EOL;
    }
}

// Say goodbye :-)
$version = redis_version($client->info());
echo "Goodbye from Redis $version!", PHP_EOL;


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\pipelining_commands.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// When you have a whole set of consecutive commands to send to a redis server,
// you can use a pipeline to dramatically improve performances. Pipelines can
// greatly reduce the effects of network round-trips.

$client = new Predis\Client($single_server);

$responses = $client->pipeline(function ($pipe) {
    $pipe->flushdb();
    $pipe->incrby('counter', 10);
    $pipe->incrby('counter', 30);
    $pipe->exists('counter');
    $pipe->get('counter');
    $pipe->mget('does_not_exist', 'counter');
});

var_export($responses);

/* OUTPUT:
array (
    0 => Predis\Response\Status::__set_state(array(
        'payload' => 'OK',
    )),
    1 => 10,
    2 => 40,
    3 => true,
    4 => '40',
    5 => array (
        0 => NULL,
        1 => '40',
    ),
)
*/


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\pubsub_consumer.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// Starting from Redis 2.0 clients can subscribe and listen for events published
// on certain channels using a Publish/Subscribe (PUB/SUB) approach.

// Create a client and disable r/w timeout on the socket
$client = new Predis\Client($single_server + ['read_write_timeout' => 0]);

// Initialize a new pubsub consumer.
$pubsub = $client->pubSubLoop();

// Subscribe to your channels
$pubsub->subscribe('control_channel', 'notifications');

// Start processing the pubsub messages. Open a terminal and use redis-cli
// to push messages to the channels. Examples:
//   redis-cli PUBLISH notifications "this is a test"
//   redis-cli PUBLISH control_channel quit_loop
foreach ($pubsub as $message) {
    switch ($message->kind) {
        case 'subscribe':
            echo "Subscribed to {$message->channel}", PHP_EOL;
            break;

        case 'message':
            if ($message->channel == 'control_channel') {
                if ($message->payload == 'quit_loop') {
                    echo 'Aborting pubsub loop...', PHP_EOL;
                    $pubsub->unsubscribe();
                } else {
                    echo "Received an unrecognized command: {$message->payload}.", PHP_EOL;
                }
            } else {
                echo "Received the following message from {$message->channel}:",
                PHP_EOL, "  {$message->payload}", PHP_EOL, PHP_EOL;
            }
            break;
    }
}

// Always unset the pubsub consumer instance when you are done! The
// class destructor will take care of cleanups and prevent protocol
// desynchronizations between the client and the server.
unset($pubsub);

// Say goodbye :-)
$version = redis_version($client->info());
echo "Goodbye from Redis $version!", PHP_EOL;


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\redis_collections_iterators.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

use Predis\Collection\Iterator;

// Starting with Redis 2.8, clients can iterate incrementally over collections
// without blocking the server like it happens when a command such as KEYS is
// executed on a Redis instance storing millions of keys. These commands are:
//
//   - SCAN (iterates over the keyspace)
//   - SSCAN (iterates over members of a set)
//   - ZSCAN (iterates over members and ranks of a sorted set)
//   - HSCAN (iterates over fields and values of an hash).

// Predis provides a specialized abstraction for each command based on standard
// SPL iterators making it possible to easily consume SCAN-based iterations in
// your PHP code.
//
// See http://redis.io/commands/scan for more details.
//

$client = new Predis\Client($single_server);

// Prepare some keys for our example
$client->del('predis:set', 'predis:zset', 'predis:hash');
for ($i = 0; $i < 5; ++$i) {
    $client->sadd('predis:set', "member:$i");
    $client->zadd('predis:zset', -$i, "member:$i");
    $client->hset('predis:hash', "field:$i", "value:$i");
}

// === Keyspace iterator based on SCAN ===
echo 'Scan the keyspace matching only our prefixed keys:', PHP_EOL;
foreach (new Iterator\Keyspace($client, 'predis:*') as $key) {
    echo " - $key", PHP_EOL;
}

/* OUTPUT
Scan the keyspace matching only our prefixed keys:
    - predis:zset
    - predis:set
    - predis:hash
*/

// === Set iterator based on SSCAN ===
echo 'Scan members of `predis:set`:', PHP_EOL;
foreach (new Iterator\SetKey($client, 'predis:set') as $member) {
    echo " - $member", PHP_EOL;
}

/* OUTPUT
Scan members of `predis:set`:
    - member:1
    - member:4
    - member:0
    - member:3
    - member:2
*/

// === Sorted set iterator based on ZSCAN ===
echo 'Scan members and ranks of `predis:zset`:', PHP_EOL;
foreach (new Iterator\SortedSetKey($client, 'predis:zset') as $member => $rank) {
    echo " - $member [rank: $rank]", PHP_EOL;
}

/* OUTPUT
Scan members and ranks of `predis:zset`:
    - member:4 [rank: -4]
    - member:3 [rank: -3]
    - member:2 [rank: -2]
    - member:1 [rank: -1]
    - member:0 [rank: 0]
*/

// === Hash iterator based on HSCAN ===
echo 'Scan fields and values of `predis:hash`:', PHP_EOL;
foreach (new Iterator\HashKey($client, 'predis:hash') as $field => $value) {
    echo " - $field => $value", PHP_EOL;
}

/* OUTPUT
Scan fields and values of `predis:hash`:
    - field:0 => value:0
    - field:1 => value:1
    - field:2 => value:2
    - field:3 => value:3
    - field:4 => value:4
*/


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\relay_compression.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// Enable igbinary serializer as well as LZ4 compression
$options = [
    'serializer' => 'igbinary',
    'compression' => 'lz4',
];

$client = new Predis\Client($single_server + $options, [
    'connections' => 'relay',
]);

$quote = (object) [
    'author' => 'Jean-Luc Picard',
    'text' => 'I look forward to your report Mr. Broccoli.',
];

// Serialize object and apply LZ4 compression, then write key to Redis
$client->set('quote', $client->pack($quote));

// NOTE: In Predis v3.x serialization and compression will happen
// automatically without the need to call `pack()` and `unpack()`

// Retrieve raw binary value from Redis
$raw = $client->get('quote');

// Decompress and unserialize binary value
$data = $client->unpack($raw);

var_dump($quote == $data); // true

var_dump($data);

/*
object(stdClass)#11 (2) {
    ["author"]=>string(15) "Jean-Luc Picard"
    ["text"]=>string(43) "I look forward to your report Mr. Broccoli."
}
*/


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\relay_connection.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2023 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

$options = [
    'timeout' => 1.0,
    'read_write_timeout' => 1.0,

    // Relay specific options
    'cache' => true,
    // 'compression' => 'lz4',
    // 'serializer' => 'igbinary',
];

$client = new Predis\Client($single_server + $options, [
    'connections' => 'relay',
]);

// Write key to Redis
$client->set('torpedo', mt_rand());

// Retrieve key from Redis
$client->get('torpedo');

// Retrieve key from Relay (without talking to Redis)
// This key is now available to all PHP workers in this FPM pool
$client->get('torpedo');

// For debugging only:
var_export(
    $client->getConnection()->getClient()->_getKeys()
);

/*
array (
    'torpedo' => array (
        0 => array (
            'type' => 'string',
            'local-len' => 10,
            'remote-len' => 10,
            'size' => 10,
        ),
    ),
)
*/


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\relay_events.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

$key = null;

$client = new Predis\Client($single_server, [
    'connections' => 'relay',
]);

/** @var Predis\Connection\RelayConnection $relay */
$relay = $client->getConnection();

// establish connection
$client->ping();

// register `FLUSH*` callback
$relay->onFlushed(
    static function (Relay\Event $event) use (&$key) {
        echo 'Redis was flushed, unsetting $key...' . PHP_EOL;
        $key = null;
    }
);

// register `INVALIDATE` callback
$relay->onInvalidated(
    static function (Relay\Event $event) use (&$key) {
        if ($event->key === 'library') {
            echo "The `{$event->key}` key was invalidated, unsetting \$key..." . PHP_EOL;
            $key = null;
        }
    }
);

// Write key to Redis
$client->set('library', mt_rand());

// Retrieve key once from Redis, then cached in Relay and $key
$key = $client->get('library');

while (true) {
    echo '$key is: ' . var_export($key, true) . PHP_EOL;

    // To trigger our event callbacks, we need to either interact with Relay:
    $client->get(mt_rand());

    // ... or alternatively dispatch events directly on Relay:
    $relay->dispatchEvents();

    sleep(1);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\relay_pubsub_consumer.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// Create a Relay client and disable r/w timeout on the connection
$client = new Predis\Client(
    $single_server + ['read_write_timeout' => 0],
    ['connections' => 'relay']
);

// Initialize a new pubsub consumer.
$pubsub = $client->pubSubLoop();

// When using Relay you cannot use foreach-loops to iterate
// over messages instead use a callback function
$poorMansKafka = function ($message, $client) {
    switch ($message->kind) {
        case 'subscribe':
            echo "Subscribed to {$message->channel}", PHP_EOL;
            break;

        case 'message':
        case 'pmessage':
            if ($message->channel == 'control_channel') {
                if ($message->payload == 'quit_loop') {
                    echo 'Aborting pubsub loop...', PHP_EOL;
                    $client->unsubscribe();
                } else {
                    echo "Received an unrecognized command: {$message->payload}.", PHP_EOL;
                }
            } else {
                echo "Received the message from `{$message->channel}` channel:",
                PHP_EOL, "  {$message->payload}", PHP_EOL, PHP_EOL;
            }
    }
};

// Subscribe to your channels and start processing the messages.
$pubsub->subscribe('control_channel', 'notifications', $poorMansKafka);

// Open a terminal and use redis-cli to push messages to the channels. Examples:
//   redis-cli PUBLISH notifications "this is a test"
//   redis-cli PUBLISH control_channel quit_loop

// When using Relay, there is no need to unset the pubsub consumer instance when you are done

// Say goodbye :-)
$version = redis_version($client->info());
echo "Goodbye from Redis $version!", PHP_EOL;


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\replication_complex.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// Predis allows to set Lua scripts as read-only operations for replication.
// This works for both EVAL and EVALSHA and also for the client-side abstraction
// built upon them (Predis\Command\ScriptCommand). This example shows a slightly
// more complex configuration that injects a new script command in the command
// factory used by the client and marks it as a read-only operation so that it
// will be executed on slaves.

use Predis\Command\ScriptCommand;
use Predis\Connection\Replication\MasterSlaveReplication;
use Predis\Replication\ReplicationStrategy;

// ------------------------------------------------------------------------- //

// Define a new script command that returns all the fields of a variable number
// of hashes with a single roundtrip.

class HashMultipleGetAll extends ScriptCommand
{
    public const BODY = <<<LUA
local hashes = {}
for _, key in pairs(KEYS) do
    table.insert(hashes, key)
    table.insert(hashes, redis.call('hgetall', key))
end
return hashes
LUA;

    public function getScript()
    {
        return self::BODY;
    }
}

// ------------------------------------------------------------------------- //

$parameters = [
    'tcp://127.0.0.1:6381?role=master&database=15',
    'tcp://127.0.0.1:6382?role=slave&alias=slave-01&database=15',
];

$options = [
    'commands' => [
        'hmgetall' => 'HashMultipleGetAll',
    ],
    'replication' => function () {
        $strategy = new ReplicationStrategy();
        $strategy->setScriptReadOnly(HashMultipleGetAll::BODY);

        $replication = new MasterSlaveReplication($strategy);

        return $replication;
    },
];

// ------------------------------------------------------------------------- //

$client = new Predis\Client($parameters, $options);

// Execute the following commands on the master server using redis-cli:
// $ ./redis-cli HMSET metavars foo bar hoge piyo
// $ ./redis-cli HMSET servers master host1 slave host2

$hashes = $client->hmgetall('metavars', 'servers');

$replication = $client->getConnection();
$stillOnSlave = $replication->getCurrent() === $replication->getConnectionByAlias('slave-01');

echo 'Is still on slave? ', $stillOnSlave ? 'YES!' : 'NO!', PHP_EOL;
var_export($hashes);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\replication_sentinel.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// Predis supports redis-sentinel to provide high availability in master / slave
// scenarios. The only but relevant difference with a basic replication scenario
// is that sentinel servers can manage the master server and its slaves based on
// their state, which means that they are able to provide an authoritative and
// updated configuration to clients thus avoiding static configurations for the
// replication servers and their roles.

// Instead of connection parameters pointing to redis nodes, we provide a list
// of instances of redis-sentinel. Users should always provide a timeout value
// low enough to not hinder operations just in case a sentinel is unreachable
// but Predis uses a default value of 100 milliseconds for sentinel parameters
// without an explicit timeout value.
//
// NOTE: in real-world scenarios sentinels should be running on different hosts!
$sentinels = [
    'tcp://127.0.0.1:5380?timeout=0.100',
    'tcp://127.0.0.1:5381?timeout=0.100',
    'tcp://127.0.0.1:5382?timeout=0.100',
];

$client = new Predis\Client($sentinels, [
    'replication' => 'sentinel',
    'service' => 'mymaster',
]);

// Read operation.
$exists = $client->exists('foo') ? 'yes' : 'no';
$current = $client->getConnection()->getCurrent()->getParameters();
echo "Does 'foo' exist on {$current->role}? $exists.", PHP_EOL;

// Write operation.
$client->set('foo', 'bar');
$current = $client->getConnection()->getCurrent()->getParameters();
echo "Now 'foo' has been set to 'bar' on {$current->role}!", PHP_EOL;

// Read operation.
$bar = $client->get('foo');
$current = $client->getConnection()->getCurrent()->getParameters();
echo "We fetched 'foo' from {$current->role} and its value is '$bar'.", PHP_EOL;

/* OUTPUT:
Does 'foo' exist on slave-127.0.0.1:6381? yes.
Now 'foo' has been set to 'bar' on master!
We fetched 'foo' from master and its value is 'bar'.
*/


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\replication_simple.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// Predis supports master / slave replication scenarios where write operations
// are performed on the master server and read operations are executed against
// one of the slaves. The behavior of commands or EVAL scripts can be customized
// at will. As soon as a write operation is performed the client switches to the
// master server for all the subsequent requests (either reads and writes).
//
// This example must be executed using the second Redis server configured as the
// slave of the first one (see the "SLAVEOF" command).
//

$parameters = [
    'tcp://127.0.0.1:6381?role=master&database=15',
    'tcp://127.0.0.1:6382?role=slave&database=15',
];

$options = ['replication' => 'predis'];

$client = new Predis\Client($parameters, $options);

// Read operation.
$exists = $client->exists('foo') ? 'yes' : 'no';
$current = $client->getConnection()->getCurrent()->getParameters();
echo "Does 'foo' exist on {$current->role}? $exists.", PHP_EOL;

// Write operation.
$client->set('foo', 'bar');
$current = $client->getConnection()->getCurrent()->getParameters();
echo "Now 'foo' has been set to 'bar' on {$current->role}!", PHP_EOL;

// Read operation.
$bar = $client->get('foo');
$current = $client->getConnection()->getCurrent()->getParameters();
echo "We fetched 'foo' from {$current->role} and its value is '$bar'.", PHP_EOL;

/* OUTPUT:
Does 'foo' exist on slave? yes.
Now 'foo' has been set to 'bar' on master!
We fetched 'foo' from master and its value is 'bar'.
*/


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\session_handler.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// This example demonstrates how to use Predis to save PHP sessions on Redis.
//
// The value of `session.gc_maxlifetime` in `php.ini` will be used by default as
// the TTL for keys holding session data but this value can be overridden when
// creating the session handler instance using the `gc_maxlifetime` option.
//
// NOTE: this class requires PHP >= 5.4 but can be used on PHP 5.3 if a polyfill
// for SessionHandlerInterface is provided either by you or an external package
// like `symfony/http-foundation`.
//
// See http://www.php.net/class.sessionhandlerinterface.php for more details.
//

if (!interface_exists('SessionHandlerInterface')) {
    exit('ATTENTION: the session handler implemented by Predis requires PHP >= 5.4.0 ' .
        "or a polyfill for SessionHandlerInterface provided by an external package.\n");
}

// Instantiate a new client just like you would normally do. Using a prefix for
// keys will effectively prefix all session keys with the specified string.
$client = new Predis\Client($single_server, ['prefix' => 'sessions:']);

// Set `gc_maxlifetime` to specify a time-to-live of 5 seconds for session keys.
$handler = new Predis\Session\Handler($client, ['gc_maxlifetime' => 5]);

// Register the session handler.
$handler->register();

// We just set a fixed session ID only for the sake of our example.
session_id('example_session_id');

session_start();

if (isset($_SESSION['foo'])) {
    echo "Session has `foo` set to {$_SESSION['foo']}", PHP_EOL;
} else {
    $_SESSION['foo'] = $value = mt_rand();
    echo "Empty session, `foo` has been set with $value", PHP_EOL;
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\shared.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

if (PHP_SAPI !== 'cli') {
    exit('Example scripts are meant to be executed locally via CLI.');
}

require __DIR__ . '/../autoload.php';

function redis_version($info)
{
    if (isset($info['Server']['redis_version'])) {
        return $info['Server']['redis_version'];
    } elseif (isset($info['redis_version'])) {
        return $info['redis_version'];
    } else {
        return 'unknown version';
    }
}

$single_server = [
    'host' => '127.0.0.1',
    'port' => 6379,
    'database' => 15,
];

$multiple_servers = [
    [
        'host' => '127.0.0.1',
        'port' => 6379,
        'database' => 15,
        'alias' => 'first',
    ],
    [
        'host' => '127.0.0.1',
        'port' => 6380,
        'database' => 15,
        'alias' => 'second',
    ],
];


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\transaction_using_cas.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

require __DIR__ . '/shared.php';

// This is an implementation of an atomic client-side ZPOP using the support for
// check-and-set (CAS) operations with MULTI/EXEC transactions, as described in
// "WATCH explained" from http://redis.io/topics/transactions
//
// First, populate your database with a tiny sample data set:
//
// ./redis-cli
// SELECT 15
// ZADD zset 1 a 2 b 3 c
//
// Then execute this script four times and see its output.
//

function zpop($client, $key)
{
    $element = null;
    $options = [
        'cas' => true,      // Initialize with support for CAS operations
        'watch' => $key,    // Key that needs to be WATCHed to detect changes
        'retry' => 3,       // Number of retries on aborted transactions, after
        // which the client bails out with an exception.
    ];

    $client->transaction($options, function ($tx) use ($key, &$element) {
        @[$element] = $tx->zrange($key, 0, 0);

        if (isset($element)) {
            $tx->multi();   // With CAS, MULTI *must* be explicitly invoked.
            $tx->zrem($key, $element);
        }
    });

    return $element;
}

$client = new Predis\Client($single_server);
$zpopped = zpop($client, 'zset');

echo isset($zpopped) ? "ZPOPed $zpopped" : 'Nothing to ZPOP!', PHP_EOL;


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\acl_dry_run.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;

require __DIR__ . '/../shared.php';

// Example of ACL DRYRUN command usage:

// 1. Set user with permissions to call only 'SET' command.
$client = new Client($single_server);
$response = $client->acl->setUser('Test_dry', '+SET', '~*');
$created = ($response == 'OK') ? 'Yes' : 'No';

echo "User with username 'Test' was created: {$created}. Permissions only to use SET command\n";

// 2. Dry run 'SET' command under 'Test_dry' user
$response = $client->acl->dryRun('Test_dry', 'SET', 'foo', 'bar');

echo 'Dry run "SET" command.' . "\n";
echo 'Response: ' . $response . "\n";

// 3. Dry run 'GET' command under 'Test_dry' user
$response = $client->acl->dryRun('Test_dry', 'GET', 'foo');

echo 'Dry run "GET" command.' . "\n";
echo 'Response: ' . $response;


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\acl_get_user.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;

require __DIR__ . '/../shared.php';

// Example of ACL GETUSER command usage:

// 1. Set user
$client = new Client($single_server);
$response = $client->acl->setUser('Test');

// 2. Retrieve user rules:

echo 'Rules: ' . "\n";
print_r(
    $client->acl->getUser('Test')
);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\acl_set_user.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;

require __DIR__ . '/../shared.php';

// Example of ACL SETUSER command usage:

// 1. Set user
$client = new Client($single_server);
$response = $client->acl->setUser('Test');
$created = ($response == 'OK') ? 'Yes' : 'No';

echo "User with username 'Test' was created: {$created}";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\fcall_ro.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;

require __DIR__ . '/../shared.php';

// Example of FCALL_RO command usage:

// 1. Set key-value pair
$client = new Client($single_server);
$client->set('foo', 'bar');

echo "Set key 'foo' with value 'bar'\n";

// 2. Load redis function with 'no-writes' flag
$client->function->load(
    "#!lua name=mylib
                redis.register_function{
                    function_name='myfunc',
                    callback=function(keys, args) return redis.call('GET', keys[1]) end,
                    flags={'no-writes'}
                }"
);

echo 'Loaded custom function that perform GET command against provided key.' . "\n";

// 3. Call function above with given key
$response = $client->fcall_ro('myfunc', ['foo']);

echo "Function returned value against provided key 'foo' is '{$response}'";

// 4. Delete test library
$client->function->delete('mylib');


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\waitaof.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;

require __DIR__ . '/../shared.php';

// Example of WAITAOF command usage:

// 1. Enable appendonly mode if it's not (command works only in appendonly mode)
$client = new Client($single_server);
$info = $client->info();
$enabled = false;

if ($info['Persistence']['aof_enabled'] === '0') {
    $client->config('set', 'appendonly', 'yes');
    $enabled = true;
}

// 2. Set key value pair
$response = $client->set('foo', 'bar');
echo "Key-value pair set status: {$response}\n";

// 3. Run WAITAOF command to make sure that all previous writes was fsynced
$response = $client->waitaof(1, 0, 0);

echo "Quantity of local instances that was fsynced - {$response[0]}, quantity of replicas - {$response[1]}";

// 4. Disable appendonly mode if it was enabled during script execution
if ($enabled) {
    $client->config('set', 'appendonly', 'no');
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Json\json_debug_memory.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;

require __DIR__ . '/../../shared.php';

// Example of JSON.DEBUG command usage:

// 1. Set JSON object
$client = new Client();

$client->jsonset('key', '$', '{"key1":"value1","key2":"value2"}');

// 2. Dump information about json memory usage in bytes
$response = $client->jsondebug->memory('key', '$');

echo 'Response:' . "\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_aggregate.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\AggregateArguments;
use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\SchemaFields\AbstractField;
use Predis\Command\Argument\Search\SchemaFields\NumericField;
use Predis\Command\Argument\Search\SchemaFields\TextField;

require __DIR__ . '/../../shared.php';

// Example of FT.AGGREGATE command usage:

// 1. Create index
$client = new Client();

$ftCreateArguments = (new CreateArguments())->prefix(['user:']);
$schema = [
    new TextField('name'),
    new TextField('country'),
    new NumericField('dob', '', AbstractField::SORTABLE),
];

$client->ftcreate('idx', $schema, $ftCreateArguments);

// 2. Add documents
$client->hset('user:0', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600);
$client->hset('user:1', 'name', 'Vlad', 'country', 'Israel', 'dob', 782265600);
$client->hset('user:2', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600);

// 3. Execute aggregation query
$ftAggregateArguments = (new AggregateArguments())
    ->apply('year(@dob)', 'birth')
    ->groupBy('@country', '@birth')
    ->reduce('COUNT', true, 'country_birth_Vlad_count')
    ->sortBy(0, '@birth', 'DESC');

$response = $client->ftaggregate('idx', '@name: "Vlad"', $ftAggregateArguments);

// Response grouped by user country and birth year, with users count in each group, sorted by birth year from DESC.
echo 'Response:' . "\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_alter.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\SchemaFields\TextField;

require __DIR__ . '/../../shared.php';

// Example of FT.ALTER command usage:

// 1. Create index
$client = new Client();

$schema = [
    new TextField('text_field'),
];
$client->ftcreate('index_alter', $schema);

echo 'Default index attributes:' . "\n";
$defaultAttributes = $client->ftinfo('index_alter');
print_r($defaultAttributes[7]);

// 2. Add additional attribute to existing index
$schema = [
    new TextField('new_field_name'),
];

$client->ftalter('index_alter', $schema);

echo 'Updated index attributes:' . "\n";
$updatedAttributes = $client->ftinfo('index_alter');
print_r($updatedAttributes[7]);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_config_help.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;

require __DIR__ . '/../../shared.php';

// Example of FT.CONFIG HELP command usage:

// 1. Dump helpful information about FT.CONFIG MAXEXPANSIONS option
$client = new Client();

echo 'Response:' . "\n";
print_r(
    $client->ftconfig->help('MAXEXPANSIONS')
);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_config_set_get.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;

require __DIR__ . '/../../shared.php';

// Example of FT.CONFIG SET command usage:

// 1. Change default timeout setting
$client = new Client();

echo 'Response:' . "\n";

print_r(
    $client->ftconfig->set('TIMEOUT', 42)
);
print_r(
    $client->ftconfig->get('TIMEOUT')
);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_cursor_del.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\AggregateArguments;
use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\SchemaFields\AbstractField;
use Predis\Command\Argument\Search\SchemaFields\NumericField;
use Predis\Command\Argument\Search\SchemaFields\TextField;

require __DIR__ . '/../../shared.php';

// Example of FT.CURSOR DEL command usage

// 1. Create index
$client = new Client();

$ftCreateArguments = (new CreateArguments())->prefix(['user:']);
$schema = [
    new TextField('name'),
    new TextField('country'),
    new NumericField('dob', '', AbstractField::SORTABLE),
];

$client->ftcreate('index_cursor_del', $schema, $ftCreateArguments);

// 2. Add documents
$client->hset('user:0', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600);
$client->hset('user:1', 'name', 'Vlad', 'country', 'Israel', 'dob', 782265600);
$client->hset('user:2', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600);

// 3. Execute aggregation query
$ftAggregateArguments = (new AggregateArguments())
    ->apply('year(@dob)', 'birth')
    ->groupBy('@country', '@birth')
    ->reduce('COUNT', true, 'country_birth_Vlad_count')
    ->sortBy(0, '@birth', 'DESC')
    ->withCursor(1);

[$_, $cursor] = $client->ftaggregate('index_cursor_del', '@name: "Vlad"', $ftAggregateArguments);

// 4. Explicitly remove returned cursor
$client->ftcursor->del('index_cursor_del', $cursor);

echo "Cursor with cursorId - {$cursor} was removed";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_cursor_read.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\AggregateArguments;
use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\SchemaFields\AbstractField;
use Predis\Command\Argument\Search\SchemaFields\NumericField;
use Predis\Command\Argument\Search\SchemaFields\TextField;

require __DIR__ . '/../../shared.php';

// Example of FT.CURSOR READ command usage

// 1. Create index
$client = new Client();

$ftCreateArguments = (new CreateArguments())->prefix(['user:']);
$schema = [
    new TextField('name'),
    new TextField('country'),
    new NumericField('dob', '', AbstractField::SORTABLE),
];

$client->ftcreate('index_cursor_read', $schema, $ftCreateArguments);

// 2. Add documents
$client->hset('user:0', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600);
$client->hset('user:1', 'name', 'Vlad', 'country', 'Israel', 'dob', 782265600);
$client->hset('user:2', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600);

// 3. Execute aggregation query
$ftAggregateArguments = (new AggregateArguments())
    ->apply('year(@dob)', 'birth')
    ->groupBy('@country', '@birth')
    ->reduce('COUNT', true, 'country_birth_Vlad_count')
    ->sortBy(0, '@birth', 'DESC')
    ->withCursor(1);

[$response, $cursor] = $client->ftaggregate('index_cursor_read', '@name: "Vlad"', $ftAggregateArguments);

// 4. Processing response in loop until cursorId exists
$actualResponse = [];
$cursors = [];

while ($cursor) {
    $actualResponse[] = $response[1];
    $cursors[] = $cursor;
    [$response, $cursor] = $client->ftcursor->read('index_cursor_read', $cursor);
}

echo "Response: \n";
print_r($actualResponse);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_explain.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\SchemaFields\TextField;

require __DIR__ . '/../../shared.php';

// Example of FT.EXPLAIN command usage:

// 1. Create index
$client = new Client();

$schema = [
    new TextField('text_field'),
];
$client->ftcreate('index_explain', $schema);

// 2. Run query explanations
$response = $client->ftexplain('index_explain', '(foo bar)|(hello world) @date:[100 200]|@date:[500 +inf]');

echo 'Response:' . "\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_profile.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\ProfileArguments;
use Predis\Command\Argument\Search\SchemaFields\TextField;

require __DIR__ . '/../../shared.php';

// Example of FT.PROFILE command usage:

// 1. Create index
$client = new Client();

$schema = [
    new TextField('text_field'),
];
$client->ftcreate('index_profile', $schema);

// 2. Create FT.PROFILE command arguments
$arguments = (new ProfileArguments())
                ->search()
                ->query('query');

// 3. Run profile query
$response = $client->ftprofile('index_profile', $arguments);

echo 'Response:' . "\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_spellcheck.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Argument\Search\SpellcheckArguments;

require __DIR__ . '/../../shared.php';

// Example of FT.SPELLCHECK command usage:

// 1. Create index
$client = new Client();

$schema = [
    new TextField('text_field'),
];
$client->ftcreate('index_spellcheck', $schema);

// 2. Add dictionary with terms
$client->ftdictadd('dict', 'hello', 'help');

// 3. Perform spelling correction query
$response = $client->ftspellcheck(
    'index_spellcheck',
    'held',
    (new SpellcheckArguments())->distance(2)->terms('dict')
);

echo 'Response:' . "\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_sug_add_get_del_len.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\SugAddArguments;
use Predis\Command\Argument\Search\SugGetArguments;

require __DIR__ . '/../../shared.php';

// Example of FT.SUGADD, FT.SUGGET, FT.SUGDEL, FT.SUGLEN commands usage:

// 1. Add suggestion to key with payload
$client = new Client();

$client->ftsugadd('key', 'hello', 2, (new SugAddArguments())->payload('payload'));

echo 'Suggestions dictionary length: ' . $client->ftsuglen('key') . "\n";

// 2. Perform fuzzy search by prefix to get previous suggestion with payload
$response = $client->ftsugget('key', 'hellp', (new SugGetArguments())->fuzzy()->withPayloads());

echo 'Suggestion for "hellp" prefix:' . "\n";
print_r($response);

// 3. Removes previous suggestion from key
$client->ftsugdel('key', 'hello');
$response = $client->ftsugget('key', 'hello');

echo 'Suggestions, after removing "hello" suggestion:' . "\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_syndump.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\SchemaFields\TextField;

require __DIR__ . '/../../shared.php';

// Example of FT.SYNDUMP command usage:

// 1. Create index
$client = new Client();

$schema = [
    new TextField('text_field'),
];
$client->ftcreate('index_syndump', $schema);

// 2. Add synonyms group with terms
$client->ftsynupdate('index_syndump', 'synonym1', null, 'term1', 'term2');

// 3. Dump terms with synonyms
$response = $client->ftsyndump('index_syndump');

echo 'Response:' . "\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_synupdate.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\SchemaFields\TextField;

require __DIR__ . '/../../shared.php';

// Example of FT.SYNUPDATE command usage:

// 1. Create index
$client = new Client();

$schema = [
    new TextField('text_field'),
];
$client->ftcreate('index_synupdate', $schema);

// 2. Add synonyms into synonym group
$response = $client->ftsynupdate('index_synupdate', 'synonym1', null, 'term1', 'term2');

echo 'Response:' . "\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\Search\ft_tagvals.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\SchemaFields\TagField;

require __DIR__ . '/../../shared.php';

// Example of FT.TAGVALS command usage:

// 1. Create index
$client = new Client();

$schema = [
    new TagField('tag_field'),
];
$client->ftcreate('index_tagvals', $schema, (new CreateArguments())->prefix(['prefix:']));

// 2. Add indexed tags
$client->hset('prefix:1', 'tag_field', 'Hello, World');
$client->hset('prefix:2', 'tag_field', 'Hey, World');

// 3. Unique tags value query
$response = $client->fttagvals('index_tagvals', 'tag_field');

echo 'Response:' . "\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_add.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\AddArguments;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.ADD command usage:

// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->retentionMsecs(60000)
    ->duplicatePolicy(CommonArguments::POLICY_MAX)
    ->labels('sensor_id', 2, 'area_id', 32);

$client->tscreate('temperature:2:32', $arguments);

// 2. Add sample into newly created time series
$addArguments = (new AddArguments())
    ->retentionMsecs(31536000000);

$response = $client->tsadd('temperature:2:32', 123123123123, 27, $addArguments);

echo "Timeseries was added with timestamp: {$response}";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_alter.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\AlterArguments;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.ALTER command usage:

// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->retentionMsecs(60000)
    ->duplicatePolicy(CommonArguments::POLICY_MAX)
    ->labels('sensor_id', 2, 'area_id', 32);

$response = $client->tscreate('temperature:2:32', $arguments);

echo "Time series creation status: {$response}\n";

// 2. Update Duplicate policy for time series above
$arguments = (new AlterArguments())
    ->duplicatePolicy(CommonArguments::POLICY_FIRST);

$response = $client->tsalter('temperature:2:32', $arguments);
$output = ($response == 'OK') ? 'Duplicate policy was successfully updated' : $response;

echo $output;


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_create.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.CREATE command usage:

// Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->retentionMsecs(60000)
    ->duplicatePolicy(CommonArguments::POLICY_MAX)
    ->labels('sensor_id', 2, 'area_id', 32);

$response = $client->tscreate('temperature:2:32', $arguments);

echo "Time series creation status: {$response}";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_createrule.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CreateArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.CREATERULE command usage:

// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->labels('type', 'temp', 'location', 'TLV');

$createResponse = $client->tscreate('temp:TLV', $arguments);
echo "Original time series creation status: {$createResponse}\n";

$createResponse = $client->tscreate('dailyAvgTemp:TLV', $arguments);
echo "Compacted time series creation status: {$createResponse}\n";

$createRuleResponse = $client->tscreaterule('temp:TLV', 'dailyAvgTemp:TLV', 'avg', 1000);
echo "Compacted rule for compacted time series creation status: {$createRuleResponse}\n";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_decrby.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\AddArguments;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\DecrByArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.DECRBY command usage:

// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->retentionMsecs(60000)
    ->duplicatePolicy(CommonArguments::POLICY_MAX)
    ->labels('sensor_id', 2, 'area_id', 32);

$client->tscreate('temperature:2:32', $arguments);

// 2. Add sample into newly created time series
$addArguments = (new AddArguments())
    ->retentionMsecs(31536000000);

$response = $client->tsadd('temperature:2:32', 123123123123, 27, $addArguments);

echo "Timeseries was added with timestamp: {$response}\n";

// 3. Increasing value and timestamp
$client->tsdecrby('temperature:2:32', 1, (new DecrByArguments())->timestamp(123123123124));
$response = $client->tsget('temperature:2:32');

echo "Decreased value to - {$response[1]} and timestamp to {$response[0]}";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_del.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.GET command usage:
// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->retentionMsecs(60000)
    ->duplicatePolicy(CommonArguments::POLICY_MAX)
    ->labels('sensor_id', 2, 'area_id', 32);

$client->tscreate('temperature:2:32', $arguments);

// 2. Add samples into time series
$client->tsadd('temperature:2:32', 123123123123, 27);
$client->tsadd('temperature:2:32', 123123123124, 28);
$client->tsadd('temperature:2:32', 123123123125, 29);

$response = $client->tsget('temperature:2:32');

echo "Sample with highest timestamp - {$response[0]} and value {$response[1]}\n";

// 3. Removes 2 samples with the highest timestamps
$response = $client->tsdel('temperature:2:32', 123123123124, 123123123125);

echo "Removed {$response} samples from timeseries.\n";

// 3. Retrieve a timestamp with the highest timestamp
$response = $client->tsget('temperature:2:32');

echo "New sample with highest timestamp - {$response[0]} and value {$response[1]}";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_deleterule.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CreateArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.CREATERULE command usage:

// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->labels('type', 'temp', 'location', 'TLV');

$createResponse = $client->tscreate('temp:TLV', $arguments);
echo "Original time series creation status: {$createResponse}\n";

$createResponse = $client->tscreate('dailyAvgTemp:TLV', $arguments);
echo "Compacted time series creation status: {$createResponse}\n";

$createRuleResponse = $client->tscreaterule('temp:TLV', 'dailyAvgTemp:TLV', 'avg', 1000);
echo "Compacted rule for compacted time series creation status: {$createRuleResponse}\n";

// 2. Remove compaction rule
$deleteRuleResponse = $client->tsdeleterule('temp:TLV', 'dailyAvgTemp:TLV');
echo "Compacted rule for compacted time series deletion status: {$deleteRuleResponse}\n";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_get.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.GET command usage:
// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->retentionMsecs(60000)
    ->duplicatePolicy(CommonArguments::POLICY_MAX)
    ->labels('sensor_id', 2, 'area_id', 32);

$client->tscreate('temperature:2:32', $arguments);

// 2. Add samples into time series
$client->tsadd('temperature:2:32', 123123123123, 27);
$client->tsadd('temperature:2:32', 123123123124, 28);
$client->tsadd('temperature:2:32', 123123123125, 29);

// 3. Retrieve a timestamp with highest timestamp
$response = $client->tsget('temperature:2:32');

echo "Sample with highest timestamp - {$response[0]} and value - {$response[1]}";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_incrby.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\AddArguments;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\IncrByArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.INCRBY command usage:

// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->retentionMsecs(60000)
    ->duplicatePolicy(CommonArguments::POLICY_MAX)
    ->labels('sensor_id', 2, 'area_id', 32);

$client->tscreate('temperature:2:32', $arguments);

// 2. Add sample into newly created time series
$addArguments = (new AddArguments())
    ->retentionMsecs(31536000000);

$response = $client->tsadd('temperature:2:32', 123123123123, 27, $addArguments);

echo "Timeseries was added with timestamp: {$response}\n";

// 3. Increasing value and timestamp
$client->tsincrby('temperature:2:32', 1, (new IncrByArguments())->timestamp(123123123124));
$response = $client->tsget('temperature:2:32');

echo "Increased value to - {$response[1]} and timestamp to {$response[0]}";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_info.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.CREATE command usage:

// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->retentionMsecs(60000)
    ->duplicatePolicy(CommonArguments::POLICY_MAX)
    ->labels('sensor_id', 2, 'area_id', 32);

$client->tscreate('temperature:2:32', $arguments);

// 2. Show info about given time series
print_r($client->tsinfo('temperature:2:32'));


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_madd.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.MADD command usage:

// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->retentionMsecs(60000)
    ->duplicatePolicy(CommonArguments::POLICY_MAX)
    ->labels('sensor_id', 2, 'area_id', 32);

$client->tscreate('temperature:2:32', $arguments);
$client->tscreate('temperature:2:33', $arguments);

// 2. Add samples into few time series
$response = $client->tsmadd('temperature:2:32', 123123123123, 27, 'temperature:2:33', 123123123124, 28);
$stringResponse = implode(', ', $response);

echo "Samples was added to time series - timestamps: {$stringResponse}";


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_mget.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\MGetArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.MGET command usage:

// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->retentionMsecs(60000)
    ->duplicatePolicy(CommonArguments::POLICY_MAX)
    ->labels('type', 'temp', 'sensor_id', 2, 'area_id', 32);

$client->tscreate('temperature:2:32', $arguments);
$client->tscreate('temperature:2:33', $arguments);

// 2. Add samples into time series
$client->tsadd('temperature:2:32', 123123123123, 27);
$client->tsadd('temperature:2:33', 123123123124, 27);

// 3. Get sample from multiple time series matching given filter expression, with selected labels only
$response = $client->tsmget((new MGetArguments())->selectedLabels('type'), 'type=temp');

echo "Sample from time series, with label = 'type':\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_mrange.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\MRangeArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.MRANGE command usage:

// 1. Create time series
$client = new Client();

$response = $client->tscreate('stock:A', (new CreateArguments())->labels('type', 'stock', 'name', 'A'));
echo "Time series A creation status: {$response}\n";

$response = $client->tscreate('stock:B', (new CreateArguments())->labels('type', 'stock', 'name', 'B'));
echo "Time series B creation status: {$response}\n";

// 2. Add samples into both time series
$response = $client->tsmadd('stock:A', 1000, 100, 'stock:A', 1010, 110, 'stock:A', 1020, 120);
$stringResponse = implode(', ', $response);
echo "Added samples into time series A with following timestamps: {$stringResponse}\n";

$response = $client->tsmadd('stock:B', 1000, 120, 'stock:B', 1010, 110, 'stock:B', 1020, 100);
$stringResponse = implode(', ', $response);
echo "Added samples into time series B with following timestamps: {$stringResponse}\n";

// 3. Query range across both time series filtered by "type" and grouped by max type
$mrangeArguments = (new MRangeArguments())
    ->withLabels()
    ->filter('type=stock')
    ->groupBy('type', 'max');

$response = $client->tsmrange('-', '+', $mrangeArguments);

echo "Response:\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_mrevrange.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\MRangeArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.MREVRANGE command usage:

// 1. Create time series
$client = new Client();

$response = $client->tscreate('stock:A', (new CreateArguments())->labels('type', 'stock', 'name', 'A'));
echo "Time series A creation status: {$response}\n";

$response = $client->tscreate('stock:B', (new CreateArguments())->labels('type', 'stock', 'name', 'B'));
echo "Time series B creation status: {$response}\n";

// 2. Add samples into both time series
$response = $client->tsmadd('stock:A', 1000, 100, 'stock:A', 1010, 110, 'stock:A', 1020, 120);
$stringResponse = implode(', ', $response);
echo "Added samples into time series A with following timestamps: {$stringResponse}\n";

$response = $client->tsmadd('stock:B', 1000, 120, 'stock:B', 1010, 110, 'stock:B', 1020, 100);
$stringResponse = implode(', ', $response);
echo "Added samples into time series B with following timestamps: {$stringResponse}\n";

// 3. Query range across both time series filtered by "type" and grouped by max type
$mrangeArguments = (new MRangeArguments())
    ->withLabels()
    ->filter('type=stock')
    ->groupBy('type', 'max');

$response = $client->tsmrevrange('-', '+', $mrangeArguments);

echo "Response:\n";
print_r($response);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_queryindex.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CreateArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.QUERYINDEX command usage:

// 1. Create time series
$client = new Client();

$arguments = (new CreateArguments())
    ->labels('type', 'temp', 'location', 'TLV');

$createResponse = $client->tscreate('temp:TLV', $arguments);
echo "Time series with location TLV creation status: {$createResponse}\n";

$anotherArguments = (new CreateArguments())
    ->labels('type', 'temp', 'location', 'JER');

$createResponse = $client->tscreate('temp:JER', $anotherArguments);
echo "Time series with location JER creation status: {$createResponse}\n";

echo "Returns all keys with location=TLV:\n";
print_r($client->tsqueryindex('location=TLV'));


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_range.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\RangeArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.RANGE command usage:

// 1. Create time series
$client = new Client();

$createArguments = (new CreateArguments())->labels('type', 'temp', 'location', 'TLV');
$createResponse = $client->tscreate('temp:TLV', $createArguments);

echo "Time series creation status: {$createResponse}\n";

// 2. Add samples into time series
$maddResponse = $client->tsmadd('temp:TLV', 1000, 30, 'temp:TLV', 1010, 35, 'temp:TLV', 1020, 9999, 'temp:TLV', 1030, 40);
$stringResponse = implode(', ', $maddResponse);

echo "Samples was added with following timestamps: {$stringResponse}\n";

// 3. Query samples by values in the given range
$rangeArguments = (new RangeArguments())->filterByValue(-100, 100);
$rangeResponse = $client->tsrange('temp:TLV', '-', '+', $rangeArguments);

echo "Samples with temperature in range -100 to 100 degrees:\n";
print_r($rangeResponse);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\examples\Commands\TimeSeries\ts_revrange.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Client;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\RangeArguments;

require __DIR__ . '/../../shared.php';

// Example of TS.REVRANGE command usage:

// 1. Create time series
$client = new Client();

$createArguments = (new CreateArguments())->labels('type', 'temp', 'location', 'TLV');
$createResponse = $client->tscreate('temp:TLV', $createArguments);

echo "Time series creation status: {$createResponse}\n";

// 2. Add samples into time series
$maddResponse = $client->tsmadd('temp:TLV', 1000, 30, 'temp:TLV', 1010, 35, 'temp:TLV', 1020, 9999, 'temp:TLV', 1030, 40);
$stringResponse = implode(', ', $maddResponse);

echo "Samples was added with following timestamps: {$stringResponse}\n";

// 3. Query samples by values in the given range
$rangeArguments = (new RangeArguments())->filterByValue(-100, 100);
$rangeResponse = $client->tsrevrange('temp:TLV', '-', '+', $rangeArguments);

echo "Samples with temperature in range -100 to 100 degrees in reverse order:\n";
print_r($rangeResponse);


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Autoloader.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

/**
 * Implements a lightweight PSR-0 compliant autoloader for Predis.
 *
 * @author Eric Naeseth <eric@thumbtack.com>
 * @author Daniele Alessandri <suppakilla@gmail.com>
 * @codeCoverageIgnore
 */
class Autoloader
{
    private $directory;
    private $prefix;
    private $prefixLength;

    /**
     * @param string $baseDirectory Base directory where the source files are located.
     */
    public function __construct($baseDirectory = __DIR__)
    {
        $this->directory = $baseDirectory;
        $this->prefix = __NAMESPACE__ . '\\';
        $this->prefixLength = strlen($this->prefix);
    }

    /**
     * Registers the autoloader class with the PHP SPL autoloader.
     *
     * @param bool $prepend Prepend the autoloader on the stack instead of appending it.
     */
    public static function register($prepend = false)
    {
        spl_autoload_register([new self(), 'autoload'], true, $prepend);
    }

    /**
     * Loads a class from a file using its fully qualified name.
     *
     * @param string $className Fully qualified name of a class.
     */
    public function autoload($className)
    {
        if (0 === strpos($className, $this->prefix)) {
            $parts = explode('\\', substr($className, $this->prefixLength));
            $filepath = $this->directory . DIRECTORY_SEPARATOR . implode(DIRECTORY_SEPARATOR, $parts) . '.php';

            if (is_file($filepath)) {
                require $filepath;
            }
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Client.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

use ArrayIterator;
use InvalidArgumentException;
use IteratorAggregate;
use Predis\Command\CommandInterface;
use Predis\Command\RawCommand;
use Predis\Command\Redis\Container\ContainerFactory;
use Predis\Command\Redis\Container\ContainerInterface;
use Predis\Command\ScriptCommand;
use Predis\Configuration\Options;
use Predis\Configuration\OptionsInterface;
use Predis\Connection\ConnectionInterface;
use Predis\Connection\Parameters;
use Predis\Connection\ParametersInterface;
use Predis\Connection\RelayConnection;
use Predis\Monitor\Consumer as MonitorConsumer;
use Predis\Pipeline\Atomic;
use Predis\Pipeline\FireAndForget;
use Predis\Pipeline\Pipeline;
use Predis\Pipeline\RelayAtomic;
use Predis\Pipeline\RelayPipeline;
use Predis\PubSub\Consumer as PubSubConsumer;
use Predis\PubSub\RelayConsumer as RelayPubSubConsumer;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use Predis\Response\ResponseInterface;
use Predis\Response\ServerException;
use Predis\Transaction\MultiExec as MultiExecTransaction;
use ReturnTypeWillChange;
use RuntimeException;
use Traversable;

/**
 * Client class used for connecting and executing commands on Redis.
 *
 * This is the main high-level abstraction of Predis upon which various other
 * abstractions are built. Internally it aggregates various other classes each
 * one with its own responsibility and scope.
 *
 * @template-implements \IteratorAggregate<string, static>
 */
class Client implements ClientInterface, IteratorAggregate
{
    public const VERSION = '2.3.0';

    /** @var OptionsInterface */
    private $options;

    /** @var ConnectionInterface */
    private $connection;

    /** @var Command\FactoryInterface */
    private $commands;

    /**
     * @param mixed $parameters Connection parameters for one or more servers.
     * @param mixed $options    Options to configure some behaviours of the client.
     */
    public function __construct($parameters = null, $options = null)
    {
        $this->options = static::createOptions($options ?? new Options());
        $this->connection = static::createConnection($this->options, $parameters ?? new Parameters());
        $this->commands = $this->options->commands;
    }

    /**
     * Creates a new set of client options for the client.
     *
     * @param array|OptionsInterface $options Set of client options
     *
     * @return OptionsInterface
     * @throws InvalidArgumentException
     */
    protected static function createOptions($options)
    {
        if (is_array($options)) {
            return new Options($options);
        } elseif ($options instanceof OptionsInterface) {
            return $options;
        } else {
            throw new InvalidArgumentException('Invalid type for client options');
        }
    }

    /**
     * Creates single or aggregate connections from supplied arguments.
     *
     * This method accepts the following types to create a connection instance:
     *
     *  - Array (dictionary: single connection, indexed: aggregate connections)
     *  - String (URI for a single connection)
     *  - Callable (connection initializer callback)
     *  - Instance of Predis\Connection\ParametersInterface (used as-is)
     *  - Instance of Predis\Connection\ConnectionInterface (returned as-is)
     *
     * When a callable is passed, it receives the original set of client options
     * and must return an instance of Predis\Connection\ConnectionInterface.
     *
     * Connections are created using the connection factory (in case of single
     * connections) or a specialized aggregate connection initializer (in case
     * of cluster and replication) retrieved from the supplied client options.
     *
     * @param OptionsInterface $options    Client options container
     * @param mixed            $parameters Connection parameters
     *
     * @return ConnectionInterface
     * @throws InvalidArgumentException
     */
    protected static function createConnection(OptionsInterface $options, $parameters)
    {
        if ($parameters instanceof ConnectionInterface) {
            return $parameters;
        }

        if ($parameters instanceof ParametersInterface || is_string($parameters)) {
            return $options->connections->create($parameters);
        }

        if (is_array($parameters)) {
            if (!isset($parameters[0])) {
                return $options->connections->create($parameters);
            } elseif ($options->defined('cluster') && $initializer = $options->cluster) {
                return $initializer($parameters, true);
            } elseif ($options->defined('replication') && $initializer = $options->replication) {
                return $initializer($parameters, true);
            } elseif ($options->defined('aggregate') && $initializer = $options->aggregate) {
                return $initializer($parameters, false);
            } else {
                throw new InvalidArgumentException(
                    'Array of connection parameters requires `cluster`, `replication` or `aggregate` client option'
                );
            }
        }

        if (is_callable($parameters)) {
            $connection = call_user_func($parameters, $options);

            if (!$connection instanceof ConnectionInterface) {
                throw new InvalidArgumentException('Callable parameters must return a valid connection');
            }

            return $connection;
        }

        throw new InvalidArgumentException('Invalid type for connection parameters');
    }

    /**
     * {@inheritdoc}
     */
    public function getCommandFactory()
    {
        return $this->commands;
    }

    /**
     * {@inheritdoc}
     */
    public function getOptions()
    {
        return $this->options;
    }

    /**
     * Creates a new client using a specific underlying connection.
     *
     * This method allows to create a new client instance by picking a specific
     * connection out of an aggregate one, with the same options of the original
     * client instance.
     *
     * The specified selector defines which logic to use to look for a suitable
     * connection by the specified value. Supported selectors are:
     *
     *   - `id`
     *   - `key`
     *   - `slot`
     *   - `command`
     *   - `alias`
     *   - `role`
     *
     * Internally the client relies on duck-typing and follows this convention:
     *
     *   $selector string => getConnectionBy$selector($value) method
     *
     * This means that support for specific selectors may vary depending on the
     * actual logic implemented by connection classes and there is no interface
     * binding a connection class to implement any of these.
     *
     * @param string $selector Type of selector.
     * @param mixed  $value    Value to be used by the selector.
     *
     * @return ClientInterface
     */
    public function getClientBy($selector, $value)
    {
        $selector = strtolower($selector);

        if (!in_array($selector, ['id', 'key', 'slot', 'role', 'alias', 'command'])) {
            throw new InvalidArgumentException("Invalid selector type: `$selector`");
        }

        if (!method_exists($this->connection, $method = "getConnectionBy$selector")) {
            $class = get_class($this->connection);
            throw new InvalidArgumentException("Selecting connection by $selector is not supported by $class");
        }

        if (!$connection = $this->connection->$method($value)) {
            throw new InvalidArgumentException("Cannot find a connection by $selector matching `$value`");
        }

        return new static($connection, $this->getOptions());
    }

    /**
     * Opens the underlying connection and connects to the server.
     */
    public function connect()
    {
        $this->connection->connect();
    }

    /**
     * Closes the underlying connection and disconnects from the server.
     */
    public function disconnect()
    {
        $this->connection->disconnect();
    }

    /**
     * Closes the underlying connection and disconnects from the server.
     *
     * This is the same as `Client::disconnect()` as it does not actually send
     * the `QUIT` command to Redis, but simply closes the connection.
     */
    public function quit()
    {
        $this->disconnect();
    }

    /**
     * Returns the current state of the underlying connection.
     *
     * @return bool
     */
    public function isConnected()
    {
        return $this->connection->isConnected();
    }

    /**
     * {@inheritdoc}
     */
    public function getConnection()
    {
        return $this->connection;
    }

    /**
     * Applies the configured serializer and compression to given value.
     *
     * @param  mixed  $value
     * @return string
     */
    public function pack($value)
    {
        return $this->connection instanceof RelayConnection
            ? $this->connection->pack($value)
            : $value;
    }

    /**
     * Deserializes and decompresses to given value.
     *
     * @param  mixed  $value
     * @return string
     */
    public function unpack($value)
    {
        return $this->connection instanceof RelayConnection
            ? $this->connection->unpack($value)
            : $value;
    }

    /**
     * Executes a command without filtering its arguments, parsing the response,
     * applying any prefix to keys or throwing exceptions on Redis errors even
     * regardless of client options.
     *
     * It is possible to identify Redis error responses from normal responses
     * using the second optional argument which is populated by reference.
     *
     * @param array $arguments Command arguments as defined by the command signature.
     * @param bool  $error     Set to TRUE when Redis returned an error response.
     *
     * @return mixed
     */
    public function executeRaw(array $arguments, &$error = null)
    {
        $error = false;
        $commandID = array_shift($arguments);

        $response = $this->connection->executeCommand(
            new RawCommand($commandID, $arguments)
        );

        if ($response instanceof ResponseInterface) {
            if ($response instanceof ErrorResponseInterface) {
                $error = true;
            }

            return (string) $response;
        }

        return $response;
    }

    /**
     * {@inheritdoc}
     */
    public function __call($commandID, $arguments)
    {
        return $this->executeCommand(
            $this->createCommand($commandID, $arguments)
        );
    }

    /**
     * {@inheritdoc}
     */
    public function createCommand($commandID, $arguments = [])
    {
        return $this->commands->create($commandID, $arguments);
    }

    /**
     * @param  string             $name
     * @return ContainerInterface
     */
    public function __get(string $name)
    {
        return ContainerFactory::create($this, $name);
    }

    /**
     * @param  string $name
     * @param  mixed  $value
     * @return mixed
     */
    public function __set(string $name, $value)
    {
        throw new RuntimeException('Not allowed');
    }

    /**
     * @param  string $name
     * @return mixed
     */
    public function __isset(string $name)
    {
        throw new RuntimeException('Not allowed');
    }

    /**
     * {@inheritdoc}
     */
    public function executeCommand(CommandInterface $command)
    {
        $response = $this->connection->executeCommand($command);

        if ($response instanceof ResponseInterface) {
            if ($response instanceof ErrorResponseInterface) {
                $response = $this->onErrorResponse($command, $response);
            }

            return $response;
        }

        return $command->parseResponse($response);
    }

    /**
     * Handles -ERR responses returned by Redis.
     *
     * @param CommandInterface       $command  Redis command that generated the error.
     * @param ErrorResponseInterface $response Instance of the error response.
     *
     * @return mixed
     * @throws ServerException
     */
    protected function onErrorResponse(CommandInterface $command, ErrorResponseInterface $response)
    {
        if ($command instanceof ScriptCommand && $response->getErrorType() === 'NOSCRIPT') {
            $response = $this->executeCommand($command->getEvalCommand());

            if (!$response instanceof ResponseInterface) {
                $response = $command->parseResponse($response);
            }

            return $response;
        }

        if ($this->options->exceptions) {
            throw new ServerException($response->getMessage());
        }

        return $response;
    }

    /**
     * Executes the specified initializer method on `$this` by adjusting the
     * actual invocation depending on the arity (0, 1 or 2 arguments). This is
     * simply an utility method to create Redis contexts instances since they
     * follow a common initialization path.
     *
     * @param string $initializer Method name.
     * @param array  $argv        Arguments for the method.
     *
     * @return mixed
     */
    private function sharedContextFactory($initializer, $argv = null)
    {
        switch (count($argv)) {
            case 0:
                return $this->$initializer();

            case 1:
                return is_array($argv[0])
                    ? $this->$initializer($argv[0])
                    : $this->$initializer(null, $argv[0]);

            case 2:
                [$arg0, $arg1] = $argv;

                return $this->$initializer($arg0, $arg1);

            default:
                return $this->$initializer($this, $argv);
        }
    }

    /**
     * Creates a new pipeline context and returns it, or returns the results of
     * a pipeline executed inside the optionally provided callable object.
     *
     * @param mixed ...$arguments Array of options, a callable for execution, or both.
     *
     * @return Pipeline|array
     */
    public function pipeline(...$arguments)
    {
        return $this->sharedContextFactory('createPipeline', func_get_args());
    }

    /**
     * Actual pipeline context initializer method.
     *
     * @param array|null $options  Options for the context.
     * @param mixed      $callable Optional callable used to execute the context.
     *
     * @return Pipeline|array
     */
    protected function createPipeline(?array $options = null, $callable = null)
    {
        if (isset($options['atomic']) && $options['atomic']) {
            $class = Atomic::class;
        } elseif (isset($options['fire-and-forget']) && $options['fire-and-forget']) {
            $class = FireAndForget::class;
        } else {
            $class = Pipeline::class;
        }

        if ($this->connection instanceof RelayConnection) {
            if (isset($options['atomic']) && $options['atomic']) {
                $class = RelayAtomic::class;
            } elseif (isset($options['fire-and-forget']) && $options['fire-and-forget']) {
                throw new NotSupportedException('The "relay" extension does not support fire-and-forget pipelines.');
            } else {
                $class = RelayPipeline::class;
            }
        }

        /*
         * @var ClientContextInterface
         */
        $pipeline = new $class($this);

        if (isset($callable)) {
            return $pipeline->execute($callable);
        }

        return $pipeline;
    }

    /**
     * Creates a new transaction context and returns it, or returns the results
     * of a transaction executed inside the optionally provided callable object.
     *
     * @param mixed ...$arguments Array of options, a callable for execution, or both.
     *
     * @return MultiExecTransaction|array
     */
    public function transaction(...$arguments)
    {
        return $this->sharedContextFactory('createTransaction', func_get_args());
    }

    /**
     * Actual transaction context initializer method.
     *
     * @param array|null $options  Options for the context.
     * @param mixed      $callable Optional callable used to execute the context.
     *
     * @return MultiExecTransaction|array
     */
    protected function createTransaction(?array $options = null, $callable = null)
    {
        $transaction = new MultiExecTransaction($this, $options);

        if (isset($callable)) {
            return $transaction->execute($callable);
        }

        return $transaction;
    }

    /**
     * Creates a new publish/subscribe context and returns it, or starts its loop
     * inside the optionally provided callable object.
     *
     * @param mixed ...$arguments Array of options, a callable for execution, or both.
     *
     * @return PubSubConsumer|null
     */
    public function pubSubLoop(...$arguments)
    {
        return $this->sharedContextFactory('createPubSub', func_get_args());
    }

    /**
     * Actual publish/subscribe context initializer method.
     *
     * @param array|null $options  Options for the context.
     * @param mixed      $callable Optional callable used to execute the context.
     *
     * @return PubSubConsumer|null
     */
    protected function createPubSub(?array $options = null, $callable = null)
    {
        if ($this->connection instanceof RelayConnection) {
            $pubsub = new RelayPubSubConsumer($this, $options);
        } else {
            $pubsub = new PubSubConsumer($this, $options);
        }

        if (!isset($callable)) {
            return $pubsub;
        }

        foreach ($pubsub as $message) {
            if (call_user_func($callable, $pubsub, $message) === false) {
                $pubsub->stop();
            }
        }

        return null;
    }

    /**
     * Creates a new monitor consumer and returns it.
     *
     * @return MonitorConsumer
     */
    public function monitor()
    {
        return new MonitorConsumer($this);
    }

    /**
     * @return Traversable<string, static>
     */
    #[ReturnTypeWillChange]
    public function getIterator()
    {
        $clients = [];
        $connection = $this->getConnection();

        if (!$connection instanceof Traversable) {
            return new ArrayIterator([
                (string) $connection => new static($connection, $this->getOptions()),
            ]);
        }

        foreach ($connection as $node) {
            $clients[(string) $node] = new static($node, $this->getOptions());
        }

        return new ArrayIterator($clients);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\ClientConfiguration.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

class ClientConfiguration
{
    /**
     * @var array{modules: array}|string[][]
     */
    private static $config = [
        'modules' => [
            ['name' => 'Json', 'commandPrefix' => 'JSON'],
            ['name' => 'BloomFilter', 'commandPrefix' => 'BF'],
            ['name' => 'CuckooFilter', 'commandPrefix' => 'CF'],
            ['name' => 'CountMinSketch', 'commandPrefix' => 'CMS'],
            ['name' => 'TDigest', 'commandPrefix' => 'TDIGEST'],
            ['name' => 'TopK', 'commandPrefix' => 'TOPK'],
            ['name' => 'Search', 'commandPrefix' => 'FT'],
            ['name' => 'TimeSeries', 'commandPrefix' => 'TS'],
        ],
    ];

    /**
     * Returns available modules with configuration.
     *
     * @return array|string[][]
     */
    public static function getModules(): array
    {
        return self::$config['modules'];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\ClientContextInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

use Predis\Command\Argument\Geospatial\ByInterface;
use Predis\Command\Argument\Geospatial\FromInterface;
use Predis\Command\Argument\Search\AggregateArguments;
use Predis\Command\Argument\Search\AlterArguments;
use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\DropArguments;
use Predis\Command\Argument\Search\ExplainArguments;
use Predis\Command\Argument\Search\ProfileArguments;
use Predis\Command\Argument\Search\SchemaFields\FieldInterface;
use Predis\Command\Argument\Search\SearchArguments;
use Predis\Command\Argument\Search\SugAddArguments;
use Predis\Command\Argument\Search\SugGetArguments;
use Predis\Command\Argument\Search\SynUpdateArguments;
use Predis\Command\Argument\Server\LimitOffsetCount;
use Predis\Command\Argument\Server\To;
use Predis\Command\Argument\TimeSeries\AddArguments;
use Predis\Command\Argument\TimeSeries\AlterArguments as TSAlterArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments as TSCreateArguments;
use Predis\Command\Argument\TimeSeries\DecrByArguments;
use Predis\Command\Argument\TimeSeries\GetArguments;
use Predis\Command\Argument\TimeSeries\IncrByArguments;
use Predis\Command\Argument\TimeSeries\InfoArguments;
use Predis\Command\Argument\TimeSeries\MGetArguments;
use Predis\Command\Argument\TimeSeries\MRangeArguments;
use Predis\Command\Argument\TimeSeries\RangeArguments;
use Predis\Command\CommandInterface;
use Predis\Command\Redis\Container\ACL;
use Predis\Command\Redis\Container\CLUSTER;
use Predis\Command\Redis\Container\FunctionContainer;
use Predis\Command\Redis\Container\Json\JSONDEBUG;
use Predis\Command\Redis\Container\Search\FTCONFIG;
use Predis\Command\Redis\Container\Search\FTCURSOR;

/**
 * Interface defining a client-side context such as a pipeline or transaction.
 *
 * @method $this copy(string $source, string $destination, int $db = -1, bool $replace = false)
 * @method $this del(array|string $keys)
 * @method $this dump($key)
 * @method $this exists($key)
 * @method $this expire($key, $seconds, string $expireOption = '')
 * @method $this expireat($key, $timestamp, string $expireOption = '')
 * @method $this expiretime(string $key)
 * @method $this keys($pattern)
 * @method $this move($key, $db)
 * @method $this object($subcommand, $key)
 * @method $this persist($key)
 * @method $this pexpire($key, $milliseconds)
 * @method $this pexpireat($key, $timestamp)
 * @method $this pttl($key)
 * @method $this randomkey()
 * @method $this rename($key, $target)
 * @method $this renamenx($key, $target)
 * @method $this scan($cursor, ?array $options = null)
 * @method $this sort($key, ?array $options = null)
 * @method $this sort_ro(string $key, ?string $byPattern = null, ?LimitOffsetCount $limit = null, array $getPatterns = [], ?string $sorting = null, bool $alpha = false)
 * @method $this ttl($key)
 * @method $this type($key)
 * @method $this append($key, $value)
 * @method $this bfadd(string $key, $item)
 * @method $this bfexists(string $key, $item)
 * @method $this bfinfo(string $key, string $modifier = '')
 * @method $this bfinsert(string $key, int $capacity = -1, float $error = -1, int $expansion = -1, bool $noCreate = false, bool $nonScaling = false, string ...$item)
 * @method $this bfloadchunk(string $key, int $iterator, $data)
 * @method $this bfmadd(string $key, ...$item)
 * @method $this bfmexists(string $key, ...$item)
 * @method $this bfreserve(string $key, float $errorRate, int $capacity, int $expansion = -1, bool $nonScaling = false)
 * @method $this bfscandump(string $key, int $iterator)
 * @method $this bitcount(string $key, $start = null, $end = null, string $index = 'byte')
 * @method $this bitop($operation, $destkey, $key)
 * @method $this bitfield($key, $subcommand, ...$subcommandArg)
 * @method $this bitpos($key, $bit, $start = null, $end = null, string $index = 'byte')
 * @method $this blmpop(int $timeout, array $keys, string $modifier = 'left', int $count = 1)
 * @method $this bzpopmax(array $keys, int $timeout)
 * @method $this bzpopmin(array $keys, int $timeout)
 * @method $this bzmpop(int $timeout, array $keys, string $modifier = 'min', int $count = 1)
 * @method $this cfadd(string $key, $item)
 * @method $this cfaddnx(string $key, $item)
 * @method $this cfcount(string $key, $item)
 * @method $this cfdel(string $key, $item)
 * @method $this cfexists(string $key, $item)
 * @method $this cfloadchunk(string $key, int $iterator, $data)
 * @method $this cfmexists(string $key, ...$item)
 * @method $this cfinfo(string $key)
 * @method $this cfinsert(string $key, int $capacity = -1, bool $noCreate = false, string ...$item)
 * @method $this cfinsertnx(string $key, int $capacity = -1, bool $noCreate = false, string ...$item)
 * @method $this cfreserve(string $key, int $capacity, int $bucketSize = -1, int $maxIterations = -1, int $expansion = -1)
 * @method $this cfscandump(string $key, int $iterator)
 * @method $this cmsincrby(string $key, string|int...$itemIncrementDictionary)
 * @method $this cmsinfo(string $key)
 * @method $this cmsinitbydim(string $key, int $width, int $depth)
 * @method $this cmsinitbyprob(string $key, float $errorRate, float $probability)
 * @method $this cmsmerge(string $destination, array $sources, array $weights = [])
 * @method $this cmsquery(string $key, string ...$item)
 * @method $this decr($key)
 * @method $this decrby($key, $decrement)
 * @method $this failover(?To $to = null, bool $abort = false, int $timeout = -1)
 * @method $this fcall(string $function, array $keys, ...$args)
 * @method $this fcall_ro(string $function, array $keys, ...$args)
 * @method $this ftaggregate(string $index, string $query, ?AggregateArguments $arguments = null)
 * @method $this ftaliasadd(string $alias, string $index)
 * @method $this ftaliasdel(string $alias)
 * @method $this ftaliasupdate(string $alias, string $index)
 * @method $this ftalter(string $index, FieldInterface[] $schema, ?AlterArguments $arguments = null)
 * @method $this ftcreate(string $index, FieldInterface[] $schema, ?CreateArguments $arguments = null)
 * @method $this ftdictadd(string $dict, ...$term)
 * @method $this ftdictdel(string $dict, ...$term)
 * @method $this ftdictdump(string $dict)
 * @method $this ftdropindex(string $index, ?DropArguments $arguments = null)
 * @method $this ftexplain(string $index, string $query, ?ExplainArguments $arguments = null)
 * @method $this ftinfo(string $index)
 * @method $this ftprofile(string $index, ProfileArguments $arguments)
 * @method $this ftsearch(string $index, string $query, ?SearchArguments $arguments = null)
 * @method $this ftspellcheck(string $index, string $query, ?SearchArguments $arguments = null)
 * @method $this ftsugadd(string $key, string $string, float $score, ?SugAddArguments $arguments = null)
 * @method $this ftsugdel(string $key, string $string)
 * @method $this ftsugget(string $key, string $prefix, ?SugGetArguments $arguments = null)
 * @method $this ftsuglen(string $key)
 * @method $this ftsyndump(string $index)
 * @method $this ftsynupdate(string $index, string $synonymGroupId, ?SynUpdateArguments $arguments = null, string ...$terms)
 * @method $this fttagvals(string $index, string $fieldName)
 * @method $this get($key)
 * @method $this getbit($key, $offset)
 * @method $this getex(string $key, $modifier = '', $value = false)
 * @method $this getrange($key, $start, $end)
 * @method $this getdel(string $key)
 * @method $this getset($key, $value)
 * @method $this incr($key)
 * @method $this incrby($key, $increment)
 * @method $this incrbyfloat($key, $increment)
 * @method $this mget(array $keys)
 * @method $this mset(array $dictionary)
 * @method $this msetnx(array $dictionary)
 * @method $this psetex($key, $milliseconds, $value)
 * @method $this set($key, $value, $expireResolution = null, $expireTTL = null, $flag = null)
 * @method $this setbit($key, $offset, $value)
 * @method $this setex($key, $seconds, $value)
 * @method $this setnx($key, $value)
 * @method $this setrange($key, $offset, $value)
 * @method $this strlen($key)
 * @method $this hdel($key, array $fields)
 * @method $this hexists($key, $field)
 * @method $this hexpire(string $key, int $seconds, array $fields, string $flag = null)
 * @method $this hexpireat(string $key, int $unixTimeSeconds, array $fields, string $flag = null)
 * @method $this hexpiretime(string $key, array $fields)
 * @method $this hpersist(string $key, array $fields)
 * @method $this hpexpire(string $key, int $milliseconds, array $fields, string $flag = null)
 * @method $this hpexpireat(string $key, int $unixTimeMilliseconds, array $fields, string $flag = null)
 * @method $this hpexpiretime(string $key, array $fields)
 * @method $this hget($key, $field)
 * @method $this hgetall($key)
 * @method $this hincrby($key, $field, $increment)
 * @method $this hincrbyfloat($key, $field, $increment)
 * @method $this hkeys($key)
 * @method $this hlen($key)
 * @method $this hmget($key, array $fields)
 * @method $this hmset($key, array $dictionary)
 * @method $this hrandfield(string $key, int $count = 1, bool $withValues = false)
 * @method $this hscan($key, $cursor, ?array $options = null)
 * @method $this hset($key, $field, $value)
 * @method $this hsetnx($key, $field, $value)
 * @method $this httl(string $key, array $fields)
 * @method $this hpttl(string $key, array $fields)
 * @method $this hvals($key)
 * @method $this hstrlen($key, $field)
 * @method $this jsonarrappend(string $key, string $path = '$', ...$value)
 * @method $this jsonarrindex(string $key, string $path, string $value, int $start = 0, int $stop = 0)
 * @method $this jsonarrinsert(string $key, string $path, int $index, string ...$value)
 * @method $this jsonarrlen(string $key, string $path = '$')
 * @method $this jsonarrpop(string $key, string $path = '$', int $index = -1)
 * @method $this jsonarrtrim(string $key, string $path, int $start, int $stop)
 * @method $this jsonclear(string $key, string $path = '$')
 * @method $this jsondel(string $key, string $path = '$')
 * @method $this jsonforget(string $key, string $path = '$')
 * @method $this jsonget(string $key, string $indent = '', string $newline = '', string $space = '', string ...$paths)
 * @method $this jsonnumincrby(string $key, string $path, int $value)
 * @method $this jsonmerge(string $key, string $path, string $value)
 * @method $this jsonmget(array $keys, string $path)
 * @method $this jsonmset(string ...$keyPathValue)
 * @method $this jsonobjkeys(string $key, string $path = '$')
 * @method $this jsonobjlen(string $key, string $path = '$')
 * @method $this jsonresp(string $key, string $path = '$')
 * @method $this jsonset(string $key, string $path, string $value, ?string $subcommand = null)
 * @method $this jsonstrappend(string $key, string $path, string $value)
 * @method $this jsonstrlen(string $key, string $path = '$')
 * @method $this jsontoggle(string $key, string $path)
 * @method $this jsontype(string $key, string $path = '$')
 * @method $this blmove(string $source, string $destination, string $where, string $to, int $timeout)
 * @method $this blpop(array|string $keys, $timeout)
 * @method $this brpop(array|string $keys, $timeout)
 * @method $this brpoplpush($source, $destination, $timeout)
 * @method $this lcs(string $key1, string $key2, bool $len = false, bool $idx = false, int $minMatchLen = 0, bool $withMatchLen = false)
 * @method $this lindex($key, $index)
 * @method $this linsert($key, $whence, $pivot, $value)
 * @method $this llen($key)
 * @method $this lmove(string $source, string $destination, string $where, string $to)
 * @method $this lmpop(array $keys, string $modifier = 'left', int $count = 1)
 * @method $this lpop($key)
 * @method $this lpush($key, array $values)
 * @method $this lpushx($key, array $values)
 * @method $this lrange($key, $start, $stop)
 * @method $this lrem($key, $count, $value)
 * @method $this lset($key, $index, $value)
 * @method $this ltrim($key, $start, $stop)
 * @method $this rpop($key)
 * @method $this rpoplpush($source, $destination)
 * @method $this rpush($key, array $values)
 * @method $this rpushx($key, array $values)
 * @method $this sadd($key, array $members)
 * @method $this scard($key)
 * @method $this sdiff(array|string $keys)
 * @method $this sdiffstore($destination, array|string $keys)
 * @method $this sinter(array|string $keys)
 * @method $this sintercard(array $keys, int $limit = 0)
 * @method $this sinterstore($destination, array|string $keys)
 * @method $this sismember($key, $member)
 * @method $this smembers($key)
 * @method $this smismember(string $key, string ...$members)
 * @method $this smove($source, $destination, $member)
 * @method $this spop($key, $count = null)
 * @method $this srandmember($key, $count = null)
 * @method $this srem($key, $member)
 * @method $this sscan($key, $cursor, ?array $options = null)
 * @method $this sunion(array|string $keys)
 * @method $this sunionstore($destination, array|string $keys)
 * @method $this tdigestadd(string $key, float ...$value)
 * @method $this tdigestbyrank(string $key, int ...$rank)
 * @method $this tdigestbyrevrank(string $key, int ...$reverseRank)
 * @method $this tdigestcdf(string $key, int ...$value)
 * @method $this tdigestcreate(string $key, int $compression = 0)
 * @method $this tdigestinfo(string $key)
 * @method $this tdigestmax(string $key)
 * @method $this tdigestmerge(string $destinationKey, array $sourceKeys, int $compression = 0, bool $override = false)
 * @method $this tdigestquantile(string $key, float ...$quantile)
 * @method $this tdigestmin(string $key)
 * @method $this tdigestrank(string $key, ...$value)
 * @method $this tdigestreset(string $key)
 * @method $this tdigestrevrank(string $key, float ...$value)
 * @method $this tdigesttrimmed_mean(string $key, float $lowCutQuantile, float $highCutQuantile)
 * @method $this topkadd(string $key, ...$items)
 * @method $this topkincrby(string $key, ...$itemIncrement)
 * @method $this topkinfo(string $key)
 * @method $this topklist(string $key, bool $withCount = false)
 * @method $this topkquery(string $key, ...$items)
 * @method $this topkreserve(string $key, int $topK, int $width = 8, int $depth = 7, float $decay = 0.9)
 * @method $this tsadd(string $key, int $timestamp, float $value, ?AddArguments $arguments = null)
 * @method $this tsalter(string $key, ?TSAlterArguments $arguments = null)
 * @method $this tscreate(string $key, ?TSCreateArguments $arguments = null)
 * @method $this tscreaterule(string $sourceKey, string $destKey, string $aggregator, int $bucketDuration, int $alignTimestamp = 0)
 * @method $this tsdecrby(string $key, float $value, ?DecrByArguments $arguments = null)
 * @method $this tsdel(string $key, int $fromTimestamp, int $toTimestamp)
 * @method $this tsdeleterule(string $sourceKey, string $destKey)
 * @method $this tsget(string $key, ?GetArguments $arguments = null)
 * @method $this tsincrby(string $key, float $value, ?IncrByArguments $arguments = null)
 * @method $this tsinfo(string $key, ?InfoArguments $arguments = null)
 * @method $this tsmadd(mixed ...$keyTimestampValue)
 * @method $this tsmget(MGetArguments $arguments, string ...$filterExpression)
 * @method $this tsmrange($fromTimestamp, $toTimestamp, MRangeArguments $arguments)
 * @method $this tsmrevrange($fromTimestamp, $toTimestamp, MRangeArguments $arguments)
 * @method $this tsqueryindex(string ...$filterExpression)
 * @method $this tsrange(string $key, $fromTimestamp, $toTimestamp, ?RangeArguments $arguments = null)
 * @method $this tsrevrange(string $key, $fromTimestamp, $toTimestamp, ?RangeArguments $arguments = null)
 * @method $this zadd($key, array $membersAndScoresDictionary)
 * @method $this zcard($key)
 * @method $this zcount($key, $min, $max)
 * @method $this zdiff(array $keys, bool $withScores = false)
 * @method $this zdiffstore(string $destination, array $keys)
 * @method $this zincrby($key, $increment, $member)
 * @method $this zintercard(array $keys, int $limit = 0)
 * @method $this zinterstore(string $destination, array $keys, int[] $weights = [], string $aggregate = 'sum')
 * @method $this zinter(array $keys, int[] $weights = [], string $aggregate = 'sum', bool $withScores = false)
 * @method $this zmpop(array $keys, string $modifier = 'min', int $count = 1)
 * @method $this zmscore(string $key, string ...$member)
 * @method $this zrandmember(string $key, int $count = 1, bool $withScores = false)
 * @method $this zrange($key, $start, $stop, ?array $options = null)
 * @method $this zrangebyscore($key, $min, $max, ?array $options = null)
 * @method $this zrangestore(string $destination, string $source, int|string $min, string|int $max, string|bool $by = false, bool $reversed = false, bool $limit = false, int $offset = 0, int $count = 0)
 * @method $this zrank($key, $member)
 * @method $this zrem($key, $member)
 * @method $this zremrangebyrank($key, $start, $stop)
 * @method $this zremrangebyscore($key, $min, $max)
 * @method $this zrevrange($key, $start, $stop, ?array $options = null)
 * @method $this zrevrangebyscore($key, $max, $min, ?array $options = null)
 * @method $this zrevrank($key, $member)
 * @method $this zunion(array $keys, int[] $weights = [], string $aggregate = 'sum', bool $withScores = false)
 * @method $this zunionstore(string $destination, array $keys, int[] $weights = [], string $aggregate = 'sum')
 * @method $this zscore($key, $member)
 * @method $this zscan($key, $cursor, ?array $options = null)
 * @method $this zrangebylex($key, $start, $stop, ?array $options = null)
 * @method $this zrevrangebylex($key, $start, $stop, ?array $options = null)
 * @method $this zremrangebylex($key, $min, $max)
 * @method $this zlexcount($key, $min, $max)
 * @method $this pexpiretime(string $key)
 * @method $this pfadd($key, array $elements)
 * @method $this pfmerge($destinationKey, array|string $sourceKeys)
 * @method $this pfcount(array|string $keys)
 * @method $this pubsub($subcommand, $argument)
 * @method $this publish($channel, $message)
 * @method $this discard()
 * @method $this exec()
 * @method $this multi()
 * @method $this unwatch()
 * @method $this waitaof(int $numLocal, int $numReplicas, int $timeout)
 * @method $this watch($key)
 * @method $this eval($script, $numkeys, $keyOrArg1 = null, $keyOrArgN = null)
 * @method $this eval_ro(string $script, array $keys, ...$argument)
 * @method $this evalsha($script, $numkeys, $keyOrArg1 = null, $keyOrArgN = null)
 * @method $this evalsha_ro(string $sha1, array $keys, ...$argument)
 * @method $this script($subcommand, $argument = null)
 * @method $this shutdown(?bool $noSave = null, bool $now = false, bool $force = false, bool $abort = false)
 * @method $this auth($password)
 * @method $this echo($message)
 * @method $this ping($message = null)
 * @method $this select($database)
 * @method $this bgrewriteaof()
 * @method $this bgsave()
 * @method $this client($subcommand, $argument = null)
 * @method $this config($subcommand, $argument = null)
 * @method $this dbsize()
 * @method $this flushall()
 * @method $this flushdb()
 * @method $this info($section = null)
 * @method $this lastsave()
 * @method $this save()
 * @method $this slaveof($host, $port)
 * @method $this slowlog($subcommand, $argument = null)
 * @method $this time()
 * @method $this command()
 * @method $this geoadd($key, $longitude, $latitude, $member)
 * @method $this geohash($key, array $members)
 * @method $this geopos($key, array $members)
 * @method $this geodist($key, $member1, $member2, $unit = null)
 * @method $this georadius($key, $longitude, $latitude, $radius, $unit, ?array $options = null)
 * @method $this georadiusbymember($key, $member, $radius, $unit, ?array $options = null)
 * @method $this geosearch(string $key, FromInterface $from, ByInterface $by, ?string $sorting = null, int $count = -1, bool $any = false, bool $withCoord = false, bool $withDist = false, bool $withHash = false)
 * @method $this geosearchstore(string $destination, string $source, FromInterface $from, ByInterface $by, ?string $sorting = null, int $count = -1, bool $any = false, bool $storeDist = false)
 *
 * Container commands
 * @property CLUSTER           $cluster
 * @property FunctionContainer $function
 * @property FTCONFIG          $ftconfig
 * @property FTCURSOR          $ftcursor
 * @property JSONDEBUG         $jsondebug
 * @property ACL               $acl
 */
interface ClientContextInterface
{
    /**
     * Sends the specified command instance to Redis.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return mixed
     */
    public function executeCommand(CommandInterface $command);

    /**
     * Sends the specified command with its arguments to Redis.
     *
     * @param string $method    Command ID.
     * @param array  $arguments Arguments for the command.
     *
     * @return mixed
     */
    public function __call($method, $arguments);

    /**
     * Starts the execution of the context.
     *
     * @param mixed $callable Optional callback for execution.
     *
     * @return array
     */
    public function execute($callable = null);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\ClientException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

/**
 * Exception class that identifies client-side errors.
 */
class ClientException extends PredisException
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\ClientInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

use Predis\Command\Argument\Geospatial\ByInterface;
use Predis\Command\Argument\Geospatial\FromInterface;
use Predis\Command\Argument\Search\AggregateArguments;
use Predis\Command\Argument\Search\AlterArguments;
use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\DropArguments;
use Predis\Command\Argument\Search\ExplainArguments;
use Predis\Command\Argument\Search\ProfileArguments;
use Predis\Command\Argument\Search\SchemaFields\FieldInterface;
use Predis\Command\Argument\Search\SearchArguments;
use Predis\Command\Argument\Search\SugAddArguments;
use Predis\Command\Argument\Search\SugGetArguments;
use Predis\Command\Argument\Search\SynUpdateArguments;
use Predis\Command\Argument\Server\LimitOffsetCount;
use Predis\Command\Argument\Server\To;
use Predis\Command\Argument\TimeSeries\AddArguments;
use Predis\Command\Argument\TimeSeries\AlterArguments as TSAlterArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments as TSCreateArguments;
use Predis\Command\Argument\TimeSeries\DecrByArguments;
use Predis\Command\Argument\TimeSeries\GetArguments;
use Predis\Command\Argument\TimeSeries\IncrByArguments;
use Predis\Command\Argument\TimeSeries\InfoArguments;
use Predis\Command\Argument\TimeSeries\MGetArguments;
use Predis\Command\Argument\TimeSeries\MRangeArguments;
use Predis\Command\Argument\TimeSeries\RangeArguments;
use Predis\Command\CommandInterface;
use Predis\Command\FactoryInterface;
use Predis\Command\Redis\Container\ACL;
use Predis\Command\Redis\Container\CLUSTER;
use Predis\Command\Redis\Container\FunctionContainer;
use Predis\Command\Redis\Container\Json\JSONDEBUG;
use Predis\Command\Redis\Container\Search\FTCONFIG;
use Predis\Command\Redis\Container\Search\FTCURSOR;
use Predis\Configuration\OptionsInterface;
use Predis\Connection\ConnectionInterface;
use Predis\Response\Status;

/**
 * Interface defining a client able to execute commands against Redis.
 *
 * All the commands exposed by the client generally have the same signature as
 * described by the Redis documentation, but some of them offer an additional
 * and more friendly interface to ease programming which is described in the
 * following list of methods:
 *
 * @method int               copy(string $source, string $destination, int $db = -1, bool $replace = false)
 * @method int               del(string[]|string $keyOrKeys, string ...$keys = null)
 * @method string|null       dump(string $key)
 * @method int               exists(string $key)
 * @method int               expire(string $key, int $seconds, string $expireOption = '')
 * @method int               expireat(string $key, int $timestamp, string $expireOption = '')
 * @method int               expiretime(string $key)
 * @method array             keys(string $pattern)
 * @method int               move(string $key, int $db)
 * @method mixed             object($subcommand, string $key)
 * @method int               persist(string $key)
 * @method int               pexpire(string $key, int $milliseconds)
 * @method int               pexpireat(string $key, int $timestamp)
 * @method int               pttl(string $key)
 * @method string|null       randomkey()
 * @method mixed             rename(string $key, string $target)
 * @method int               renamenx(string $key, string $target)
 * @method array             scan($cursor, ?array $options = null)
 * @method array             sort(string $key, ?array $options = null)
 * @method array             sort_ro(string $key, ?string $byPattern = null, ?LimitOffsetCount $limit = null, array $getPatterns = [], ?string $sorting = null, bool $alpha = false)
 * @method int               ttl(string $key)
 * @method mixed             type(string $key)
 * @method int               append(string $key, $value)
 * @method int               bfadd(string $key, $item)
 * @method int               bfexists(string $key, $item)
 * @method array             bfinfo(string $key, string $modifier = '')
 * @method array             bfinsert(string $key, int $capacity = -1, float $error = -1, int $expansion = -1, bool $noCreate = false, bool $nonScaling = false, string ...$item)
 * @method Status            bfloadchunk(string $key, int $iterator, $data)
 * @method array             bfmadd(string $key, ...$item)
 * @method array             bfmexists(string $key, ...$item)
 * @method Status            bfreserve(string $key, float $errorRate, int $capacity, int $expansion = -1, bool $nonScaling = false)
 * @method array             bfscandump(string $key, int $iterator)
 * @method int               bitcount(string $key, $start = null, $end = null, string $index = 'byte')
 * @method int               bitop($operation, $destkey, $key)
 * @method array|null        bitfield(string $key, $subcommand, ...$subcommandArg)
 * @method int               bitpos(string $key, $bit, $start = null, $end = null, string $index = 'byte')
 * @method array             blmpop(int $timeout, array $keys, string $modifier = 'left', int $count = 1)
 * @method array             bzpopmax(array $keys, int $timeout)
 * @method array             bzpopmin(array $keys, int $timeout)
 * @method array             bzmpop(int $timeout, array $keys, string $modifier = 'min', int $count = 1)
 * @method int               cfadd(string $key, $item)
 * @method int               cfaddnx(string $key, $item)
 * @method int               cfcount(string $key, $item)
 * @method int               cfdel(string $key, $item)
 * @method int               cfexists(string $key, $item)
 * @method Status            cfloadchunk(string $key, int $iterator, $data)
 * @method int               cfmexists(string $key, ...$item)
 * @method array             cfinfo(string $key)
 * @method array             cfinsert(string $key, int $capacity = -1, bool $noCreate = false, string ...$item)
 * @method array             cfinsertnx(string $key, int $capacity = -1, bool $noCreate = false, string ...$item)
 * @method Status            cfreserve(string $key, int $capacity, int $bucketSize = -1, int $maxIterations = -1, int $expansion = -1)
 * @method array             cfscandump(string $key, int $iterator)
 * @method array             cmsincrby(string $key, string|int ...$itemIncrementDictionary)
 * @method array             cmsinfo(string $key)
 * @method Status            cmsinitbydim(string $key, int $width, int $depth)
 * @method Status            cmsinitbyprob(string $key, float $errorRate, float $probability)
 * @method Status            cmsmerge(string $destination, array $sources, array $weights = [])
 * @method array             cmsquery(string $key, string ...$item)
 * @method int               decr(string $key)
 * @method int               decrby(string $key, int $decrement)
 * @method Status            failover(?To $to = null, bool $abort = false, int $timeout = -1)
 * @method mixed             fcall(string $function, array $keys, ...$args)
 * @method mixed             fcall_ro(string $function, array $keys, ...$args)
 * @method array             ftaggregate(string $index, string $query, ?AggregateArguments $arguments = null)
 * @method Status            ftaliasadd(string $alias, string $index)
 * @method Status            ftaliasdel(string $alias)
 * @method Status            ftaliasupdate(string $alias, string $index)
 * @method Status            ftalter(string $index, FieldInterface[] $schema, ?AlterArguments $arguments = null)
 * @method Status            ftcreate(string $index, FieldInterface[] $schema, ?CreateArguments $arguments = null)
 * @method int               ftdictadd(string $dict, ...$term)
 * @method int               ftdictdel(string $dict, ...$term)
 * @method array             ftdictdump(string $dict)
 * @method Status            ftdropindex(string $index, ?DropArguments $arguments = null)
 * @method string            ftexplain(string $index, string $query, ?ExplainArguments $arguments = null)
 * @method array             ftinfo(string $index)
 * @method array             ftprofile(string $index, ProfileArguments $arguments)
 * @method array             ftsearch(string $index, string $query, ?SearchArguments $arguments = null)
 * @method array             ftspellcheck(string $index, string $query, ?SearchArguments $arguments = null)
 * @method int               ftsugadd(string $key, string $string, float $score, ?SugAddArguments $arguments = null)
 * @method int               ftsugdel(string $key, string $string)
 * @method array             ftsugget(string $key, string $prefix, ?SugGetArguments $arguments = null)
 * @method int               ftsuglen(string $key)
 * @method array             ftsyndump(string $index)
 * @method Status            ftsynupdate(string $index, string $synonymGroupId, ?SynUpdateArguments $arguments = null, string ...$terms)
 * @method array             fttagvals(string $index, string $fieldName)
 * @method string|null       get(string $key)
 * @method int               getbit(string $key, $offset)
 * @method int|null          getex(string $key, $modifier = '', $value = false)
 * @method string            getrange(string $key, $start, $end)
 * @method string            getdel(string $key)
 * @method string|null       getset(string $key, $value)
 * @method int               incr(string $key)
 * @method int               incrby(string $key, int $increment)
 * @method string            incrbyfloat(string $key, int|float $increment)
 * @method array             mget(string[]|string $keyOrKeys, string ...$keys = null)
 * @method mixed             mset(array $dictionary)
 * @method int               msetnx(array $dictionary)
 * @method Status            psetex(string $key, $milliseconds, $value)
 * @method Status|null       set(string $key, $value, $expireResolution = null, $expireTTL = null, $flag = null)
 * @method int               setbit(string $key, $offset, $value)
 * @method Status            setex(string $key, $seconds, $value)
 * @method int               setnx(string $key, $value)
 * @method int               setrange(string $key, $offset, $value)
 * @method int               strlen(string $key)
 * @method int               hdel(string $key, array $fields)
 * @method int               hexists(string $key, string $field)
 * @method array|null        hexpire(string $key, int $seconds, array $fields, string $flag = null)
 * @method array|null        hexpireat(string $key, int $unixTimeSeconds, array $fields, string $flag = null)
 * @method array|null        hexpiretime(string $key, array $fields)
 * @method array|null        hpersist(string $key, array $fields)
 * @method array|null        hpexpire(string $key, int $milliseconds, array $fields, string $flag = null)
 * @method array|null        hpexpireat(string $key, int $unixTimeMilliseconds, array $fields, string $flag = null)
 * @method array|null        hpexpiretime(string $key, array $fields)
 * @method string|null       hget(string $key, string $field)
 * @method array             hgetall(string $key)
 * @method int               hincrby(string $key, string $field, int $increment)
 * @method string            hincrbyfloat(string $key, string $field, int|float $increment)
 * @method array             hkeys(string $key)
 * @method int               hlen(string $key)
 * @method array             hmget(string $key, array $fields)
 * @method mixed             hmset(string $key, array $dictionary)
 * @method array             hrandfield(string $key, int $count = 1, bool $withValues = false)
 * @method array             hscan(string $key, $cursor, ?array $options = null)
 * @method int               hset(string $key, string $field, string $value)
 * @method int               hsetnx(string $key, string $field, string $value)
 * @method array|null        httl(string $key, array $fields)
 * @method array|null        hpttl(string $key, array $fields)
 * @method array             hvals(string $key)
 * @method int               hstrlen(string $key, string $field)
 * @method array             jsonarrappend(string $key, string $path = '$', ...$value)
 * @method array             jsonarrindex(string $key, string $path, string $value, int $start = 0, int $stop = 0)
 * @method array             jsonarrinsert(string $key, string $path, int $index, string ...$value)
 * @method array             jsonarrlen(string $key, string $path = '$')
 * @method array             jsonarrpop(string $key, string $path = '$', int $index = -1)
 * @method int               jsonclear(string $key, string $path = '$')
 * @method array             jsonarrtrim(string $key, string $path, int $start, int $stop)
 * @method int               jsondel(string $key, string $path = '$')
 * @method int               jsonforget(string $key, string $path = '$')
 * @method string            jsonget(string $key, string $indent = '', string $newline = '', string $space = '', string ...$paths)
 * @method string            jsonnumincrby(string $key, string $path, int $value)
 * @method Status            jsonmerge(string $key, string $path, string $value)
 * @method array             jsonmget(array $keys, string $path)
 * @method Status            jsonmset(string ...$keyPathValue)
 * @method array             jsonobjkeys(string $key, string $path = '$')
 * @method array             jsonobjlen(string $key, string $path = '$')
 * @method array             jsonresp(string $key, string $path = '$')
 * @method string            jsonset(string $key, string $path, string $value, ?string $subcommand = null)
 * @method array             jsonstrappend(string $key, string $path, string $value)
 * @method array             jsonstrlen(string $key, string $path = '$')
 * @method array             jsontoggle(string $key, string $path)
 * @method array             jsontype(string $key, string $path = '$')
 * @method string            blmove(string $source, string $destination, string $where, string $to, int $timeout)
 * @method array|null        blpop(array|string $keys, int|float $timeout)
 * @method array|null        brpop(array|string $keys, int|float $timeout)
 * @method string|null       brpoplpush(string $source, string $destination, int|float $timeout)
 * @method mixed             lcs(string $key1, string $key2, bool $len = false, bool $idx = false, int $minMatchLen = 0, bool $withMatchLen = false)
 * @method string|null       lindex(string $key, int $index)
 * @method int               linsert(string $key, $whence, $pivot, $value)
 * @method int               llen(string $key)
 * @method string            lmove(string $source, string $destination, string $where, string $to)
 * @method array|null        lmpop(array $keys, string $modifier = 'left', int $count = 1)
 * @method string|null       lpop(string $key)
 * @method int               lpush(string $key, array $values)
 * @method int               lpushx(string $key, array $values)
 * @method string[]          lrange(string $key, int $start, int $stop)
 * @method int               lrem(string $key, int $count, string $value)
 * @method mixed             lset(string $key, int $index, string $value)
 * @method mixed             ltrim(string $key, int $start, int $stop)
 * @method string|null       rpop(string $key)
 * @method string|null       rpoplpush(string $source, string $destination)
 * @method int               rpush(string $key, array $values)
 * @method int               rpushx(string $key, array $values)
 * @method int               sadd(string $key, array $members)
 * @method int               scard(string $key)
 * @method string[]          sdiff(array|string $keys)
 * @method int               sdiffstore(string $destination, array|string $keys)
 * @method string[]          sinter(array|string $keys)
 * @method int               sintercard(array $keys, int $limit = 0)
 * @method int               sinterstore(string $destination, array|string $keys)
 * @method int               sismember(string $key, string $member)
 * @method string[]          smembers(string $key)
 * @method array             smismember(string $key, string ...$members)
 * @method int               smove(string $source, string $destination, string $member)
 * @method string|array|null spop(string $key, ?int $count = null)
 * @method string|null       srandmember(string $key, ?int $count = null)
 * @method int               srem(string $key, array|string $member)
 * @method array             sscan(string $key, int $cursor, ?array $options = null)
 * @method string[]          sunion(array|string $keys)
 * @method int               sunionstore(string $destination, array|string $keys)
 * @method int               touch(string[]|string $keyOrKeys, string ...$keys = null)
 * @method Status            tdigestadd(string $key, float ...$value)
 * @method array             tdigestbyrank(string $key, int ...$rank)
 * @method array             tdigestbyrevrank(string $key, int ...$reverseRank)
 * @method array             tdigestcdf(string $key, int ...$value)
 * @method Status            tdigestcreate(string $key, int $compression = 0)
 * @method array             tdigestinfo(string $key)
 * @method string            tdigestmax(string $key)
 * @method Status            tdigestmerge(string $destinationKey, array $sourceKeys, int $compression = 0, bool $override = false)
 * @method string[]          tdigestquantile(string $key, float ...$quantile)
 * @method string            tdigestmin(string $key)
 * @method array             tdigestrank(string $key, float ...$value)
 * @method Status            tdigestreset(string $key)
 * @method array             tdigestrevrank(string $key, float ...$value)
 * @method string            tdigesttrimmed_mean(string $key, float $lowCutQuantile, float $highCutQuantile)
 * @method array             topkadd(string $key, ...$items)
 * @method array             topkincrby(string $key, ...$itemIncrement)
 * @method array             topkinfo(string $key)
 * @method array             topklist(string $key, bool $withCount = false)
 * @method array             topkquery(string $key, ...$items)
 * @method Status            topkreserve(string $key, int $topK, int $width = 8, int $depth = 7, float $decay = 0.9)
 * @method int               tsadd(string $key, int $timestamp, float $value, ?AddArguments $arguments = null)
 * @method Status            tsalter(string $key, ?TSAlterArguments $arguments = null)
 * @method Status            tscreate(string $key, ?TSCreateArguments $arguments = null)
 * @method Status            tscreaterule(string $sourceKey, string $destKey, string $aggregator, int $bucketDuration, int $alignTimestamp = 0)
 * @method int               tsdecrby(string $key, float $value, ?DecrByArguments $arguments = null)
 * @method int               tsdel(string $key, int $fromTimestamp, int $toTimestamp)
 * @method Status            tsdeleterule(string $sourceKey, string $destKey)
 * @method array             tsget(string $key, ?GetArguments $arguments = null)
 * @method int               tsincrby(string $key, float $value, ?IncrByArguments $arguments = null)
 * @method array             tsinfo(string $key, ?InfoArguments $arguments = null)
 * @method array             tsmadd(mixed ...$keyTimestampValue)
 * @method array             tsmget(MGetArguments $arguments, string ...$filterExpression)
 * @method array             tsmrange($fromTimestamp, $toTimestamp, MRangeArguments $arguments)
 * @method array             tsmrevrange($fromTimestamp, $toTimestamp, MRangeArguments $arguments)
 * @method array             tsqueryindex(string ...$filterExpression)
 * @method array             tsrange(string $key, $fromTimestamp, $toTimestamp, ?RangeArguments $arguments = null)
 * @method array             tsrevrange(string $key, $fromTimestamp, $toTimestamp, ?RangeArguments $arguments = null)
 * @method string            xadd(string $key, array $dictionary, string $id = '*', ?array $options = null)
 * @method int               xdel(string $key, string ...$id)
 * @method int               xlen(string $key)
 * @method array             xrevrange(string $key, string $end, string $start, ?int $count = null)
 * @method array             xrange(string $key, string $start, string $end, ?int $count = null)
 * @method string            xtrim(string $key, array|string $strategy, string $threshold, ?array $options = null)
 * @method array|null        xread(int $count = null, int $block = null, array $streams = null, string ...$id)
 * @method int               zadd(string $key, array $membersAndScoresDictionary)
 * @method int               zcard(string $key)
 * @method string            zcount(string $key, int|string $min, int|string $max)
 * @method array             zdiff(array $keys, bool $withScores = false)
 * @method int               zdiffstore(string $destination, array $keys)
 * @method string            zincrby(string $key, int $increment, string $member)
 * @method int               zintercard(array $keys, int $limit = 0)
 * @method int               zinterstore(string $destination, array $keys, int[] $weights = [], string $aggregate = 'sum')
 * @method array             zinter(array $keys, int[] $weights = [], string $aggregate = 'sum', bool $withScores = false)
 * @method array             zmpop(array $keys, string $modifier = 'min', int $count = 1)
 * @method array             zmscore(string $key, string ...$member)
 * @method array             zpopmin(string $key, int $count = 1)
 * @method array             zpopmax(string $key, int $count = 1)
 * @method mixed             zrandmember(string $key, int $count = 1, bool $withScores = false)
 * @method array             zrange(string $key, int|string $start, int|string $stop, ?array $options = null)
 * @method array             zrangebyscore(string $key, int|string $min, int|string $max, ?array $options = null)
 * @method int               zrangestore(string $destination, string $source, int|string $min, int|string $max, string|bool $by = false, bool $reversed = false, bool $limit = false, int $offset = 0, int $count = 0)
 * @method int|null          zrank(string $key, string $member)
 * @method int               zrem(string $key, string ...$member)
 * @method int               zremrangebyrank(string $key, int|string $start, int|string $stop)
 * @method int               zremrangebyscore(string $key, int|string $min, int|string $max)
 * @method array             zrevrange(string $key, int|string $start, int|string $stop, ?array $options = null)
 * @method array             zrevrangebyscore(string $key, int|string $max, int|string $min, ?array $options = null)
 * @method int|null          zrevrank(string $key, string $member)
 * @method array             zunion(array $keys, int[] $weights = [], string $aggregate = 'sum', bool $withScores = false)
 * @method int               zunionstore(string $destination, array $keys, int[] $weights = [], string $aggregate = 'sum')
 * @method string|null       zscore(string $key, string $member)
 * @method array             zscan(string $key, int $cursor, ?array $options = null)
 * @method array             zrangebylex(string $key, string $start, string $stop, ?array $options = null)
 * @method array             zrevrangebylex(string $key, string $start, string $stop, ?array $options = null)
 * @method int               zremrangebylex(string $key, string $min, string $max)
 * @method int               zlexcount(string $key, string $min, string $max)
 * @method int               pexpiretime(string $key)
 * @method int               pfadd(string $key, array $elements)
 * @method mixed             pfmerge(string $destinationKey, array|string $sourceKeys)
 * @method int               pfcount(string[]|string $keyOrKeys, string ...$keys = null)
 * @method mixed             pubsub($subcommand, $argument)
 * @method int               publish($channel, $message)
 * @method mixed             discard()
 * @method array|null        exec()
 * @method mixed             multi()
 * @method mixed             unwatch()
 * @method array             waitaof(int $numLocal, int $numReplicas, int $timeout)
 * @method mixed             watch(string $key)
 * @method mixed             eval(string $script, int $numkeys, string ...$keyOrArg = null)
 * @method mixed             eval_ro(string $script, array $keys, ...$argument)
 * @method mixed             evalsha(string $script, int $numkeys, string ...$keyOrArg = null)
 * @method mixed             evalsha_ro(string $sha1, array $keys, ...$argument)
 * @method mixed             script($subcommand, $argument = null)
 * @method Status            shutdown(?bool $noSave = null, bool $now = false, bool $force = false, bool $abort = false)
 * @method mixed             auth(string $password)
 * @method string            echo(string $message)
 * @method mixed             ping(?string $message = null)
 * @method mixed             select(int $database)
 * @method mixed             bgrewriteaof()
 * @method mixed             bgsave()
 * @method mixed             client($subcommand, $argument = null)
 * @method mixed             config($subcommand, $argument = null)
 * @method int               dbsize()
 * @method mixed             flushall()
 * @method mixed             flushdb()
 * @method array             info($section = null)
 * @method int               lastsave()
 * @method mixed             save()
 * @method mixed             slaveof(string $host, int $port)
 * @method mixed             slowlog($subcommand, $argument = null)
 * @method array             time()
 * @method array             command()
 * @method int               geoadd(string $key, $longitude, $latitude, $member)
 * @method array             geohash(string $key, array $members)
 * @method array             geopos(string $key, array $members)
 * @method string|null       geodist(string $key, $member1, $member2, $unit = null)
 * @method array             georadius(string $key, $longitude, $latitude, $radius, $unit, ?array $options = null)
 * @method array             georadiusbymember(string $key, $member, $radius, $unit, ?array $options = null)
 * @method array             geosearch(string $key, FromInterface $from, ByInterface $by, ?string $sorting = null, int $count = -1, bool $any = false, bool $withCoord = false, bool $withDist = false, bool $withHash = false)
 * @method int               geosearchstore(string $destination, string $source, FromInterface $from, ByInterface $by, ?string $sorting = null, int $count = -1, bool $any = false, bool $storeDist = false)
 *
 * Container commands
 * @property CLUSTER           $cluster
 * @property FunctionContainer $function
 * @property FTCONFIG          $ftconfig
 * @property FTCURSOR          $ftcursor
 * @property JSONDEBUG         $jsondebug
 * @property ACL               $acl
 */
interface ClientInterface
{
    /**
     * Returns the command factory used by the client.
     *
     * @return FactoryInterface
     */
    public function getCommandFactory();

    /**
     * Returns the client options specified upon initialization.
     *
     * @return OptionsInterface
     */
    public function getOptions();

    /**
     * Opens the underlying connection to the server.
     */
    public function connect();

    /**
     * Closes the underlying connection from the server.
     */
    public function disconnect();

    /**
     * Returns the underlying connection instance.
     *
     * @return ConnectionInterface
     */
    public function getConnection();

    /**
     * Creates a new instance of the specified Redis command.
     *
     * @param string $method    Command ID.
     * @param array  $arguments Arguments for the command.
     *
     * @return CommandInterface
     */
    public function createCommand($method, $arguments = []);

    /**
     * Executes the specified Redis command.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return mixed
     */
    public function executeCommand(CommandInterface $command);

    /**
     * Creates a Redis command with the specified arguments and sends a request
     * to the server.
     *
     * @param string $method    Command ID.
     * @param array  $arguments Arguments for the command.
     *
     * @return mixed
     */
    public function __call($method, $arguments);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\CommunicationException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

use Exception;
use Predis\Connection\NodeConnectionInterface;

/**
 * Base exception class for network-related errors.
 */
abstract class CommunicationException extends PredisException
{
    private $connection;

    /**
     * @param NodeConnectionInterface $connection     Connection that generated the exception.
     * @param string                  $message        Error message.
     * @param int                     $code           Error code.
     * @param Exception|null          $innerException Inner exception for wrapping the original error.
     */
    public function __construct(
        NodeConnectionInterface $connection,
        $message = '',
        $code = 0,
        ?Exception $innerException = null
    ) {
        parent::__construct(
            is_null($message) ? '' : $message,
            is_null($code) ? 0 : $code,
            $innerException
        );

        $this->connection = $connection;
    }

    /**
     * Gets the connection that generated the exception.
     *
     * @return NodeConnectionInterface
     */
    public function getConnection()
    {
        return $this->connection;
    }

    /**
     * Indicates if the receiver should reset the underlying connection.
     *
     * @return bool
     */
    public function shouldResetConnection()
    {
        return true;
    }

    /**
     * Helper method to handle exceptions generated by a connection object.
     *
     * @param CommunicationException $exception Exception.
     *
     * @throws CommunicationException
     */
    public static function handle(CommunicationException $exception)
    {
        if ($exception->shouldResetConnection()) {
            $connection = $exception->getConnection();

            if ($connection->isConnected()) {
                $connection->disconnect();
            }
        }

        throw $exception;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\NotSupportedException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

/**
 * Exception class thrown when trying to use features not supported by certain
 * classes or abstractions of Predis.
 */
class NotSupportedException extends PredisException
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\PredisException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

use Exception;

/**
 * Base exception class for Predis-related errors.
 */
abstract class PredisException extends Exception
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\ClusterStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster;

use InvalidArgumentException;
use Predis\Command\CommandInterface;
use Predis\Command\ScriptCommand;

/**
 * Common class implementing the logic needed to support clustering strategies.
 */
abstract class ClusterStrategy implements StrategyInterface
{
    protected $commands;

    public function __construct()
    {
        $this->commands = $this->getDefaultCommands();
    }

    /**
     * Returns the default map of supported commands with their handlers.
     *
     * @return array
     */
    protected function getDefaultCommands()
    {
        $getKeyFromFirstArgument = [$this, 'getKeyFromFirstArgument'];
        $getKeyFromAllArguments = [$this, 'getKeyFromAllArguments'];

        return [
            /* commands operating on the key space */
            'EXISTS' => $getKeyFromAllArguments,
            'DEL' => $getKeyFromAllArguments,
            'TYPE' => $getKeyFromFirstArgument,
            'EXPIRE' => $getKeyFromFirstArgument,
            'EXPIREAT' => $getKeyFromFirstArgument,
            'PERSIST' => $getKeyFromFirstArgument,
            'PEXPIRE' => $getKeyFromFirstArgument,
            'PEXPIREAT' => $getKeyFromFirstArgument,
            'TTL' => $getKeyFromFirstArgument,
            'PTTL' => $getKeyFromFirstArgument,
            'SORT' => [$this, 'getKeyFromSortCommand'],
            'DUMP' => $getKeyFromFirstArgument,
            'RESTORE' => $getKeyFromFirstArgument,
            'FLUSHDB' => [$this, 'getFakeKey'],

            /* commands operating on string values */
            'APPEND' => $getKeyFromFirstArgument,
            'DECR' => $getKeyFromFirstArgument,
            'DECRBY' => $getKeyFromFirstArgument,
            'GET' => $getKeyFromFirstArgument,
            'GETBIT' => $getKeyFromFirstArgument,
            'MGET' => $getKeyFromAllArguments,
            'SET' => $getKeyFromFirstArgument,
            'GETRANGE' => $getKeyFromFirstArgument,
            'GETSET' => $getKeyFromFirstArgument,
            'INCR' => $getKeyFromFirstArgument,
            'INCRBY' => $getKeyFromFirstArgument,
            'INCRBYFLOAT' => $getKeyFromFirstArgument,
            'SETBIT' => $getKeyFromFirstArgument,
            'SETEX' => $getKeyFromFirstArgument,
            'MSET' => [$this, 'getKeyFromInterleavedArguments'],
            'MSETNX' => [$this, 'getKeyFromInterleavedArguments'],
            'SETNX' => $getKeyFromFirstArgument,
            'SETRANGE' => $getKeyFromFirstArgument,
            'STRLEN' => $getKeyFromFirstArgument,
            'SUBSTR' => $getKeyFromFirstArgument,
            'BITOP' => [$this, 'getKeyFromBitOp'],
            'BITCOUNT' => $getKeyFromFirstArgument,
            'BITFIELD' => $getKeyFromFirstArgument,

            /* commands operating on lists */
            'LINSERT' => $getKeyFromFirstArgument,
            'LINDEX' => $getKeyFromFirstArgument,
            'LLEN' => $getKeyFromFirstArgument,
            'LPOP' => $getKeyFromFirstArgument,
            'RPOP' => $getKeyFromFirstArgument,
            'RPOPLPUSH' => $getKeyFromAllArguments,
            'BLPOP' => [$this, 'getKeyFromBlockingListCommands'],
            'BRPOP' => [$this, 'getKeyFromBlockingListCommands'],
            'BRPOPLPUSH' => [$this, 'getKeyFromBlockingListCommands'],
            'LPUSH' => $getKeyFromFirstArgument,
            'LPUSHX' => $getKeyFromFirstArgument,
            'RPUSH' => $getKeyFromFirstArgument,
            'RPUSHX' => $getKeyFromFirstArgument,
            'LRANGE' => $getKeyFromFirstArgument,
            'LREM' => $getKeyFromFirstArgument,
            'LSET' => $getKeyFromFirstArgument,
            'LTRIM' => $getKeyFromFirstArgument,

            /* commands operating on sets */
            'SADD' => $getKeyFromFirstArgument,
            'SCARD' => $getKeyFromFirstArgument,
            'SDIFF' => $getKeyFromAllArguments,
            'SDIFFSTORE' => $getKeyFromAllArguments,
            'SINTER' => $getKeyFromAllArguments,
            'SINTERSTORE' => $getKeyFromAllArguments,
            'SUNION' => $getKeyFromAllArguments,
            'SUNIONSTORE' => $getKeyFromAllArguments,
            'SISMEMBER' => $getKeyFromFirstArgument,
            'SMEMBERS' => $getKeyFromFirstArgument,
            'SSCAN' => $getKeyFromFirstArgument,
            'SPOP' => $getKeyFromFirstArgument,
            'SRANDMEMBER' => $getKeyFromFirstArgument,
            'SREM' => $getKeyFromFirstArgument,

            /* commands operating on sorted sets */
            'ZADD' => $getKeyFromFirstArgument,
            'ZCARD' => $getKeyFromFirstArgument,
            'ZCOUNT' => $getKeyFromFirstArgument,
            'ZINCRBY' => $getKeyFromFirstArgument,
            'ZINTERSTORE' => [$this, 'getKeyFromZsetAggregationCommands'],
            'ZRANGE' => $getKeyFromFirstArgument,
            'ZRANGEBYSCORE' => $getKeyFromFirstArgument,
            'ZRANK' => $getKeyFromFirstArgument,
            'ZREM' => $getKeyFromFirstArgument,
            'ZREMRANGEBYRANK' => $getKeyFromFirstArgument,
            'ZREMRANGEBYSCORE' => $getKeyFromFirstArgument,
            'ZREVRANGE' => $getKeyFromFirstArgument,
            'ZREVRANGEBYSCORE' => $getKeyFromFirstArgument,
            'ZREVRANK' => $getKeyFromFirstArgument,
            'ZSCORE' => $getKeyFromFirstArgument,
            'ZUNIONSTORE' => [$this, 'getKeyFromZsetAggregationCommands'],
            'ZSCAN' => $getKeyFromFirstArgument,
            'ZLEXCOUNT' => $getKeyFromFirstArgument,
            'ZRANGEBYLEX' => $getKeyFromFirstArgument,
            'ZREMRANGEBYLEX' => $getKeyFromFirstArgument,
            'ZREVRANGEBYLEX' => $getKeyFromFirstArgument,

            /* commands operating on hashes */
            'HDEL' => $getKeyFromFirstArgument,
            'HEXISTS' => $getKeyFromFirstArgument,
            'HGET' => $getKeyFromFirstArgument,
            'HGETALL' => $getKeyFromFirstArgument,
            'HMGET' => $getKeyFromFirstArgument,
            'HMSET' => $getKeyFromFirstArgument,
            'HINCRBY' => $getKeyFromFirstArgument,
            'HINCRBYFLOAT' => $getKeyFromFirstArgument,
            'HKEYS' => $getKeyFromFirstArgument,
            'HLEN' => $getKeyFromFirstArgument,
            'HSET' => $getKeyFromFirstArgument,
            'HSETNX' => $getKeyFromFirstArgument,
            'HVALS' => $getKeyFromFirstArgument,
            'HSCAN' => $getKeyFromFirstArgument,
            'HSTRLEN' => $getKeyFromFirstArgument,

            /* commands operating on HyperLogLog */
            'PFADD' => $getKeyFromFirstArgument,
            'PFCOUNT' => $getKeyFromAllArguments,
            'PFMERGE' => $getKeyFromAllArguments,

            /* scripting */
            'EVAL' => [$this, 'getKeyFromScriptingCommands'],
            'EVALSHA' => [$this, 'getKeyFromScriptingCommands'],

            /* server */
            'INFO' => [$this, 'getFakeKey'],

            /* commands performing geospatial operations */
            'GEOADD' => $getKeyFromFirstArgument,
            'GEOHASH' => $getKeyFromFirstArgument,
            'GEOPOS' => $getKeyFromFirstArgument,
            'GEODIST' => $getKeyFromFirstArgument,
            'GEORADIUS' => [$this, 'getKeyFromGeoradiusCommands'],
            'GEORADIUSBYMEMBER' => [$this, 'getKeyFromGeoradiusCommands'],

            /* cluster */
            'CLUSTER' => [$this, 'getFakeKey'],
        ];
    }

    /**
     * Returns the list of IDs for the supported commands.
     *
     * @return array
     */
    public function getSupportedCommands()
    {
        return array_keys($this->commands);
    }

    /**
     * Sets an handler for the specified command ID.
     *
     * The signature of the callback must have a single parameter of type
     * Predis\Command\CommandInterface.
     *
     * When the callback argument is omitted or NULL, the previously associated
     * handler for the specified command ID is removed.
     *
     * @param string $commandID Command ID.
     * @param mixed  $callback  A valid callable object, or NULL to unset the handler.
     *
     * @throws InvalidArgumentException
     */
    public function setCommandHandler($commandID, $callback = null)
    {
        $commandID = strtoupper($commandID);

        if (!isset($callback)) {
            unset($this->commands[$commandID]);

            return;
        }

        if (!is_callable($callback)) {
            throw new InvalidArgumentException(
                'The argument must be a callable object or NULL.'
            );
        }

        $this->commands[$commandID] = $callback;
    }

    /**
     * Get fake key for commands with no key argument.
     *
     * @return string
     */
    protected function getFakeKey(): string
    {
        return 'key';
    }

    /**
     * Extracts the key from the first argument of a command instance.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return string
     */
    protected function getKeyFromFirstArgument(CommandInterface $command)
    {
        return $command->getArgument(0);
    }

    /**
     * Extracts the key from a command with multiple keys only when all keys in
     * the arguments array produce the same hash.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return string|null
     */
    protected function getKeyFromAllArguments(CommandInterface $command)
    {
        $arguments = $command->getArguments();

        if (!$this->checkSameSlotForKeys($arguments)) {
            return null;
        }

        return $arguments[0];
    }

    /**
     * Extracts the key from a command with multiple keys only when all keys in
     * the arguments array produce the same hash.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return string|null
     */
    protected function getKeyFromInterleavedArguments(CommandInterface $command)
    {
        $arguments = $command->getArguments();
        $keys = [];

        for ($i = 0; $i < count($arguments); $i += 2) {
            $keys[] = $arguments[$i];
        }

        if (!$this->checkSameSlotForKeys($keys)) {
            return null;
        }

        return $arguments[0];
    }

    /**
     * Extracts the key from SORT command.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return string|null
     */
    protected function getKeyFromSortCommand(CommandInterface $command)
    {
        $arguments = $command->getArguments();
        $firstKey = $arguments[0];

        if (1 === $argc = count($arguments)) {
            return $firstKey;
        }

        $keys = [$firstKey];

        for ($i = 1; $i < $argc; ++$i) {
            if (strtoupper($arguments[$i]) === 'STORE') {
                $keys[] = $arguments[++$i];
            }
        }

        if (!$this->checkSameSlotForKeys($keys)) {
            return null;
        }

        return $firstKey;
    }

    /**
     * Extracts the key from BLPOP and BRPOP commands.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return string|null
     */
    protected function getKeyFromBlockingListCommands(CommandInterface $command)
    {
        $arguments = $command->getArguments();

        if (!$this->checkSameSlotForKeys(array_slice($arguments, 0, count($arguments) - 1))) {
            return null;
        }

        return $arguments[0];
    }

    /**
     * Extracts the key from BITOP command.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return string|null
     */
    protected function getKeyFromBitOp(CommandInterface $command)
    {
        $arguments = $command->getArguments();

        if (!$this->checkSameSlotForKeys(array_slice($arguments, 1, count($arguments)))) {
            return null;
        }

        return $arguments[1];
    }

    /**
     * Extracts the key from GEORADIUS and GEORADIUSBYMEMBER commands.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return string|null
     */
    protected function getKeyFromGeoradiusCommands(CommandInterface $command)
    {
        $arguments = $command->getArguments();
        $argc = count($arguments);
        $startIndex = $command->getId() === 'GEORADIUS' ? 5 : 4;

        if ($argc > $startIndex) {
            $keys = [$arguments[0]];

            for ($i = $startIndex; $i < $argc; ++$i) {
                $argument = strtoupper($arguments[$i]);
                if ($argument === 'STORE' || $argument === 'STOREDIST') {
                    $keys[] = $arguments[++$i];
                }
            }

            if (!$this->checkSameSlotForKeys($keys)) {
                return null;
            }
        }

        return $arguments[0];
    }

    /**
     * Extracts the key from ZINTERSTORE and ZUNIONSTORE commands.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return string|null
     */
    protected function getKeyFromZsetAggregationCommands(CommandInterface $command)
    {
        $arguments = $command->getArguments();
        $keys = array_merge([$arguments[0]], array_slice($arguments, 2, $arguments[1]));

        if (!$this->checkSameSlotForKeys($keys)) {
            return null;
        }

        return $arguments[0];
    }

    /**
     * Extracts the key from EVAL and EVALSHA commands.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return string|null
     */
    protected function getKeyFromScriptingCommands(CommandInterface $command)
    {
        $keys = $command instanceof ScriptCommand
            ? $command->getKeys()
            : array_slice($args = $command->getArguments(), 2, $args[1]);

        if (!$keys || !$this->checkSameSlotForKeys($keys)) {
            return null;
        }

        return $keys[0];
    }

    /**
     * {@inheritdoc}
     */
    public function getSlot(CommandInterface $command)
    {
        $slot = $command->getSlot();

        if (!isset($slot) && isset($this->commands[$cmdID = $command->getId()])) {
            $key = call_user_func($this->commands[$cmdID], $command);

            if (isset($key)) {
                $slot = $this->getSlotByKey($key);
                $command->setSlot($slot);
            }
        }

        return $slot;
    }

    /**
     * Checks if the specified array of keys will generate the same hash.
     *
     * @param array $keys Array of keys.
     *
     * @return bool
     */
    protected function checkSameSlotForKeys(array $keys)
    {
        if (!$count = count($keys)) {
            return false;
        }

        $currentSlot = $this->getSlotByKey($keys[0]);

        for ($i = 1; $i < $count; ++$i) {
            $nextSlot = $this->getSlotByKey($keys[$i]);

            if ($currentSlot !== $nextSlot) {
                return false;
            }

            $currentSlot = $nextSlot;
        }

        return true;
    }

    /**
     * Returns only the hashable part of a key (delimited by "{...}"), or the
     * whole key if a key tag is not found in the string.
     *
     * @param string $key A key.
     *
     * @return string
     */
    protected function extractKeyTag($key)
    {
        if (false !== $start = strpos($key, '{')) {
            if (false !== ($end = strpos($key, '}', $start)) && $end !== ++$start) {
                $key = substr($key, $start, $end - $start);
            }
        }

        return $key;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\PredisStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster;

use Predis\Cluster\Distributor\DistributorInterface;
use Predis\Cluster\Distributor\HashRing;

/**
 * Default cluster strategy used by Predis to handle client-side sharding.
 */
class PredisStrategy extends ClusterStrategy
{
    protected $distributor;

    /**
     * @param DistributorInterface|null $distributor Optional distributor instance.
     */
    public function __construct(?DistributorInterface $distributor = null)
    {
        parent::__construct();

        $this->distributor = $distributor ?: new HashRing();
    }

    /**
     * {@inheritdoc}
     */
    public function getSlotByKey($key)
    {
        $key = $this->extractKeyTag($key);
        $hash = $this->distributor->hash($key);

        return $this->distributor->getSlot($hash);
    }

    /**
     * {@inheritdoc}
     */
    protected function checkSameSlotForKeys(array $keys)
    {
        if (!$count = count($keys)) {
            return false;
        }

        $currentKey = $this->extractKeyTag($keys[0]);

        for ($i = 1; $i < $count; ++$i) {
            $nextKey = $this->extractKeyTag($keys[$i]);

            if ($currentKey !== $nextKey) {
                return false;
            }

            $currentKey = $nextKey;
        }

        return true;
    }

    /**
     * {@inheritdoc}
     */
    public function getDistributor()
    {
        return $this->distributor;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\RedisStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster;

use Predis\Cluster\Hash\CRC16;
use Predis\Cluster\Hash\HashGeneratorInterface;
use Predis\NotSupportedException;

/**
 * Default class used by Predis to calculate hashes out of keys of
 * commands supported by redis-cluster.
 */
class RedisStrategy extends ClusterStrategy
{
    protected $hashGenerator;

    /**
     * @param HashGeneratorInterface|null $hashGenerator Hash generator instance.
     */
    public function __construct(?HashGeneratorInterface $hashGenerator = null)
    {
        parent::__construct();

        $this->hashGenerator = $hashGenerator ?: new CRC16();
    }

    /**
     * {@inheritdoc}
     */
    public function getSlotByKey($key)
    {
        $key = $this->extractKeyTag($key);

        return $this->hashGenerator->hash($key) & 0x3FFF;
    }

    /**
     * {@inheritdoc}
     */
    public function getDistributor()
    {
        $class = get_class($this);
        throw new NotSupportedException("$class does not provide an external distributor");
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\SlotMap.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster;

use ArrayAccess;
use ArrayIterator;
use Countable;
use IteratorAggregate;
use OutOfBoundsException;
use Predis\Connection\NodeConnectionInterface;
use ReturnTypeWillChange;
use Traversable;

/**
 * Slot map for redis-cluster.
 */
class SlotMap implements ArrayAccess, IteratorAggregate, Countable
{
    private $slots = [];

    /**
     * Checks if the given slot is valid.
     *
     * @param int $slot Slot index.
     *
     * @return bool
     */
    public static function isValid($slot)
    {
        return $slot >= 0x0000 && $slot <= 0x3FFF;
    }

    /**
     * Checks if the given slot range is valid.
     *
     * @param int $first Initial slot of the range.
     * @param int $last  Last slot of the range.
     *
     * @return bool
     */
    public static function isValidRange($first, $last)
    {
        return $first >= 0x0000 && $first <= 0x3FFF && $last >= 0x0000 && $last <= 0x3FFF && $first <= $last;
    }

    /**
     * Resets the slot map.
     */
    public function reset()
    {
        $this->slots = [];
    }

    /**
     * Checks if the slot map is empty.
     *
     * @return bool
     */
    public function isEmpty()
    {
        return empty($this->slots);
    }

    /**
     * Returns the current slot map as a dictionary of $slot => $node.
     *
     * The order of the slots in the dictionary is not guaranteed.
     *
     * @return array
     */
    public function toArray()
    {
        return $this->slots;
    }

    /**
     * Returns the list of unique nodes in the slot map.
     *
     * @return array
     */
    public function getNodes()
    {
        return array_keys(array_flip($this->slots));
    }

    /**
     * Assigns the specified slot range to a node.
     *
     * @param int                            $first      Initial slot of the range.
     * @param int                            $last       Last slot of the range.
     * @param NodeConnectionInterface|string $connection ID or connection instance.
     *
     * @throws OutOfBoundsException
     */
    public function setSlots($first, $last, $connection)
    {
        if (!static::isValidRange($first, $last)) {
            throw new OutOfBoundsException("Invalid slot range $first-$last for `$connection`");
        }

        $this->slots += array_fill($first, $last - $first + 1, (string) $connection);
    }

    /**
     * Returns the specified slot range.
     *
     * @param int $first Initial slot of the range.
     * @param int $last  Last slot of the range.
     *
     * @return array
     */
    public function getSlots($first, $last)
    {
        if (!static::isValidRange($first, $last)) {
            throw new OutOfBoundsException("Invalid slot range $first-$last");
        }

        return array_intersect_key($this->slots, array_fill($first, $last - $first + 1, null));
    }

    /**
     * Checks if the specified slot is assigned.
     *
     * @param int $slot Slot index.
     *
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function offsetExists($slot)
    {
        return isset($this->slots[$slot]);
    }

    /**
     * Returns the node assigned to the specified slot.
     *
     * @param int $slot Slot index.
     *
     * @return string|null
     */
    #[ReturnTypeWillChange]
    public function offsetGet($slot)
    {
        return $this->slots[$slot] ?? null;
    }

    /**
     * Assigns the specified slot to a node.
     *
     * @param int                            $slot       Slot index.
     * @param NodeConnectionInterface|string $connection ID or connection instance.
     *
     * @return void
     */
    #[ReturnTypeWillChange]
    public function offsetSet($slot, $connection)
    {
        if (!static::isValid($slot)) {
            throw new OutOfBoundsException("Invalid slot $slot for `$connection`");
        }

        $this->slots[(int) $slot] = (string) $connection;
    }

    /**
     * Returns the node assigned to the specified slot.
     *
     * @param int $slot Slot index.
     *
     * @return void
     */
    #[ReturnTypeWillChange]
    public function offsetUnset($slot)
    {
        unset($this->slots[$slot]);
    }

    /**
     * Returns the current number of assigned slots.
     *
     * @return int
     */
    #[ReturnTypeWillChange]
    public function count()
    {
        return count($this->slots);
    }

    /**
     * Returns an iterator over the slot map.
     *
     * @return Traversable<int, string>
     */
    #[ReturnTypeWillChange]
    public function getIterator()
    {
        return new ArrayIterator($this->slots);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\StrategyInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster;

use Predis\Cluster\Distributor\DistributorInterface;
use Predis\Command\CommandInterface;

/**
 * Interface for classes defining the strategy used to calculate an hash out of
 * keys extracted from supported commands.
 *
 * This is mostly useful to support clustering via client-side sharding.
 */
interface StrategyInterface
{
    /**
     * Returns a slot for the given command used for clustering distribution or
     * NULL when this is not possible.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return int|null
     */
    public function getSlot(CommandInterface $command);

    /**
     * Returns a slot for the given key used for clustering distribution or NULL
     * when this is not possible.
     *
     * @param string $key Key string.
     *
     * @return int|null
     */
    public function getSlotByKey($key);

    /**
     * Returns a distributor instance to be used by the cluster.
     *
     * @return DistributorInterface
     */
    public function getDistributor();
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\Distributor\DistributorInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Distributor;

use Predis\Cluster\Hash\HashGeneratorInterface;

/**
 * A distributor implements the logic to automatically distribute keys among
 * several nodes for client-side sharding.
 */
interface DistributorInterface
{
    /**
     * Adds a node to the distributor with an optional weight.
     *
     * @param mixed $node   Node object.
     * @param int   $weight Weight for the node.
     */
    public function add($node, $weight = null);

    /**
     * Removes a node from the distributor.
     *
     * @param mixed $node Node object.
     */
    public function remove($node);

    /**
     * Returns the corresponding slot of a node from the distributor using the
     * computed hash of a key.
     *
     * @param mixed $hash
     *
     * @return mixed
     */
    public function getSlot($hash);

    /**
     * Returns a node from the distributor using its assigned slot ID.
     *
     * @param mixed $slot
     *
     * @return mixed|null
     */
    public function getBySlot($slot);

    /**
     * Returns a node from the distributor using the computed hash of a key.
     *
     * @param mixed $hash
     *
     * @return mixed
     */
    public function getByHash($hash);

    /**
     * Returns a node from the distributor mapping to the specified value.
     *
     * @param string $value
     *
     * @return mixed
     */
    public function get($value);

    /**
     * Returns the underlying hash generator instance.
     *
     * @return HashGeneratorInterface
     */
    public function getHashGenerator();
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\Distributor\EmptyRingException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Distributor;

use Exception;

/**
 * Exception class that identifies empty rings.
 */
class EmptyRingException extends Exception
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\Distributor\HashRing.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Distributor;

use Predis\Cluster\Hash\HashGeneratorInterface;

/**
 * This class implements an hashring-based distributor that uses the same
 * algorithm of memcache to distribute keys in a cluster using client-side
 * sharding.
 * @author Lorenzo Castelli <lcastelli@gmail.com>
 */
class HashRing implements DistributorInterface, HashGeneratorInterface
{
    public const DEFAULT_REPLICAS = 128;
    public const DEFAULT_WEIGHT = 100;

    private $ring;
    private $ringKeys;
    private $ringKeysCount;
    private $replicas;
    private $nodeHashCallback;
    private $nodes = [];

    /**
     * @param int   $replicas         Number of replicas in the ring.
     * @param mixed $nodeHashCallback Callback returning a string used to calculate the hash of nodes.
     */
    public function __construct($replicas = self::DEFAULT_REPLICAS, $nodeHashCallback = null)
    {
        $this->replicas = $replicas;
        $this->nodeHashCallback = $nodeHashCallback;
    }

    /**
     * Adds a node to the ring with an optional weight.
     *
     * @param mixed $node   Node object.
     * @param int   $weight Weight for the node.
     */
    public function add($node, $weight = null)
    {
        // In case of collisions in the hashes of the nodes, the node added
        // last wins, thus the order in which nodes are added is significant.
        $this->nodes[] = [
            'object' => $node,
            'weight' => (int) $weight ?: $this::DEFAULT_WEIGHT,
        ];

        $this->reset();
    }

    /**
     * {@inheritdoc}
     */
    public function remove($node)
    {
        // A node is removed by resetting the ring so that it's recreated from
        // scratch, in order to reassign possible hashes with collisions to the
        // right node according to the order in which they were added in the
        // first place.
        for ($i = 0; $i < count($this->nodes); ++$i) {
            if ($this->nodes[$i]['object'] === $node) {
                array_splice($this->nodes, $i, 1);
                $this->reset();

                break;
            }
        }
    }

    /**
     * Resets the distributor.
     */
    private function reset()
    {
        unset(
            $this->ring,
            $this->ringKeys,
            $this->ringKeysCount
        );
    }

    /**
     * Returns the initialization status of the distributor.
     *
     * @return bool
     */
    private function isInitialized()
    {
        return isset($this->ringKeys);
    }

    /**
     * Calculates the total weight of all the nodes in the distributor.
     *
     * @return int
     */
    private function computeTotalWeight()
    {
        $totalWeight = 0;

        foreach ($this->nodes as $node) {
            $totalWeight += $node['weight'];
        }

        return $totalWeight;
    }

    /**
     * Initializes the distributor.
     */
    private function initialize()
    {
        if ($this->isInitialized()) {
            return;
        }

        if (!$this->nodes) {
            throw new EmptyRingException('Cannot initialize an empty hashring.');
        }

        $this->ring = [];
        $totalWeight = $this->computeTotalWeight();
        $nodesCount = count($this->nodes);

        foreach ($this->nodes as $node) {
            $weightRatio = $node['weight'] / $totalWeight;
            $this->addNodeToRing($this->ring, $node, $nodesCount, $this->replicas, $weightRatio);
        }

        ksort($this->ring, SORT_NUMERIC);
        $this->ringKeys = array_keys($this->ring);
        $this->ringKeysCount = count($this->ringKeys);
    }

    /**
     * Implements the logic needed to add a node to the hashring.
     *
     * @param array $ring        Source hashring.
     * @param mixed $node        Node object to be added.
     * @param int   $totalNodes  Total number of nodes.
     * @param int   $replicas    Number of replicas in the ring.
     * @param float $weightRatio Weight ratio for the node.
     */
    protected function addNodeToRing(&$ring, $node, $totalNodes, $replicas, $weightRatio)
    {
        $nodeObject = $node['object'];
        $nodeHash = $this->getNodeHash($nodeObject);
        $replicas = (int) round($weightRatio * $totalNodes * $replicas);

        for ($i = 0; $i < $replicas; ++$i) {
            $key = $this->hash("$nodeHash:$i");
            $ring[$key] = $nodeObject;
        }
    }

    /**
     * {@inheritdoc}
     */
    protected function getNodeHash($nodeObject)
    {
        if (!isset($this->nodeHashCallback)) {
            return (string) $nodeObject;
        }

        return call_user_func($this->nodeHashCallback, $nodeObject);
    }

    /**
     * {@inheritdoc}
     */
    public function hash($value)
    {
        return crc32($value);
    }

    /**
     * {@inheritdoc}
     */
    public function getByHash($hash)
    {
        return $this->ring[$this->getSlot($hash)];
    }

    /**
     * {@inheritdoc}
     */
    public function getBySlot($slot)
    {
        $this->initialize();

        if (isset($this->ring[$slot])) {
            return $this->ring[$slot];
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getSlot($hash)
    {
        $this->initialize();

        $ringKeys = $this->ringKeys;
        $upper = $this->ringKeysCount - 1;
        $lower = 0;

        while ($lower <= $upper) {
            $index = ($lower + $upper) >> 1;
            $item = $ringKeys[$index];

            if ($item > $hash) {
                $upper = $index - 1;
            } elseif ($item < $hash) {
                $lower = $index + 1;
            } else {
                return $item;
            }
        }

        return $ringKeys[$this->wrapAroundStrategy($upper, $lower, $this->ringKeysCount)];
    }

    /**
     * {@inheritdoc}
     */
    public function get($value)
    {
        $hash = $this->hash($value);

        return $this->getByHash($hash);
    }

    /**
     * Implements a strategy to deal with wrap-around errors during binary searches.
     *
     * @param int $upper
     * @param int $lower
     * @param int $ringKeysCount
     *
     * @return int
     */
    protected function wrapAroundStrategy($upper, $lower, $ringKeysCount)
    {
        // Binary search for the last item in ringkeys with a value less or
        // equal to the key. If no such item exists, return the last item.
        return $upper >= 0 ? $upper : $ringKeysCount - 1;
    }

    /**
     * {@inheritdoc}
     */
    public function getHashGenerator()
    {
        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\Distributor\KetamaRing.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Distributor;

/**
 * This class implements an hashring-based distributor that uses the same
 * algorithm of libketama to distribute keys in a cluster using client-side
 * sharding.
 * @author Lorenzo Castelli <lcastelli@gmail.com>
 */
class KetamaRing extends HashRing
{
    public const DEFAULT_REPLICAS = 160;

    /**
     * @param mixed $nodeHashCallback Callback returning a string used to calculate the hash of nodes.
     */
    public function __construct($nodeHashCallback = null)
    {
        parent::__construct($this::DEFAULT_REPLICAS, $nodeHashCallback);
    }

    /**
     * {@inheritdoc}
     */
    protected function addNodeToRing(&$ring, $node, $totalNodes, $replicas, $weightRatio)
    {
        $nodeObject = $node['object'];
        $nodeHash = $this->getNodeHash($nodeObject);
        $replicas = (int) floor($weightRatio * $totalNodes * ($replicas / 4));

        for ($i = 0; $i < $replicas; ++$i) {
            $unpackedDigest = unpack('V4', md5("$nodeHash-$i", true));

            foreach ($unpackedDigest as $key) {
                $ring[$key] = $nodeObject;
            }
        }
    }

    /**
     * {@inheritdoc}
     */
    public function hash($value)
    {
        $hash = unpack('V', md5($value, true));

        return $hash[1];
    }

    /**
     * {@inheritdoc}
     */
    protected function wrapAroundStrategy($upper, $lower, $ringKeysCount)
    {
        // Binary search for the first item in ringkeys with a value greater
        // or equal to the key. If no such item exists, return the first item.
        return $lower < $ringKeysCount ? $lower : 0;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\Hash\CRC16.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Hash;

/**
 * Hash generator implementing the CRC-CCITT-16 algorithm used by redis-cluster.
 */
class CRC16 implements HashGeneratorInterface
{
    private static $CCITT_16 = [
        0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
        0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
        0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
        0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
        0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
        0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
        0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
        0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
        0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
        0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
        0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
        0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
        0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
        0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
        0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
        0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
        0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
        0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
        0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
        0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
        0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
        0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
        0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
        0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
        0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
        0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
        0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
        0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
        0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
        0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
        0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
        0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0,
    ];

    /**
     * {@inheritdoc}
     */
    public function hash($value)
    {
        // CRC-CCITT-16 algorithm
        $crc = 0;
        $CCITT_16 = self::$CCITT_16;

        $value = (string) $value;
        $strlen = strlen($value);

        for ($i = 0; $i < $strlen; ++$i) {
            $crc = (($crc << 8) ^ $CCITT_16[($crc >> 8) ^ ord($value[$i])]) & 0xFFFF;
        }

        return $crc;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\Hash\HashGeneratorInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Hash;

/**
 * An hash generator implements the logic used to calculate the hash of a key to
 * distribute operations among Redis nodes.
 */
interface HashGeneratorInterface
{
    /**
     * Generates an hash from a string to be used for distribution.
     *
     * @param string $value String value.
     *
     * @return int
     */
    public function hash($value);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Cluster\Hash\PhpiredisCRC16.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Hash;

use Predis\NotSupportedException;

/**
 * Hash generator implementing the CRC-CCITT-16 algorithm used by redis-cluster.
 *
 * @deprecated 2.1.2
 */
class PhpiredisCRC16 implements HashGeneratorInterface
{
    public function __construct()
    {
        if (!function_exists('phpiredis_utils_crc16')) {
            // @codeCoverageIgnoreStart
            throw new NotSupportedException(
                'This hash generator requires a compatible version of ext-phpiredis'
            );
            // @codeCoverageIgnoreEnd
        }
    }

    /**
     * {@inheritdoc}
     */
    public function hash($value)
    {
        return phpiredis_utils_crc16($value);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Collection\Iterator\CursorBasedIterator.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use Iterator;
use Predis\ClientInterface;
use Predis\NotSupportedException;
use ReturnTypeWillChange;

/**
 * Provides the base implementation for a fully-rewindable PHP iterator that can
 * incrementally iterate over cursor-based collections stored on Redis using the
 * commands in the `SCAN` family.
 *
 * Given their incremental nature with multiple fetches, these kind of iterators
 * offer limited guarantees about the returned elements because the collection
 * can change several times during the iteration process.
 *
 * @see http://redis.io/commands/scan
 */
abstract class CursorBasedIterator implements Iterator
{
    protected $client;
    protected $match;
    protected $count;

    protected $valid;
    protected $fetchmore;
    protected $elements;
    protected $cursor;
    protected $position;
    protected $current;

    /**
     * @param ClientInterface $client Client connected to Redis.
     * @param string          $match  Pattern to match during the server-side iteration.
     * @param int             $count  Hint used by Redis to compute the number of results per iteration.
     */
    public function __construct(ClientInterface $client, $match = null, $count = null)
    {
        $this->client = $client;
        $this->match = $match;
        $this->count = $count;

        $this->reset();
    }

    /**
     * Ensures that the client supports the specified Redis command required to
     * fetch elements from the server to perform the iteration.
     *
     * @param ClientInterface $client    Client connected to Redis.
     * @param string          $commandID Command ID.
     *
     * @throws NotSupportedException
     */
    protected function requiredCommand(ClientInterface $client, $commandID)
    {
        if (!$client->getCommandFactory()->supports($commandID)) {
            throw new NotSupportedException("'$commandID' is not supported by the current command factory.");
        }
    }

    /**
     * Resets the inner state of the iterator.
     */
    protected function reset()
    {
        $this->valid = true;
        $this->fetchmore = true;
        $this->elements = [];
        $this->cursor = 0;
        $this->position = -1;
        $this->current = null;
    }

    /**
     * Returns an array of options for the `SCAN` command.
     *
     * @return array
     */
    protected function getScanOptions()
    {
        $options = [];

        if (strlen(strval($this->match)) > 0) {
            $options['MATCH'] = $this->match;
        }

        if ($this->count > 0) {
            $options['COUNT'] = $this->count;
        }

        return $options;
    }

    /**
     * Fetches a new set of elements from the remote collection, effectively
     * advancing the iteration process.
     *
     * @return array
     */
    abstract protected function executeCommand();

    /**
     * Populates the local buffer of elements fetched from the server during
     * the iteration.
     */
    protected function fetch()
    {
        [$cursor, $elements] = $this->executeCommand();

        if (!$cursor) {
            $this->fetchmore = false;
        }

        $this->cursor = $cursor;
        $this->elements = $elements;
    }

    /**
     * Extracts next values for key() and current().
     */
    protected function extractNext()
    {
        ++$this->position;
        $this->current = array_shift($this->elements);
    }

    /**
     * @return void
     */
    #[ReturnTypeWillChange]
    public function rewind()
    {
        $this->reset();
        $this->next();
    }

    /**
     * @return mixed
     */
    #[ReturnTypeWillChange]
    public function current()
    {
        return $this->current;
    }

    /**
     * @return int|null
     */
    #[ReturnTypeWillChange]
    public function key()
    {
        return $this->position;
    }

    /**
     * @return void
     */
    #[ReturnTypeWillChange]
    public function next()
    {
        tryFetch:
            if (!$this->elements && $this->fetchmore) {
                $this->fetch();
            }

        if ($this->elements) {
            $this->extractNext();
        } elseif ($this->cursor) {
            goto tryFetch;
        } else {
            $this->valid = false;
        }
    }

    /**
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function valid()
    {
        return $this->valid;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Collection\Iterator\HashKey.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use Predis\ClientInterface;

/**
 * Abstracts the iteration of fields and values of an hash by leveraging the
 * HSCAN command (Redis >= 2.8) wrapped in a fully-rewindable PHP iterator.
 *
 * @see http://redis.io/commands/scan
 */
class HashKey extends CursorBasedIterator
{
    protected $key;

    /**
     * {@inheritdoc}
     */
    public function __construct(ClientInterface $client, $key, $match = null, $count = null)
    {
        $this->requiredCommand($client, 'HSCAN');

        parent::__construct($client, $match, $count);

        $this->key = $key;
    }

    /**
     * {@inheritdoc}
     */
    protected function executeCommand()
    {
        return $this->client->hscan($this->key, $this->cursor, $this->getScanOptions());
    }

    /**
     * {@inheritdoc}
     */
    protected function extractNext()
    {
        $this->position = key($this->elements);
        $this->current = current($this->elements);

        unset($this->elements[$this->position]);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Collection\Iterator\Keyspace.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use Predis\ClientInterface;

/**
 * Abstracts the iteration of the keyspace on a Redis instance by leveraging the
 * SCAN command (Redis >= 2.8) wrapped in a fully-rewindable PHP iterator.
 *
 * @see http://redis.io/commands/scan
 */
class Keyspace extends CursorBasedIterator
{
    /**
     * {@inheritdoc}
     */
    public function __construct(ClientInterface $client, $match = null, $count = null)
    {
        $this->requiredCommand($client, 'SCAN');

        parent::__construct($client, $match, $count);
    }

    /**
     * {@inheritdoc}
     */
    protected function executeCommand()
    {
        return $this->client->scan($this->cursor, $this->getScanOptions());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Collection\Iterator\ListKey.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use InvalidArgumentException;
use Iterator;
use Predis\ClientInterface;
use Predis\NotSupportedException;
use ReturnTypeWillChange;

/**
 * Abstracts the iteration of items stored in a list by leveraging the LRANGE
 * command wrapped in a fully-rewindable PHP iterator.
 *
 * This iterator tries to emulate the behaviour of cursor-based iterators based
 * on the SCAN-family of commands introduced in Redis <= 2.8, meaning that due
 * to its incremental nature with multiple fetches it can only offer limited
 * guarantees on the returned elements because the collection can change several
 * times (trimmed, deleted, overwritten) during the iteration process.
 *
 * @see http://redis.io/commands/lrange
 */
class ListKey implements Iterator
{
    protected $client;
    protected $count;
    protected $key;

    protected $valid;
    protected $fetchmore;
    protected $elements;
    protected $position;
    protected $current;

    /**
     * @param ClientInterface $client Client connected to Redis.
     * @param string          $key    Redis list key.
     * @param int             $count  Number of items retrieved on each fetch operation.
     *
     * @throws InvalidArgumentException
     */
    public function __construct(ClientInterface $client, $key, $count = 10)
    {
        $this->requiredCommand($client, 'LRANGE');

        if ((false === $count = filter_var($count, FILTER_VALIDATE_INT)) || $count < 0) {
            throw new InvalidArgumentException('The $count argument must be a positive integer.');
        }

        $this->client = $client;
        $this->key = $key;
        $this->count = $count;

        $this->reset();
    }

    /**
     * Ensures that the client instance supports the specified Redis command
     * required to fetch elements from the server to perform the iteration.
     *
     * @param ClientInterface $client    Client connected to Redis.
     * @param string          $commandID Command ID.
     *
     * @throws NotSupportedException
     */
    protected function requiredCommand(ClientInterface $client, $commandID)
    {
        if (!$client->getCommandFactory()->supports($commandID)) {
            throw new NotSupportedException("'$commandID' is not supported by the current command factory.");
        }
    }

    /**
     * Resets the inner state of the iterator.
     */
    protected function reset()
    {
        $this->valid = true;
        $this->fetchmore = true;
        $this->elements = [];
        $this->position = -1;
        $this->current = null;
    }

    /**
     * Fetches a new set of elements from the remote collection, effectively
     * advancing the iteration process.
     *
     * @return array
     */
    protected function executeCommand()
    {
        return $this->client->lrange($this->key, $this->position + 1, $this->position + $this->count);
    }

    /**
     * Populates the local buffer of elements fetched from the server during the
     * iteration.
     */
    protected function fetch()
    {
        $elements = $this->executeCommand();

        if (count($elements) < $this->count) {
            $this->fetchmore = false;
        }

        $this->elements = $elements;
    }

    /**
     * Extracts next values for key() and current().
     */
    protected function extractNext()
    {
        ++$this->position;
        $this->current = array_shift($this->elements);
    }

    /**
     * @return void
     */
    #[ReturnTypeWillChange]
    public function rewind()
    {
        $this->reset();
        $this->next();
    }

    /**
     * @return mixed
     */
    #[ReturnTypeWillChange]
    public function current()
    {
        return $this->current;
    }

    /**
     * @return int|null
     */
    #[ReturnTypeWillChange]
    public function key()
    {
        return $this->position;
    }

    /**
     * @return void
     */
    #[ReturnTypeWillChange]
    public function next()
    {
        if (!$this->elements && $this->fetchmore) {
            $this->fetch();
        }

        if ($this->elements) {
            $this->extractNext();
        } else {
            $this->valid = false;
        }
    }

    /**
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function valid()
    {
        return $this->valid;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Collection\Iterator\SetKey.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use Predis\ClientInterface;

/**
 * Abstracts the iteration of members stored in a set by leveraging the SSCAN
 * command (Redis >= 2.8) wrapped in a fully-rewindable PHP iterator.
 *
 * @see http://redis.io/commands/scan
 */
class SetKey extends CursorBasedIterator
{
    protected $key;

    /**
     * {@inheritdoc}
     */
    public function __construct(ClientInterface $client, $key, $match = null, $count = null)
    {
        $this->requiredCommand($client, 'SSCAN');

        parent::__construct($client, $match, $count);

        $this->key = $key;
    }

    /**
     * {@inheritdoc}
     */
    protected function executeCommand()
    {
        return $this->client->sscan($this->key, $this->cursor, $this->getScanOptions());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Collection\Iterator\SortedSetKey.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use Predis\ClientInterface;

/**
 * Abstracts the iteration of members stored in a sorted set by leveraging the
 * ZSCAN command (Redis >= 2.8) wrapped in a fully-rewindable PHP iterator.
 *
 * @see http://redis.io/commands/scan
 */
class SortedSetKey extends CursorBasedIterator
{
    protected $key;

    /**
     * {@inheritdoc}
     */
    public function __construct(ClientInterface $client, $key, $match = null, $count = null)
    {
        $this->requiredCommand($client, 'ZSCAN');

        parent::__construct($client, $match, $count);

        $this->key = $key;
    }

    /**
     * {@inheritdoc}
     */
    protected function executeCommand()
    {
        return $this->client->zscan($this->key, $this->cursor, $this->getScanOptions());
    }

    /**
     * {@inheritdoc}
     */
    protected function extractNext()
    {
        $this->position = key($this->elements);
        $this->current = current($this->elements);

        unset($this->elements[$this->position]);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Command.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

/**
 * Base class for Redis commands.
 */
abstract class Command implements CommandInterface
{
    private $slot;
    private $arguments = [];

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $this->arguments = $arguments;
        unset($this->slot);
    }

    /**
     * {@inheritdoc}
     */
    public function setRawArguments(array $arguments)
    {
        $this->arguments = $arguments;
        unset($this->slot);
    }

    /**
     * {@inheritdoc}
     */
    public function getArguments()
    {
        return $this->arguments;
    }

    /**
     * {@inheritdoc}
     */
    public function getArgument($index)
    {
        if (isset($this->arguments[$index])) {
            return $this->arguments[$index];
        }
    }

    /**
     * {@inheritdoc}
     */
    public function setSlot($slot)
    {
        $this->slot = $slot;
    }

    /**
     * {@inheritdoc}
     */
    public function getSlot()
    {
        return $this->slot ?? null;
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        return $data;
    }

    /**
     * Normalizes the arguments array passed to a Redis command.
     *
     * @param array $arguments Arguments for a command.
     *
     * @return array
     */
    public static function normalizeArguments(array $arguments)
    {
        if (count($arguments) === 1 && isset($arguments[0]) && is_array($arguments[0])) {
            return $arguments[0];
        }

        return $arguments;
    }

    /**
     * Normalizes the arguments array passed to a variadic Redis command.
     *
     * @param array $arguments Arguments for a command.
     *
     * @return array
     */
    public static function normalizeVariadic(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[1])) {
            return array_merge([$arguments[0]], $arguments[1]);
        }

        return $arguments;
    }

    /**
     * Remove all false values from arguments.
     *
     * @return void
     */
    public function filterArguments(): void
    {
        $this->arguments = array_filter($this->arguments, static function ($argument) {
            return $argument !== false && $argument !== null;
        });
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\CommandInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

/**
 * Defines an abstraction representing a Redis command.
 */
interface CommandInterface
{
    /**
     * Returns the ID of the Redis command. By convention, command identifiers
     * must always be uppercase.
     *
     * @return string
     */
    public function getId();

    /**
     * Assign the specified slot to the command for clustering distribution.
     *
     * @param int $slot Slot ID.
     */
    public function setSlot($slot);

    /**
     * Returns the assigned slot of the command for clustering distribution.
     *
     * @return int|null
     */
    public function getSlot();

    /**
     * Sets the arguments for the command.
     *
     * @param array $arguments List of arguments.
     */
    public function setArguments(array $arguments);

    /**
     * Sets the raw arguments for the command without processing them.
     *
     * @param array $arguments List of arguments.
     */
    public function setRawArguments(array $arguments);

    /**
     * Gets the arguments of the command.
     *
     * @return array
     */
    public function getArguments();

    /**
     * Gets the argument of the command at the specified index.
     *
     * @param int $index Index of the desired argument.
     *
     * @return mixed|null
     */
    public function getArgument($index);

    /**
     * Parses a raw response and returns a PHP object.
     *
     * @param string|array|null $data Binary string containing the whole response.
     *
     * @return mixed
     */
    public function parseResponse($data);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Factory.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

use InvalidArgumentException;
use Predis\ClientException;
use Predis\Command\Processor\ProcessorInterface;

/**
 * Base command factory class.
 *
 * This class provides all of the common functionalities required for a command
 * factory to create new instances of Redis commands objects. It also allows to
 * define or undefine command handler classes for each command ID.
 */
abstract class Factory implements FactoryInterface
{
    protected $commands = [];
    protected $processor;

    /**
     * {@inheritdoc}
     */
    public function supports(string ...$commandIDs): bool
    {
        foreach ($commandIDs as $commandID) {
            if ($this->getCommandClass($commandID) === null) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns the FQCN of a class that represents the specified command ID.
     *
     * @codeCoverageIgnore
     *
     * @param string $commandID Command ID
     *
     * @return string|null
     */
    public function getCommandClass(string $commandID): ?string
    {
        return $this->commands[strtoupper($commandID)] ?? null;
    }

    /**
     * {@inheritdoc}
     */
    public function create(string $commandID, array $arguments = []): CommandInterface
    {
        if (!$commandClass = $this->getCommandClass($commandID)) {
            $commandID = strtoupper($commandID);

            throw new ClientException("Command `$commandID` is not a registered Redis command.");
        }

        $command = new $commandClass();
        $command->setArguments($arguments);

        if (isset($this->processor)) {
            $this->processor->process($command);
        }

        return $command;
    }

    /**
     * Defines a command in the factory.
     *
     * Only classes implementing Predis\Command\CommandInterface are allowed to
     * handle a command. If the command specified by its ID is already handled
     * by the factory, the underlying command class is replaced by the new one.
     *
     * @param string $commandID    Command ID
     * @param string $commandClass FQCN of a class implementing Predis\Command\CommandInterface
     *
     * @throws InvalidArgumentException
     */
    public function define(string $commandID, string $commandClass): void
    {
        if (!is_a($commandClass, 'Predis\Command\CommandInterface', true)) {
            throw new InvalidArgumentException(
                "Class $commandClass must implement Predis\Command\CommandInterface"
            );
        }

        $this->commands[strtoupper($commandID)] = $commandClass;
    }

    /**
     * Undefines a command in the factory.
     *
     * When the factory already has a class handler associated to the specified
     * command ID it is removed from the map of known commands. Nothing happens
     * when the command is not handled by the factory.
     *
     * @param string $commandID Command ID
     */
    public function undefine(string $commandID): void
    {
        unset($this->commands[strtoupper($commandID)]);
    }

    /**
     * Sets a command processor for processing command arguments.
     *
     * Command processors are used to process and transform arguments of Redis
     * commands before their newly created instances are returned to the caller
     * of "create()".
     *
     * A NULL value can be used to effectively unset any processor if previously
     * set for the command factory.
     *
     * @param ProcessorInterface|null $processor Command processor or NULL value.
     */
    public function setProcessor(?ProcessorInterface $processor): void
    {
        $this->processor = $processor;
    }

    /**
     * Returns the current command processor.
     *
     * @return ProcessorInterface|null
     */
    public function getProcessor(): ?ProcessorInterface
    {
        return $this->processor;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\FactoryInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

/**
 * Command factory interface.
 *
 * A command factory is used through the library to create instances of commands
 * classes implementing Predis\Command\CommandInterface mapped to Redis commands
 * by their command ID string (SET, GET, etc...).
 */
interface FactoryInterface
{
    /**
     * Checks if the command factory supports the specified list of commands.
     *
     * @param string ...$commandIDs List of command IDs
     *
     * @return bool
     */
    public function supports(string ...$commandIDs): bool;

    /**
     * Creates a new command instance.
     *
     * @param string $commandID Command ID
     * @param array  $arguments Arguments for the command
     *
     * @return CommandInterface
     */
    public function create(string $commandID, array $arguments = []): CommandInterface;
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\PrefixableCommandInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

/**
 * Defines a command whose keys can be prefixed.
 */
interface PrefixableCommandInterface extends CommandInterface
{
    /**
     * Prefixes all the keys found in the arguments of the command.
     *
     * @param string $prefix String used to prefix the keys.
     */
    public function prefixKeys($prefix);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\RawCommand.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

/**
 * Class representing a generic Redis command.
 *
 * Arguments and responses for these commands are not normalized and they follow
 * what is defined by the Redis documentation.
 *
 * Raw commands can be useful when implementing higher level abstractions on top
 * of Predis\Client or managing internals like Redis Sentinel or Cluster as they
 * are not potentially subject to hijacking from third party libraries when they
 * override command handlers for standard Redis commands.
 */
final class RawCommand implements CommandInterface
{
    private $slot;
    private $commandID;
    private $arguments;

    /**
     * @param string $commandID Command ID
     * @param array  $arguments Command arguments
     */
    public function __construct($commandID, array $arguments = [])
    {
        $this->commandID = strtoupper($commandID);
        $this->setArguments($arguments);
    }

    /**
     * Creates a new raw command using a variadic method.
     *
     * @param string $commandID Redis command ID
     * @param string ...$args   Arguments list for the command
     *
     * @return CommandInterface
     */
    public static function create($commandID, ...$args)
    {
        $arguments = func_get_args();

        return new static(array_shift($arguments), $arguments);
    }

    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return $this->commandID;
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $this->arguments = $arguments;
        unset($this->slot);
    }

    /**
     * {@inheritdoc}
     */
    public function setRawArguments(array $arguments)
    {
        $this->setArguments($arguments);
    }

    /**
     * {@inheritdoc}
     */
    public function getArguments()
    {
        return $this->arguments;
    }

    /**
     * {@inheritdoc}
     */
    public function getArgument($index)
    {
        if (isset($this->arguments[$index])) {
            return $this->arguments[$index];
        }
    }

    /**
     * {@inheritdoc}
     */
    public function setSlot($slot)
    {
        $this->slot = $slot;
    }

    /**
     * {@inheritdoc}
     */
    public function getSlot()
    {
        return $this->slot ?? null;
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\RawFactory.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

/**
 * Command factory creating raw command instances out of command IDs.
 *
 * Any command ID will produce a command instance even for unknown commands that
 * are not implemented by Redis (the server will return a "-ERR unknown command"
 * error responses).
 *
 * When using this factory the client does not process arguments before sending
 * commands to Redis and server responses are not further processed before being
 * returned to the caller.
 */
class RawFactory implements FactoryInterface
{
    /**
     * {@inheritdoc}
     */
    public function supports(string ...$commandIDs): bool
    {
        return true;
    }

    /**
     * {@inheritdoc}
     */
    public function create(string $commandID, array $arguments = []): CommandInterface
    {
        return new RawCommand($commandID, $arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\RedisFactory.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

use Predis\ClientConfiguration;
use Predis\Command\Redis\FUNCTIONS;

/**
 * Command factory for mainline Redis servers.
 *
 * This factory is intended to handle standard commands implemented by mainline
 * Redis servers. By default it maps a command ID to a specific command handler
 * class in the Predis\Command\Redis namespace but this can be overridden for
 * any command ID simply by defining a new command handler class implementing
 * Predis\Command\CommandInterface.
 */
class RedisFactory extends Factory
{
    private const COMMANDS_NAMESPACE = "Predis\Command\Redis";

    public function __construct()
    {
        $this->commands = [
            'ECHO' => 'Predis\Command\Redis\ECHO_',
            'EVAL' => 'Predis\Command\Redis\EVAL_',
            'OBJECT' => 'Predis\Command\Redis\OBJECT_',
            // Class name corresponds to PHP reserved word "function", added mapping to bypass restrictions
            'FUNCTION' => FUNCTIONS::class,
        ];
    }

    /**
     * {@inheritdoc}
     */
    public function getCommandClass(string $commandID): ?string
    {
        $commandID = strtoupper($commandID);

        if (isset($this->commands[$commandID]) || array_key_exists($commandID, $this->commands)) {
            return $this->commands[$commandID];
        }

        $commandClass = $this->resolve($commandID);

        if (null === $commandClass) {
            return null;
        }

        $this->commands[$commandID] = $commandClass;

        return $commandClass;
    }

    /**
     * {@inheritdoc}
     */
    public function undefine(string $commandID): void
    {
        // NOTE: we explicitly associate `NULL` to the command ID in the map
        // instead of the parent's `unset()` because our subclass tries to load
        // a predefined class from the Predis\Command\Redis namespace when no
        // explicit mapping is defined, see RedisFactory::getCommandClass() for
        // details of the implementation of this mechanism.
        $this->commands[strtoupper($commandID)] = null;
    }

    /**
     * Resolves command object from given command ID.
     *
     * @param  string      $commandID Command ID of virtual method call
     * @return string|null FQDN of corresponding command object
     */
    private function resolve(string $commandID): ?string
    {
        if (class_exists($commandClass = self::COMMANDS_NAMESPACE . '\\' . $commandID)) {
            return $commandClass;
        }

        $commandModule = $this->resolveCommandModuleByPrefix($commandID);

        if (null === $commandModule) {
            return null;
        }

        if (class_exists($commandClass = self::COMMANDS_NAMESPACE . '\\' . $commandModule . '\\' . $commandID)) {
            return $commandClass;
        }

        return null;
    }

    private function resolveCommandModuleByPrefix(string $commandID): ?string
    {
        foreach (ClientConfiguration::getModules() as $module) {
            if (preg_match("/^{$module['commandPrefix']}/", $commandID)) {
                return $module['name'];
            }
        }

        return null;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\ScriptCommand.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

/**
 * Base class used to implement an higher level abstraction for commands based
 * on Lua scripting with EVAL and EVALSHA.
 *
 * @see http://redis.io/commands/eval
 */
abstract class ScriptCommand extends Command
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'EVALSHA';
    }

    /**
     * Gets the body of a Lua script.
     *
     * @return string
     */
    abstract public function getScript();

    /**
     * Calculates the SHA1 hash of the body of the script.
     *
     * @return string SHA1 hash.
     */
    public function getScriptHash()
    {
        return sha1($this->getScript());
    }

    /**
     * Specifies the number of arguments that should be considered as keys.
     *
     * The default behaviour for the base class is to return 0 to indicate that
     * all the elements of the arguments array should be considered as keys, but
     * subclasses can enforce a static number of keys.
     *
     * @return int
     */
    protected function getKeysCount()
    {
        return 0;
    }

    /**
     * Returns the elements from the arguments that are identified as keys.
     *
     * @return array
     */
    public function getKeys()
    {
        return array_slice($this->getArguments(), 2, $this->getKeysCount());
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (($numkeys = $this->getKeysCount()) && $numkeys < 0) {
            $numkeys = count($arguments) + $numkeys;
        }

        $arguments = array_merge([$this->getScriptHash(), (int) $numkeys], $arguments);

        parent::setArguments($arguments);
    }

    /**
     * Returns arguments for EVAL command.
     *
     * @return array
     */
    public function getEvalArguments()
    {
        $arguments = $this->getArguments();
        $arguments[0] = $this->getScript();

        return $arguments;
    }

    /**
     * Returns the equivalent EVAL command as a raw command instance.
     *
     * @return RawCommand
     */
    public function getEvalCommand()
    {
        return new RawCommand('EVAL', $this->getEvalArguments());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\ArrayableArgument.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument;

/**
 * Allows to use object-oriented approach to handle complex conditional arguments.
 */
interface ArrayableArgument
{
    /**
     * Get the instance as an array.
     *
     * @return array
     */
    public function toArray(): array;
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Geospatial\AbstractBy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Geospatial;

use UnexpectedValueException;

abstract class AbstractBy implements ByInterface
{
    /**
     * @var string[]
     */
    private static $unitEnum = ['m', 'km', 'ft', 'mi'];

    /**
     * @var string
     */
    protected $unit;

    /**
     * {@inheritDoc}
     */
    abstract public function toArray(): array;

    /**
     * @param  string $unit
     * @return void
     */
    protected function setUnit(string $unit): void
    {
        if (!in_array($unit, self::$unitEnum, true)) {
            throw new UnexpectedValueException('Wrong value given for unit');
        }

        $this->unit = $unit;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Geospatial\ByBox.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Geospatial;

class ByBox extends AbstractBy
{
    private const KEYWORD = 'BYBOX';

    /**
     * @var int
     */
    private $width;

    /**
     * @var int
     */
    private $height;

    public function __construct(int $width, int $height, string $unit)
    {
        $this->width = $width;
        $this->height = $height;
        $this->setUnit($unit);
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return [self::KEYWORD, $this->width, $this->height, $this->unit];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Geospatial\ByInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Geospatial;

use Predis\Command\Argument\ArrayableArgument;

interface ByInterface extends ArrayableArgument
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Geospatial\ByRadius.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Geospatial;

class ByRadius extends AbstractBy
{
    private const KEYWORD = 'BYRADIUS';

    /**
     * @var int
     */
    private $radius;

    public function __construct(int $radius, string $unit)
    {
        $this->radius = $radius;
        $this->setUnit($unit);
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return [self::KEYWORD, $this->radius, $this->unit];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Geospatial\FromInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Geospatial;

use Predis\Command\Argument\ArrayableArgument;

interface FromInterface extends ArrayableArgument
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Geospatial\FromLonLat.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Geospatial;

class FromLonLat implements FromInterface
{
    private const KEYWORD = 'FROMLONLAT';

    /**
     * @var float
     */
    private $longitude;

    /**
     * @var float
     */
    private $latitude;

    public function __construct(float $longitude, float $latitude)
    {
        $this->longitude = $longitude;
        $this->latitude = $latitude;
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return [self::KEYWORD, $this->longitude, $this->latitude];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Geospatial\FromMember.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Geospatial;

class FromMember implements FromInterface
{
    private const KEYWORD = 'FROMMEMBER';

    /**
     * @var string
     */
    private $member;

    public function __construct(string $member)
    {
        $this->member = $member;
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return [self::KEYWORD, $this->member];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\AggregateArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

class AggregateArguments extends CommonArguments
{
    /**
     * @var string[]
     */
    private $sortingEnum = [
        'asc' => 'ASC',
        'desc' => 'DESC',
    ];

    /**
     * Loads document attributes from the source document.
     *
     * @param  string ...$fields Could be just '*' to load all fields
     * @return $this
     */
    public function load(string ...$fields): self
    {
        $arguments = func_get_args();

        $this->arguments[] = 'LOAD';

        if ($arguments[0] === '*') {
            $this->arguments[] = '*';

            return $this;
        }

        $this->arguments[] = count($arguments);
        $this->arguments = array_merge($this->arguments, $arguments);

        return $this;
    }

    /**
     * Loads document attributes from the source document.
     *
     * @param  string ...$properties
     * @return $this
     */
    public function groupBy(string ...$properties): self
    {
        $arguments = func_get_args();

        array_push($this->arguments, 'GROUPBY', count($arguments));
        $this->arguments = array_merge($this->arguments, $arguments);

        return $this;
    }

    /**
     * Groups the results in the pipeline based on one or more properties.
     *
     * If you want to add alias property to your argument just add "true" value in arguments enumeration,
     * next value will be considered as alias to previous one.
     *
     * Example: 'argument', true, 'name' => 'argument' AS 'name'
     *
     * @param  string      $function
     * @param  string|bool ...$argument
     * @return $this
     */
    public function reduce(string $function, ...$argument): self
    {
        $arguments = func_get_args();
        $functionValue = array_shift($arguments);
        $argumentsCounter = 0;

        for ($i = 0, $iMax = count($arguments); $i < $iMax; $i++) {
            if (true === $arguments[$i]) {
                $arguments[$i] = 'AS';
                $i++;
                continue;
            }

            $argumentsCounter++;
        }

        array_push($this->arguments, 'REDUCE', $functionValue);
        $this->arguments = array_merge($this->arguments, [$argumentsCounter], $arguments);

        return $this;
    }

    /**
     * Sorts the pipeline up until the point of SORTBY, using a list of properties.
     *
     * @param  int    $max
     * @param  string ...$properties Enumeration of properties, including sorting direction (ASC, DESC)
     * @return $this
     */
    public function sortBy(int $max = 0, ...$properties): self
    {
        $arguments = func_get_args();
        $maxValue = array_shift($arguments);

        $this->arguments[] = 'SORTBY';
        $this->arguments = array_merge($this->arguments, [count($arguments)], $arguments);

        if ($maxValue !== 0) {
            array_push($this->arguments, 'MAX', $maxValue);
        }

        return $this;
    }

    /**
     * Applies a 1-to-1 transformation on one or more properties and either stores the result
     * as a new property down the pipeline or replaces any property using this transformation.
     *
     * @param  string $expression
     * @param  string $as
     * @return $this
     */
    public function apply(string $expression, string $as = ''): self
    {
        array_push($this->arguments, 'APPLY', $expression);

        if ($as !== '') {
            array_push($this->arguments, 'AS', $as);
        }

        return $this;
    }

    /**
     * Scan part of the results with a quicker alternative than LIMIT.
     *
     * @param  int   $readSize
     * @param  int   $idleTime
     * @return $this
     */
    public function withCursor(int $readSize = 0, int $idleTime = 0): self
    {
        $this->arguments[] = 'WITHCURSOR';

        if ($readSize !== 0) {
            array_push($this->arguments, 'COUNT', $readSize);
        }

        if ($idleTime !== 0) {
            array_push($this->arguments, 'MAXIDLE', $idleTime);
        }

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\AlterArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

class AlterArguments extends CommonArguments
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\CommonArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use Predis\Command\Argument\ArrayableArgument;

class CommonArguments implements ArrayableArgument
{
    /**
     * @var array
     */
    protected $arguments = [];

    /**
     * Adds default language for documents within an index.
     *
     * @param  string $defaultLanguage
     * @return $this
     */
    public function language(string $defaultLanguage = 'english'): self
    {
        $this->arguments[] = 'LANGUAGE';
        $this->arguments[] = $defaultLanguage;

        return $this;
    }

    /**
     * Selects the dialect version under which to execute the query.
     * If not specified, the query will execute under the default dialect version
     * set during module initial loading or via FT.CONFIG SET command.
     *
     * @param  string $dialect
     * @return $this
     */
    public function dialect(string $dialect): self
    {
        $this->arguments[] = 'DIALECT';
        $this->arguments[] = $dialect;

        return $this;
    }

    /**
     * If set, does not scan and index.
     *
     * @return $this
     */
    public function skipInitialScan(): self
    {
        $this->arguments[] = 'SKIPINITIALSCAN';

        return $this;
    }

    /**
     * Adds an arbitrary, binary safe payload that is exposed to custom scoring functions.
     *
     * @param  string $payload
     * @return $this
     */
    public function payload(string $payload): self
    {
        $this->arguments[] = 'PAYLOAD';
        $this->arguments[] = $payload;

        return $this;
    }

    /**
     * Also returns the relative internal score of each document.
     *
     * @return $this
     */
    public function withScores(): self
    {
        $this->arguments[] = 'WITHSCORES';

        return $this;
    }

    /**
     * Retrieves optional document payloads.
     *
     * @return $this
     */
    public function withPayloads(): self
    {
        $this->arguments[] = 'WITHPAYLOADS';

        return $this;
    }

    /**
     * Does not try to use stemming for query expansion but searches the query terms verbatim.
     *
     * @return $this
     */
    public function verbatim(): self
    {
        $this->arguments[] = 'VERBATIM';

        return $this;
    }

    /**
     * Overrides the timeout parameter of the module.
     *
     * @param  int   $timeout
     * @return $this
     */
    public function timeout(int $timeout): self
    {
        $this->arguments[] = 'TIMEOUT';
        $this->arguments[] = $timeout;

        return $this;
    }

    /**
     * Adds an arbitrary, binary safe payload that is exposed to custom scoring functions.
     *
     * @param  int   $offset
     * @param  int   $num
     * @return $this
     */
    public function limit(int $offset, int $num): self
    {
        array_push($this->arguments, 'LIMIT', $offset, $num);

        return $this;
    }

    /**
     * Adds filter expression into index.
     *
     * @param  string $filter
     * @return $this
     */
    public function filter(string $filter): self
    {
        $this->arguments[] = 'FILTER';
        $this->arguments[] = $filter;

        return $this;
    }

    /**
     * Defines one or more value parameters. Each parameter has a name and a value.
     *
     * Example: ['name1', 'value1', 'name2', 'value2'...]
     *
     * @param  array $nameValuesDictionary
     * @return $this
     */
    public function params(array $nameValuesDictionary): self
    {
        $this->arguments[] = 'PARAMS';
        $this->arguments[] = count($nameValuesDictionary);
        $this->arguments = array_merge($this->arguments, $nameValuesDictionary);

        return $this;
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return $this->arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\CreateArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use InvalidArgumentException;

class CreateArguments extends CommonArguments
{
    /**
     * @var string[]
     */
    private $supportedDataTypesEnum = [
        'hash' => 'HASH',
        'json' => 'JSON',
    ];

    /**
     * Specify data type for given index. To index JSON you must have the RedisJSON module to be installed.
     *
     * @param  string $modifier
     * @return $this
     */
    public function on(string $modifier = 'HASH'): self
    {
        if (in_array(strtoupper($modifier), $this->supportedDataTypesEnum)) {
            $this->arguments[] = 'ON';
            $this->arguments[] = $this->supportedDataTypesEnum[strtolower($modifier)];

            return $this;
        }

        $enumValues = implode(', ', array_values($this->supportedDataTypesEnum));
        throw new InvalidArgumentException("Wrong modifier value given. Currently supports: {$enumValues}");
    }

    /**
     * Adds one or more prefixes into index.
     *
     * @param  array $prefixes
     * @return $this
     */
    public function prefix(array $prefixes): self
    {
        $this->arguments[] = 'PREFIX';
        $this->arguments[] = count($prefixes);
        $this->arguments = array_merge($this->arguments, $prefixes);

        return $this;
    }

    /**
     * Document attribute set as document language.
     *
     * @param  string $languageAttribute
     * @return $this
     */
    public function languageField(string $languageAttribute): self
    {
        $this->arguments[] = 'LANGUAGE_FIELD';
        $this->arguments[] = $languageAttribute;

        return $this;
    }

    /**
     * Default score for documents in the index.
     *
     * @param  float $defaultScore
     * @return $this
     */
    public function score(float $defaultScore = 1.0): self
    {
        $this->arguments[] = 'SCORE';
        $this->arguments[] = $defaultScore;

        return $this;
    }

    /**
     * Document attribute that used as the document rank based on the user ranking.
     *
     * @param  string $scoreAttribute
     * @return $this
     */
    public function scoreField(string $scoreAttribute): self
    {
        $this->arguments[] = 'SCORE_FIELD';
        $this->arguments[] = $scoreAttribute;

        return $this;
    }

    /**
     * Forces RediSearch to encode indexes as if there were more than 32 text attributes.
     *
     * @return $this
     */
    public function maxTextFields(): self
    {
        $this->arguments[] = 'MAXTEXTFIELDS';

        return $this;
    }

    /**
     * Does not store term offsets for documents.
     *
     * @return $this
     */
    public function noOffsets(): self
    {
        $this->arguments[] = 'NOOFFSETS';

        return $this;
    }

    /**
     * Creates a lightweight temporary index that expires after a specified period of inactivity, in seconds.
     *
     * @param  int   $seconds
     * @return $this
     */
    public function temporary(int $seconds): self
    {
        $this->arguments[] = 'TEMPORARY';
        $this->arguments[] = $seconds;

        return $this;
    }

    /**
     * Conserves storage space and memory by disabling highlighting support.
     *
     * @return $this
     */
    public function noHl(): self
    {
        $this->arguments[] = 'NOHL';

        return $this;
    }

    /**
     * Does not store attribute bits for each term.
     *
     * @return $this
     */
    public function noFields(): self
    {
        $this->arguments[] = 'NOFIELDS';

        return $this;
    }

    /**
     * Avoids saving the term frequencies in the index.
     *
     * @return $this
     */
    public function noFreqs(): self
    {
        $this->arguments[] = 'NOFREQS';

        return $this;
    }

    /**
     * Sets the index with a custom stopword list, to be ignored during indexing and search time.
     *
     * @param  array $stopWords
     * @return $this
     */
    public function stopWords(array $stopWords): self
    {
        $this->arguments[] = 'STOPWORDS';
        $this->arguments[] = count($stopWords);
        $this->arguments = array_merge($this->arguments, $stopWords);

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\CursorArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use Predis\Command\Argument\ArrayableArgument;

class CursorArguments implements ArrayableArgument
{
    /**
     * @var array
     */
    protected $arguments = [];

    /**
     * Is number of results to read. This parameter overrides COUNT specified in FT.AGGREGATE.
     *
     * @param  int   $readSize
     * @return $this
     */
    public function count(int $readSize): self
    {
        array_push($this->arguments, 'COUNT', $readSize);

        return $this;
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return $this->arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\DropArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use Predis\Command\Argument\ArrayableArgument;

class DropArguments implements ArrayableArgument
{
    /**
     * @var array
     */
    protected $arguments = [];

    /**
     * Drop operation that, if set, deletes the actual document hashes.
     *
     * @return $this
     */
    public function dd(): self
    {
        $this->arguments[] = 'DD';

        return $this;
    }

    /**
     * @return array
     */
    public function toArray(): array
    {
        return $this->arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\ExplainArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

class ExplainArguments extends CommonArguments
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\ProfileArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use Predis\Command\Argument\ArrayableArgument;

class ProfileArguments implements ArrayableArgument
{
    /**
     * @var array
     */
    protected $arguments = [];

    /**
     * Adds search context.
     *
     * @return $this
     */
    public function search(): self
    {
        $this->arguments[] = 'SEARCH';

        return $this;
    }

    /**
     * Adds aggregate context.
     *
     * @return $this
     */
    public function aggregate(): self
    {
        $this->arguments[] = 'AGGREGATE';

        return $this;
    }

    /**
     * Removes details of reader iterator.
     *
     * @return $this
     */
    public function limited(): self
    {
        $this->arguments[] = 'LIMITED';

        return $this;
    }

    /**
     * Is query string, as if sent to FT.SEARCH.
     *
     * @param  string $query
     * @return $this
     */
    public function query(string $query): self
    {
        $this->arguments[] = 'QUERY';
        $this->arguments[] = $query;

        return $this;
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return $this->arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SearchArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use InvalidArgumentException;

class SearchArguments extends CommonArguments
{
    /**
     * @var string[]
     */
    private $sortingEnum = [
        'asc' => 'ASC',
        'desc' => 'DESC',
    ];

    /**
     * Returns the document ids and not the content.
     *
     * @return $this
     */
    public function noContent(): self
    {
        $this->arguments[] = 'NOCONTENT';

        return $this;
    }

    /**
     * Returns the value of the sorting key, right after the id and score and/or payload, if requested.
     *
     * @return $this
     */
    public function withSortKeys(): self
    {
        $this->arguments[] = 'WITHSORTKEYS';

        return $this;
    }

    /**
     * Limits results to those having numeric values ranging between min and max,
     * if numeric_attribute is defined as a numeric attribute in FT.CREATE.
     * Min and max follow ZRANGE syntax, and can be -inf, +inf, and use( for exclusive ranges.
     * Multiple numeric filters for different attributes are supported in one query.
     *
     * @param  array ...$filter Should contain: numeric_field, min and max. Example: ['numeric_field', 1, 10]
     * @return $this
     */
    public function searchFilter(array ...$filter): self
    {
        $arguments = func_get_args();

        foreach ($arguments as $argument) {
            array_push($this->arguments, 'FILTER', ...$argument);
        }

        return $this;
    }

    /**
     * Filter the results to a given radius from lon and lat. Radius is given as a number and units.
     *
     * @param  array ...$filter Should contain: geo_field, lon, lat, radius, unit. Example: ['geo_field', 34.1231, 35.1231, 300, km]
     * @return $this
     */
    public function geoFilter(array ...$filter): self
    {
        $arguments = func_get_args();

        foreach ($arguments as $argument) {
            array_push($this->arguments, 'GEOFILTER', ...$argument);
        }

        return $this;
    }

    /**
     * Limits the result to a given set of keys specified in the list.
     *
     * @param  array $keys
     * @return $this
     */
    public function inKeys(array $keys): self
    {
        $this->arguments[] = 'INKEYS';
        $this->arguments[] = count($keys);
        $this->arguments = array_merge($this->arguments, $keys);

        return $this;
    }

    /**
     * Filters the results to those appearing only in specific attributes of the document, like title or URL.
     *
     * @param  array $fields
     * @return $this
     */
    public function inFields(array $fields): self
    {
        $this->arguments[] = 'INFIELDS';
        $this->arguments[] = count($fields);
        $this->arguments = array_merge($this->arguments, $fields);

        return $this;
    }

    /**
     * Limits the attributes returned from the document.
     * Num is the number of attributes following the keyword.
     * If num is 0, it acts like NOCONTENT.
     * Identifier is either an attribute name (for hashes and JSON) or a JSON Path expression (for JSON).
     * Property is an optional name used in the result. If not provided, the identifier is used in the result.
     *
     * If you want to add alias property to your identifier just add "true" value in identifier enumeration,
     * next value will be considered as alias to previous one.
     *
     * Example: 'identifier', true, 'property' => 'identifier' AS 'property'
     *
     * @param  int         $count
     * @param  string|bool ...$identifier
     * @return $this
     */
    public function addReturn(int $count, ...$identifier): self
    {
        $arguments = func_get_args();

        $this->arguments[] = 'RETURN';

        for ($i = 1, $iMax = count($arguments); $i < $iMax; $i++) {
            if (true === $arguments[$i]) {
                $arguments[$i] = 'AS';
            }
        }

        $this->arguments = array_merge($this->arguments, $arguments);

        return $this;
    }

    /**
     * Returns only the sections of the attribute that contain the matched text.
     *
     * @param  array  $fields
     * @param  int    $frags
     * @param  int    $len
     * @param  string $separator
     * @return $this
     */
    public function summarize(array $fields = [], int $frags = 0, int $len = 0, string $separator = ''): self
    {
        $this->arguments[] = 'SUMMARIZE';

        if (!empty($fields)) {
            $this->arguments[] = 'FIELDS';
            $this->arguments[] = count($fields);
            $this->arguments = array_merge($this->arguments, $fields);
        }

        if ($frags !== 0) {
            $this->arguments[] = 'FRAGS';
            $this->arguments[] = $frags;
        }

        if ($len !== 0) {
            $this->arguments[] = 'LEN';
            $this->arguments[] = $len;
        }

        if ($separator !== '') {
            $this->arguments[] = 'SEPARATOR';
            $this->arguments[] = $separator;
        }

        return $this;
    }

    /**
     * Formats occurrences of matched text.
     *
     * @param  array  $fields
     * @param  string $openTag
     * @param  string $closeTag
     * @return $this
     */
    public function highlight(array $fields = [], string $openTag = '', string $closeTag = ''): self
    {
        $this->arguments[] = 'HIGHLIGHT';

        if (!empty($fields)) {
            $this->arguments[] = 'FIELDS';
            $this->arguments[] = count($fields);
            $this->arguments = array_merge($this->arguments, $fields);
        }

        if ($openTag !== '' && $closeTag !== '') {
            array_push($this->arguments, 'TAGS', $openTag, $closeTag);
        }

        return $this;
    }

    /**
     * Allows a maximum of N intervening number of unmatched offsets between phrase terms.
     * In other words, the slop for exact phrases is 0.
     *
     * @param  int   $slop
     * @return $this
     */
    public function slop(int $slop): self
    {
        $this->arguments[] = 'SLOP';
        $this->arguments[] = $slop;

        return $this;
    }

    /**
     * Puts the query terms in the same order in the document as in the query, regardless of the offsets between them.
     * Typically used in conjunction with SLOP.
     *
     * @return $this
     */
    public function inOrder(): self
    {
        $this->arguments[] = 'INORDER';

        return $this;
    }

    /**
     * Uses a custom query expander instead of the stemmer.
     *
     * @param  string $expander
     * @return $this
     */
    public function expander(string $expander): self
    {
        $this->arguments[] = 'EXPANDER';
        $this->arguments[] = $expander;

        return $this;
    }

    /**
     * Uses a custom scoring function you define.
     *
     * @param  string $scorer
     * @return $this
     */
    public function scorer(string $scorer): self
    {
        $this->arguments[] = 'SCORER';
        $this->arguments[] = $scorer;

        return $this;
    }

    /**
     * Returns a textual description of how the scores were calculated.
     * Using this options requires the WITHSCORES option.
     *
     * @return $this
     */
    public function explainScore(): self
    {
        $this->arguments[] = 'EXPLAINSCORE';

        return $this;
    }

    /**
     * Orders the results by the value of this attribute.
     * This applies to both text and numeric attributes.
     * Attributes needed for SORTBY should be declared as SORTABLE in the index, in order to be available with very low latency.
     * Note that this adds memory overhead.
     *
     * @param  string $sortAttribute
     * @param  string $orderBy
     * @return $this
     */
    public function sortBy(string $sortAttribute, string $orderBy = 'asc'): self
    {
        $this->arguments[] = 'SORTBY';
        $this->arguments[] = $sortAttribute;

        if (in_array(strtoupper($orderBy), $this->sortingEnum)) {
            $this->arguments[] = $this->sortingEnum[strtolower($orderBy)];
        } else {
            $enumValues = implode(', ', array_values($this->sortingEnum));
            throw new InvalidArgumentException("Wrong order direction value given. Currently supports: {$enumValues}");
        }

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SpellcheckArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use InvalidArgumentException;

class SpellcheckArguments extends CommonArguments
{
    /**
     * @var string[]
     */
    private $termsEnum = [
        'include' => 'INCLUDE',
        'exclude' => 'EXCLUDE',
    ];

    /**
     * Is maximum Levenshtein distance for spelling suggestions (default: 1, max: 4).
     *
     * @return $this
     */
    public function distance(int $distance): self
    {
        $this->arguments[] = 'DISTANCE';
        $this->arguments[] = $distance;

        return $this;
    }

    /**
     * Specifies an inclusion (INCLUDE) or exclusion (EXCLUDE) of a custom dictionary named {dict}.
     *
     * @param  string $dictionary
     * @param  string $modifier
     * @param  string ...$terms
     * @return $this
     */
    public function terms(string $dictionary, string $modifier = 'INCLUDE', string ...$terms): self
    {
        if (!in_array(strtoupper($modifier), $this->termsEnum)) {
            $enumValues = implode(', ', array_values($this->termsEnum));
            throw new InvalidArgumentException("Wrong modifier value given. Currently supports: {$enumValues}");
        }

        array_push($this->arguments, 'TERMS', $this->termsEnum[strtolower($modifier)], $dictionary, ...$terms);

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SugAddArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

class SugAddArguments extends CommonArguments
{
    /**
     * Adds INCR modifier.
     *
     * @return $this
     */
    public function incr(): self
    {
        $this->arguments[] = 'INCR';

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SugGetArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

class SugGetArguments extends CommonArguments
{
    /**
     * Performs a fuzzy prefix search, including prefixes at Levenshtein distance of 1 from the prefix sent.
     *
     * @return $this
     */
    public function fuzzy(): self
    {
        $this->arguments[] = 'FUZZY';

        return $this;
    }

    /**
     * Limits the results to a maximum of num (default: 5).
     *
     * @param  int   $num
     * @return $this
     */
    public function max(int $num): self
    {
        array_push($this->arguments, 'MAX', $num);

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SynUpdateArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

class SynUpdateArguments extends CommonArguments
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SchemaFields\AbstractField.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

abstract class AbstractField implements FieldInterface
{
    public const SORTABLE = true;
    public const NOT_SORTABLE = false;
    public const SORTABLE_UNF = 'UNF';

    /**
     * @var array
     */
    protected $fieldArguments = [];

    /**
     * @param  string      $fieldType
     * @param  string      $identifier
     * @param  string      $alias
     * @param  bool|string $sortable
     * @param  bool        $noIndex
     * @param  bool        $allowsMissing
     * @return void
     */
    protected function setCommonOptions(
        string $fieldType,
        string $identifier,
        string $alias = '',
        $sortable = self::NOT_SORTABLE,
        bool $noIndex = false,
        bool $allowsMissing = false
    ): void {
        $this->fieldArguments[] = $identifier;

        if ($alias !== '') {
            $this->fieldArguments[] = 'AS';
            $this->fieldArguments[] = $alias;
        }

        $this->fieldArguments[] = $fieldType;

        if ($sortable === self::SORTABLE) {
            $this->fieldArguments[] = 'SORTABLE';
        } elseif ($sortable === self::SORTABLE_UNF) {
            $this->fieldArguments[] = 'SORTABLE';
            $this->fieldArguments[] = 'UNF';
        }

        if ($noIndex) {
            $this->fieldArguments[] = 'NOINDEX';
        }

        if ($allowsMissing) {
            $this->fieldArguments[] = 'INDEXMISSING';
        }
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return $this->fieldArguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SchemaFields\FieldInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

use Predis\Command\Argument\ArrayableArgument;

/**
 * Represents field in search schema.
 */
interface FieldInterface extends ArrayableArgument
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SchemaFields\GeoField.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

class GeoField extends AbstractField
{
    /**
     * @param string      $identifier
     * @param string      $alias
     * @param bool|string $sortable
     * @param bool        $noIndex
     * @param bool        $allowsMissing
     */
    public function __construct(
        string $identifier,
        string $alias = '',
        $sortable = self::NOT_SORTABLE,
        bool $noIndex = false,
        bool $allowsMissing = false
    ) {
        $this->setCommonOptions('GEO', $identifier, $alias, $sortable, $noIndex, $allowsMissing);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SchemaFields\GeoShapeField.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

class GeoShapeField extends AbstractField
{
    public const COORD_FLAT = 'FLAT';

    /**
     * @param string      $identifier
     * @param string      $alias
     * @param bool|string $sortable
     * @param bool        $noIndex
     * @param string|null $coordSystem Constants that represents available systems available on a class level.
     */
    public function __construct(
        string $identifier,
        string $alias = '',
        $sortable = self::NOT_SORTABLE,
        bool $noIndex = false,
        ?string $coordSystem = null
    ) {
        $this->fieldArguments[] = $identifier;

        if ($alias !== '') {
            $this->fieldArguments[] = 'AS';
            $this->fieldArguments[] = $alias;
        }

        $this->fieldArguments[] = 'GEOSHAPE';

        if (null !== $coordSystem) {
            $this->fieldArguments[] = $coordSystem;
        }

        if ($sortable === self::SORTABLE) {
            $this->fieldArguments[] = 'SORTABLE';
        } elseif ($sortable === self::SORTABLE_UNF) {
            $this->fieldArguments[] = 'SORTABLE';
            $this->fieldArguments[] = 'UNF';
        }

        if ($noIndex) {
            $this->fieldArguments[] = 'NOINDEX';
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SchemaFields\NumericField.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

class NumericField extends AbstractField
{
    /**
     * @param string      $identifier
     * @param string      $alias
     * @param bool|string $sortable
     * @param bool        $noIndex
     * @param bool        $allowsMissing
     */
    public function __construct(
        string $identifier,
        string $alias = '',
        $sortable = self::NOT_SORTABLE,
        bool $noIndex = false,
        bool $allowsMissing = false
    ) {
        $this->setCommonOptions('NUMERIC', $identifier, $alias, $sortable, $noIndex, $allowsMissing);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SchemaFields\TagField.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

class TagField extends AbstractField
{
    /**
     * @param string      $identifier
     * @param string      $alias
     * @param bool|string $sortable
     * @param bool        $noIndex
     * @param string      $separator
     * @param bool        $caseSensitive
     * @param bool        $allowsEmpty
     */
    public function __construct(
        string $identifier,
        string $alias = '',
        $sortable = self::NOT_SORTABLE,
        bool $noIndex = false,
        string $separator = ',',
        bool $caseSensitive = false,
        bool $allowsEmpty = false,
        bool $allowsMissing = false
    ) {
        $this->setCommonOptions('TAG', $identifier, $alias, $sortable, $noIndex, $allowsMissing);

        if ($separator !== ',') {
            $this->fieldArguments[] = 'SEPARATOR';
            $this->fieldArguments[] = $separator;
        }

        if ($caseSensitive) {
            $this->fieldArguments[] = 'CASESENSITIVE';
        }

        if ($allowsEmpty) {
            $this->fieldArguments[] = 'INDEXEMPTY';
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SchemaFields\TextField.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

class TextField extends AbstractField
{
    /**
     * @param string      $identifier
     * @param string      $alias
     * @param bool|string $sortable
     * @param bool        $noIndex
     * @param bool        $noStem
     * @param string      $phonetic
     * @param int         $weight
     * @param bool        $withSuffixTrie
     * @param bool        $allowsEmpty
     * @param bool        $allowsMissing
     */
    public function __construct(
        string $identifier,
        string $alias = '',
        $sortable = self::NOT_SORTABLE,
        bool $noIndex = false,
        bool $noStem = false,
        string $phonetic = '',
        int $weight = 1,
        bool $withSuffixTrie = false,
        bool $allowsEmpty = false,
        bool $allowsMissing = false
    ) {
        $this->setCommonOptions('TEXT', $identifier, $alias, $sortable, $noIndex, $allowsMissing);

        if ($noStem) {
            $this->fieldArguments[] = 'NOSTEM';
        }

        if ($phonetic !== '') {
            $this->fieldArguments[] = 'PHONETIC';
            $this->fieldArguments[] = $phonetic;
        }

        if ($weight !== 1) {
            $this->fieldArguments[] = 'WEIGHT';
            $this->fieldArguments[] = $weight;
        }

        if ($withSuffixTrie) {
            $this->fieldArguments[] = 'WITHSUFFIXTRIE';
        }

        if ($allowsEmpty) {
            $this->fieldArguments[] = 'INDEXEMPTY';
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Search\SchemaFields\VectorField.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

class VectorField extends AbstractField
{
    /**
     * @var array
     */
    protected $fieldArguments = [];

    /**
     * @param string $fieldName
     * @param string $algorithm
     * @param array  $attributeNameValueDictionary
     * @param string $alias
     */
    public function __construct(
        string $fieldName,
        string $algorithm,
        array $attributeNameValueDictionary,
        string $alias = ''
    ) {
        $this->setCommonOptions('VECTOR', $fieldName, $alias);

        array_push($this->fieldArguments, $algorithm, count($attributeNameValueDictionary));
        $this->fieldArguments = array_merge($this->fieldArguments, $attributeNameValueDictionary);
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return $this->fieldArguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Server\LimitInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Server;

use Predis\Command\Argument\ArrayableArgument;

interface LimitInterface extends ArrayableArgument
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Server\LimitOffsetCount.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Server;

class LimitOffsetCount implements LimitInterface
{
    private const KEYWORD = 'LIMIT';

    /**
     * @var int
     */
    private $offset;

    /**
     * @var int
     */
    private $count;

    public function __construct(int $offset, int $count)
    {
        $this->offset = $offset;
        $this->count = $count;
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return [self::KEYWORD, $this->offset, $this->count];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\Server\To.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Server;

use Predis\Command\Argument\ArrayableArgument;

class To implements ArrayableArgument
{
    private const KEYWORD = 'TO';
    private const FORCE_KEYWORD = 'FORCE';

    /**
     * @var string
     */
    private $host;

    /**
     * @var int
     */
    private $port;

    /**
     * @var bool
     */
    private $isForce;

    public function __construct(string $host, int $port, bool $isForce = false)
    {
        $this->host = $host;
        $this->port = $port;
        $this->isForce = $isForce;
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        $arguments = [self::KEYWORD, $this->host, $this->port];

        if ($this->isForce) {
            $arguments[] = self::FORCE_KEYWORD;
        }

        return $arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\AddArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

class AddArguments extends CommonArguments
{
    /**
     * Is overwrite key and database configuration for DUPLICATE_POLICY,
     * the policy for handling samples with identical timestamps.
     *
     * @param  string $policy
     * @return $this
     */
    public function onDuplicate(string $policy = self::POLICY_BLOCK): self
    {
        array_push($this->arguments, 'ON_DUPLICATE', $policy);

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\AlterArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

class AlterArguments extends CommonArguments
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\CommonArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

use Predis\Command\Argument\ArrayableArgument;
use UnexpectedValueException;

class CommonArguments implements ArrayableArgument
{
    public const POLICY_BLOCK = 'BLOCK';
    public const POLICY_FIRST = 'FIRST';
    public const POLICY_LAST = 'LAST';
    public const POLICY_MIN = 'MIN';
    public const POLICY_MAX = 'MAX';
    public const POLICY_SUM = 'SUM';

    public const ENCODING_UNCOMPRESSED = 'UNCOMPRESSED';
    public const ENCODING_COMPRESSED = 'COMPRESSED';

    /**
     * @var array
     */
    protected $arguments = [];

    /**
     * Is maximum age for samples compared to the highest reported timestamp, in milliseconds.
     *
     * @param  int   $retentionPeriod
     * @return $this
     */
    public function retentionMsecs(int $retentionPeriod): self
    {
        array_push($this->arguments, 'RETENTION', $retentionPeriod);

        return $this;
    }

    /**
     * Ignore samples with given time or value difference.
     *
     * @param  int   $maxTimeDiff Non-negative integer value in milliseconds
     * @param  float $maxValDiff  Non-negative float value
     * @return $this
     */
    public function ignore(int $maxTimeDiff, float $maxValDiff): self
    {
        if ($maxTimeDiff < 0 || $maxValDiff < 0) {
            throw new UnexpectedValueException('Ignore does not accept negative values');
        }

        array_push($this->arguments, 'IGNORE', $maxTimeDiff, $maxValDiff);

        return $this;
    }

    /**
     * Is initial allocation size, in bytes, for the data part of each new chunk.
     *
     * @param  int   $size
     * @return $this
     */
    public function chunkSize(int $size): self
    {
        array_push($this->arguments, 'CHUNK_SIZE', $size);

        return $this;
    }

    /**
     * Is policy for handling insertion of multiple samples with identical timestamps.
     *
     * @param  string $policy
     * @return $this
     */
    public function duplicatePolicy(string $policy = self::POLICY_BLOCK): self
    {
        array_push($this->arguments, 'DUPLICATE_POLICY', $policy);

        return $this;
    }

    /**
     * Is set of label-value pairs that represent metadata labels of the key and serve as a secondary index.
     *
     * @param  mixed ...$labelValuePair
     * @return $this
     */
    public function labels(...$labelValuePair): self
    {
        array_push($this->arguments, 'LABELS', ...$labelValuePair);

        return $this;
    }

    /**
     * Specifies the series samples encoding format.
     *
     * @param  string $encoding
     * @return $this
     */
    public function encoding(string $encoding = self::ENCODING_COMPRESSED): self
    {
        array_push($this->arguments, 'ENCODING', $encoding);

        return $this;
    }

    /**
     * Is used when a time series is a compaction.
     * With LATEST, TS.GET reports the compacted value of the latest, possibly partial, bucket.
     *
     * @return $this
     */
    public function latest(): self
    {
        $this->arguments[] = 'LATEST';

        return $this;
    }

    /**
     * Includes in the reply all label-value pairs representing metadata labels of the time series.
     *
     * @return $this
     */
    public function withLabels(): self
    {
        $this->arguments[] = 'WITHLABELS';

        return $this;
    }

    /**
     * Returns a subset of the label-value pairs that represent metadata labels of the time series.
     *
     * @return $this
     */
    public function selectedLabels(string ...$labels): self
    {
        array_push($this->arguments, 'SELECTED_LABELS', ...$labels);

        return $this;
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return $this->arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\CreateArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

class CreateArguments extends CommonArguments
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\DecrByArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

class DecrByArguments extends IncrByArguments
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\GetArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

class GetArguments extends CommonArguments
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\IncrByArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

class IncrByArguments extends CommonArguments
{
    /**
     * Is (integer) UNIX sample timestamp in milliseconds or * to set the timestamp according to the server clock.
     *
     * @param  string|int $timeStamp
     * @return $this
     */
    public function timestamp($timeStamp): self
    {
        array_push($this->arguments, 'TIMESTAMP', $timeStamp);

        return $this;
    }

    /**
     * Changes data storage from compressed (default) to uncompressed.
     *
     * @return $this
     */
    public function uncompressed(): self
    {
        $this->arguments[] = 'UNCOMPRESSED';

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\InfoArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

use Predis\Command\Argument\ArrayableArgument;

class InfoArguments implements ArrayableArgument
{
    /**
     * @var array
     */
    private $arguments = [];

    /**
     * Is an optional flag to get a more detailed information about the chunks.
     *
     * @return $this
     */
    public function debug(): self
    {
        $this->arguments[] = 'DEBUG';

        return $this;
    }

    /**
     * {@inheritDoc}
     */
    public function toArray(): array
    {
        return $this->arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\MGetArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

class MGetArguments extends CommonArguments
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\MRangeArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

class MRangeArguments extends RangeArguments
{
    /**
     * Filters time series based on their labels and label values.
     *
     * @param  string ...$filterExpressions
     * @return $this
     */
    public function filter(string ...$filterExpressions): self
    {
        array_push($this->arguments, 'FILTER', ...$filterExpressions);

        return $this;
    }

    /**
     * Splits time series into groups, each group contains time series that share the same
     * value for the provided label name, then aggregates results in each group.
     *
     * @param  string $label
     * @param  string $reducer
     * @return $this
     */
    public function groupBy(string $label, string $reducer): self
    {
        array_push($this->arguments, 'GROUPBY', $label, 'REDUCE', $reducer);

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Argument\TimeSeries\RangeArguments.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

class RangeArguments extends CommonArguments
{
    /**
     * Filters samples by a list of specific timestamps.
     *
     * @param  int   ...$ts
     * @return $this
     */
    public function filterByTs(int ...$ts): self
    {
        array_push($this->arguments, 'FILTER_BY_TS', ...$ts);

        return $this;
    }

    /**
     * Filters samples by minimum and maximum values.
     *
     * @param  int   $min
     * @param  int   $max
     * @return $this
     */
    public function filterByValue(int $min, int $max): self
    {
        array_push($this->arguments, 'FILTER_BY_VALUE', $min, $max);

        return $this;
    }

    /**
     * Limits the number of returned samples.
     *
     * @param  int   $count
     * @return $this
     */
    public function count(int $count): self
    {
        array_push($this->arguments, 'COUNT', $count);

        return $this;
    }

    /**
     * Aggregates samples into time buckets.
     *
     * @param  string $aggregator
     * @param  int    $bucketDuration  Is duration of each bucket, in milliseconds.
     * @param  int    $align           It controls the time bucket timestamps by changing the reference timestamp on which a bucket is defined.
     * @param  int    $bucketTimestamp Controls how bucket timestamps are reported.
     * @param  bool   $empty           Is a flag, which, when specified, reports aggregations also for empty buckets.
     * @return $this
     */
    public function aggregation(string $aggregator, int $bucketDuration, int $align = 0, int $bucketTimestamp = 0, bool $empty = false): self
    {
        if ($align > 0) {
            array_push($this->arguments, 'ALIGN', $align);
        }

        array_push($this->arguments, 'AGGREGATION', $aggregator, $bucketDuration);

        if ($bucketTimestamp > 0) {
            array_push($this->arguments, 'BUCKETTIMESTAMP', $bucketTimestamp);
        }

        if (true === $empty) {
            $this->arguments[] = 'EMPTY';
        }

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Processor\KeyPrefixProcessor.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Processor;

use InvalidArgumentException;
use Predis\Command\CommandInterface;
use Predis\Command\PrefixableCommandInterface;

/**
 * Command processor capable of prefixing keys stored in the arguments of Redis
 * commands supported.
 */
class KeyPrefixProcessor implements ProcessorInterface
{
    private $prefix;
    private $commands;

    /**
     * @param string $prefix Prefix for the keys.
     */
    public function __construct($prefix)
    {
        $this->prefix = $prefix;

        $prefixFirst = static::class . '::first';
        $prefixFirstTwo = static::class . '::firstTwo';
        $prefixAll = static::class . '::all';
        $prefixInterleaved = static::class . '::interleaved';
        $prefixSkipFirst = static::class . '::skipFirst';
        $prefixSkipLast = static::class . '::skipLast';
        $prefixSort = static::class . '::sort';
        $prefixEvalKeys = static::class . '::evalKeys';
        $prefixZsetStore = static::class . '::zsetStore';
        $prefixMigrate = static::class . '::migrate';
        $prefixGeoradius = static::class . '::georadius';

        $this->commands = [
            /* ---------------- Redis 1.2 ---------------- */
            'EXISTS' => $prefixAll,
            'DEL' => $prefixAll,
            'TYPE' => $prefixFirst,
            'KEYS' => $prefixFirst,
            'RENAME' => $prefixAll,
            'RENAMENX' => $prefixAll,
            'EXPIRE' => $prefixFirst,
            'EXPIREAT' => $prefixFirst,
            'TTL' => $prefixFirst,
            'MOVE' => $prefixFirst,
            'SORT' => $prefixSort,
            'DUMP' => $prefixFirst,
            'RESTORE' => $prefixFirst,
            'SET' => $prefixFirst,
            'SETNX' => $prefixFirst,
            'MSET' => $prefixInterleaved,
            'MSETNX' => $prefixInterleaved,
            'GET' => $prefixFirst,
            'MGET' => $prefixAll,
            'GETSET' => $prefixFirst,
            'INCR' => $prefixFirst,
            'INCRBY' => $prefixFirst,
            'DECR' => $prefixFirst,
            'DECRBY' => $prefixFirst,
            'RPUSH' => $prefixFirst,
            'LPUSH' => $prefixFirst,
            'LLEN' => $prefixFirst,
            'LRANGE' => $prefixFirst,
            'LTRIM' => $prefixFirst,
            'LINDEX' => $prefixFirst,
            'LSET' => $prefixFirst,
            'LREM' => $prefixFirst,
            'LPOP' => $prefixFirst,
            'RPOP' => $prefixFirst,
            'RPOPLPUSH' => $prefixAll,
            'SADD' => $prefixFirst,
            'SREM' => $prefixFirst,
            'SPOP' => $prefixFirst,
            'SMOVE' => $prefixSkipLast,
            'SCARD' => $prefixFirst,
            'SISMEMBER' => $prefixFirst,
            'SINTER' => $prefixAll,
            'SINTERSTORE' => $prefixAll,
            'SUNION' => $prefixAll,
            'SUNIONSTORE' => $prefixAll,
            'SDIFF' => $prefixAll,
            'SDIFFSTORE' => $prefixAll,
            'SMEMBERS' => $prefixFirst,
            'SMISMEMBER' => $prefixFirst,
            'SRANDMEMBER' => $prefixFirst,
            'ZADD' => $prefixFirst,
            'ZINCRBY' => $prefixFirst,
            'ZREM' => $prefixFirst,
            'ZRANGE' => $prefixFirst,
            'ZREVRANGE' => $prefixFirst,
            'ZRANGEBYSCORE' => $prefixFirst,
            'ZCARD' => $prefixFirst,
            'ZSCORE' => $prefixFirst,
            'ZREMRANGEBYSCORE' => $prefixFirst,

            /* ---------------- Redis 2.0 ---------------- */
            'SETEX' => $prefixFirst,
            'APPEND' => $prefixFirst,
            'SUBSTR' => $prefixFirst,
            'BLPOP' => $prefixSkipLast,
            'BRPOP' => $prefixSkipLast,
            'ZUNIONSTORE' => $prefixZsetStore,
            'ZINTERSTORE' => $prefixZsetStore,
            'ZCOUNT' => $prefixFirst,
            'ZRANK' => $prefixFirst,
            'ZREVRANK' => $prefixFirst,
            'ZREMRANGEBYRANK' => $prefixFirst,
            'HSET' => $prefixFirst,
            'HSETNX' => $prefixFirst,
            'HMSET' => $prefixFirst,
            'HINCRBY' => $prefixFirst,
            'HGET' => $prefixFirst,
            'HMGET' => $prefixFirst,
            'HDEL' => $prefixFirst,
            'HEXISTS' => $prefixFirst,
            'HLEN' => $prefixFirst,
            'HKEYS' => $prefixFirst,
            'HVALS' => $prefixFirst,
            'HGETALL' => $prefixFirst,
            'SUBSCRIBE' => $prefixAll,
            'UNSUBSCRIBE' => $prefixAll,
            'PSUBSCRIBE' => $prefixAll,
            'PUNSUBSCRIBE' => $prefixAll,
            'PUBLISH' => $prefixFirst,

            /* ---------------- Redis 2.2 ---------------- */
            'PERSIST' => $prefixFirst,
            'STRLEN' => $prefixFirst,
            'SETRANGE' => $prefixFirst,
            'GETRANGE' => $prefixFirst,
            'SETBIT' => $prefixFirst,
            'GETBIT' => $prefixFirst,
            'RPUSHX' => $prefixFirst,
            'LPUSHX' => $prefixFirst,
            'LINSERT' => $prefixFirst,
            'BRPOPLPUSH' => $prefixSkipLast,
            'ZREVRANGEBYSCORE' => $prefixFirst,
            'WATCH' => $prefixAll,

            /* ---------------- Redis 2.6 ---------------- */
            'PTTL' => $prefixFirst,
            'PEXPIRE' => $prefixFirst,
            'PEXPIREAT' => $prefixFirst,
            'PSETEX' => $prefixFirst,
            'INCRBYFLOAT' => $prefixFirst,
            'BITOP' => $prefixSkipFirst,
            'BITCOUNT' => $prefixFirst,
            'HINCRBYFLOAT' => $prefixFirst,
            'EVAL' => $prefixEvalKeys,
            'EVALSHA' => $prefixEvalKeys,
            'MIGRATE' => $prefixMigrate,

            /* ---------------- Redis 2.8 ---------------- */
            'SSCAN' => $prefixFirst,
            'ZSCAN' => $prefixFirst,
            'HSCAN' => $prefixFirst,
            'PFADD' => $prefixFirst,
            'PFCOUNT' => $prefixAll,
            'PFMERGE' => $prefixAll,
            'ZLEXCOUNT' => $prefixFirst,
            'ZRANGEBYLEX' => $prefixFirst,
            'ZREMRANGEBYLEX' => $prefixFirst,
            'ZREVRANGEBYLEX' => $prefixFirst,
            'BITPOS' => $prefixFirst,

            /* ---------------- Redis 3.2 ---------------- */
            'HSTRLEN' => $prefixFirst,
            'BITFIELD' => $prefixFirst,
            'GEOADD' => $prefixFirst,
            'GEOHASH' => $prefixFirst,
            'GEOPOS' => $prefixFirst,
            'GEODIST' => $prefixFirst,
            'GEORADIUS' => $prefixGeoradius,
            'GEORADIUSBYMEMBER' => $prefixGeoradius,

            /* ---------------- Redis 5.0 ---------------- */
            'XADD' => $prefixFirst,
            'XRANGE' => $prefixFirst,
            'XREVRANGE' => $prefixFirst,
            'XDEL' => $prefixFirst,
            'XLEN' => $prefixFirst,
            'XACK' => $prefixFirst,
            'XTRIM' => $prefixFirst,
            'ZPOPMIN' => $prefixFirst,
            'ZPOPMAX' => $prefixFirst,

            /* ---------------- Redis 6.2 ---------------- */
            'GETDEL' => $prefixFirst,
            'ZMSCORE' => $prefixFirst,
            'LMOVE' => $prefixFirstTwo,
            'BLMOVE' => $prefixFirstTwo,
            'GEOSEARCH' => $prefixFirst,

            /* ---------------- Redis 7.0 ---------------- */
            'EXPIRETIME' => $prefixFirst,

            /* RedisJSON */
            'JSON.ARRAPPEND' => $prefixFirst,
            'JSON.ARRINDEX' => $prefixFirst,
            'JSON.ARRINSERT' => $prefixFirst,
            'JSON.ARRLEN' => $prefixFirst,
            'JSON.ARRPOP' => $prefixFirst,
            'JSON.ARRTRIM' => $prefixFirst,
            'JSON.CLEAR' => $prefixFirst,
            'JSON.DEBUG MEMORY' => $prefixFirst,
            'JSON.DEL' => $prefixFirst,
            'JSON.FORGET' => $prefixFirst,
            'JSON.GET' => $prefixFirst,
            'JSON.MGET' => $prefixAll,
            'JSON.NUMINCRBY' => $prefixFirst,
            'JSON.OBJKEYS' => $prefixFirst,
            'JSON.OBJLEN' => $prefixFirst,
            'JSON.RESP' => $prefixFirst,
            'JSON.SET' => $prefixFirst,
            'JSON.STRAPPEND' => $prefixFirst,
            'JSON.STRLEN' => $prefixFirst,
            'JSON.TOGGLE' => $prefixFirst,
            'JSON.TYPE' => $prefixFirst,

            /* RedisBloom */
            'BF.ADD' => $prefixFirst,
            'BF.EXISTS' => $prefixFirst,
            'BF.INFO' => $prefixFirst,
            'BF.INSERT' => $prefixFirst,
            'BF.LOADCHUNK' => $prefixFirst,
            'BF.MADD' => $prefixFirst,
            'BF.MEXISTS' => $prefixFirst,
            'BF.RESERVE' => $prefixFirst,
            'BF.SCANDUMP' => $prefixFirst,
            'CF.ADD' => $prefixFirst,
            'CF.ADDNX' => $prefixFirst,
            'CF.COUNT' => $prefixFirst,
            'CF.DEL' => $prefixFirst,
            'CF.EXISTS' => $prefixFirst,
            'CF.INFO' => $prefixFirst,
            'CF.INSERT' => $prefixFirst,
            'CF.INSERTNX' => $prefixFirst,
            'CF.LOADCHUNK' => $prefixFirst,
            'CF.MEXISTS' => $prefixFirst,
            'CF.RESERVE' => $prefixFirst,
            'CF.SCANDUMP' => $prefixFirst,
            'CMS.INCRBY' => $prefixFirst,
            'CMS.INFO' => $prefixFirst,
            'CMS.INITBYDIM' => $prefixFirst,
            'CMS.INITBYPROB' => $prefixFirst,
            'CMS.QUERY' => $prefixFirst,
            'TDIGEST.ADD' => $prefixFirst,
            'TDIGEST.BYRANK' => $prefixFirst,
            'TDIGEST.BYREVRANK' => $prefixFirst,
            'TDIGEST.CDF' => $prefixFirst,
            'TDIGEST.CREATE' => $prefixFirst,
            'TDIGEST.INFO' => $prefixFirst,
            'TDIGEST.MAX' => $prefixFirst,
            'TDIGEST.MIN' => $prefixFirst,
            'TDIGEST.QUANTILE' => $prefixFirst,
            'TDIGEST.RANK' => $prefixFirst,
            'TDIGEST.RESET' => $prefixFirst,
            'TDIGEST.REVRANK' => $prefixFirst,
            'TDIGEST.TRIMMED_MEAN' => $prefixFirst,
            'TOPK.ADD' => $prefixFirst,
            'TOPK.INCRBY' => $prefixFirst,
            'TOPK.INFO' => $prefixFirst,
            'TOPK.LIST' => $prefixFirst,
            'TOPK.QUERY' => $prefixFirst,
            'TOPK.RESERVE' => $prefixFirst,

            /* RediSearch */
            'FT.AGGREGATE' => $prefixFirst,
            'FT.ALTER' => $prefixFirst,
            'FT.CREATE' => $prefixFirst,
            'FT.CURSOR DEL' => $prefixFirst,
            'FT.CURSOR READ' => $prefixFirst,
            'FT.DROPINDEX' => $prefixFirst,
            'FT.EXPLAIN' => $prefixFirst,
            'FT.INFO' => $prefixFirst,
            'FT.PROFILE' => $prefixFirst,
            'FT.SEARCH' => $prefixFirst,
            'FT.SPELLCHECK' => $prefixFirst,
            'FT.SYNDUMP' => $prefixFirst,
            'FT.SYNUPDATE' => $prefixFirst,
            'FT.TAGVALS' => $prefixFirst,

            /* Redis TimeSeries */
            'TS.ADD' => $prefixFirst,
            'TS.ALTER' => $prefixFirst,
            'TS.CREATE' => $prefixFirst,
            'TS.DECRBY' => $prefixFirst,
            'TS.DEL' => $prefixFirst,
            'TS.GET' => $prefixFirst,
            'TS.INCRBY' => $prefixFirst,
            'TS.INFO' => $prefixFirst,
            'TS.MGET' => $prefixFirst,
            'TS.MRANGE' => $prefixFirst,
            'TS.MREVRANGE' => $prefixFirst,
            'TS.QUERYINDEX' => $prefixFirst,
            'TS.RANGE' => $prefixFirst,
            'TS.REVRANGE' => $prefixFirst,
        ];
    }

    /**
     * Sets a prefix that is applied to all the keys.
     *
     * @param string $prefix Prefix for the keys.
     */
    public function setPrefix($prefix)
    {
        $this->prefix = $prefix;
    }

    /**
     * Gets the current prefix.
     *
     * @return string
     */
    public function getPrefix()
    {
        return $this->prefix;
    }

    /**
     * {@inheritdoc}
     */
    public function process(CommandInterface $command)
    {
        if ($command instanceof PrefixableCommandInterface) {
            $command->prefixKeys($this->prefix);
        } elseif (isset($this->commands[$commandID = strtoupper($command->getId())])) {
            $this->commands[$commandID]($command, $this->prefix);
        }
    }

    /**
     * Sets an handler for the specified command ID.
     *
     * The callback signature must have 2 parameters of the following types:
     *
     *   - Predis\Command\CommandInterface (command instance)
     *   - String (prefix)
     *
     * When the callback argument is omitted or NULL, the previously
     * associated handler for the specified command ID is removed.
     *
     * @param string $commandID The ID of the command to be handled.
     * @param mixed  $callback  A valid callable object or NULL.
     *
     * @throws InvalidArgumentException
     */
    public function setCommandHandler($commandID, $callback = null)
    {
        $commandID = strtoupper($commandID);

        if (!isset($callback)) {
            unset($this->commands[$commandID]);

            return;
        }

        if (!is_callable($callback)) {
            throw new InvalidArgumentException(
                'Callback must be a valid callable object or NULL'
            );
        }

        $this->commands[$commandID] = $callback;
    }

    /**
     * {@inheritdoc}
     */
    public function __toString()
    {
        return $this->getPrefix();
    }

    /**
     * Applies the specified prefix only the first argument.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function first(CommandInterface $command, $prefix)
    {
        if ($arguments = $command->getArguments()) {
            $arguments[0] = "$prefix{$arguments[0]}";
            $command->setRawArguments($arguments);
        }
    }

    /**
     * Applies the specified prefix only to the first two arguments.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function firstTwo(CommandInterface $command, $prefix)
    {
        $arguments = $command->getArguments();
        $length = min(count($arguments), 2);

        for ($i = 0; $i < $length; $i++) {
            $arguments[$i] = "$prefix{$arguments[$i]}";
        }

        $command->setRawArguments($arguments);
    }

    /**
     * Applies the specified prefix to all the arguments.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function all(CommandInterface $command, $prefix)
    {
        if ($arguments = $command->getArguments()) {
            foreach ($arguments as &$key) {
                $key = "$prefix$key";
            }

            $command->setRawArguments($arguments);
        }
    }

    /**
     * Applies the specified prefix only to even arguments in the list.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function interleaved(CommandInterface $command, $prefix)
    {
        if ($arguments = $command->getArguments()) {
            $length = count($arguments);

            for ($i = 0; $i < $length; $i += 2) {
                $arguments[$i] = "$prefix{$arguments[$i]}";
            }

            $command->setRawArguments($arguments);
        }
    }

    /**
     * Applies the specified prefix to all the arguments but the first one.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function skipFirst(CommandInterface $command, $prefix)
    {
        if ($arguments = $command->getArguments()) {
            $length = count($arguments);

            for ($i = 1; $i < $length; ++$i) {
                $arguments[$i] = "$prefix{$arguments[$i]}";
            }

            $command->setRawArguments($arguments);
        }
    }

    /**
     * Applies the specified prefix to all the arguments but the last one.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function skipLast(CommandInterface $command, $prefix)
    {
        if ($arguments = $command->getArguments()) {
            $length = count($arguments);

            for ($i = 0; $i < $length - 1; ++$i) {
                $arguments[$i] = "$prefix{$arguments[$i]}";
            }

            $command->setRawArguments($arguments);
        }
    }

    /**
     * Applies the specified prefix to the keys of a SORT command.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function sort(CommandInterface $command, $prefix)
    {
        if ($arguments = $command->getArguments()) {
            $arguments[0] = "$prefix{$arguments[0]}";

            if (($count = count($arguments)) > 1) {
                for ($i = 1; $i < $count; ++$i) {
                    switch (strtoupper($arguments[$i])) {
                        case 'BY':
                        case 'STORE':
                            $arguments[$i] = "$prefix{$arguments[++$i]}";
                            break;

                        case 'GET':
                            $value = $arguments[++$i];
                            if ($value !== '#') {
                                $arguments[$i] = "$prefix$value";
                            }
                            break;

                        case 'LIMIT':
                            $i += 2;
                            break;
                    }
                }
            }

            $command->setRawArguments($arguments);
        }
    }

    /**
     * Applies the specified prefix to the keys of an EVAL-based command.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function evalKeys(CommandInterface $command, $prefix)
    {
        if ($arguments = $command->getArguments()) {
            for ($i = 2; $i < $arguments[1] + 2; ++$i) {
                $arguments[$i] = "$prefix{$arguments[$i]}";
            }

            $command->setRawArguments($arguments);
        }
    }

    /**
     * Applies the specified prefix to the keys of Z[INTERSECTION|UNION]STORE.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function zsetStore(CommandInterface $command, $prefix)
    {
        if ($arguments = $command->getArguments()) {
            $arguments[0] = "$prefix{$arguments[0]}";
            $length = ((int) $arguments[1]) + 2;

            for ($i = 2; $i < $length; ++$i) {
                $arguments[$i] = "$prefix{$arguments[$i]}";
            }

            $command->setRawArguments($arguments);
        }
    }

    /**
     * Applies the specified prefix to the key of a MIGRATE command.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function migrate(CommandInterface $command, $prefix)
    {
        if ($arguments = $command->getArguments()) {
            $arguments[2] = "$prefix{$arguments[2]}";
            $command->setRawArguments($arguments);
        }
    }

    /**
     * Applies the specified prefix to the key of a GEORADIUS command.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $prefix  Prefix string.
     */
    public static function georadius(CommandInterface $command, $prefix)
    {
        if ($arguments = $command->getArguments()) {
            $arguments[0] = "$prefix{$arguments[0]}";
            $startIndex = $command->getId() === 'GEORADIUS' ? 5 : 4;

            if (($count = count($arguments)) > $startIndex) {
                for ($i = $startIndex; $i < $count; ++$i) {
                    switch (strtoupper($arguments[$i])) {
                        case 'STORE':
                        case 'STOREDIST':
                            $arguments[$i] = "$prefix{$arguments[++$i]}";
                            break;
                    }
                }
            }

            $command->setRawArguments($arguments);
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Processor\ProcessorChain.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Processor;

use ArrayAccess;
use ArrayIterator;
use InvalidArgumentException;
use Predis\Command\CommandInterface;
use ReturnTypeWillChange;
use Traversable;

/**
 * Default implementation of a command processors chain.
 */
class ProcessorChain implements ArrayAccess, ProcessorInterface
{
    private $processors = [];

    /**
     * @param array $processors List of instances of ProcessorInterface.
     */
    public function __construct($processors = [])
    {
        foreach ($processors as $processor) {
            $this->add($processor);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function add(ProcessorInterface $processor)
    {
        $this->processors[] = $processor;
    }

    /**
     * {@inheritdoc}
     */
    public function remove(ProcessorInterface $processor)
    {
        if (false !== $index = array_search($processor, $this->processors, true)) {
            unset($this[$index]);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function process(CommandInterface $command)
    {
        for ($i = 0; $i < $count = count($this->processors); ++$i) {
            $this->processors[$i]->process($command);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getProcessors()
    {
        return $this->processors;
    }

    /**
     * Returns an iterator over the list of command processor in the chain.
     *
     * @return Traversable<int, ProcessorInterface>
     */
    public function getIterator()
    {
        return new ArrayIterator($this->processors);
    }

    /**
     * Returns the number of command processors in the chain.
     *
     * @return int
     */
    public function count()
    {
        return count($this->processors);
    }

    /**
     * @param  int  $index
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function offsetExists($index)
    {
        return isset($this->processors[$index]);
    }

    /**
     * @param  int                $index
     * @return ProcessorInterface
     */
    #[ReturnTypeWillChange]
    public function offsetGet($index)
    {
        return $this->processors[$index];
    }

    /**
     * @param  int                $index
     * @param  ProcessorInterface $processor
     * @return void
     */
    #[ReturnTypeWillChange]
    public function offsetSet($index, $processor)
    {
        if (!$processor instanceof ProcessorInterface) {
            throw new InvalidArgumentException(
                'Processor chain accepts only instances of `Predis\Command\Processor\ProcessorInterface`'
            );
        }

        $this->processors[$index] = $processor;
    }

    /**
     * @param  int  $index
     * @return void
     */
    #[ReturnTypeWillChange]
    public function offsetUnset($index)
    {
        unset($this->processors[$index]);
        $this->processors = array_values($this->processors);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Processor\ProcessorInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Processor;

use Predis\Command\CommandInterface;

/**
 * A command processor processes Redis commands before they are sent to Redis.
 */
interface ProcessorInterface
{
    /**
     * Processes the given Redis command.
     *
     * @param CommandInterface $command Command instance.
     */
    public function process(CommandInterface $command);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ACL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/?name=ACL
 *
 * Container command corresponds to any ACL *.
 * Represents any ACL command with subcommand as first argument.
 */
class ACL extends RedisCommand
{
    public function getId()
    {
        return 'ACL';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (!is_array($data)) {
            return $data;
        }

        if ($data === array_values($data)) {
            return $data;
        }

        // flatten Relay (RESP3) maps
        $return = [];

        array_walk($data, function ($value, $key) use (&$return) {
            $return[] = $key;
            $return[] = $value;
        });

        return $return;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\APPEND.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/append
 */
class APPEND extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'APPEND';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\AUTH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/auth
 */
class AUTH extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'AUTH';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BGREWRITEAOF.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/bgrewriteaof
 */
class BGREWRITEAOF extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'BGREWRITEAOF';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        return $data == 'Background append only file rewriting started';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BGSAVE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/bgsave
 */
class BGSAVE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'BGSAVE';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        return $data === 'Background saving started' ? true : $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BITCOUNT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\BitByte;

/**
 * @see http://redis.io/commands/bitcount
 *
 * Count the number of set bits (population counting) in a string.
 */
class BITCOUNT extends RedisCommand
{
    use BitByte;

    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'BITCOUNT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BITFIELD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/bitfield
 */
class BITFIELD extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'BITFIELD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BITOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/bitop
 */
class BITOP extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'BITOP';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 3 && is_array($arguments[2])) {
            [$operation, $destination] = $arguments;
            $arguments = $arguments[2];
            array_unshift($arguments, $operation, $destination);
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BITPOS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\BitByte;

/**
 * @see http://redis.io/commands/bitpos
 *
 * Return the position of the first bit set to 1 or 0 in a string.
 */
class BITPOS extends RedisCommand
{
    use BitByte;

    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'BITPOS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BLMOVE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class BLMOVE extends LMOVE
{
    public function getId()
    {
        return 'BLMOVE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BLMPOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class BLMPOP extends LMPOP
{
    protected static $keysArgumentPositionOffset = 1;
    protected static $leftRightArgumentPositionOffset = 2;
    protected static $countArgumentPositionOffset = 3;

    public function getId()
    {
        return 'BLMPOP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BLPOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/blpop
 */
class BLPOP extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'BLPOP';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[0])) {
            [$arguments, $timeout] = $arguments;
            array_push($arguments, $timeout);
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BRPOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/brpop
 */
class BRPOP extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'BRPOP';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[0])) {
            [$arguments, $timeout] = $arguments;
            array_push($arguments, $timeout);
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BRPOPLPUSH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/brpoplpush
 */
class BRPOPLPUSH extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'BRPOPLPUSH';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BZMPOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see https://redis.io/commands/bzmpop/
 *
 * BZMPOP is the blocking variant of ZMPOP.
 */
class BZMPOP extends ZMPOP
{
    protected static $keysArgumentPositionOffset = 1;
    protected static $countArgumentPositionOffset = 3;
    protected static $modifierArgumentPositionOffset = 2;

    public function getId()
    {
        return 'BZMPOP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BZPOPMAX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Redis\AbstractCommand\BZPOPBase;

/**
 * @see https://redis.io/commands/bzpopmax/
 *
 * BZPOPMAX is the blocking variant of the sorted set ZPOPMAX primitive.
 *
 * It is the blocking version because it blocks the connection when there are
 * no members to pop from any of the given sorted sets.
 * A member with the highest score is popped from first sorted set that is non-empty,
 * with the given keys being checked in the order that they are given.
 */
class BZPOPMAX extends BZPOPBase
{
    public function getId(): string
    {
        return 'BZPOPMAX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BZPOPMIN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Redis\AbstractCommand\BZPOPBase;

/**
 * @see https://redis.io/commands/bzpopmin/
 *
 * BZPOPMIN is the blocking variant of the sorted set ZPOPMIN primitive.
 *
 * It is the blocking version because it blocks the connection when there are
 * no members to pop from any of the given sorted sets.
 * A member with the lowest score is popped from first sorted set that is non-empty,
 * with the given keys being checked in the order that they are given.
 */
class BZPOPMIN extends BZPOPBase
{
    public function getId(): string
    {
        return 'BZPOPMIN';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CLIENT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/client-list
 * @see http://redis.io/commands/client-kill
 * @see http://redis.io/commands/client-getname
 * @see http://redis.io/commands/client-setname
 */
class CLIENT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'CLIENT';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        $args = array_change_key_case($this->getArguments(), CASE_UPPER);

        switch (strtoupper($args[0])) {
            case 'LIST':
                return $this->parseClientList($data);
            case 'KILL':
            case 'GETNAME':
            case 'SETNAME':
            default:
                return $data;
        } // @codeCoverageIgnore
    }

    /**
     * Parses the response to CLIENT LIST and returns a structured list.
     *
     * @param string $data Response buffer.
     *
     * @return array
     */
    protected function parseClientList($data)
    {
        $clients = [];

        foreach (explode("\n", $data, -1) as $clientData) {
            $client = [];

            foreach (explode(' ', $clientData) as $kv) {
                @[$k, $v] = explode('=', $kv);
                $client[$k] = $v;
            }

            $clients[] = $client;
        }

        return $clients;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CLUSTER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/?name=cluster
 */
class CLUSTER extends RedisCommand
{
    public function getId()
    {
        return 'CLUSTER';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\COMMAND.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as BaseCommand;

/**
 * @see http://redis.io/commands/command
 */
class COMMAND extends BaseCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'COMMAND';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        // Relay (RESP3) uses maps and it might be good
        // to make the return value a breaking change

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CONFIG.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/config-set
 * @see http://redis.io/commands/config-get
 * @see http://redis.io/commands/config-resetstat
 * @see http://redis.io/commands/config-rewrite
 */
class CONFIG extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'CONFIG';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (is_array($data)) {
            if ($data !== array_values($data)) {
                return $data; // Relay
            }

            $result = [];

            for ($i = 0; $i < count($data); ++$i) {
                $result[$data[$i]] = $data[++$i];
            }

            return $result;
        }

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\COPY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\DB;
use Predis\Command\Traits\Replace;

/**
 * @see https://redis.io/commands/copy/
 *
 * This command copies the value stored at the source key to the destination key.
 */
class COPY extends RedisCommand
{
    use DB {
        DB::setArguments as setDB;
    }
    use Replace {
        Replace::setArguments as setReplace;
    }

    protected static $dbArgumentPositionOffset = 2;

    public function getId()
    {
        return 'COPY';
    }

    public function setArguments(array $arguments)
    {
        $this->setDB($arguments);
        $arguments = $this->getArguments();

        $this->setReplace($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\DBSIZE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/dbsize
 */
class DBSIZE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'DBSIZE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\DECR.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/decr
 */
class DECR extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'DECR';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\DECRBY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/decrby
 */
class DECRBY extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'DECRBY';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\DEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/del
 */
class DEL extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'DEL';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\DISCARD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/discard
 */
class DISCARD extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'DISCARD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\DUMP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/dump
 */
class DUMP extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'DUMP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ECHO_.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/echo
 */
class ECHO_ extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ECHO';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\EVALSHA.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see http://redis.io/commands/evalsha
 */
class EVALSHA extends EVAL_
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'EVALSHA';
    }

    /**
     * Returns the SHA1 hash of the body of the script.
     *
     * @return string SHA1 hash.
     */
    public function getScriptHash()
    {
        return $this->getArgument(0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\EVALSHA_RO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see https://redis.io/commands/evalsha_ro/
 *
 * This is a read-only variant of the EVALSHA command
 * that cannot execute commands that modify data.
 */
class EVALSHA_RO extends EVAL_RO
{
    public function getId()
    {
        return 'EVALSHA_RO';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\EVAL_.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/eval
 */
class EVAL_ extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'EVAL';
    }

    /**
     * Calculates the SHA1 hash of the body of the script.
     *
     * @return string SHA1 hash.
     */
    public function getScriptHash()
    {
        return sha1($this->getArgument(0));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\EVAL_RO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Keys;

/**
 * @see https://redis.io/commands/eval_ro/
 *
 * This is a read-only variant of the EVAL command
 * that cannot execute commands that modify data.
 */
class EVAL_RO extends RedisCommand
{
    use Keys;

    protected static $keysArgumentPositionOffset = 1;

    public function getId()
    {
        return 'EVAL_RO';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\EXEC.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/exec
 */
class EXEC extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'EXEC';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\EXISTS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/exists
 */
class EXISTS extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'EXISTS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\EXPIRE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Expire\ExpireOptions;

/**
 * @see http://redis.io/commands/expire
 *
 * Set a timeout on key.
 * After the timeout has expired, the key will automatically be deleted.
 * A key with an associated timeout is often said to be volatile in Redis terminology.
 */
class EXPIRE extends RedisCommand
{
    use ExpireOptions;

    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'EXPIRE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\EXPIREAT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Expire\ExpireOptions;

/**
 * @see http://redis.io/commands/expireat
 *
 * EXPIREAT has the same effect and semantic as EXPIRE, but instead of specifying
 * the number of seconds representing the TTL (time to live), it takes an absolute Unix timestamp
 */
class EXPIREAT extends RedisCommand
{
    use ExpireOptions;

    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'EXPIREAT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\EXPIRETIME.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/expiretime/
 *
 * Returns the absolute Unix timestamp (since January 1, 1970)
 * in seconds at which the given key will expire.
 */
class EXPIRETIME extends RedisCommand
{
    public function getId()
    {
        return 'EXPIRETIME';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\FAILOVER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Timeout;
use Predis\Command\Traits\To\ServerTo;

class FAILOVER extends RedisCommand
{
    use ServerTo {
        ServerTo::setArguments as setTo;
    }
    use Timeout {
        Timeout::setArguments as setTimeout;
    }

    protected static $toArgumentPositionOffset = 0;
    protected static $timeoutArgumentPositionOffset = 2;

    public function getId()
    {
        return 'FAILOVER';
    }

    public function setArguments(array $arguments)
    {
        if (array_key_exists(1, $arguments) && false !== $arguments[1]) {
            $arguments[1] = 'ABORT';
        }

        $this->setTimeout($arguments);
        $arguments = $this->getArguments();

        $this->setTo($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\FCALL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Keys;

/**
 * @see https://redis.io/commands/fcall/
 *
 * Invoke a function.
 */
class FCALL extends RedisCommand
{
    use Keys;

    protected static $keysArgumentPositionOffset = 1;

    public function getId()
    {
        return 'FCALL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\FCALL_RO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/fcall_ro/
 *
 * This is a read-only variant of the FCALL command that cannot execute commands that modify data.
 */
class FCALL_RO extends RedisCommand
{
    public function getId()
    {
        return 'FCALL_RO';
    }

    public function setArguments(array $arguments)
    {
        $processedArguments = array_merge([$arguments[0], count($arguments[1])], $arguments[1]);

        if (count($arguments) > 2) {
            for ($i = 2, $iMax = count($arguments); $i < $iMax; $i++) {
                $processedArguments[] = $arguments[$i];
            }
        }

        parent::setArguments($processedArguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\FLUSHALL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/flushall
 */
class FLUSHALL extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'FLUSHALL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\FLUSHDB.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/flushdb
 */
class FLUSHDB extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'FLUSHDB';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\FUNCTIONS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Strategy\StrategyResolverInterface;
use Predis\Command\Strategy\SubcommandStrategyResolver;

/**
 * @see https://redis.io/commands/?name=function
 *
 * Container command corresponds to any FUNCTION *.
 * Represents any FUNCTION command with subcommand as first argument.
 */
class FUNCTIONS extends RedisCommand
{
    /**
     * @var StrategyResolverInterface
     */
    private $strategyResolver;

    public function __construct()
    {
        $this->strategyResolver = new SubcommandStrategyResolver();
    }

    public function getId()
    {
        return 'FUNCTION';
    }

    public function setArguments(array $arguments)
    {
        $strategy = $this->strategyResolver->resolve('functions', strtolower($arguments[0]));
        $arguments = $strategy->processArguments($arguments);

        parent::setArguments($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GEOADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/geoadd
 */
class GEOADD extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'GEOADD';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[1])) {
            foreach (array_pop($arguments) as $item) {
                $arguments = array_merge($arguments, $item);
            }
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GEODIST.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/geodist
 */
class GEODIST extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'GEODIST';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GEOHASH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/geohash
 */
class GEOHASH extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'GEOHASH';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[1])) {
            $members = array_pop($arguments);
            $arguments = array_merge($arguments, $members);
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GEOPOS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/geopos
 */
class GEOPOS extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'GEOPOS';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[1])) {
            $members = array_pop($arguments);
            $arguments = array_merge($arguments, $members);
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GEORADIUS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @deprecated As of Redis version 6.2.0, this command is regarded as deprecated.
 *
 * It can be replaced by GEOSEARCH and GEOSEARCHSTORE with the BYRADIUS argument
 * when migrating or writing new code.
 *
 * @see http://redis.io/commands/georadius
 */
class GEORADIUS extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'GEORADIUS';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if ($arguments && is_array(end($arguments))) {
            $options = array_change_key_case(array_pop($arguments), CASE_UPPER);

            if (isset($options['WITHCOORD']) && $options['WITHCOORD'] == true) {
                $arguments[] = 'WITHCOORD';
            }

            if (isset($options['WITHDIST']) && $options['WITHDIST'] == true) {
                $arguments[] = 'WITHDIST';
            }

            if (isset($options['WITHHASH']) && $options['WITHHASH'] == true) {
                $arguments[] = 'WITHHASH';
            }

            if (isset($options['COUNT'])) {
                $arguments[] = 'COUNT';
                $arguments[] = $options['COUNT'];
            }

            if (isset($options['SORT'])) {
                $arguments[] = strtoupper($options['SORT']);
            }

            if (isset($options['STORE'])) {
                $arguments[] = 'STORE';
                $arguments[] = $options['STORE'];
            }

            if (isset($options['STOREDIST'])) {
                $arguments[] = 'STOREDIST';
                $arguments[] = $options['STOREDIST'];
            }
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GEORADIUSBYMEMBER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @deprecated As of Redis version 6.2.0, this command is regarded as deprecated.
 *
 * It can be replaced by GEOSEARCH and GEOSEARCHSTORE with the FROMMEMBER arguments
 * when migrating or writing new code.
 *
 * @see http://redis.io/commands/georadiusbymember
 */
class GEORADIUSBYMEMBER extends GEORADIUS
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'GEORADIUSBYMEMBER';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GEOSEARCH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\By\GeoBy;
use Predis\Command\Traits\Count;
use Predis\Command\Traits\From\GeoFrom;
use Predis\Command\Traits\Sorting;
use Predis\Command\Traits\With\WithCoord;
use Predis\Command\Traits\With\WithDist;
use Predis\Command\Traits\With\WithHash;

/**
 * @see https://redis.io/commands/geosearch/
 *
 * Return the members of a sorted set populated with geospatial information using GEOADD,
 * which are within the borders of the area specified by a given shape.
 *
 * This command extends the GEORADIUS command, so in addition to searching
 * within circular areas, it supports searching within rectangular areas.
 */
class GEOSEARCH extends RedisCommand
{
    use GeoFrom {
        GeoFrom::setArguments as setFrom;
    }
    use GeoBy {
        GeoBy::setArguments as setBy;
    }
    use Sorting {
        Sorting::setArguments as setSorting;
    }
    use Count {
        Count::setArguments as setCount;
    }
    use WithCoord {
        WithCoord::setArguments as setWithCoord;
    }
    use WithDist {
        WithDist::setArguments as setWithDist;
    }
    use WithHash {
        WithHash::setArguments as setWithHash;
    }

    protected static $sortArgumentPositionOffset = 3;
    protected static $countArgumentPositionOffset = 4;
    protected static $withCoordArgumentPositionOffset = 6;
    protected static $withDistArgumentPositionOffset = 7;
    protected static $withHashArgumentPositionOffset = 8;

    public function getId()
    {
        return 'GEOSEARCH';
    }

    public function setArguments(array $arguments)
    {
        $this->setSorting($arguments);
        $arguments = $this->getArguments();

        $this->setWithCoord($arguments);
        $arguments = $this->getArguments();

        $this->setWithDist($arguments);
        $arguments = $this->getArguments();

        $this->setWithHash($arguments);
        $arguments = $this->getArguments();

        $this->setCount($arguments, $arguments[5] ?? false);
        $arguments = $this->getArguments();

        $this->setFrom($arguments);
        $arguments = $this->getArguments();

        $this->setBy($arguments);
        $this->filterArguments();
    }

    public function parseResponse($data)
    {
        $parsedData = [];
        $itemKey = '';

        foreach ($data as $item) {
            if (!is_array($item)) {
                $parsedData[] = $item;
                continue;
            }

            foreach ($item as $key => $itemRow) {
                if ($key === 0) {
                    $itemKey = $itemRow;
                    continue;
                }

                if (is_string($itemRow)) {
                    $parsedData[$itemKey]['dist'] = round((float) $itemRow, 5);
                } elseif (is_int($itemRow)) {
                    $parsedData[$itemKey]['hash'] = $itemRow;
                } else {
                    $parsedData[$itemKey]['lng'] = round($itemRow[0], 5);
                    $parsedData[$itemKey]['lat'] = round($itemRow[1], 5);
                }
            }
        }

        return $parsedData;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GEOSEARCHSTORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\By\GeoBy;
use Predis\Command\Traits\Count;
use Predis\Command\Traits\From\GeoFrom;
use Predis\Command\Traits\Sorting;
use Predis\Command\Traits\Storedist;

/**
 * @see https://redis.io/commands/geosearchstore/
 *
 * This command is like GEOSEARCH, but stores the result in destination key.
 */
class GEOSEARCHSTORE extends RedisCommand
{
    use GeoFrom {
        GeoFrom::setArguments as setFrom;
    }
    use GeoBy {
        GeoBy::setArguments as setBy;
    }
    use Sorting {
        Sorting::setArguments as setSorting;
    }
    use Count {
        Count::setArguments as setCount;
    }
    use Storedist {
        Storedist::setArguments as setStoreDist;
    }

    protected static $sortArgumentPositionOffset = 4;
    protected static $countArgumentPositionOffset = 5;
    protected static $storeDistArgumentPositionOffset = 7;

    public function getId()
    {
        return 'GEOSEARCHSTORE';
    }

    public function setArguments(array $arguments)
    {
        $this->setStoreDist($arguments);
        $arguments = $this->getArguments();

        $this->setCount($arguments, $arguments[6] ?? false);
        $arguments = $this->getArguments();

        $this->setSorting($arguments);
        $arguments = $this->getArguments();

        $this->setFrom($arguments);
        $arguments = $this->getArguments();

        $this->setBy($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/get
 */
class GET extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'GET';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GETBIT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/getbit
 */
class GETBIT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'GETBIT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GETDEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

class GETDEL extends RedisCommand
{
    public function getId()
    {
        return 'GETDEL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GETEX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use UnexpectedValueException;

class GETEX extends RedisCommand
{
    /**
     * @var string[]
     */
    private static $modifierEnum = [
        'ex' => 'EX',
        'px' => 'PX',
        'exat' => 'EXAT',
        'pxat' => 'PXAT',
        'persist' => 'PERSIST',
    ];

    public function getId()
    {
        return 'GETEX';
    }

    public function setArguments(array $arguments)
    {
        if (!array_key_exists(1, $arguments) || $arguments[1] === '') {
            parent::setArguments([$arguments[0]]);

            return;
        }

        if (!in_array(strtoupper($arguments[1]), self::$modifierEnum)) {
            $enumValues = implode(', ', array_keys(self::$modifierEnum));
            throw new UnexpectedValueException("Modifier argument accepts only: {$enumValues} values");
        }

        if ($arguments[1] === 'persist') {
            parent::setArguments([$arguments[0], self::$modifierEnum[$arguments[1]]]);

            return;
        }

        $arguments[1] = self::$modifierEnum[$arguments[1]];

        if (!array_key_exists(2, $arguments)) {
            throw new UnexpectedValueException('You should provide value for current modifier');
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GETRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/getrange
 */
class GETRANGE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'GETRANGE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\GETSET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/getset
 */
class GETSET extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'GETSET';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HDEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hdel
 */
class HDEL extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HDEL';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeVariadic($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HEXISTS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hexists
 */
class HEXISTS extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HEXISTS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HEXPIRE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use UnexpectedValueException;

class HEXPIRE extends RedisCommand
{
    /**
     * @var array
     */
    protected $flagsEnum = [
        'NX', 'XX', 'GT', 'LT',
    ];

    public function getId()
    {
        return 'HEXPIRE';
    }

    public function setArguments(array $arguments)
    {
        $processedArguments = [$arguments[0], $arguments[1]];

        if (array_key_exists(3, $arguments) && null !== $arguments[3]) {
            if (in_array(strtoupper($arguments[3]), $this->flagsEnum, true)) {
                $processedArguments[] = strtoupper($arguments[3]);
            } else {
                throw new UnexpectedValueException('Unsupported flag value');
            }
        }

        if (array_key_exists(2, $arguments) && null !== $arguments[2]) {
            array_push($processedArguments, 'FIELDS', count($arguments[2]));
            $processedArguments = array_merge($processedArguments, $arguments[2]);
        }

        parent::setArguments($processedArguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HEXPIREAT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class HEXPIREAT extends HEXPIRE
{
    public function getId()
    {
        return 'HEXPIREAT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HEXPIRETIME.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

class HEXPIRETIME extends RedisCommand
{
    public function getId()
    {
        return 'HEXPIRETIME';
    }

    public function setArguments(array $arguments)
    {
        $processedArguments = [$arguments[0], 'FIELDS', count($arguments[1])];
        $processedArguments = array_merge($processedArguments, $arguments[1]);

        parent::setArguments($processedArguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HGET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hget
 */
class HGET extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HGET';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HGETALL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hgetall
 */
class HGETALL extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HGETALL';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if ($data !== array_values($data)) {
            return $data; // Relay
        }

        $result = [];

        for ($i = 0; $i < count($data); ++$i) {
            $result[$data[$i]] = $data[++$i];
        }

        return $result;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HINCRBY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hincrby
 */
class HINCRBY extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HINCRBY';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HINCRBYFLOAT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hincrbyfloat
 */
class HINCRBYFLOAT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HINCRBYFLOAT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HKEYS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hkeys
 */
class HKEYS extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HKEYS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HLEN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hlen
 */
class HLEN extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HLEN';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HMGET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hmget
 */
class HMGET extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HMGET';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeVariadic($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HMSET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hmset
 */
class HMSET extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HMSET';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[1])) {
            $flattenedKVs = [$arguments[0]];
            $args = $arguments[1];

            foreach ($args as $k => $v) {
                $flattenedKVs[] = $k;
                $flattenedKVs[] = $v;
            }

            $arguments = $flattenedKVs;
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HPERSIST.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

class HPERSIST extends RedisCommand
{
    public function getId()
    {
        return 'HPERSIST';
    }

    public function setArguments(array $arguments)
    {
        $processedArguments = [$arguments[0], 'FIELDS', count($arguments[1])];
        $processedArguments = array_merge($processedArguments, $arguments[1]);

        parent::setArguments($processedArguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HPEXPIRE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class HPEXPIRE extends HEXPIRE
{
    public function getId()
    {
        return 'HPEXPIRE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HPEXPIREAT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class HPEXPIREAT extends HEXPIRE
{
    public function getId()
    {
        return 'HPEXPIREAT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HPEXPIRETIME.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class HPEXPIRETIME extends HEXPIRETIME
{
    public function getId()
    {
        return 'HPEXPIRETIME';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HPTTL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class HPTTL extends HTTL
{
    public function getId()
    {
        return 'HPTTL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HRANDFIELD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\With\WithValues;

/**
 * @see https://redis.io/commands/hrandfield/
 *
 * When called with just the key argument, return a random field from the hash value stored at key.
 *
 * If the provided count argument is positive, return an array of distinct fields.
 * The array's length is either count or the hash's number of fields (HLEN), whichever is lower.
 */
class HRANDFIELD extends RedisCommand
{
    use WithValues;

    public function getId()
    {
        return 'HRANDFIELD';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (!is_array($data)) {
            return $data;
        }

        // flatten Relay (RESP3) maps
        $return = [];

        array_walk_recursive($data, function ($value) use (&$return) {
            $return[] = $value;
        });

        return $return;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HSCAN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hscan
 */
class HSCAN extends RedisCommand
{
    /**
     * @var array
     */
    private $arguments;

    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HSCAN';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 3 && is_array($arguments[2])) {
            $options = $this->prepareOptions(array_pop($arguments));
            $arguments = array_merge($arguments, $options);
        }

        $this->arguments = $arguments;
        parent::setArguments($arguments);
    }

    /**
     * Returns a list of options and modifiers compatible with Redis.
     *
     * @param array $options List of options.
     *
     * @return array
     */
    protected function prepareOptions($options)
    {
        $options = array_change_key_case($options, CASE_UPPER);
        $normalized = [];

        if (!empty($options['MATCH'])) {
            $normalized[] = 'MATCH';
            $normalized[] = $options['MATCH'];
        }

        if (!empty($options['COUNT'])) {
            $normalized[] = 'COUNT';
            $normalized[] = $options['COUNT'];
        }

        if (!empty($options['NOVALUES']) && true === $options['NOVALUES']) {
            $normalized[] = 'NOVALUES';
        }

        return $normalized;
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (!in_array('NOVALUES', $this->arguments, true)) {
            if (is_array($data)) {
                $fields = $data[1];
                $result = [];

                for ($i = 0; $i < count($fields); ++$i) {
                    $result[$fields[$i]] = $fields[++$i];
                }

                $data[1] = $result;
            }
        }

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HSET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hset
 */
class HSET extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HSET';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HSETNX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hsetnx
 */
class HSETNX extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HSETNX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HSTRLEN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hstrlen
 */
class HSTRLEN extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HSTRLEN';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HTTL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

class HTTL extends RedisCommand
{
    public function getId()
    {
        return 'HTTL';
    }

    public function setArguments(array $arguments)
    {
        $processedArguments = [$arguments[0], 'FIELDS', count($arguments[1])];
        $processedArguments = array_merge($processedArguments, $arguments[1]);

        parent::setArguments($processedArguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\HVALS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/hvals
 */
class HVALS extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'HVALS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\INCR.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/incr
 */
class INCR extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'INCR';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\INCRBY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/incrby
 */
class INCRBY extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'INCRBY';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\INCRBYFLOAT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/incrbyfloat
 */
class INCRBYFLOAT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'INCRBYFLOAT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\INFO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/info
 */
class INFO extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'INFO';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (empty($data) || !$lines = preg_split('/\r?\n/', $data)) {
            return [];
        }

        if (strpos($lines[0], '#') === 0) {
            return $this->parseNewResponseFormat($lines);
        } else {
            return $this->parseOldResponseFormat($lines);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function parseNewResponseFormat($lines)
    {
        $info = [];
        $current = null;

        foreach ($lines as $row) {
            if ($row === '') {
                continue;
            }

            if (preg_match('/^# (\w+)$/', $row, $matches)) {
                $info[$matches[1]] = [];
                $current = &$info[$matches[1]];
                continue;
            }

            [$k, $v] = $this->parseRow($row);
            $current[$k] = $v;
        }

        return $info;
    }

    /**
     * {@inheritdoc}
     */
    public function parseOldResponseFormat($lines)
    {
        $info = [];

        foreach ($lines as $row) {
            if (strpos($row, ':') === false) {
                continue;
            }

            [$k, $v] = $this->parseRow($row);
            $info[$k] = $v;
        }

        return $info;
    }

    /**
     * Parses a single row of the response and returns the key-value pair.
     *
     * @param string $row Single row of the response.
     *
     * @return array
     */
    protected function parseRow($row)
    {
        if (preg_match('/^module:name/', $row)) {
            return $this->parseModuleRow($row);
        }

        [$k, $v] = explode(':', $row, 2);

        if (preg_match('/^db\d+$/', $k)) {
            $v = $this->parseDatabaseStats($v);
        }

        return [$k, $v];
    }

    /**
     * Extracts the statistics of each logical DB from the string buffer.
     *
     * @param string $str Response buffer.
     *
     * @return array
     */
    protected function parseDatabaseStats($str)
    {
        $db = [];

        foreach (explode(',', $str) as $dbvar) {
            [$dbvk, $dbvv] = explode('=', $dbvar);
            $db[trim($dbvk)] = $dbvv;
        }

        return $db;
    }

    /**
     * Parsing module rows because of different format.
     *
     * @param  string $row
     * @return array
     */
    protected function parseModuleRow(string $row): array
    {
        [$moduleKeyword, $moduleData] = explode(':', $row);
        $explodedData = explode(',', $moduleData);
        $parsedData = [];

        foreach ($explodedData as $moduleDataRow) {
            [$k, $v] = explode('=', $moduleDataRow);

            if ($k === 'name') {
                $parsedData[0] = $v;
                continue;
            }

            $parsedData[1][$k] = $v;
        }

        return $parsedData;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\KEYS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/keys
 */
class KEYS extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'KEYS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LASTSAVE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/lastsave
 */
class LASTSAVE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LASTSAVE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LCS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/lcs/
 *
 * The LCS command implements the longest common subsequence algorithm.
 */
class LCS extends RedisCommand
{
    public function getId()
    {
        return 'LCS';
    }

    public function setArguments(array $arguments)
    {
        if (isset($arguments[2]) && $arguments[2]) {
            $arguments[2] = 'LEN';
        }

        if (isset($arguments[3]) && $arguments[3]) {
            $arguments[3] = 'IDX';
        }

        if (isset($arguments[5]) && $arguments[5]) {
            $arguments[5] = 'WITHMATCHLEN';
        }

        if (isset($arguments[4])) {
            if ($arguments[4] !== 0) {
                $argumentsBefore = array_slice($arguments, 0, 4);
                $argumentsAfter = array_slice($arguments, 5);
                $arguments = array_merge($argumentsBefore, ['MINMATCHLEN', $arguments[4]], $argumentsAfter);
            } else {
                $arguments[4] = false;
            }
        }

        parent::setArguments($arguments);
        $this->filterArguments();
    }

    public function parseResponse($data)
    {
        if (is_array($data)) {
            if ($data !== array_values($data)) {
                return $data; // Relay
            }

            return [$data[0] => $data[1], $data[2] => $data[3]];
        }

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LINDEX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/lindex
 */
class LINDEX extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LINDEX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LINSERT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/linsert
 */
class LINSERT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LINSERT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LLEN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/llen
 */
class LLEN extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LLEN';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LMOVE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

class LMOVE extends RedisCommand
{
    public function getId()
    {
        return 'LMOVE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LMPOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Count;
use Predis\Command\Traits\Keys;
use Predis\Command\Traits\LeftRight;

class LMPOP extends RedisCommand
{
    use Keys {
        Keys::setArguments as setKeys;
    }
    use LeftRight {
        LeftRight::setArguments as setLeftRight;
    }
    use Count {
        Count::setArguments as setCount;
    }

    protected static $keysArgumentPositionOffset = 0;
    protected static $leftRightArgumentPositionOffset = 1;
    protected static $countArgumentPositionOffset = 2;

    public function getId()
    {
        return 'LMPOP';
    }

    public function setArguments(array $arguments)
    {
        $this->setCount($arguments);
        $arguments = $this->getArguments();

        $this->setLeftRight($arguments);
        $arguments = $this->getArguments();

        $this->setKeys($arguments);
        $this->filterArguments();
    }

    public function parseResponse($data)
    {
        if (null === $data) {
            return null;
        }

        return [$data[0] => $data[1]];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LPOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/lpop
 */
class LPOP extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LPOP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LPUSH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/lpush
 */
class LPUSH extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LPUSH';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeVariadic($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LPUSHX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/lpushx
 */
class LPUSHX extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LPUSHX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/lrange
 */
class LRANGE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LRANGE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LREM.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/lrem
 */
class LREM extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LREM';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LSET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/lset
 */
class LSET extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LSET';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\LTRIM.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/ltrim
 */
class LTRIM extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'LTRIM';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\MGET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/mget
 */
class MGET extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'MGET';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\MIGRATE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/migrate
 */
class MIGRATE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'MIGRATE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (is_array(end($arguments))) {
            foreach (array_pop($arguments) as $modifier => $value) {
                $modifier = strtoupper($modifier);

                if ($modifier === 'COPY' && $value == true) {
                    $arguments[] = $modifier;
                }

                if ($modifier === 'REPLACE' && $value == true) {
                    $arguments[] = $modifier;
                }
            }
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\MONITOR.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/monitor
 */
class MONITOR extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'MONITOR';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\MOVE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/move
 */
class MOVE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'MOVE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\MSET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/mset
 */
class MSET extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'MSET';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 1 && is_array($arguments[0])) {
            $flattenedKVs = [];
            $args = $arguments[0];

            foreach ($args as $k => $v) {
                $flattenedKVs[] = $k;
                $flattenedKVs[] = $v;
            }

            $arguments = $flattenedKVs;
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\MSETNX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see http://redis.io/commands/msetnx
 */
class MSETNX extends MSET
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'MSETNX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\MULTI.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/multi
 */
class MULTI extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'MULTI';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\OBJECT_.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/object
 */
class OBJECT_ extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'OBJECT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PERSIST.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/persist
 */
class PERSIST extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PERSIST';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PEXPIRE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/pexpire
 */
class PEXPIRE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PEXPIRE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PEXPIREAT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/pexpireat
 */
class PEXPIREAT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PEXPIREAT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PEXPIRETIME.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/pexpiretime/
 *
 * PEXPIRETIME has the same semantic as EXPIRETIME,
 * but returns the absolute Unix expiration timestamp in milliseconds instead of seconds.
 */
class PEXPIRETIME extends RedisCommand
{
    public function getId()
    {
        return 'PEXPIRETIME';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PFADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/pfadd
 */
class PFADD extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PFADD';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeVariadic($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PFCOUNT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/pfcount
 */
class PFCOUNT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PFCOUNT';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PFMERGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/pfmerge
 */
class PFMERGE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PFMERGE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PING.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/ping
 */
class PING extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PING';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PSETEX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/psetex
 */
class PSETEX extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PSETEX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PSUBSCRIBE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/psubscribe
 */
class PSUBSCRIBE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PSUBSCRIBE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PTTL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/pttl
 */
class PTTL extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PTTL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PUBLISH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/publish
 */
class PUBLISH extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PUBLISH';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PUBSUB.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/pubsub
 */
class PUBSUB extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PUBSUB';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        switch (strtolower($this->getArgument(0))) {
            case 'numsub':
                return self::processNumsub($data);

            default:
                return $data;
        }
    }

    /**
     * Returns the processed response to PUBSUB NUMSUB.
     *
     * @param array $channels List of channels
     *
     * @return array
     */
    protected static function processNumsub(array $channels)
    {
        $processed = [];
        $count = count($channels);

        for ($i = 0; $i < $count; ++$i) {
            $processed[$channels[$i]] = $channels[++$i];
        }

        return $processed;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\PUNSUBSCRIBE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/punsubscribe
 */
class PUNSUBSCRIBE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'PUNSUBSCRIBE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\QUIT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/quit
 */
class QUIT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'QUIT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\RANDOMKEY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/randomkey
 */
class RANDOMKEY extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'RANDOMKEY';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        return $data !== '' ? $data : null;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\RENAME.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/rename
 */
class RENAME extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'RENAME';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\RENAMENX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/renamenx
 */
class RENAMENX extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'RENAMENX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\RESTORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/restore
 */
class RESTORE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'RESTORE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\RPOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/rpop
 */
class RPOP extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'RPOP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\RPOPLPUSH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/rpoplpush
 */
class RPOPLPUSH extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'RPOPLPUSH';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\RPUSH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/rpush
 */
class RPUSH extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'RPUSH';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeVariadic($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\RPUSHX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/rpushx
 */
class RPUSHX extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'RPUSHX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/sadd
 */
class SADD extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SADD';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeVariadic($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SAVE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/save
 */
class SAVE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SAVE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SCAN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/scan
 */
class SCAN extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SCAN';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[1])) {
            $options = $this->prepareOptions(array_pop($arguments));
            $arguments = array_merge($arguments, $options);
        }

        parent::setArguments($arguments);
    }

    /**
     * Returns a list of options and modifiers compatible with Redis.
     *
     * @param array $options List of options.
     *
     * @return array
     */
    protected function prepareOptions($options)
    {
        $options = array_change_key_case($options, CASE_UPPER);
        $normalized = [];

        if (!empty($options['MATCH'])) {
            $normalized[] = 'MATCH';
            $normalized[] = $options['MATCH'];
        }

        if (!empty($options['COUNT'])) {
            $normalized[] = 'COUNT';
            $normalized[] = $options['COUNT'];
        }

        return $normalized;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SCARD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/scard
 */
class SCARD extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SCARD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SCRIPT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/script
 */
class SCRIPT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SCRIPT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SDIFF.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/sdiff
 */
class SDIFF extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SDIFF';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SDIFFSTORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/sdiffstore
 */
class SDIFFSTORE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SDIFFSTORE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[1])) {
            $arguments = array_merge([$arguments[0]], $arguments[1]);
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SELECT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/select
 */
class SELECT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SELECT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SENTINEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/topics/sentinel
 */
class SENTINEL extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SENTINEL';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        $argument = $this->getArgument(0);
        $argument = is_null($argument) ? null : strtolower($argument);

        switch ($argument) {
            case 'masters':
            case 'slaves':
                return self::processMastersOrSlaves($data);

            default:
                return $data;
        }
    }

    /**
     * Returns a processed response to SENTINEL MASTERS or SENTINEL SLAVES.
     *
     * @param array $servers List of Redis servers.
     *
     * @return array
     */
    protected static function processMastersOrSlaves(array $servers)
    {
        foreach ($servers as $idx => $node) {
            $processed = [];
            $count = count($node);

            for ($i = 0; $i < $count; ++$i) {
                $processed[$node[$i]] = $node[++$i];
            }

            $servers[$idx] = $processed;
        }

        return $servers;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/set
 */
class SET extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SET';
    }

    public function setArguments(array $arguments)
    {
        foreach ($arguments as $index => $value) {
            if ($index < 2) {
                continue;
            }

            if (false === $value || null === $value) {
                unset($arguments[$index]);
            }
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SETBIT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/setbit
 */
class SETBIT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SETBIT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SETEX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/setex
 */
class SETEX extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SETEX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SETNX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/setnx
 */
class SETNX extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SETNX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SETRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/setrange
 */
class SETRANGE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SETRANGE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SHUTDOWN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/shutdown
 */
class SHUTDOWN extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SHUTDOWN';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (empty($arguments)) {
            parent::setArguments($arguments);

            return;
        }

        $processedArguments = [];

        if (array_key_exists(0, $arguments) && null !== $arguments[0]) {
            $processedArguments[] = ($arguments[0]) ? 'SAVE' : 'NOSAVE';
        }

        if (array_key_exists(1, $arguments) && false !== $arguments[1]) {
            $processedArguments[] = 'NOW';
        }

        if (array_key_exists(2, $arguments) && false !== $arguments[2]) {
            $processedArguments[] = 'FORCE';
        }

        if (array_key_exists(3, $arguments) && false !== $arguments[3]) {
            $processedArguments[] = 'ABORT';
        }

        parent::setArguments($processedArguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SINTER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/sinter
 */
class SINTER extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SINTER';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SINTERCARD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Keys;
use Predis\Command\Traits\Limit\Limit;

class SINTERCARD extends RedisCommand
{
    use Keys {
        Keys::setArguments as setKeys;
    }
    use Limit {
        Limit::setArguments as setLimit;
    }

    protected static $keysArgumentPositionOffset = 0;
    protected static $limitArgumentPositionOffset = 1;

    public function getId()
    {
        return 'SINTERCARD';
    }

    public function setArguments(array $arguments)
    {
        $this->setLimit($arguments);
        $arguments = $this->getArguments();

        $this->setKeys($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SINTERSTORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/sinterstore
 */
class SINTERSTORE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SINTERSTORE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[1])) {
            $arguments = array_merge([$arguments[0]], $arguments[1]);
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SISMEMBER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/sismember
 */
class SISMEMBER extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SISMEMBER';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SLAVEOF.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/slaveof
 */
class SLAVEOF extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SLAVEOF';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 0 || $arguments[0] === 'NO ONE') {
            $arguments = ['NO', 'ONE'];
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SLOWLOG.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/slowlog
 */
class SLOWLOG extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SLOWLOG';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (is_array($data)) {
            $log = [];

            foreach ($data as $index => $entry) {
                $log[$index] = [
                    'id' => $entry[0],
                    'timestamp' => $entry[1],
                    'duration' => $entry[2],
                    'command' => $entry[3],
                ];
            }

            return $log;
        }

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SMEMBERS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/smembers
 */
class SMEMBERS extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SMEMBERS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SMISMEMBER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/smismember/
 *
 * Returns whether each member is a member of the set stored at key.
 */
class SMISMEMBER extends RedisCommand
{
    public function getId()
    {
        return 'SMISMEMBER';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SMOVE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/smove
 */
class SMOVE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SMOVE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SORT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/sort
 */
class SORT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SORT';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 1) {
            parent::setArguments($arguments);

            return;
        }

        $query = [$arguments[0]];
        $sortParams = array_change_key_case($arguments[1], CASE_UPPER);

        if (isset($sortParams['BY'])) {
            $query[] = 'BY';
            $query[] = $sortParams['BY'];
        }

        if (isset($sortParams['GET'])) {
            $getargs = $sortParams['GET'];

            if (is_array($getargs)) {
                foreach ($getargs as $getarg) {
                    $query[] = 'GET';
                    $query[] = $getarg;
                }
            } else {
                $query[] = 'GET';
                $query[] = $getargs;
            }
        }

        if (isset($sortParams['LIMIT'])
            && is_array($sortParams['LIMIT'])
            && count($sortParams['LIMIT']) == 2) {
            $query[] = 'LIMIT';
            $query[] = $sortParams['LIMIT'][0];
            $query[] = $sortParams['LIMIT'][1];
        }

        if (isset($sortParams['SORT'])) {
            $query[] = strtoupper($sortParams['SORT']);
        }

        if (isset($sortParams['ALPHA']) && $sortParams['ALPHA'] == true) {
            $query[] = 'ALPHA';
        }

        if (isset($sortParams['STORE'])) {
            $query[] = 'STORE';
            $query[] = $sortParams['STORE'];
        }

        parent::setArguments($query);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SORT_RO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\By\ByArgument;
use Predis\Command\Traits\Get\Get;
use Predis\Command\Traits\Limit\LimitObject;
use Predis\Command\Traits\Sorting;

/**
 * @see https://redis.io/commands/sort_ro/
 *
 * Read-only variant of the SORT command.
 * It is exactly like the original SORT but refuses the STORE option
 * and can safely be used in read-only replicas.
 */
class SORT_RO extends RedisCommand
{
    use ByArgument {
        ByArgument::setArguments as setBy;
    }
    use LimitObject {
        LimitObject::setArguments as setLimit;
    }
    use Get {
        Get::setArguments as setGetArgument;
    }
    use Sorting {
        Sorting::setArguments as setSorting;
    }

    protected static $byArgumentPositionOffset = 1;
    protected static $getArgumentPositionOffset = 3;
    protected static $sortArgumentPositionOffset = 4;

    public function getId()
    {
        return 'SORT_RO';
    }

    public function setArguments(array $arguments)
    {
        $alpha = array_pop($arguments);

        if (is_bool($alpha) && $alpha) {
            $arguments[] = 'ALPHA';
        } elseif (!is_bool($alpha)) {
            $arguments[] = $alpha;
        }

        $this->setSorting($arguments);
        $arguments = $this->getArguments();

        $this->setGetArgument($arguments);
        $arguments = $this->getArguments();

        $this->setLimit($arguments);
        $arguments = $this->getArguments();

        $this->setBy($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SPOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/spop
 */
class SPOP extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SPOP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SRANDMEMBER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/srandmember
 */
class SRANDMEMBER extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SRANDMEMBER';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SREM.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/srem
 */
class SREM extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SREM';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeVariadic($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SSCAN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/sscan
 */
class SSCAN extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SSCAN';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 3 && is_array($arguments[2])) {
            $options = $this->prepareOptions(array_pop($arguments));
            $arguments = array_merge($arguments, $options);
        }

        parent::setArguments($arguments);
    }

    /**
     * Returns a list of options and modifiers compatible with Redis.
     *
     * @param array $options List of options.
     *
     * @return array
     */
    protected function prepareOptions($options)
    {
        $options = array_change_key_case($options, CASE_UPPER);
        $normalized = [];

        if (!empty($options['MATCH'])) {
            $normalized[] = 'MATCH';
            $normalized[] = $options['MATCH'];
        }

        if (!empty($options['COUNT'])) {
            $normalized[] = 'COUNT';
            $normalized[] = $options['COUNT'];
        }

        return $normalized;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\STRLEN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/strlen
 */
class STRLEN extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'STRLEN';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SUBSCRIBE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/subscribe
 */
class SUBSCRIBE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SUBSCRIBE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SUBSTR.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/substr
 */
class SUBSTR extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SUBSTR';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SUNION.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/sunion
 */
class SUNION extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SUNION';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\SUNIONSTORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/sunionstore
 */
class SUNIONSTORE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'SUNIONSTORE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[1])) {
            $arguments = array_merge([$arguments[0]], $arguments[1]);
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TIME.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/time
 */
class TIME extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'TIME';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TOUCH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/touch
 */
class TOUCH extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'TOUCH';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TTL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/ttl
 */
class TTL extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'TTL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TYPE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/type
 */
class TYPE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'TYPE';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (is_string($data)) {
            return $data;
        }

        // Relay types
        switch ($data) {
            case 0: return 'none';
            case 1: return 'string';
            case 2: return 'set';
            case 3: return 'list';
            case 4: return 'zset';
            case 5: return 'hash';
            case 6: return 'stream';
            default: return $data;
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\UNSUBSCRIBE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/unsubscribe
 */
class UNSUBSCRIBE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'UNSUBSCRIBE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeArguments($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\UNWATCH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/unwatch
 */
class UNWATCH extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'UNWATCH';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\WAITAOF.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/waitaof/
 *
 * This command blocks the current client until all the previous write commands are acknowledged
 * as having been fsynced to the AOF of the local Redis and/or at least the specified number of replicas.
 */
class WAITAOF extends RedisCommand
{
    public function getId()
    {
        return 'WAITAOF';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\WATCH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/watch
 */
class WATCH extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'WATCH';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (isset($arguments[0]) && is_array($arguments[0])) {
            $arguments = $arguments[0];
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\XADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/xadd
 */
class XADD extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'XADD';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $args = [];

        $args[] = $arguments[0];
        $options = $arguments[3] ?? [];

        if (isset($options['nomkstream']) && $options['nomkstream']) {
            $args[] = 'NOMKSTREAM';
        }

        if (isset($options['trim']) && is_array($options['trim'])) {
            array_push($args, ...$options['trim']);

            if (isset($options['limit'])) {
                $args[] = 'LIMIT';
                $args[] = $options['limit'];
            }
        }

        // ID, default to * to let Redis set it
        $args[] = $arguments[2] ?? '*';
        if (isset($arguments[1]) && is_array($arguments[1])) {
            foreach ($arguments[1] as $key => $val) {
                $args[] = $key;
                $args[] = $val;
            }
        }

        parent::setArguments($args);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\XDEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/xdel
 */
class XDEL extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'XDEL';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeVariadic($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\XLEN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/xlen
 */
class XLEN extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'XLEN';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\XRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/xrange
 */
class XRANGE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'XRANGE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 4) {
            $arguments[] = $arguments[3];
            $arguments[3] = 'COUNT';
        }

        parent::setArguments($arguments);
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        $result = [];
        foreach ($data as $entry) {
            $processed = [];
            $count = count($entry[1]);

            for ($i = 0; $i < $count; ++$i) {
                $processed[$entry[1][$i]] = $entry[1][++$i];
            }

            $result[$entry[0]] = $processed;
        }

        return $result;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\XREAD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

class XREAD extends RedisCommand
{
    public function getId()
    {
        return 'XREAD';
    }

    public function setArguments(array $arguments)
    {
        $processedArguments = [];

        if (array_key_exists(0, $arguments) && null !== $arguments[0]) {
            array_push($processedArguments, 'COUNT', $arguments[0]);
        }

        if (array_key_exists(1, $arguments) && null !== $arguments[1]) {
            array_push($processedArguments, 'BLOCK', $arguments[1]);
        }

        if (array_key_exists(2, $arguments) && null !== $arguments[2]) {
            $processedArguments[] = 'STREAMS';
            $processedArguments = array_merge($processedArguments, $arguments[2]);
        }

        $ids = array_slice($arguments, 3);
        $processedArguments = array_merge($processedArguments, $ids);

        parent::setArguments($processedArguments);
    }

    public function parseResponse($data)
    {
        $processedData = [];

        foreach ($data as $stream) {
            $processedData[$stream[0]] = $stream[1];
        }

        return $processedData;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\XREVRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see http://redis.io/commands/xrevrange
 */
class XREVRANGE extends XRANGE
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'XREVRANGE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\XTRIM.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/xtrim
 */
class XTRIM extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'XTRIM';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $args = [];
        $options = $arguments[3] ?? [];

        $args[] = $arguments[0];
        // Either e.g. 'MAXLEN' or ['MAXLEN', '~']
        if (is_array($arguments[1])) {
            array_push($args, ...$arguments[1]);
        } else {
            $args[] = $arguments[1];
        }

        $args[] = $arguments[2];
        if (isset($options['limit'])) {
            $args[] = 'LIMIT';
            $args[] = $options['limit'];
        }

        parent::setArguments($args);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zadd
 */
class ZADD extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZADD';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (is_array(end($arguments))) {
            foreach (array_pop($arguments) as $member => $score) {
                $arguments[] = $score;
                $arguments[] = $member;
            }
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZCARD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zcard
 */
class ZCARD extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZCARD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZCOUNT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zcount
 */
class ZCOUNT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZCOUNT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZDIFF.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Keys;
use Predis\Command\Traits\With\WithScores;

/**
 * @see https://redis.io/commands/zdiff/
 *
 * This command is similar to ZDIFFSTORE, but instead of
 * storing the resulting sorted set, it is returned to the client.
 */
class ZDIFF extends RedisCommand
{
    use WithScores {
        WithScores::setArguments as setWithScore;
    }
    use Keys {
        Keys::setArguments as setKeys;
    }

    protected static $keysArgumentPositionOffset = 0;

    public function getId()
    {
        return 'ZDIFF';
    }

    public function setArguments(array $arguments)
    {
        $this->setKeys($arguments);
        $arguments = $this->getArguments();

        $this->setWithScore($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZDIFFSTORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Keys;

/**
 * @see https://redis.io/commands/zdiffstore/
 *
 * Computes the difference between the first and all successive input sorted sets
 * and stores the result in destination. The total number of input keys is specified by numkeys.
 *
 * Keys that do not exist are considered to be empty sets.
 *
 * If destination already exists, it is overwritten.
 */
class ZDIFFSTORE extends RedisCommand
{
    use Keys {
        Keys::setArguments as setKeys;
    }

    public static $keysArgumentPositionOffset = 1;

    public function getId()
    {
        return 'ZDIFFSTORE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZINCRBY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zincrby
 */
class ZINCRBY extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZINCRBY';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZINTER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Traits\With\WithScores;

/**
 * @see https://redis.io/commands/zinter/
 *
 * This command is similar to ZINTERSTORE, but instead of
 * storing the resulting sorted set, it is returned to the client.
 */
class ZINTER extends ZINTERSTORE
{
    use WithScores;

    protected static $keysArgumentPositionOffset = 0;
    protected static $weightsArgumentPositionOffset = 1;
    protected static $aggregateArgumentPositionOffset = 2;

    public function getId()
    {
        return 'ZINTER';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZINTERCARD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Keys;
use Predis\Command\Traits\Limit\Limit;

/**
 * @see https://redis.io/commands/zintercard/
 *
 * This command is similar to ZINTER, but instead of returning the result set,
 * it returns just the cardinality of the result.
 */
class ZINTERCARD extends RedisCommand
{
    use Keys {
        Keys::setArguments as setKeys;
    }
    use Limit {
        Limit::setArguments as setLimit;
    }

    protected static $keysArgumentPositionOffset = 0;
    protected static $limitArgumentPositionOffset = 1;

    public function getId()
    {
        return 'ZINTERCARD';
    }

    public function setArguments(array $arguments)
    {
        $this->setLimit($arguments);
        $arguments = $this->getArguments();

        $this->setKeys($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZINTERSTORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see http://redis.io/commands/zinterstore
 */
class ZINTERSTORE extends ZUNIONSTORE
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZINTERSTORE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZLEXCOUNT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zlexcount
 */
class ZLEXCOUNT extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZLEXCOUNT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZMPOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Count;
use Predis\Command\Traits\Keys;
use Predis\Command\Traits\MinMaxModifier;

/**
 * @see https://redis.io/commands/zmpop/
 *
 * Pops one or more elements, that are member-score pairs,
 * from the first non-empty sorted set in the provided list of key names.
 */
class ZMPOP extends RedisCommand
{
    use Keys {
        Keys::setArguments as setKeys;
    }
    use Count {
        Count::setArguments as setCount;
    }
    use MinMaxModifier;

    protected static $keysArgumentPositionOffset = 0;
    protected static $countArgumentPositionOffset = 2;
    protected static $modifierArgumentPositionOffset = 1;

    public function getId()
    {
        return 'ZMPOP';
    }

    public function setArguments(array $arguments)
    {
        $this->setCount($arguments);
        $arguments = $this->getArguments();

        $this->resolveModifier(static::$modifierArgumentPositionOffset, $arguments);

        $this->setKeys($arguments);
        $arguments = $this->getArguments();

        parent::setArguments($arguments);
    }

    public function parseResponse($data)
    {
        $key = array_shift($data);

        if (null === $key) {
            return [$key];
        }

        $data = $data[0];
        $parsedData = [];

        for ($i = 0, $iMax = count($data); $i < $iMax; $i++) {
            for ($j = 0, $jMax = count($data[$i]); $j < $jMax; ++$j) {
                if ($data[$i][$j + 1] ?? false) {
                    $parsedData[$data[$i][$j]] = $data[$i][++$j];
                }
            }
        }

        return array_combine([$key], [$parsedData]);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZMSCORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/zmscore/
 *
 * Returns the scores associated with the specified members
 * in the sorted set stored at key.
 *
 * For every member that does not exist in the sorted set, a null value is returned.
 */
class ZMSCORE extends RedisCommand
{
    /**
     * {@inheritDoc}
     */
    public function getId()
    {
        return 'ZMSCORE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZPOPMAX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zpopmax
 */
class ZPOPMAX extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZPOPMAX';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        $result = [];

        for ($i = 0; $i < count($data); ++$i) {
            if (is_array($data[$i])) {
                $result[$data[$i][0]] = $data[$i][1]; // Relay
            } else {
                $result[$data[$i]] = $data[++$i];
            }
        }

        return $result;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZPOPMIN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zpopmin
 */
class ZPOPMIN extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZPOPMIN';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        $result = [];

        for ($i = 0; $i < count($data); ++$i) {
            if (is_array($data[$i])) {
                $result[$data[$i][0]] = $data[$i][1]; // Relay
            } else {
                $result[$data[$i]] = $data[++$i];
            }
        }

        return $result;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZRANDMEMBER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\With\WithScores;

/**
 * @see https://redis.io/commands/zrandmember/
 *
 * Return a random element from the sorted set value stored at key.
 *
 * If the provided count argument is positive, return an array of distinct elements.
 *
 * If called with a negative count, the behavior changes and the command
 * is allowed to return the same element multiple times.
 */
class ZRANDMEMBER extends RedisCommand
{
    use WithScores;

    public function getId()
    {
        return 'ZRANDMEMBER';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zrange
 */
class ZRANGE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZRANGE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 4) {
            $lastType = gettype($arguments[3]);

            if ($lastType === 'string' && strtoupper($arguments[3]) === 'WITHSCORES') {
                // Used for compatibility with older versions
                $arguments[3] = ['WITHSCORES' => true];
                $lastType = 'array';
            }

            if ($lastType === 'array') {
                $options = $this->prepareOptions(array_pop($arguments));
                $arguments = array_merge($arguments, $options);
            }
        }

        parent::setArguments($arguments);
    }

    /**
     * Returns a list of options and modifiers compatible with Redis.
     *
     * @param array $options List of options.
     *
     * @return array
     */
    protected function prepareOptions($options)
    {
        $opts = array_change_key_case($options, CASE_UPPER);
        $finalizedOpts = [];

        if (!empty($opts['WITHSCORES'])) {
            $finalizedOpts[] = 'WITHSCORES';
        }

        return $finalizedOpts;
    }

    /**
     * Checks for the presence of the WITHSCORES modifier.
     *
     * @return bool
     */
    protected function withScores()
    {
        $arguments = $this->getArguments();

        if (count($arguments) < 4) {
            return false;
        }

        return strtoupper($arguments[3]) === 'WITHSCORES';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if ($this->withScores()) {
            $result = [];

            for ($i = 0; $i < count($data); ++$i) {
                if (is_array($data[$i])) {
                    $result[$data[$i][0]] = $data[$i][1]; // Relay
                } else {
                    $result[$data[$i]] = $data[++$i];
                }
            }

            return $result;
        }

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZRANGEBYLEX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see http://redis.io/commands/zrangebylex
 */
class ZRANGEBYLEX extends ZRANGE
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZRANGEBYLEX';
    }

    /**
     * {@inheritdoc}
     */
    protected function prepareOptions($options)
    {
        $opts = array_change_key_case($options, CASE_UPPER);
        $finalizedOpts = [];

        if (isset($opts['LIMIT']) && is_array($opts['LIMIT'])) {
            $limit = array_change_key_case($opts['LIMIT'], CASE_UPPER);

            $finalizedOpts[] = 'LIMIT';
            $finalizedOpts[] = $limit['OFFSET'] ?? $limit[0];
            $finalizedOpts[] = $limit['COUNT'] ?? $limit[1];
        }

        return $finalizedOpts;
    }

    /**
     * {@inheritdoc}
     */
    protected function withScores()
    {
        return false;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZRANGEBYSCORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see http://redis.io/commands/zrangebyscore
 */
class ZRANGEBYSCORE extends ZRANGE
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZRANGEBYSCORE';
    }

    /**
     * {@inheritdoc}
     */
    protected function prepareOptions($options)
    {
        $opts = array_change_key_case($options, CASE_UPPER);
        $finalizedOpts = [];

        if (isset($opts['LIMIT']) && is_array($opts['LIMIT'])) {
            $limit = array_change_key_case($opts['LIMIT'], CASE_UPPER);

            $finalizedOpts[] = 'LIMIT';
            $finalizedOpts[] = $limit['OFFSET'] ?? $limit[0];
            $finalizedOpts[] = $limit['COUNT'] ?? $limit[1];
        }

        return array_merge($finalizedOpts, parent::prepareOptions($options));
    }

    /**
     * {@inheritdoc}
     */
    protected function withScores()
    {
        $arguments = $this->getArguments();

        for ($i = 3; $i < count($arguments); ++$i) {
            switch (strtoupper($arguments[$i])) {
                case 'WITHSCORES':
                    return true;

                case 'LIMIT':
                    $i += 2;
                    break;
            }
        }

        return false;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZRANGESTORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\By\ByLexByScore;
use Predis\Command\Traits\Limit\Limit;
use Predis\Command\Traits\Rev;

/**
 * @see https://redis.io/commands/zrangestore/
 *
 * This command is like ZRANGE, but stores the result in the destination key.
 */
class ZRANGESTORE extends RedisCommand
{
    use ByLexByScore {
        ByLexByScore::setArguments as setByLexByScoreArgument;
    }
    use Rev {
        Rev::setArguments as setReversedArgument;
    }
    use Limit {
        Limit::setArguments as setLimitArguments;
    }

    protected static $byLexByScoreArgumentPositionOffset = 4;
    protected static $revArgumentPositionOffset = 5;
    protected static $limitArgumentPositionOffset = 6;

    public function getId()
    {
        return 'ZRANGESTORE';
    }

    public function setArguments(array $arguments)
    {
        $this->setByLexByScoreArgument($arguments);
        $arguments = $this->getArguments();

        $this->setReversedArgument($arguments);
        $arguments = $this->getArguments();

        $this->setLimitArguments($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZRANK.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zrank
 */
class ZRANK extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZRANK';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZREM.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zrem
 */
class ZREM extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZREM';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        $arguments = self::normalizeVariadic($arguments);

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZREMRANGEBYLEX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zremrangebylex
 */
class ZREMRANGEBYLEX extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZREMRANGEBYLEX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZREMRANGEBYRANK.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zremrangebyrank
 */
class ZREMRANGEBYRANK extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZREMRANGEBYRANK';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZREMRANGEBYSCORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zremrangebyscore
 */
class ZREMRANGEBYSCORE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZREMRANGEBYSCORE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZREVRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see http://redis.io/commands/zrevrange
 */
class ZREVRANGE extends ZRANGE
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZREVRANGE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZREVRANGEBYLEX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see http://redis.io/commands/zrevrangebylex
 */
class ZREVRANGEBYLEX extends ZRANGEBYLEX
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZREVRANGEBYLEX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZREVRANGEBYSCORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @see http://redis.io/commands/zrevrangebyscore
 */
class ZREVRANGEBYSCORE extends ZRANGEBYSCORE
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZREVRANGEBYSCORE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZREVRANK.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zrevrank
 */
class ZREVRANK extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZREVRANK';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZSCAN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zscan
 */
class ZSCAN extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZSCAN';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        if (count($arguments) === 3 && is_array($arguments[2])) {
            $options = $this->prepareOptions(array_pop($arguments));
            $arguments = array_merge($arguments, $options);
        }

        parent::setArguments($arguments);
    }

    /**
     * Returns a list of options and modifiers compatible with Redis.
     *
     * @param array $options List of options.
     *
     * @return array
     */
    protected function prepareOptions($options)
    {
        $options = array_change_key_case($options, CASE_UPPER);
        $normalized = [];

        if (!empty($options['MATCH'])) {
            $normalized[] = 'MATCH';
            $normalized[] = $options['MATCH'];
        }

        if (!empty($options['COUNT'])) {
            $normalized[] = 'COUNT';
            $normalized[] = $options['COUNT'];
        }

        return $normalized;
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (is_array($data)) {
            $members = $data[1];
            $result = [];

            for ($i = 0; $i < count($members); ++$i) {
                $result[$members[$i]] = (float) $members[++$i];
            }

            $data[1] = $result;
        }

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZSCORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;

/**
 * @see http://redis.io/commands/zscore
 */
class ZSCORE extends RedisCommand
{
    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZSCORE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZUNION.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Traits\With\WithScores;

/**
 * @see https://redis.io/commands/zunion/
 *
 * This command is similar to ZUNIONSTORE, but instead of
 * storing the resulting sorted set, it is returned to the client.
 */
class ZUNION extends ZUNIONSTORE
{
    use WithScores;

    protected static $keysArgumentPositionOffset = 0;
    protected static $weightsArgumentPositionOffset = 1;
    protected static $aggregateArgumentPositionOffset = 2;

    public function getId()
    {
        return 'ZUNION';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\ZUNIONSTORE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Aggregate;
use Predis\Command\Traits\Keys;
use Predis\Command\Traits\Weights;

/**
 * @see http://redis.io/commands/zunionstore
 */
class ZUNIONSTORE extends RedisCommand
{
    use Keys {
        Keys::setArguments as setKeys;
    }
    use Weights {
        Weights::setArguments as setWeights;
    }
    use Aggregate{
        Aggregate::setArguments as setAggregate;
    }

    protected static $keysArgumentPositionOffset = 1;
    protected static $weightsArgumentPositionOffset = 2;
    protected static $aggregateArgumentPositionOffset = 3;

    /**
     * {@inheritdoc}
     */
    public function getId()
    {
        return 'ZUNIONSTORE';
    }

    /**
     * {@inheritdoc}
     */
    public function setArguments(array $arguments)
    {
        // support old `$options` array for backwards compatibility
        if (!isset($arguments[3]) && (isset($arguments[2]['weights']) || isset($arguments[2]['aggregate']))) {
            $options = array_pop($arguments);
            array_push($arguments, $options['weights'] ?? []);
            array_push($arguments, $options['aggregate'] ?? 'sum');
        }

        $this->setAggregate($arguments);
        $arguments = $this->getArguments();

        $this->setWeights($arguments);
        $arguments = $this->getArguments();

        $this->setKeys($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\AbstractCommand\BZPOPBase.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\AbstractCommand;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Keys;

abstract class BZPOPBase extends RedisCommand
{
    use Keys {
        Keys::setArguments as setKeys;
    }

    protected static $keysArgumentPositionOffset = 0;

    abstract public function getId(): string;

    public function setArguments(array $arguments)
    {
        $this->setKeys($arguments, false);
    }

    public function parseResponse($data)
    {
        $key = array_shift($data);

        if (null === $key) {
            return [$key];
        }

        return array_combine([$key], [[$data[0] => $data[1]]]);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BloomFilter\BFADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/bf.add/
 *
 * Creates an empty Bloom Filter with a single sub-filter for the
 * initial capacity requested and with an upper bound error_rate.
 */
class BFADD extends RedisCommand
{
    public function getId()
    {
        return 'BF.ADD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BloomFilter\BFEXISTS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/bf.exists/
 *
 * Determines whether an item may exist in the Bloom Filter or not.
 */
class BFEXISTS extends RedisCommand
{
    public function getId()
    {
        return 'BF.EXISTS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BloomFilter\BFINFO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Command as RedisCommand;
use UnexpectedValueException;

/**
 * @see https://redis.io/commands/bf.info/
 *
 * Return information about key filter.
 */
class BFINFO extends RedisCommand
{
    /**
     * @var string[]
     */
    private $modifierEnum = [
        'capacity' => 'CAPACITY',
        'size' => 'SIZE',
        'filters' => 'FILTERS',
        'items' => 'ITEMS',
        'expansion' => 'EXPANSION',
    ];

    public function getId()
    {
        return 'BF.INFO';
    }

    public function setArguments(array $arguments)
    {
        if (isset($arguments[1])) {
            $modifier = array_pop($arguments);

            if ($modifier === '') {
                parent::setArguments($arguments);

                return;
            }

            if (!in_array(strtoupper($modifier), $this->modifierEnum)) {
                $enumValues = implode(', ', array_keys($this->modifierEnum));
                throw new UnexpectedValueException("Argument accepts only: {$enumValues} values");
            }

            $arguments[] = $this->modifierEnum[strtolower($modifier)];
        }

        parent::setArguments($arguments);
    }

    public function parseResponse($data)
    {
        if (count($data) > 1) {
            $result = [];

            for ($i = 0, $iMax = count($data); $i < $iMax; ++$i) {
                if (array_key_exists($i + 1, $data)) {
                    $result[(string) $data[$i]] = $data[++$i];
                }
            }

            return $result;
        }

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BloomFilter\BFINSERT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\BloomFilters\Capacity;
use Predis\Command\Traits\BloomFilters\Error;
use Predis\Command\Traits\BloomFilters\Expansion;
use Predis\Command\Traits\BloomFilters\Items;
use Predis\Command\Traits\BloomFilters\NoCreate;

class BFINSERT extends RedisCommand
{
    use Capacity {
        Capacity::setArguments as setCapacity;
    }
    use Error {
        Error::setArguments as setErrorRate;
    }
    use Expansion {
        Expansion::setArguments as setExpansion;
    }
    use Items {
        Items::setArguments as setItems;
    }
    use NoCreate {
        NoCreate::setArguments as setNoCreate;
    }

    protected static $capacityArgumentPositionOffset = 1;
    protected static $errorArgumentPositionOffset = 2;
    protected static $expansionArgumentPositionOffset = 3;
    protected static $noCreateArgumentPositionOffset = 4;
    protected static $itemsArgumentPositionOffset = 6;

    public function getId()
    {
        return 'BF.INSERT';
    }

    public function setArguments(array $arguments)
    {
        $this->setNoCreate($arguments);
        $arguments = $this->getArguments();

        if (array_key_exists(5, $arguments) && $arguments[5]) {
            $arguments[5] = 'NONSCALING';
        }

        $this->setItems($arguments);
        $arguments = $this->getArguments();

        $this->setExpansion($arguments);
        $arguments = $this->getArguments();

        $this->setErrorRate($arguments);
        $arguments = $this->getArguments();

        $this->setCapacity($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BloomFilter\BFLOADCHUNK.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/bf.loadchunk/
 *
 * Restores a filter previously saved using SCANDUMP. See the SCANDUMP command for example usage.
 */
class BFLOADCHUNK extends RedisCommand
{
    public function getId()
    {
        return 'BF.LOADCHUNK';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BloomFilter\BFMADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/bf.madd/
 *
 * Adds one or more items to the Bloom Filter and creates the filter if it does not exist yet.
 * This command operates identically to BF.ADD except that it allows multiple inputs and returns multiple values.
 */
class BFMADD extends RedisCommand
{
    public function getId()
    {
        return 'BF.MADD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BloomFilter\BFMEXISTS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/bf.mexists/
 *
 * Determines if one or more items may exist in the filter or not.
 */
class BFMEXISTS extends RedisCommand
{
    public function getId()
    {
        return 'BF.MEXISTS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BloomFilter\BFRESERVE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\BloomFilters\Expansion;

/**
 * @see https://redis.io/commands/bf.reserve/
 *
 * Creates an empty Bloom Filter with a single sub-filter for the initial capacity
 * requested and with an upper bound error_rate.
 *
 * By default, the filter auto-scales by creating additional sub-filters when capacity is reached.
 * The new sub-filter is created with size of the previous sub-filter multiplied by expansion.
 */
class BFRESERVE extends RedisCommand
{
    use Expansion {
        Expansion::setArguments as setExpansion;
    }

    protected static $expansionArgumentPositionOffset = 3;

    public function getId()
    {
        return 'BF.RESERVE';
    }

    public function setArguments(array $arguments)
    {
        if (array_key_exists(4, $arguments) && $arguments[4]) {
            $arguments[4] = 'NONSCALING';
        }

        $this->setExpansion($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\BloomFilter\BFSCANDUMP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/bf.scandump/
 *
 * Begins an incremental save of the bloom filter.
 * This is useful for large bloom filters which cannot fit into the normal DUMP and RESTORE model.
 */
class BFSCANDUMP extends RedisCommand
{
    public function getId()
    {
        return 'BF.SCANDUMP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Container\AbstractContainer.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container;

use Predis\ClientInterface;

abstract class AbstractContainer implements ContainerInterface
{
    /**
     * @var ClientInterface
     */
    protected $client;

    public function __construct(ClientInterface $client)
    {
        $this->client = $client;
    }

    /**
     * {@inheritDoc}
     */
    public function __call(string $subcommandID, array $arguments)
    {
        array_unshift($arguments, strtoupper($subcommandID));

        return $this->client->executeCommand(
            $this->client->createCommand($this->getContainerCommandId(), $arguments)
        );
    }

    abstract public function getContainerCommandId(): string;
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Container\ACL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container;

use Predis\Response\Status;

/**
 * @method Status dryRun(string $username, string $command, ...$arguments)
 * @method array  getUser(string $username)
 * @method Status setUser(string $username, string ...$rules)
 */
class ACL extends AbstractContainer
{
    public function getContainerCommandId(): string
    {
        return 'acl';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Container\CLUSTER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container;

use Predis\Response\Status;

/**
 * @method Status addSlotsRange(int ...$startEndSlots)
 * @method Status delSlotsRange(int ...$startEndSlots)
 * @method array  links()
 * @method array  shards()
 */
class CLUSTER extends AbstractContainer
{
    public function getContainerCommandId(): string
    {
        return 'CLUSTER';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Container\ContainerFactory.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container;

use Predis\ClientConfiguration;
use Predis\ClientInterface;
use UnexpectedValueException;

class ContainerFactory
{
    private const CONTAINER_NAMESPACE = "Predis\Command\Redis\Container";

    /**
     * Mappings for class names that corresponds to PHP reserved words.
     *
     * @var array
     */
    private static $specialMappings = [
        'FUNCTION' => FunctionContainer::class,
    ];

    /**
     * Creates container command.
     *
     * @param  ClientInterface    $client
     * @param  string             $containerCommandID
     * @return ContainerInterface
     */
    public static function create(ClientInterface $client, string $containerCommandID): ContainerInterface
    {
        $containerCommandID = strtoupper($containerCommandID);
        $commandModule = self::resolveCommandModuleByPrefix($containerCommandID);

        if (null !== $commandModule) {
            if (class_exists($containerClass = self::CONTAINER_NAMESPACE . '\\' . $commandModule . '\\' . $containerCommandID)) {
                return new $containerClass($client);
            }

            throw new UnexpectedValueException('Given module container command is not supported.');
        }

        if (class_exists($containerClass = self::CONTAINER_NAMESPACE . '\\' . $containerCommandID)) {
            return new $containerClass($client);
        }

        if (array_key_exists($containerCommandID, self::$specialMappings)) {
            $containerClass = self::$specialMappings[$containerCommandID];

            return new $containerClass($client);
        }

        throw new UnexpectedValueException('Given container command is not supported.');
    }

    /**
     * @param  string      $commandID
     * @return string|null
     */
    private static function resolveCommandModuleByPrefix(string $commandID): ?string
    {
        $modules = ClientConfiguration::getModules();

        foreach ($modules as $module) {
            if (preg_match("/^{$module['commandPrefix']}/", $commandID)) {
                return $module['name'];
            }
        }

        return null;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Container\ContainerInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container;

interface ContainerInterface
{
    /**
     * Creates Redis container command with subcommand as virtual method name
     * and sends a request to the server.
     *
     * @param  string $subcommandID
     * @param  array  $arguments
     * @return mixed
     */
    public function __call(string $subcommandID, array $arguments);

    /**
     * Returns containerCommandId of specific container command.
     *
     * @return string
     */
    public function getContainerCommandId(): string;
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Container\FunctionContainer.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container;

use Predis\Response\Status;

/**
 * @method Status delete(string $libraryName)
 * @method string dump()
 * @method Status flush(?string $mode = null)
 * @method Status kill()
 * @method array  list(?string $libraryNamePattern = null, bool $withCode = false)
 * @method string load(string $functionCode, bool $replace = 'false')
 * @method Status restore(string $value, ?string $policy = null)
 * @method array  stats()
 */
class FunctionContainer extends AbstractContainer
{
    public function getContainerCommandId(): string
    {
        return 'FUNCTIONS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Container\Json\JSONDEBUG.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container\Json;

use Predis\Command\Redis\Container\AbstractContainer;

/**
 * @method array memory(string $key, string $path)
 * @method array help()
 */
class JSONDEBUG extends AbstractContainer
{
    public function getContainerCommandId(): string
    {
        return 'JSONDEBUG';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Container\Search\FTCONFIG.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container\Search;

use Predis\Command\Redis\Container\AbstractContainer;
use Predis\Response\Status;

/**
 * @method array  get(string $option)
 * @method array  help(string $option)
 * @method Status set(string $option, $value)
 */
class FTCONFIG extends AbstractContainer
{
    public function getContainerCommandId(): string
    {
        return 'FTCONFIG';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Container\Search\FTCURSOR.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container\Search;

use Predis\Command\Argument\Search\CursorArguments;
use Predis\Command\Redis\Container\AbstractContainer;
use Predis\Response\Status;

/**
 * @method Status del(string $index, int $cursorId)
 * @method array  read(string $index, int $cursorId, ?CursorArguments $arguments = null)
 */
class FTCURSOR extends AbstractContainer
{
    public function getContainerCommandId(): string
    {
        return 'FTCURSOR';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CountMinSketch\CMSINCRBY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cms.incrby/
 *
 * Increases the count of item by increment.
 * Multiple items can be increased with one call.
 */
class CMSINCRBY extends RedisCommand
{
    public function getId()
    {
        return 'CMS.INCRBY';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CountMinSketch\CMSINFO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cms.info/
 *
 * Returns width, depth and total count of the sketch.
 */
class CMSINFO extends RedisCommand
{
    public function getId()
    {
        return 'CMS.INFO';
    }

    public function parseResponse($data)
    {
        if (count($data) > 1) {
            $result = [];

            for ($i = 0, $iMax = count($data); $i < $iMax; ++$i) {
                if (array_key_exists($i + 1, $data)) {
                    $result[(string) $data[$i]] = $data[++$i];
                }
            }

            return $result;
        }

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CountMinSketch\CMSINITBYDIM.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cms.initbydim/
 *
 * Initializes a Count-Min Sketch to dimensions specified by user.
 */
class CMSINITBYDIM extends RedisCommand
{
    public function getId()
    {
        return 'CMS.INITBYDIM';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CountMinSketch\CMSINITBYPROB.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cms.initbyprob/
 *
 * Initializes a Count-Min Sketch to accommodate requested tolerances.
 */
class CMSINITBYPROB extends RedisCommand
{
    public function getId()
    {
        return 'CMS.INITBYPROB';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CountMinSketch\CMSMERGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cms.merge/
 *
 * Merges several sketches into one sketch.
 * All sketches must have identical width and depth.
 * Weights can be used to multiply certain sketches. Default weight is 1.
 */
class CMSMERGE extends RedisCommand
{
    public function getId()
    {
        return 'CMS.MERGE';
    }

    public function setArguments(array $arguments)
    {
        $processedArguments = array_merge([$arguments[0], count($arguments[1])], $arguments[1]);

        if (!empty($arguments[2])) {
            $processedArguments[] = 'WEIGHTS';
            $processedArguments = array_merge($processedArguments, $arguments[2]);
        }

        parent::setArguments($processedArguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CountMinSketch\CMSQUERY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cms.query/
 *
 * Returns the count for one or more items in a sketch.
 */
class CMSQUERY extends RedisCommand
{
    public function getId()
    {
        return 'CMS.QUERY';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cf.add/
 *
 * Adds an item to the cuckoo filter, creating the filter if it does not exist.
 */
class CFADD extends RedisCommand
{
    public function getId()
    {
        return 'CF.ADD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFADDNX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cf.addnx/
 *
 * Adds an item to a cuckoo filter if the item did not exist previously.
 */
class CFADDNX extends RedisCommand
{
    public function getId()
    {
        return 'CF.ADDNX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFCOUNT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cf.count/
 *
 * Returns the number of times an item may be in the filter.
 * Because this is a probabilistic data structure, this may not necessarily be accurate.
 */
class CFCOUNT extends RedisCommand
{
    public function getId()
    {
        return 'CF.COUNT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFDEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cf.del/
 *
 * Deletes an item once from the filter.
 * If the item exists only once, it will be removed from the filter.
 * If the item was added multiple times, it will still be present.
 */
class CFDEL extends RedisCommand
{
    public function getId()
    {
        return 'CF.DEL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFEXISTS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cf.exists/
 *
 * Check if an item exists in a Cuckoo Filter key.
 */
class CFEXISTS extends RedisCommand
{
    public function getId()
    {
        return 'CF.EXISTS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFINFO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cf.info/
 *
 * Return information about key
 */
class CFINFO extends RedisCommand
{
    public function getId()
    {
        return 'CF.INFO';
    }

    public function parseResponse($data)
    {
        if (count($data) > 1) {
            $result = [];

            for ($i = 0, $iMax = count($data); $i < $iMax; ++$i) {
                if (array_key_exists($i + 1, $data)) {
                    $result[(string) $data[$i]] = $data[++$i];
                }
            }

            return $result;
        }

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFINSERT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\BloomFilters\Capacity;
use Predis\Command\Traits\BloomFilters\Items;
use Predis\Command\Traits\BloomFilters\NoCreate;

class CFINSERT extends RedisCommand
{
    use Capacity {
        Capacity::setArguments as setCapacity;
    }
    use NoCreate {
        NoCreate::setArguments as setNoCreate;
    }
    use Items {
        Items::setArguments as setItems;
    }

    protected static $capacityArgumentPositionOffset = 1;
    protected static $noCreateArgumentPositionOffset = 2;
    protected static $itemsArgumentPositionOffset = 3;

    public function getId()
    {
        return 'CF.INSERT';
    }

    public function setArguments(array $arguments)
    {
        $this->setNoCreate($arguments);
        $arguments = $this->getArguments();

        $this->setItems($arguments);
        $arguments = $this->getArguments();

        $this->setCapacity($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFINSERTNX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

/**
 * @see https://redis.io/commands/cf.insertnx/
 *
 * Adds one or more items to a cuckoo filter, allowing the filter
 * to be created with a custom capacity if it does not exist yet.
 */
class CFINSERTNX extends CFINSERT
{
    public function getId()
    {
        return 'CF.INSERTNX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFLOADCHUNK.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cf.loadchunk/
 *
 * Restores a filter previously saved using SCANDUMP.
 * See the SCANDUMP command for example usage.
 */
class CFLOADCHUNK extends RedisCommand
{
    public function getId()
    {
        return 'CF.LOADCHUNK';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFMEXISTS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cf.mexists/
 *
 * Check if one or more items exists in a Cuckoo Filter key.
 */
class CFMEXISTS extends RedisCommand
{
    public function getId()
    {
        return 'CF.MEXISTS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFRESERVE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\BloomFilters\BucketSize;
use Predis\Command\Traits\BloomFilters\Expansion;
use Predis\Command\Traits\BloomFilters\MaxIterations;

class CFRESERVE extends RedisCommand
{
    use BucketSize {
        BucketSize::setArguments as setBucketSize;
    }
    use MaxIterations {
        MaxIterations::setArguments as setMaxIterations;
    }
    use Expansion {
        Expansion::setArguments as setExpansion;
    }

    protected static $bucketSizeArgumentPositionOffset = 2;
    protected static $maxIterationsArgumentPositionOffset = 3;
    protected static $expansionArgumentPositionOffset = 4;

    public function getId()
    {
        return 'CF.RESERVE';
    }

    public function setArguments(array $arguments)
    {
        $this->setExpansion($arguments);
        $arguments = $this->getArguments();

        $this->setMaxIterations($arguments);
        $arguments = $this->getArguments();

        $this->setBucketSize($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\CuckooFilter\CFSCANDUMP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/cf.scandump/
 *
 * Begins an incremental save of the cuckoo filter.
 * This is useful for large cuckoo filters which cannot fit into the normal DUMP and RESTORE model.
 */
class CFSCANDUMP extends RedisCommand
{
    public function getId()
    {
        return 'CF.SCANDUMP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONARRAPPEND.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.arrappend/
 *
 * Append the json values into the array at path after the last element in it
 */
class JSONARRAPPEND extends RedisCommand
{
    public function getId()
    {
        return 'JSON.ARRAPPEND';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONARRINDEX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.arrindex/
 *
 * Search for the first occurrence of a JSON value in an array
 */
class JSONARRINDEX extends RedisCommand
{
    public function getId()
    {
        return 'JSON.ARRINDEX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONARRINSERT.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.arrinsert/
 *
 * Insert the json values into the array at path before the index (shifts to the right)
 */
class JSONARRINSERT extends RedisCommand
{
    public function getId()
    {
        return 'JSON.ARRINSERT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONARRLEN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.arrlen/
 *
 * Report the length of the JSON array at path in key
 */
class JSONARRLEN extends RedisCommand
{
    public function getId()
    {
        return 'JSON.ARRLEN';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONARRPOP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.arrpop/
 *
 * Remove and return an element from the index in the array
 */
class JSONARRPOP extends RedisCommand
{
    public function getId()
    {
        return 'JSON.ARRPOP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONARRTRIM.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.arrtrim/
 *
 * Trim an array so that it contains only the specified inclusive range of elements
 */
class JSONARRTRIM extends RedisCommand
{
    public function getId()
    {
        return 'JSON.ARRTRIM';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONCLEAR.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.clear/
 *
 * Clear container values (arrays/objects) and set numeric values to 0
 */
class JSONCLEAR extends RedisCommand
{
    public function getId()
    {
        return 'JSON.CLEAR';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONDEBUG.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.debug/
 *
 * This is a container command for debugging related tasks.
 */
class JSONDEBUG extends RedisCommand
{
    public function getId()
    {
        return 'JSON.DEBUG';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONDEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.del/
 *
 * Delete a value
 */
class JSONDEL extends RedisCommand
{
    public function getId()
    {
        return 'JSON.DEL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONFORGET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.forget/
 *
 * @see https://redis.io/commands/json.del/
 */
class JSONFORGET extends RedisCommand
{
    public function getId()
    {
        return 'JSON.FORGET';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONGET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Json\Indent;
use Predis\Command\Traits\Json\Newline;
use Predis\Command\Traits\Json\Space;

/**
 * @see https://redis.io/commands/json.get/
 *
 * Return the value at path in JSON serialized form
 */
class JSONGET extends RedisCommand
{
    use Indent {
        Indent::setArguments as setIndent;
    }
    use Newline {
        Newline::setArguments as setNewline;
    }
    use Space {
        Space::setArguments as setSpace;
    }

    protected static $indentArgumentPositionOffset = 1;
    protected static $newlineArgumentPositionOffset = 2;
    protected static $spaceArgumentPositionOffset = 3;

    public function getId()
    {
        return 'JSON.GET';
    }

    public function setArguments(array $arguments)
    {
        $this->setSpace($arguments);
        $arguments = $this->getArguments();

        $this->setNewline($arguments);
        $arguments = $this->getArguments();

        $this->setIndent($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONMERGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.merge/
 *
 * Merge a given JSON value into matching paths.
 * Consequently, JSON values at matching paths are updated, deleted, or expanded with new children.
 */
class JSONMERGE extends RedisCommand
{
    public function getId()
    {
        return 'JSON.MERGE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONMGET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

class JSONMGET extends RedisCommand
{
    public function getId()
    {
        return 'JSON.MGET';
    }

    public function setArguments(array $arguments)
    {
        $unpackedArguments = [];

        foreach ($arguments[0] as $key) {
            $unpackedArguments[] = $key;
        }

        $unpackedArguments[] = $arguments[1];

        parent::setArguments($unpackedArguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONMSET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.mset/
 *
 * Set or update one or more JSON values according to the specified key-path-value triplets.
 */
class JSONMSET extends RedisCommand
{
    public function getId()
    {
        return 'JSON.MSET';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONNUMINCRBY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.numincrby/
 *
 * Increment the number value stored at path by number
 */
class JSONNUMINCRBY extends RedisCommand
{
    public function getId()
    {
        return 'JSON.NUMINCRBY';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONOBJKEYS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.objkeys/
 *
 * Return the keys in the object that's referenced by path
 */
class JSONOBJKEYS extends RedisCommand
{
    public function getId()
    {
        return 'JSON.OBJKEYS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONOBJLEN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.objlen/
 *
 * Report the number of keys in the JSON object at path in key
 */
class JSONOBJLEN extends RedisCommand
{
    public function getId()
    {
        return 'JSON.OBJLEN';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONRESP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.resp/
 *
 * Return the JSON in key in Redis serialization protocol specification form
 */
class JSONRESP extends RedisCommand
{
    public function getId()
    {
        return 'JSON.RESP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONSET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\Json\NxXxArgument;

/**
 * @see https://redis.io/commands/json.set/
 *
 * Set the JSON value at path in key
 */
class JSONSET extends RedisCommand
{
    use NxXxArgument {
        setArguments as setSubcommand;
    }

    protected static $nxXxArgumentPositionOffset = 3;

    public function getId()
    {
        return 'JSON.SET';
    }

    public function setArguments(array $arguments)
    {
        $this->setSubcommand($arguments);
        $this->filterArguments();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONSTRAPPEND.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.strappend/
 *
 * Append the json-string values to the string at path
 */
class JSONSTRAPPEND extends RedisCommand
{
    public function getId()
    {
        return 'JSON.STRAPPEND';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONSTRLEN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.strlen/
 *
 * Report the length of the JSON String at path in key
 */
class JSONSTRLEN extends RedisCommand
{
    public function getId()
    {
        return 'JSON.STRLEN';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONTOGGLE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.toggle/
 *
 * Toggle a Boolean value stored at path
 */
class JSONTOGGLE extends RedisCommand
{
    public function getId()
    {
        return 'JSON.TOGGLE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Json\JSONTYPE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/json.type/
 *
 * Report the type of JSON value at path
 */
class JSONTYPE extends RedisCommand
{
    public function getId()
    {
        return 'JSON.TYPE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTAGGREGATE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.aggregate/
 *
 * Run a search query on an index, and perform aggregate transformations
 * on the results, extracting statistics etc. from them
 */
class FTAGGREGATE extends RedisCommand
{
    public function getId()
    {
        return 'FT.AGGREGATE';
    }

    public function setArguments(array $arguments)
    {
        [$index, $query] = $arguments;
        $commandArguments = (!empty($arguments[2])) ? $arguments[2]->toArray() : [];

        parent::setArguments(array_merge(
            [$index, $query],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTALIASADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.aliasadd/
 *
 * Add an alias to an index.
 */
class FTALIASADD extends RedisCommand
{
    public function getId()
    {
        return 'FT.ALIASADD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTALIASDEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.aliasdel/
 *
 * Remove an alias from an index.
 */
class FTALIASDEL extends RedisCommand
{
    public function getId()
    {
        return 'FT.ALIASDEL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTALIASUPDATE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.aliasupdate/
 *
 * Add an alias to an index. If the alias is already associated with another index,
 * FT.ALIASUPDATE removes the alias association with the previous index.
 */
class FTALIASUPDATE extends RedisCommand
{
    public function getId()
    {
        return 'FT.ALIASUPDATE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTALTER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\SchemaFields\FieldInterface;
use Predis\Command\Command as RedisCommand;

class FTALTER extends RedisCommand
{
    public function getId()
    {
        return 'FT.ALTER';
    }

    public function setArguments(array $arguments)
    {
        [$index, $schema] = $arguments;
        $commandArguments = (!empty($arguments[2])) ? $arguments[2]->toArray() : [];

        $schema = array_reduce($schema, static function (array $carry, FieldInterface $field) {
            return array_merge($carry, $field->toArray());
        }, []);

        array_unshift($schema, 'SCHEMA', 'ADD');

        parent::setArguments(array_merge(
            [$index],
            $commandArguments,
            $schema
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTCONFIG.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.config-get/
 * @see https://redis.io/commands/ft.config-set/
 *
 * Container command corresponds to any FT.CONFIG *.
 * Represents any FUNCTION command with subcommand as first argument.
 */
class FTCONFIG extends RedisCommand
{
    public function getId()
    {
        return 'FT.CONFIG';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTCREATE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\SchemaFields\FieldInterface;
use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.create/
 *
 * Create an index with the given specification
 */
class FTCREATE extends RedisCommand
{
    public function getId()
    {
        return 'FT.CREATE';
    }

    public function setArguments(array $arguments)
    {
        [$index, $schema] = $arguments;
        $commandArguments = (!empty($arguments[2])) ? $arguments[2]->toArray() : [];

        $schema = array_reduce($schema, static function (array $carry, FieldInterface $field) {
            return array_merge($carry, $field->toArray());
        }, []);

        array_unshift($schema, 'SCHEMA');

        parent::setArguments(array_merge(
            [$index],
            $commandArguments,
            $schema
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTCURSOR.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

class FTCURSOR extends RedisCommand
{
    public function getId()
    {
        return 'FT.CURSOR';
    }

    public function setArguments(array $arguments)
    {
        [$subcommand, $index, $cursorId] = $arguments;
        $commandArguments = (!empty($arguments[3])) ? $arguments[3]->toArray() : [];

        parent::setArguments(array_merge(
            [$subcommand, $index, $cursorId],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTDICTADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.dictadd/
 *
 * Add terms to a dictionary.
 */
class FTDICTADD extends RedisCommand
{
    public function getId()
    {
        return 'FT.DICTADD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTDICTDEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.dictdel/
 *
 * Delete terms from a dictionary.
 */
class FTDICTDEL extends RedisCommand
{
    public function getId()
    {
        return 'FT.DICTDEL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTDICTDUMP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.dictdump/
 *
 * Dump all terms in the given dictionary.
 */
class FTDICTDUMP extends RedisCommand
{
    public function getId()
    {
        return 'FT.DICTDUMP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTDROPINDEX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

class FTDROPINDEX extends RedisCommand
{
    public function getId()
    {
        return 'FT.DROPINDEX';
    }

    public function setArguments(array $arguments)
    {
        [$index] = $arguments;
        $commandArguments = [];

        if (!empty($arguments[1])) {
            $commandArguments = $arguments[1]->toArray();
        }

        parent::setArguments(array_merge(
            [$index],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTEXPLAIN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.explain/
 *
 * Return the execution plan for a complex query.
 */
class FTEXPLAIN extends RedisCommand
{
    public function getId()
    {
        return 'FT.EXPLAIN';
    }

    public function setArguments(array $arguments)
    {
        [$index, $query] = $arguments;
        $commandArguments = [];

        if (!empty($arguments[2])) {
            $commandArguments = $arguments[2]->toArray();
        }

        parent::setArguments(array_merge(
            [$index, $query],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTINFO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.info/
 *
 * Return information and statistics on the index.
 */
class FTINFO extends RedisCommand
{
    public function getId()
    {
        return 'FT.INFO';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTPROFILE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.profile/
 *
 * Perform a FT.SEARCH or FT.AGGREGATE command and collects performance information.
 */
class FTPROFILE extends RedisCommand
{
    public function getId()
    {
        return 'FT.PROFILE';
    }

    public function setArguments(array $arguments)
    {
        [$index, $arguments] = $arguments;

        parent::setArguments(array_merge(
            [$index],
            $arguments->toArray()
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTSEARCH.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see  https://redis.io/commands/ft.search/
 *
 * Search the index with a textual query, returning either documents or just ids
 */
class FTSEARCH extends RedisCommand
{
    public function getId()
    {
        return 'FT.SEARCH';
    }

    public function setArguments(array $arguments)
    {
        [$index, $query] = $arguments;
        $commandArguments = (!empty($arguments[2])) ? $arguments[2]->toArray() : [];

        parent::setArguments(array_merge(
            [$index, $query],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTSPELLCHECK.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

class FTSPELLCHECK extends RedisCommand
{
    public function getId()
    {
        return 'FT.SPELLCHECK';
    }

    public function setArguments(array $arguments)
    {
        [$index, $query] = $arguments;
        $commandArguments = [];

        if (!empty($arguments[2])) {
            $commandArguments = $arguments[2]->toArray();
        }

        parent::setArguments(array_merge(
            [$index, $query],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTSUGADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.sugadd/
 *
 * Add a suggestion string to an auto-complete suggestion dictionary.
 */
class FTSUGADD extends RedisCommand
{
    public function getId()
    {
        return 'FT.SUGADD';
    }

    public function setArguments(array $arguments)
    {
        [$key, $string, $score] = $arguments;
        $commandArguments = (!empty($arguments[3])) ? $arguments[3]->toArray() : [];

        parent::setArguments(array_merge(
            [$key, $string, $score],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTSUGDEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.sugdel/
 *
 * Delete a string from a suggestion index.
 */
class FTSUGDEL extends RedisCommand
{
    public function getId()
    {
        return 'FT.SUGDEL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTSUGGET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.sugget/
 *
 * Get completion suggestions for a prefix.
 */
class FTSUGGET extends RedisCommand
{
    public function getId()
    {
        return 'FT.SUGGET';
    }

    public function setArguments(array $arguments)
    {
        [$key, $prefix] = $arguments;
        $commandArguments = (!empty($arguments[2])) ? $arguments[2]->toArray() : [];

        parent::setArguments(array_merge(
            [$key, $prefix],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTSUGLEN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.suglen/
 *
 * Get the size of an auto-complete suggestion dictionary.
 */
class FTSUGLEN extends RedisCommand
{
    public function getId()
    {
        return 'FT.SUGLEN';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTSYNDUMP.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.syndump/
 *
 * Dump the contents of a synonym group.
 */
class FTSYNDUMP extends RedisCommand
{
    public function getId()
    {
        return 'FT.SYNDUMP';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTSYNUPDATE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.synupdate/
 *
 * Update a synonym group
 */
class FTSYNUPDATE extends RedisCommand
{
    public function getId()
    {
        return 'FT.SYNUPDATE';
    }

    public function setArguments(array $arguments)
    {
        [$index, $synonymGroupId] = $arguments;
        $commandArguments = [];

        if (!empty($arguments[2])) {
            $commandArguments = $arguments[2]->toArray();
        }

        $terms = array_slice($arguments, 3);

        parent::setArguments(array_merge(
            [$index, $synonymGroupId],
            $commandArguments,
            $terms
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\Search\FTTAGVALS.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ft.tagvals/
 *
 * Return a distinct set of values indexed in a Tag field.
 */
class FTTAGVALS extends RedisCommand
{
    public function getId()
    {
        return 'FT.TAGVALS';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.add/
 *
 * Adds one or more observations to a t-digest sketch.
 */
class TDIGESTADD extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.ADD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTBYRANK.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.byrank/
 *
 * Returns, for each input rank, an estimation of the value (floating-point) with that rank.
 */
class TDIGESTBYRANK extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.BYRANK';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (!is_array($data)) {
            return $data;
        }

        // convert Relay (RESP3) constants to strings
        return array_map(function ($value) {
            if (is_string($value) || !is_float($value)) {
                return $value;
            }

            if (is_nan($value)) {
                return 'nan';
            }

            switch ($value) {
                case INF: return 'inf';
                case -INF: return '-inf';
                default: return $value;
            }
        }, $data);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTBYREVRANK.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.byrevrank/
 *
 * Returns, for each input reverse rank, an estimation of the value (floating-point) with that reverse rank.
 */
class TDIGESTBYREVRANK extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.BYREVRANK';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (!is_array($data)) {
            return $data;
        }

        // convert Relay (RESP3) constants to strings
        return array_map(function ($value) {
            if (is_string($value) || !is_float($value)) {
                return $value;
            }

            if (is_nan($value)) {
                return 'nan';
            }

            switch ($value) {
                case INF: return 'inf';
                case -INF: return '-inf';
                default: return $value;
            }
        }, $data);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTCDF.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.cdf/
 *
 * Returns, for each input value, an estimation of the fraction (floating-point)
 * of (observations smaller than the given value + half
 * the observations equal to the given value).
 */
class TDIGESTCDF extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.CDF';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (!is_array($data)) {
            return $data;
        }

        // convert Relay (RESP3) constants to strings
        return array_map(function ($value) {
            if (is_string($value) || !is_float($value)) {
                return $value;
            }

            if (is_nan($value)) {
                return 'nan';
            }

            switch ($value) {
                case INF: return 'inf';
                case -INF: return '-inf';
                default: return $value;
            }
        }, $data);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTCREATE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.create/
 *
 * Allocates memory and initializes a new t-digest sketch.
 */
class TDIGESTCREATE extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.CREATE';
    }

    public function setArguments(array $arguments)
    {
        if (!empty($arguments[1])) {
            $arguments[2] = $arguments[1];
            $arguments[1] = 'COMPRESSION';
        } elseif (array_key_exists(1, $arguments) && $arguments[1] < 1) {
            array_pop($arguments);
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTINFO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.info/
 *
 * Returns information and statistics about a t-digest sketch.
 */
class TDIGESTINFO extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.INFO';
    }

    public function parseResponse($data)
    {
        $result = [];

        for ($i = 0, $iMax = count($data); $i < $iMax; ++$i) {
            if (array_key_exists($i + 1, $data)) {
                $result[(string) $data[$i]] = $data[++$i];
            }
        }

        return $result;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTMAX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.max/
 *
 * Returns the maximum observation value from a t-digest sketch.
 */
class TDIGESTMAX extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.MAX';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (is_string($data) || !is_float($data)) {
            return $data;
        }

        // convert Relay (RESP3) constants to strings
        if (is_nan($data)) {
            return 'nan';
        }

        switch ($data) {
            case INF: return 'inf';
            case -INF: return '-inf';
            default: return $data;
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTMERGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.merge/
 *
 * Merges multiple t-digest sketches into a single sketch.
 */
class TDIGESTMERGE extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.MERGE';
    }

    public function setArguments(array $arguments)
    {
        $processedArguments = array_merge([$arguments[0], count($arguments[1])], $arguments[1]);

        for ($i = 2, $iMax = count($arguments); $i < $iMax; $i++) {
            if (is_int($arguments[$i]) && $arguments[$i] !== 0) {
                array_push($processedArguments, 'COMPRESSION', $arguments[$i]);
            } elseif (is_bool($arguments[$i]) && $arguments[$i]) {
                $processedArguments[] = 'OVERRIDE';
            }
        }

        parent::setArguments($processedArguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTMIN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.min/
 *
 * Returns the minimum observation value from a t-digest sketch.
 */
class TDIGESTMIN extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.MIN';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (is_string($data) || !is_float($data)) {
            return $data;
        }

        // convert Relay (RESP3) constants to strings
        if (is_nan($data)) {
            return 'nan';
        }

        switch ($data) {
            case INF: return 'inf';
            case -INF: return '-inf';
            default: return $data;
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTQUANTILE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.quantile/
 *
 * Returns, for each input fraction, an estimation of the value (floating point) that is smaller than the given fraction of observations.
 */
class TDIGESTQUANTILE extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.QUANTILE';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (!is_array($data)) {
            return $data;
        }

        // convert Relay (RESP3) constants to strings
        return array_map(function ($value) {
            if (is_string($value) || !is_float($value)) {
                return $value;
            }

            if (is_nan($value)) {
                return 'nan';
            }

            switch ($value) {
                case INF: return 'inf';
                case -INF: return '-inf';
                default: return $value;
            }
        }, $data);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTRANK.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.rank/
 *
 * Returns, for each input value (floating-point), the estimated rank
 * of the value (the number of observations in the sketch that are smaller than
 * the value + half the number of observations that are equal to the value).
 */
class TDIGESTRANK extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.RANK';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTRESET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.reset/
 *
 * Resets a t-digest sketch: empty the sketch and re-initializes it.
 */
class TDIGESTRESET extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.RESET';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTREVRANK.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.revrank/
 *
 * Returns, for each input value (floating-point), the estimated reverse rank
 * of the value (the number of observations in the sketch that are larger than
 * the value + half the number of observations that are equal to the value).
 */
class TDIGESTREVRANK extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.REVRANK';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TDigest\TDIGESTTRIMMED_MEAN.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/tdigest.trimmed_mean/
 *
 * Returns an estimation of the mean value from the sketch,
 * excluding observation values outside the low and high cutoff quantiles.
 */
class TDIGESTTRIMMED_MEAN extends RedisCommand
{
    public function getId()
    {
        return 'TDIGEST.TRIMMED_MEAN';
    }

    /**
     * {@inheritdoc}
     */
    public function parseResponse($data)
    {
        if (is_string($data) || !is_float($data)) {
            return $data;
        }

        // convert Relay (RESP3) constants to strings
        if (is_nan($data)) {
            return 'nan';
        }

        switch ($data) {
            case INF: return 'inf';
            case -INF: return '-inf';
            default: return $data;
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.add/
 *
 * Append a sample to a time series.
 */
class TSADD extends RedisCommand
{
    public function getId()
    {
        return 'TS.ADD';
    }

    public function setArguments(array $arguments)
    {
        [$key, $timestamp, $value] = $arguments;
        $commandArguments = (!empty($arguments[3])) ? $arguments[3]->toArray() : [];

        parent::setArguments(array_merge(
            [$key, $timestamp, $value],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSALTER.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.alter/
 *
 * Update the retention, chunk size, duplicate policy, and labels of an existing time series.
 */
class TSALTER extends RedisCommand
{
    public function getId()
    {
        return 'TS.ALTER';
    }

    public function setArguments(array $arguments)
    {
        [$key] = $arguments;
        $commandArguments = (!empty($arguments[1])) ? $arguments[1]->toArray() : [];

        parent::setArguments(array_merge(
            [$key],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSCREATE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.create/
 *
 * Create a new time series.
 */
class TSCREATE extends RedisCommand
{
    public function getId()
    {
        return 'TS.CREATE';
    }

    public function setArguments(array $arguments)
    {
        [$key] = $arguments;
        $commandArguments = (!empty($arguments[1])) ? $arguments[1]->toArray() : [];

        parent::setArguments(array_merge(
            [$key],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSCREATERULE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.createrule/
 *
 * Create a compaction rule
 */
class TSCREATERULE extends RedisCommand
{
    public function getId()
    {
        return 'TS.CREATERULE';
    }

    public function setArguments(array $arguments)
    {
        [$sourceKey, $destKey, $aggregator, $bucketDuration] = $arguments;
        $processedArguments = [$sourceKey, $destKey, 'AGGREGATION', $aggregator, $bucketDuration];

        if (count($arguments) === 5) {
            $processedArguments[] = $arguments[4];
        }

        parent::setArguments($processedArguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSDECRBY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.decrby/
 *
 * Decrease the value of the sample with the maximum existing timestamp,
 * or create a new sample with a value equal to the value of the sample
 * with the maximum existing timestamp with a given decrement.
 */
class TSDECRBY extends RedisCommand
{
    public function getId()
    {
        return 'TS.DECRBY';
    }

    public function setArguments(array $arguments)
    {
        [$key, $value] = $arguments;
        $commandArguments = (!empty($arguments[2])) ? $arguments[2]->toArray() : [];

        parent::setArguments(array_merge(
            [$key, $value],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSDEL.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.del/
 *
 * Delete all samples between two timestamps for a given time series.
 */
class TSDEL extends RedisCommand
{
    public function getId()
    {
        return 'TS.DEL';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSDELETERULE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.deleterule/
 *
 * Delete a compaction rule.
 */
class TSDELETERULE extends RedisCommand
{
    public function getId()
    {
        return 'TS.DELETERULE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSGET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.get/
 *
 * Get the sample with the highest timestamp from a given time series.
 */
class TSGET extends RedisCommand
{
    public function getId()
    {
        return 'TS.GET';
    }

    public function setArguments(array $arguments)
    {
        [$key] = $arguments;
        $commandArguments = (!empty($arguments[1])) ? $arguments[1]->toArray() : [];

        parent::setArguments(array_merge(
            [$key],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSINCRBY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.incrby/
 *
 * Increase the value of the sample with the maximum existing timestamp,
 * or create a new sample with a value equal to the value of the sample
 * with the maximum existing timestamp with a given increment
 */
class TSINCRBY extends RedisCommand
{
    public function getId()
    {
        return 'TS.INCRBY';
    }

    public function setArguments(array $arguments)
    {
        [$key, $value] = $arguments;
        $commandArguments = (!empty($arguments[2])) ? $arguments[2]->toArray() : [];

        parent::setArguments(array_merge(
            [$key, $value],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSINFO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.info/
 *
 * Return information and statistics for a time series.
 */
class TSINFO extends RedisCommand
{
    public function getId()
    {
        return 'TS.INFO';
    }

    public function setArguments(array $arguments)
    {
        [$key] = $arguments;
        $commandArguments = (!empty($arguments[1])) ? $arguments[1]->toArray() : [];

        parent::setArguments(array_merge(
            [$key],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSMADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.madd/
 *
 * Append new samples to one or more time series.
 */
class TSMADD extends RedisCommand
{
    public function getId()
    {
        return 'TS.MADD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSMGET.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

class TSMGET extends RedisCommand
{
    public function getId()
    {
        return 'TS.MGET';
    }

    public function setArguments(array $arguments)
    {
        $processedArguments = [];
        $argumentsObject = array_shift($arguments);
        $commandArguments = $argumentsObject->toArray();

        array_push($processedArguments, 'FILTER', ...$arguments);

        parent::setArguments(array_merge(
            $commandArguments,
            $processedArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSMRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.mrange/
 *
 * Query a range across multiple time series by filters in forward direction.
 */
class TSMRANGE extends RedisCommand
{
    public function getId()
    {
        return 'TS.MRANGE';
    }

    public function setArguments(array $arguments)
    {
        [$fromTimestamp, $toTimestamp] = $arguments;
        $commandArguments = $arguments[2]->toArray();

        parent::setArguments(array_merge(
            [$fromTimestamp, $toTimestamp],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSMREVRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

/**
 * @see https://redis.io/commands/ts.mrevrange/
 *
 * Query a range across multiple time series by filters in reverse direction.
 */
class TSMREVRANGE extends TSMRANGE
{
    public function getId()
    {
        return 'TS.MREVRANGE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSQUERYINDEX.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.queryindex/
 *
 * Get all time series keys matching a filter list.
 */
class TSQUERYINDEX extends RedisCommand
{
    public function getId()
    {
        return 'TS.QUERYINDEX';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/ts.range/
 *
 * Query a range in forward direction.
 */
class TSRANGE extends RedisCommand
{
    public function getId()
    {
        return 'TS.RANGE';
    }

    public function setArguments(array $arguments)
    {
        [$key, $fromTimestamp, $toTimestamp] = $arguments;
        $commandArguments = (!empty($arguments[3])) ? $arguments[3]->toArray() : [];

        parent::setArguments(array_merge(
            [$key, $fromTimestamp, $toTimestamp],
            $commandArguments
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TimeSeries\TSREVRANGE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

/**
 * @see https://redis.io/commands/ts.revrange/
 *
 * Query a range in reverse direction.
 */
class TSREVRANGE extends TSRANGE
{
    public function getId()
    {
        return 'TS.REVRANGE';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TopK\TOPKADD.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/topk.add/
 *
 * Adds an item to the data structure.
 * Multiple items can be added at once.
 * If an item enters the Top-K list, the item which is expelled is returned.
 * This allows dynamic heavy-hitter detection of items being entered or expelled from Top-K list.
 */
class TOPKADD extends RedisCommand
{
    public function getId()
    {
        return 'TOPK.ADD';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TopK\TOPKINCRBY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/topk.incrby/
 *
 * Increase the score of an item in the data structure by increment.
 * Multiple items' score can be increased at once.
 * If an item enters the Top-K list, the item which is expelled is returned.
 */
class TOPKINCRBY extends RedisCommand
{
    public function getId()
    {
        return 'TOPK.INCRBY';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TopK\TOPKINFO.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/topk.info/
 *
 * Returns number of required items (k), width, depth and decay values.
 */
class TOPKINFO extends RedisCommand
{
    public function getId()
    {
        return 'TOPK.INFO';
    }

    public function parseResponse($data)
    {
        $result = [];

        for ($i = 0, $iMax = count($data); $i < $iMax; ++$i) {
            if (array_key_exists($i + 1, $data)) {
                $result[(string) $data[$i]] = $data[++$i];
            }
        }

        return $result;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TopK\TOPKLIST.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/topk.list/
 *
 * Return full list of items in Top K list.
 */
class TOPKLIST extends RedisCommand
{
    public function getId()
    {
        return 'TOPK.LIST';
    }

    public function setArguments(array $arguments)
    {
        if (!empty($arguments[1])) {
            $arguments[1] = 'WITHCOUNT';
        }

        parent::setArguments($arguments);
        $this->filterArguments();
    }

    public function parseResponse($data)
    {
        if ($this->isWithCountModifier()) {
            $result = [];

            for ($i = 0, $iMax = count($data); $i < $iMax; ++$i) {
                if (array_key_exists($i + 1, $data)) {
                    $result[(string) $data[$i]] = $data[++$i];
                }
            }

            return $result;
        }

        return $data;
    }

    /**
     * Checks for the presence of the WITHCOUNT modifier.
     *
     * @return bool
     */
    private function isWithCountModifier(): bool
    {
        $arguments = $this->getArguments();
        $lastArgument = (!empty($arguments)) ? $arguments[count($arguments) - 1] : null;

        return is_string($lastArgument) && strtoupper($lastArgument) === 'WITHCOUNT';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TopK\TOPKQUERY.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/topk.query/
 *
 * Checks whether an item is one of Top-K items.
 * Multiple items can be checked at once.
 */
class TOPKQUERY extends RedisCommand
{
    public function getId()
    {
        return 'TOPK.QUERY';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Redis\TopK\TOPKRESERVE.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Command as RedisCommand;

/**
 * @see https://redis.io/commands/topk.reserve/
 *
 * Initializes a TopK with specified parameters.
 */
class TOPKRESERVE extends RedisCommand
{
    public function getId()
    {
        return 'TOPK.RESERVE';
    }

    public function setArguments(array $arguments)
    {
        switch (count($arguments)) {
            case 3:
                $arguments[] = 7; // default depth
                $arguments[] = 0.9; // default decay
                break;
            case 4:
                $arguments[] = 0.9; // default decay
                break;
            default:
                parent::setArguments($arguments);

                return;
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\StrategyResolverInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy;

interface StrategyResolverInterface
{
    /**
     * Resolves subcommand strategy.
     *
     * @param  string                      $commandId
     * @param  string                      $subcommandId
     * @return SubcommandStrategyInterface
     */
    public function resolve(string $commandId, string $subcommandId): SubcommandStrategyInterface;
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\SubcommandStrategyInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy;

interface SubcommandStrategyInterface
{
    /**
     * Process arguments for given subcommand.
     *
     * @param  array $arguments
     * @return array
     */
    public function processArguments(array $arguments): array;
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\SubcommandStrategyResolver.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy;

use InvalidArgumentException;

class SubcommandStrategyResolver implements StrategyResolverInterface
{
    private const CONTAINER_COMMANDS_NAMESPACE = 'Predis\Command\Strategy\ContainerCommands';

    /**
     * @var ?string
     */
    private $separator;

    public function __construct(?string $separator = null)
    {
        $this->separator = $separator;
    }

    /**
     * {@inheritDoc}
     */
    public function resolve(string $commandId, string $subcommandId): SubcommandStrategyInterface
    {
        $subcommandStrategyClass = ucwords($subcommandId) . 'Strategy';
        $commandDirectoryName = ucwords($commandId);

        if (!is_null($this->separator)) {
            $subcommandStrategyClass = str_replace($this->separator, '', $subcommandStrategyClass);
            $commandDirectoryName = str_replace($this->separator, '', $commandDirectoryName);
        }

        if (class_exists(
            $containerCommandClass = self::CONTAINER_COMMANDS_NAMESPACE . '\\' . $commandDirectoryName . '\\' . $subcommandStrategyClass
        )) {
            return new $containerCommandClass();
        }

        throw new InvalidArgumentException('Non-existing container command given');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\ContainerCommands\Functions\DeleteStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use Predis\Command\Strategy\SubcommandStrategyInterface;

class DeleteStrategy implements SubcommandStrategyInterface
{
    /**
     * {@inheritDoc}
     */
    public function processArguments(array $arguments): array
    {
        return $arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\ContainerCommands\Functions\DumpStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use Predis\Command\Strategy\SubcommandStrategyInterface;

class DumpStrategy implements SubcommandStrategyInterface
{
    /**
     * {@inheritDoc}
     */
    public function processArguments(array $arguments): array
    {
        return $arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\ContainerCommands\Functions\FlushStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use Predis\Command\Strategy\SubcommandStrategyInterface;

class FlushStrategy implements SubcommandStrategyInterface
{
    /**
     * {@inheritDoc}
     */
    public function processArguments(array $arguments): array
    {
        $processedArguments = [$arguments[0]];

        if (array_key_exists(1, $arguments) && null !== $arguments[1]) {
            $processedArguments[] = strtoupper($arguments[1]);
        }

        return $processedArguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\ContainerCommands\Functions\KillStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use Predis\Command\Strategy\SubcommandStrategyInterface;

class KillStrategy implements SubcommandStrategyInterface
{
    /**
     * {@inheritDoc}
     */
    public function processArguments(array $arguments): array
    {
        return $arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\ContainerCommands\Functions\ListStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use Predis\Command\Strategy\SubcommandStrategyInterface;

class ListStrategy implements SubcommandStrategyInterface
{
    /**
     * {@inheritDoc}
     */
    public function processArguments(array $arguments): array
    {
        $processedArguments = [$arguments[0]];

        if (array_key_exists(1, $arguments) && null !== $arguments[1]) {
            array_push($processedArguments, 'LIBRARYNAME', $arguments[1]);
        }

        if (array_key_exists(2, $arguments) && true === $arguments[2]) {
            $processedArguments[] = 'WITHCODE';
        }

        return $processedArguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\ContainerCommands\Functions\LoadStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use Predis\Command\Strategy\SubcommandStrategyInterface;

class LoadStrategy implements SubcommandStrategyInterface
{
    /**
     * {@inheritdoc}
     */
    public function processArguments(array $arguments): array
    {
        if (count($arguments) <= 2) {
            return $arguments;
        }

        $processedArguments = [$arguments[0]];
        $replace = array_pop($arguments);

        if (is_bool($replace) && $replace) {
            $processedArguments[] = 'REPLACE';
        } elseif (!is_bool($replace)) {
            $processedArguments[] = $replace;
        }

        $processedArguments[] = $arguments[1];

        return $processedArguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\ContainerCommands\Functions\RestoreStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use Predis\Command\Strategy\SubcommandStrategyInterface;

class RestoreStrategy implements SubcommandStrategyInterface
{
    /**
     * {@inheritDoc}
     */
    public function processArguments(array $arguments): array
    {
        $processedArguments = [$arguments[0], $arguments[1]];

        if (array_key_exists(2, $arguments) && null !== $arguments[2]) {
            $processedArguments[] = strtoupper($arguments[2]);
        }

        return $processedArguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Strategy\ContainerCommands\Functions\StatsStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use Predis\Command\Strategy\SubcommandStrategyInterface;

class StatsStrategy implements SubcommandStrategyInterface
{
    /**
     * {@inheritDoc}
     */
    public function processArguments(array $arguments): array
    {
        return $arguments;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Aggregate.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait Aggregate
{
    /**
     * @var string[]
     */
    private static $aggregateValuesEnum = [
        'min' => 'MIN',
        'max' => 'MAX',
        'sum' => 'SUM',
    ];

    /**
     * @var string
     */
    private static $aggregateModifier = 'AGGREGATE';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$aggregateArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$aggregateArgumentPositionOffset];

        if (is_string($argument) && in_array(strtoupper($argument), self::$aggregateValuesEnum)) {
            $argument = self::$aggregateValuesEnum[$argument];
        } else {
            $enumValues = implode(', ', array_keys(self::$aggregateValuesEnum));
            throw new UnexpectedValueException("Aggregate argument accepts only: {$enumValues} values");
        }

        $argumentsBefore = array_slice($arguments, 0, static::$aggregateArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$aggregateArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$aggregateModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\BitByte.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

trait BitByte
{
    private static $argumentEnum = [
        'bit' => 'BIT',
        'byte' => 'BYTE',
    ];

    public function setArguments(array $arguments)
    {
        $value = array_pop($arguments);

        if (null === $value) {
            parent::setArguments($arguments);

            return;
        }

        if (in_array(strtoupper($value), self::$argumentEnum, true)) {
            $arguments[] = self::$argumentEnum[$value];
        } else {
            $arguments[] = $value;
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Count.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait Count
{
    private $countModifier = 'COUNT';
    private $anyModifier = 'ANY';

    public function setArguments(array $arguments, bool $any = false)
    {
        $argumentsLength = count($arguments);

        if (static::$countArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$countArgumentPositionOffset] === -1) {
            array_splice($arguments, static::$countArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$countArgumentPositionOffset] < 1) {
            throw new UnexpectedValueException('Wrong count argument value or position offset');
        }

        $countArgument = $arguments[static::$countArgumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, static::$countArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$countArgumentPositionOffset + 2);

        if (!$any) {
            $argumentsAfter = array_slice($arguments, static::$countArgumentPositionOffset + 1);
            parent::setArguments(array_merge(
                $argumentsBefore,
                [$this->countModifier],
                [$countArgument],
                $argumentsAfter
            ));

            return;
        }

        parent::setArguments(array_merge(
            $argumentsBefore,
            [$this->countModifier],
            [$countArgument],
            [$this->anyModifier],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\DB.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use UnexpectedValueException;

trait DB
{
    private $dbModifier = 'DB';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$dbArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if (!is_numeric($arguments[static::$dbArgumentPositionOffset])) {
            throw new UnexpectedValueException('DB argument should be a valid numeric value');
        }

        if ($arguments[static::$dbArgumentPositionOffset] < 0) {
            array_splice($arguments, static::$dbArgumentPositionOffset, 1);
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$dbArgumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, static::$dbArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$dbArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [$this->dbModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Keys.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait Keys
{
    public function setArguments(array $arguments, bool $withNumkeys = true)
    {
        $argumentsLength = count($arguments);

        if (
            static::$keysArgumentPositionOffset > $argumentsLength
            || !is_array($arguments[static::$keysArgumentPositionOffset])
        ) {
            throw new UnexpectedValueException('Wrong keys argument type or position offset');
        }

        $keysArgument = $arguments[static::$keysArgumentPositionOffset];
        $argumentsBeforeKeys = array_slice($arguments, 0, static::$keysArgumentPositionOffset);
        $argumentsAfterKeys = array_slice($arguments, static::$keysArgumentPositionOffset + 1);

        if ($withNumkeys) {
            $numkeys = count($keysArgument);
            parent::setArguments(array_merge($argumentsBeforeKeys, [$numkeys], $keysArgument, $argumentsAfterKeys));

            return;
        }

        parent::setArguments(array_merge($argumentsBeforeKeys, $keysArgument, $argumentsAfterKeys));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\LeftRight.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait LeftRight
{
    /**
     * @var array{string: string}
     */
    private static $leftRightEnum = [
        'left' => 'LEFT',
        'right' => 'RIGHT',
    ];

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$leftRightArgumentPositionOffset >= $argumentsLength) {
            $arguments[] = 'LEFT';
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$leftRightArgumentPositionOffset];

        if (is_string($argument) && in_array(strtoupper($argument), self::$leftRightEnum, true)) {
            $argument = self::$leftRightEnum[$argument];
        } else {
            $enumValues = implode(', ', array_keys(self::$leftRightEnum));
            throw new UnexpectedValueException("Left/Right argument accepts only: {$enumValues} values");
        }

        $argumentsBefore = array_slice($arguments, 0, static::$leftRightArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$leftRightArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\MinMaxModifier.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait MinMaxModifier
{
    /**
     * @var array{string: string}
     */
    private $modifierEnum = [
        'min' => 'MIN',
        'max' => 'MAX',
    ];

    public function resolveModifier(int $offset, array &$arguments): void
    {
        if ($offset >= count($arguments)) {
            $arguments[$offset] = $this->modifierEnum['min'];

            return;
        }

        if (!is_string($arguments[$offset]) || !array_key_exists($arguments[$offset], $this->modifierEnum)) {
            throw new UnexpectedValueException('Wrong type of modifier given');
        }

        $arguments[$offset] = $this->modifierEnum[$arguments[$offset]];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Replace.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command;

/**
 * @mixin Command
 */
trait Replace
{
    public function setArguments(array $arguments)
    {
        $replace = array_pop($arguments);

        if (is_bool($replace) && $replace) {
            $arguments[] = 'REPLACE';
        } elseif (!is_bool($replace)) {
            $arguments[] = $replace;
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Rev.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait Rev
{
    public function setArguments(array $arguments)
    {
        $argument = $arguments[static::$revArgumentPositionOffset];

        if (false === $argument) {
            parent::setArguments($arguments);

            return;
        }

        if (true === $argument) {
            $argument = 'REV';
        } else {
            throw new UnexpectedValueException('Wrong rev argument type');
        }

        $argumentsBefore = array_slice($arguments, 0, static::$revArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$revArgumentPositionOffset + 1);

        parent::setArguments(array_merge($argumentsBefore, [$argument], $argumentsAfter));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Sorting.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use UnexpectedValueException;

trait Sorting
{
    private static $sortingEnum = [
        'asc' => 'ASC',
        'desc' => 'DESC',
    ];

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$sortArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$sortArgumentPositionOffset];

        if (null === $argument) {
            array_splice($arguments, static::$sortArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        if (!in_array(strtoupper($argument), self::$sortingEnum, true)) {
            $enumValues = implode(', ', array_keys(self::$sortingEnum));
            throw new UnexpectedValueException("Sorting argument accepts only: {$enumValues} values");
        }

        $argumentsBefore = array_slice($arguments, 0, static::$sortArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$sortArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$sortingEnum[$argument]],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Storedist.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait Storedist
{
    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (
            static::$storeDistArgumentPositionOffset >= $argumentsLength
            || false === $arguments[static::$storeDistArgumentPositionOffset]
        ) {
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$storeDistArgumentPositionOffset];

        if (true === $argument) {
            $argument = 'STOREDIST';
        } else {
            throw new UnexpectedValueException('Wrong STOREDIST argument type');
        }

        $argumentsBefore = array_slice($arguments, 0, static::$storeDistArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$storeDistArgumentPositionOffset + 1);

        parent::setArguments(array_merge($argumentsBefore, [$argument], $argumentsAfter));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Timeout.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use UnexpectedValueException;

trait Timeout
{
    private static $timeoutModifier = 'TIMEOUT';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$timeoutArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$timeoutArgumentPositionOffset] === -1) {
            array_splice($arguments, static::$timeoutArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$timeoutArgumentPositionOffset] < 1) {
            throw new UnexpectedValueException('Wrong timeout argument value or position offset');
        }

        $argument = $arguments[static::$timeoutArgumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, static::$timeoutArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$timeoutArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$timeoutModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Weights.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait Weights
{
    /**
     * @var string
     */
    private static $weightsModifier = 'WEIGHTS';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$weightsArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if (!is_array($arguments[static::$weightsArgumentPositionOffset])) {
            throw new UnexpectedValueException('Wrong weights argument type');
        }

        $weightsArray = $arguments[static::$weightsArgumentPositionOffset];

        if (empty($weightsArray)) {
            unset($arguments[static::$weightsArgumentPositionOffset]);
            parent::setArguments($arguments);

            return;
        }

        $argumentsBefore = array_slice($arguments, 0, static::$weightsArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$weightsArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$weightsModifier],
            $weightsArray,
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\BloomFilters\BucketSize.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait BucketSize
{
    private static $bucketSizeModifier = 'BUCKETSIZE';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$bucketSizeArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$bucketSizeArgumentPositionOffset] === -1) {
            array_splice($arguments, static::$bucketSizeArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$bucketSizeArgumentPositionOffset] < 1) {
            throw new UnexpectedValueException('Wrong bucket size argument value or position offset');
        }

        $argument = $arguments[static::$bucketSizeArgumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, static::$bucketSizeArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$bucketSizeArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$bucketSizeModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\BloomFilters\Capacity.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait Capacity
{
    private static $capacityModifier = 'CAPACITY';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$capacityArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$capacityArgumentPositionOffset] === -1) {
            array_splice($arguments, static::$capacityArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$capacityArgumentPositionOffset] < 1) {
            throw new UnexpectedValueException('Wrong capacity argument value or position offset');
        }

        $argument = $arguments[static::$capacityArgumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, static::$capacityArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$capacityArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$capacityModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\BloomFilters\Error.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait Error
{
    private static $errorModifier = 'ERROR';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$errorArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$errorArgumentPositionOffset] === -1) {
            array_splice($arguments, static::$errorArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$errorArgumentPositionOffset] < 0) {
            throw new UnexpectedValueException('Wrong error argument value or position offset');
        }

        $argument = $arguments[static::$errorArgumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, static::$errorArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$errorArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$errorModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\BloomFilters\Expansion.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use UnexpectedValueException;

trait Expansion
{
    private static $expansionModifier = 'EXPANSION';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$expansionArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$expansionArgumentPositionOffset] === -1) {
            array_splice($arguments, static::$expansionArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$expansionArgumentPositionOffset] < 1) {
            throw new UnexpectedValueException('Wrong expansion argument value or position offset');
        }

        $argument = $arguments[static::$expansionArgumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, static::$expansionArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$expansionArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$expansionModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\BloomFilters\Items.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command;

/**
 * @mixin Command
 */
trait Items
{
    private static $itemsModifier = 'ITEMS';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$itemsArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$itemsArgumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, static::$itemsArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$itemsArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$itemsModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\BloomFilters\MaxIterations.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait MaxIterations
{
    private static $maxIterationsModifier = 'MAXITERATIONS';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$maxIterationsArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$maxIterationsArgumentPositionOffset] === -1) {
            array_splice($arguments, static::$maxIterationsArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$maxIterationsArgumentPositionOffset] < 1) {
            throw new UnexpectedValueException('Wrong max iterations argument value or position offset');
        }

        $argument = $arguments[static::$maxIterationsArgumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, static::$maxIterationsArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$maxIterationsArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$maxIterationsModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\BloomFilters\NoCreate.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait NoCreate
{
    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (
            static::$noCreateArgumentPositionOffset >= $argumentsLength
            || false === $arguments[static::$noCreateArgumentPositionOffset]
        ) {
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$noCreateArgumentPositionOffset];

        if (true === $argument) {
            $argument = 'NOCREATE';
        } else {
            throw new UnexpectedValueException('Wrong NOCREATE argument type');
        }

        $argumentsBefore = array_slice($arguments, 0, static::$noCreateArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$noCreateArgumentPositionOffset + 1);

        parent::setArguments(array_merge($argumentsBefore, [$argument], $argumentsAfter));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\By\ByArgument.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\By;

use Predis\Command\Command;

/**
 * @mixin Command
 */
trait ByArgument
{
    private $byModifier = 'BY';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$byArgumentPositionOffset >= $argumentsLength || null === $arguments[static::$byArgumentPositionOffset]) {
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$byArgumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, static::$byArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$byArgumentPositionOffset + 1);

        parent::setArguments(array_merge($argumentsBefore, [$this->byModifier, $argument], $argumentsAfter));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\By\ByLexByScore.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\By;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait ByLexByScore
{
    private static $argumentsEnum = [
        'bylex' => 'BYLEX',
        'byscore' => 'BYSCORE',
    ];

    public function setArguments(array $arguments)
    {
        $argument = $arguments[static::$byLexByScoreArgumentPositionOffset];

        if (false === $argument) {
            parent::setArguments($arguments);

            return;
        }

        if (is_string($argument) && in_array(strtoupper($argument), self::$argumentsEnum)) {
            $argument = self::$argumentsEnum[$argument];
        } else {
            throw new UnexpectedValueException('By argument accepts only "bylex" and "byscore" values');
        }

        $argumentsBefore = array_slice($arguments, 0, static::$byLexByScoreArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$byLexByScoreArgumentPositionOffset + 1);

        parent::setArguments(array_merge($argumentsBefore, [$argument], $argumentsAfter));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\By\GeoBy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\By;

use InvalidArgumentException;
use Predis\Command\Argument\Geospatial\ByInterface;

trait GeoBy
{
    public function setArguments(array $arguments)
    {
        $argumentPositionOffset = $this->getByArgumentPositionOffset($arguments);

        if (null === $argumentPositionOffset) {
            throw new InvalidArgumentException('Invalid BY argument value given');
        }

        $byArgumentObject = $arguments[$argumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, $argumentPositionOffset);
        $argumentsAfter = array_slice($arguments, $argumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            $byArgumentObject->toArray(),
            $argumentsAfter
        ));
    }

    private function getByArgumentPositionOffset(array $arguments): ?int
    {
        foreach ($arguments as $i => $value) {
            if ($value instanceof ByInterface) {
                return $i;
            }
        }

        return null;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Expire\ExpireOptions.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Expire;

trait ExpireOptions
{
    private static $argumentEnum = [
        'nx' => 'NX',
        'xx' => 'XX',
        'gt' => 'GT',
        'lt' => 'LT',
    ];

    public function setArguments(array $arguments)
    {
        $value = array_pop($arguments);

        if (null === $value) {
            parent::setArguments($arguments);

            return;
        }

        if (in_array(strtoupper($value), self::$argumentEnum, true)) {
            $arguments[] = self::$argumentEnum[strtolower($value)];
        } else {
            $arguments[] = $value;
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\From\GeoFrom.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\From;

use InvalidArgumentException;
use Predis\Command\Argument\Geospatial\FromInterface;

trait GeoFrom
{
    public function setArguments(array $arguments)
    {
        $argumentPositionOffset = $this->getFromArgumentPositionOffset($arguments);

        if (null === $argumentPositionOffset) {
            throw new InvalidArgumentException('Invalid FROM argument value given');
        }

        $fromArgumentObject = $arguments[$argumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, $argumentPositionOffset);
        $argumentsAfter = array_slice($arguments, $argumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            $fromArgumentObject->toArray(),
            $argumentsAfter
        ));
    }

    private function getFromArgumentPositionOffset(array $arguments): ?int
    {
        foreach ($arguments as $i => $value) {
            if ($value instanceof FromInterface) {
                return $i;
            }
        }

        return null;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Get\Get.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Get;

use UnexpectedValueException;

trait Get
{
    private static $getModifier = 'GET';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$getArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if (!is_array($arguments[static::$getArgumentPositionOffset])) {
            throw new UnexpectedValueException('Wrong get argument type');
        }

        $patterns = [];

        foreach ($arguments[static::$getArgumentPositionOffset] as $pattern) {
            $patterns[] = self::$getModifier;
            $patterns[] = $pattern;
        }

        $argumentsBeforeKeys = array_slice($arguments, 0, static::$getArgumentPositionOffset);
        $argumentsAfterKeys = array_slice($arguments, static::$getArgumentPositionOffset + 1);

        parent::setArguments(array_merge($argumentsBeforeKeys, $patterns, $argumentsAfterKeys));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Json\Indent.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Json;

use UnexpectedValueException;

trait Indent
{
    private static $indentModifier = 'INDENT';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$indentArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$indentArgumentPositionOffset] === '') {
            array_splice($arguments, static::$indentArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$indentArgumentPositionOffset];

        if (!is_string($argument)) {
            throw new UnexpectedValueException('Indent argument value should be a string');
        }

        $argumentsBefore = array_slice($arguments, 0, static::$indentArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$indentArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$indentModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Json\Newline.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Json;

use UnexpectedValueException;

trait Newline
{
    private static $newlineModifier = 'NEWLINE';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$newlineArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$newlineArgumentPositionOffset] === '') {
            array_splice($arguments, static::$newlineArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$newlineArgumentPositionOffset];

        if (!is_string($argument)) {
            throw new UnexpectedValueException('Newline argument value should be a string');
        }

        $argumentsBefore = array_slice($arguments, 0, static::$newlineArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$newlineArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$newlineModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Json\NxXxArgument.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Json;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait NxXxArgument
{
    /**
     * @var string[]
     */
    private static $argumentEnum = [
        'nx' => 'NX',
        'xx' => 'XX',
    ];

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$nxXxArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if (null === $arguments[static::$nxXxArgumentPositionOffset]) {
            array_splice($arguments, static::$nxXxArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$nxXxArgumentPositionOffset];

        if (!in_array(strtoupper($argument), self::$argumentEnum, true)) {
            $enumValues = implode(', ', array_keys(self::$argumentEnum));
            throw new UnexpectedValueException("Argument accepts only: {$enumValues} values");
        }

        $argumentsBefore = array_slice($arguments, 0, static::$nxXxArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$nxXxArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$argumentEnum[strtolower($argument)]],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Json\Space.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Json;

use UnexpectedValueException;

trait Space
{
    private static $spaceModifier = 'SPACE';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$spaceArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        if ($arguments[static::$spaceArgumentPositionOffset] === '') {
            array_splice($arguments, static::$spaceArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$spaceArgumentPositionOffset];

        if (!is_string($argument)) {
            throw new UnexpectedValueException('Space argument value should be a string');
        }

        $argumentsBefore = array_slice($arguments, 0, static::$spaceArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$spaceArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            [self::$spaceModifier],
            [$argument],
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Limit\Limit.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Limit;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait Limit
{
    private static $limitModifier = 'LIMIT';

    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);
        $argumentsBefore = array_slice($arguments, 0, static::$limitArgumentPositionOffset);

        if (
            static::$limitArgumentPositionOffset >= $argumentsLength
            || false === $arguments[static::$limitArgumentPositionOffset]
        ) {
            parent::setArguments($argumentsBefore);

            return;
        }

        $argument = $arguments[static::$limitArgumentPositionOffset];
        $argumentsAfter = array_slice($arguments, static::$limitArgumentPositionOffset + 1);

        if (true === $argument) {
            parent::setArguments(array_merge($argumentsBefore, [self::$limitModifier], $argumentsAfter));

            return;
        }

        if (!is_int($argument)) {
            throw new UnexpectedValueException('Wrong limit argument type');
        }

        parent::setArguments(array_merge($argumentsBefore, [self::$limitModifier], [$argument], $argumentsAfter));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\Limit\LimitObject.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Limit;

use Predis\Command\Argument\Server\LimitInterface;

trait LimitObject
{
    public function setArguments(array $arguments)
    {
        $argumentPositionOffset = $this->getLimitArgumentPositionOffset($arguments);

        if (null === $argumentPositionOffset) {
            parent::setArguments($arguments);

            return;
        }

        $limitObject = $arguments[$argumentPositionOffset];
        $argumentsBefore = array_slice($arguments, 0, $argumentPositionOffset);
        $argumentsAfter = array_slice($arguments, $argumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            $limitObject->toArray(),
            $argumentsAfter
        ));
    }

    private function getLimitArgumentPositionOffset(array $arguments): ?int
    {
        foreach ($arguments as $i => $value) {
            if ($value instanceof LimitInterface) {
                return $i;
            }
        }

        return null;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\To\ServerTo.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\To;

use Predis\Command\Argument\Server\To;

trait ServerTo
{
    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (static::$toArgumentPositionOffset >= $argumentsLength) {
            parent::setArguments($arguments);

            return;
        }

        /** @var To|null $toArgument */
        $toArgument = $arguments[static::$toArgumentPositionOffset];

        if (null === $toArgument) {
            array_splice($arguments, static::$toArgumentPositionOffset, 1, [false]);
            parent::setArguments($arguments);

            return;
        }

        $argumentsBefore = array_slice($arguments, 0, static::$toArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$toArgumentPositionOffset + 1);

        parent::setArguments(array_merge(
            $argumentsBefore,
            $toArgument->toArray(),
            $argumentsAfter
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\With\WithCoord.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\With;

use Predis\Command\Command;
use UnexpectedValueException;

/**
 * @mixin Command
 */
trait WithCoord
{
    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (
            static::$withCoordArgumentPositionOffset >= $argumentsLength
            || false === $arguments[static::$withCoordArgumentPositionOffset]
        ) {
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$withCoordArgumentPositionOffset];

        if (true === $argument) {
            $argument = 'WITHCOORD';
        } else {
            throw new UnexpectedValueException('Wrong WITHCOORD argument type');
        }

        $argumentsBefore = array_slice($arguments, 0, static::$withCoordArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$withCoordArgumentPositionOffset + 1);

        parent::setArguments(array_merge($argumentsBefore, [$argument], $argumentsAfter));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\With\WithDist.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\With;

use UnexpectedValueException;

trait WithDist
{
    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (
            static::$withDistArgumentPositionOffset >= $argumentsLength
            || false === $arguments[static::$withDistArgumentPositionOffset]
        ) {
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$withDistArgumentPositionOffset];

        if (true === $argument) {
            $argument = 'WITHDIST';
        } else {
            throw new UnexpectedValueException('Wrong WITHDIST argument type');
        }

        $argumentsBefore = array_slice($arguments, 0, static::$withDistArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$withDistArgumentPositionOffset + 1);

        parent::setArguments(array_merge($argumentsBefore, [$argument], $argumentsAfter));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\With\WithHash.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\With;

use UnexpectedValueException;

trait WithHash
{
    public function setArguments(array $arguments)
    {
        $argumentsLength = count($arguments);

        if (
            static::$withHashArgumentPositionOffset >= $argumentsLength
            || false === $arguments[static::$withHashArgumentPositionOffset]
        ) {
            parent::setArguments($arguments);

            return;
        }

        $argument = $arguments[static::$withHashArgumentPositionOffset];

        if (true === $argument) {
            $argument = 'WITHHASH';
        } else {
            throw new UnexpectedValueException('Wrong WITHHASH argument type');
        }

        $argumentsBefore = array_slice($arguments, 0, static::$withHashArgumentPositionOffset);
        $argumentsAfter = array_slice($arguments, static::$withHashArgumentPositionOffset + 1);

        parent::setArguments(array_merge($argumentsBefore, [$argument], $argumentsAfter));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\With\WithScores.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\With;

use Predis\Command\Command;

/**
 * Handles last argument passed into command as WITHSCORES.
 *
 * @mixin Command
 */
trait WithScores
{
    public function setArguments(array $arguments)
    {
        $withScores = array_pop($arguments);

        if (is_bool($withScores) && $withScores) {
            $arguments[] = 'WITHSCORES';
        } elseif (!is_bool($withScores)) {
            $arguments[] = $withScores;
        }

        parent::setArguments($arguments);
    }

    /**
     * Checks for the presence of the WITHSCORES modifier.
     *
     * @return bool
     */
    private function isWithScoreModifier(): bool
    {
        $arguments = parent::getArguments();
        $lastArgument = (!empty($arguments)) ? $arguments[count($arguments) - 1] : null;

        return is_string($lastArgument) && strtoupper($lastArgument) === 'WITHSCORES';
    }

    public function parseResponse($data)
    {
        if ($this->isWithScoreModifier()) {
            $result = [];

            for ($i = 0, $iMax = count($data); $i < $iMax; ++$i) {
                if (is_array($data[$i])) {
                    $result[$data[$i][0]] = $data[$i][1]; // Relay
                } elseif (array_key_exists($i + 1, $data)) {
                    $result[$data[$i]] = $data[++$i];
                }
            }

            return $result;
        }

        return $data;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Command\Traits\With\WithValues.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\With;

use Predis\Command\Command;

/**
 * @mixin Command
 */
trait WithValues
{
    public function setArguments(array $arguments)
    {
        $withValues = array_pop($arguments);

        if (is_bool($withValues) && $withValues) {
            $arguments[] = 'WITHVALUES';
        } elseif (!is_bool($withValues)) {
            $arguments[] = $withValues;
        }

        parent::setArguments($arguments);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\OptionInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration;

/**
 * Defines an handler used by Predis\Configuration\Options to filter, validate
 * or return default values for a given option.
 */
interface OptionInterface
{
    /**
     * Filters and validates the passed value.
     *
     * @param OptionsInterface $options Options container.
     * @param mixed            $value   Input value.
     *
     * @return mixed
     */
    public function filter(OptionsInterface $options, $value);

    /**
     * Returns the default value for the option.
     *
     * @param OptionsInterface $options Options container.
     *
     * @return mixed
     */
    public function getDefault(OptionsInterface $options);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\Options.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration;

/**
 * Default client options container for Predis\Client.
 *
 * Pre-defined options have their specialized handlers that can filter, convert
 * an lazily initialize values in a mini-DI container approach.
 *
 * {@inheritdoc}
 */
class Options implements OptionsInterface
{
    /** @var array */
    protected $handlers = [
        'aggregate' => Option\Aggregate::class,
        'cluster' => Option\Cluster::class,
        'replication' => Option\Replication::class,
        'connections' => Option\Connections::class,
        'commands' => Option\Commands::class,
        'exceptions' => Option\Exceptions::class,
        'prefix' => Option\Prefix::class,
        'crc16' => Option\CRC16::class,
    ];

    /** @var array */
    protected $options = [];

    /** @var array */
    protected $input;

    /**
     * @param array|null $options Named array of client options
     */
    public function __construct(?array $options = null)
    {
        $this->input = $options ?? [];
    }

    /**
     * {@inheritdoc}
     */
    public function getDefault($option)
    {
        if (isset($this->handlers[$option])) {
            $handler = $this->handlers[$option];
            $handler = new $handler();

            return $handler->getDefault($this);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function defined($option)
    {
        return
            array_key_exists($option, $this->options)
            || array_key_exists($option, $this->input)
        ;
    }

    /**
     * {@inheritdoc}
     */
    public function __isset($option)
    {
        return (
            array_key_exists($option, $this->options)
            || array_key_exists($option, $this->input)
        ) && $this->__get($option) !== null;
    }

    /**
     * {@inheritdoc}
     */
    public function __get($option)
    {
        if (isset($this->options[$option]) || array_key_exists($option, $this->options)) {
            return $this->options[$option];
        }

        if (isset($this->input[$option]) || array_key_exists($option, $this->input)) {
            $value = $this->input[$option];
            unset($this->input[$option]);

            if (isset($this->handlers[$option])) {
                $handler = $this->handlers[$option];
                $handler = new $handler();
                $value = $handler->filter($this, $value);
            } elseif (is_object($value) && method_exists($value, '__invoke')) {
                $value = $value($this);
            }

            return $this->options[$option] = $value;
        }

        if (isset($this->handlers[$option])) {
            return $this->options[$option] = $this->getDefault($option);
        }

        return;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\OptionsInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration;

use Predis\Command\Processor\ProcessorInterface;

/**
 * @property callable                            $aggregate   Custom aggregate connection initializer
 * @property callable                            $cluster     Aggregate connection initializer for clustering
 * @property \Predis\Connection\FactoryInterface $connections Connection factory for creating new connections
 * @property bool                                $exceptions  Toggles exceptions in client for -ERR responses
 * @property ProcessorInterface                  $prefix      Key prefixing strategy using the supplied string as prefix
 * @property \Predis\Command\FactoryInterface    $commands    Command factory for creating Redis commands
 * @property callable                            $replication Aggregate connection initializer for replication
 */
interface OptionsInterface
{
    /**
     * Returns the default value for the given option.
     *
     * @param string $option Name of the option
     *
     * @return mixed|null
     */
    public function getDefault($option);

    /**
     * Checks if the given option has been set by the user upon initialization.
     *
     * @param string $option Name of the option
     *
     * @return bool
     */
    public function defined($option);

    /**
     * Checks if the given option has been set and does not evaluate to NULL.
     *
     * @param string $option Name of the option
     *
     * @return bool
     */
    public function __isset($option);

    /**
     * Returns the value of the given option.
     *
     * @param string $option Name of the option
     *
     * @return mixed|null
     */
    public function __get($option);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\Option\Aggregate.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use InvalidArgumentException;
use Predis\Configuration\OptionInterface;
use Predis\Configuration\OptionsInterface;
use Predis\Connection\AggregateConnectionInterface;
use Predis\Connection\NodeConnectionInterface;

/**
 * Client option for configuring generic aggregate connections.
 *
 * The only value accepted by this option is a callable that must return a valid
 * connection instance of Predis\Connection\AggregateConnectionInterface when
 * invoked by the client to create a new aggregate connection instance.
 *
 * Creation and configuration of the aggregate connection is up to the user.
 */
class Aggregate implements OptionInterface
{
    /**
     * {@inheritdoc}
     */
    public function filter(OptionsInterface $options, $value)
    {
        if (!is_callable($value)) {
            throw new InvalidArgumentException(sprintf(
                '%s expects a callable object acting as an aggregate connection initializer',
                static::class
            ));
        }

        return $this->getConnectionInitializer($options, $value);
    }

    /**
     * Wraps a user-supplied callable used to create a new aggregate connection.
     *
     * When the original callable acting as a connection initializer is executed
     * by the client to create a new aggregate connection, it will receive the
     * following arguments:
     *
     * - $parameters (same as passed to Predis\Client::__construct())
     * - $options (options container, Predis\Configuration\OptionsInterface)
     * - $option (current option, Predis\Configuration\OptionInterface)
     *
     * The original callable must return a valid aggregation connection instance
     * of type Predis\Connection\AggregateConnectionInterface, this is enforced
     * by the wrapper returned by this method and an exception is thrown when
     * invalid values are returned.
     *
     * @param OptionsInterface $options  Client options
     * @param callable         $callable Callable initializer
     *
     * @return callable
     * @throws InvalidArgumentException
     */
    protected function getConnectionInitializer(OptionsInterface $options, callable $callable)
    {
        return function ($parameters = null, $autoaggregate = false) use ($callable, $options) {
            $connection = call_user_func_array($callable, [&$parameters, $options, $this]);

            if (!$connection instanceof AggregateConnectionInterface) {
                throw new InvalidArgumentException(sprintf(
                    '%s expects the supplied callable to return an instance of %s, but %s was returned',
                    static::class,
                    AggregateConnectionInterface::class,
                    is_object($connection) ? get_class($connection) : gettype($connection)
                ));
            }

            if ($parameters && $autoaggregate) {
                static::aggregate($options, $connection, $parameters);
            }

            return $connection;
        };
    }

    /**
     * Adds single connections to an aggregate connection instance.
     *
     * @param OptionsInterface             $options    Client options
     * @param AggregateConnectionInterface $connection Target aggregate connection
     * @param array                        $nodes      List of nodes to be added to the target aggregate connection
     */
    public static function aggregate(OptionsInterface $options, AggregateConnectionInterface $connection, array $nodes)
    {
        $connections = $options->connections;

        foreach ($nodes as $node) {
            $connection->add($node instanceof NodeConnectionInterface ? $node : $connections->create($node));
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getDefault(OptionsInterface $options)
    {
        return;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\Option\Cluster.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use InvalidArgumentException;
use Predis\Cluster\RedisStrategy;
use Predis\Configuration\OptionsInterface;
use Predis\Connection\Cluster\PredisCluster;
use Predis\Connection\Cluster\RedisCluster;

/**
 * Configures an aggregate connection used for clustering
 * multiple Redis nodes using various implementations with
 * different algorithms or strategies.
 */
class Cluster extends Aggregate
{
    /**
     * {@inheritdoc}
     */
    public function filter(OptionsInterface $options, $value)
    {
        if (is_string($value)) {
            $value = $this->getConnectionInitializerByString($options, $value);
        }

        if (is_callable($value)) {
            return $this->getConnectionInitializer($options, $value);
        } else {
            throw new InvalidArgumentException(sprintf(
                '%s expects either a string or a callable value, %s given',
                static::class,
                is_object($value) ? get_class($value) : gettype($value)
            ));
        }
    }

    /**
     * Returns a connection initializer from a descriptive name.
     *
     * @param OptionsInterface $options     Client options
     * @param string           $description Identifier of a replication backend (`predis`, `sentinel`)
     *
     * @return callable
     */
    protected function getConnectionInitializerByString(OptionsInterface $options, string $description)
    {
        switch ($description) {
            case 'redis':
            case 'redis-cluster':
                return function ($parameters, $options, $option) {
                    return new RedisCluster($options->connections, new RedisStrategy($options->crc16));
                };

            case 'predis':
                return $this->getDefaultConnectionInitializer();

            default:
                throw new InvalidArgumentException(sprintf(
                    '%s expects either `predis`, `redis` or `redis-cluster` as valid string values, `%s` given',
                    static::class,
                    $description
                ));
        }
    }

    /**
     * Returns the default connection initializer.
     *
     * @return callable
     */
    protected function getDefaultConnectionInitializer()
    {
        return function ($parameters, $options, $option) {
            return new PredisCluster();
        };
    }

    /**
     * {@inheritdoc}
     */
    public function getDefault(OptionsInterface $options)
    {
        return $this->getConnectionInitializer(
            $options,
            $this->getDefaultConnectionInitializer()
        );
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\Option\Commands.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use InvalidArgumentException;
use Predis\Command\FactoryInterface;
use Predis\Command\RawFactory;
use Predis\Command\RedisFactory;
use Predis\Configuration\OptionInterface;
use Predis\Configuration\OptionsInterface;

/**
 * Configures a connection factory to be used by the client.
 */
class Commands implements OptionInterface
{
    /**
     * {@inheritdoc}
     */
    public function filter(OptionsInterface $options, $value)
    {
        if (is_callable($value)) {
            $value = call_user_func($value, $options);
        }

        if ($value instanceof FactoryInterface) {
            return $value;
        } elseif (is_array($value)) {
            return $this->createFactoryByArray($options, $value);
        } elseif (is_string($value)) {
            return $this->createFactoryByString($options, $value);
        } else {
            throw new InvalidArgumentException(sprintf(
                '%s expects a valid command factory',
                static::class
            ));
        }
    }

    /**
     * Creates a new default command factory from a named array.
     *
     * The factory instance is configured according to the supplied named array
     * mapping command IDs (passed as keys) to the FCQN of classes implementing
     * Predis\Command\CommandInterface.
     *
     * @param OptionsInterface $options Client options container
     * @param array            $value   Named array mapping command IDs to classes
     *
     * @return FactoryInterface
     */
    protected function createFactoryByArray(OptionsInterface $options, array $value)
    {
        /**
         * @var FactoryInterface
         */
        $commands = $this->getDefault($options);

        foreach ($value as $commandID => $commandClass) {
            if ($commandClass === null) {
                $commands->undefine($commandID);
            } else {
                $commands->define($commandID, $commandClass);
            }
        }

        return $commands;
    }

    /**
     * Creates a new command factory from a descriptive string.
     *
     * The factory instance is configured according to the supplied descriptive
     * string that identifies specific configurations of schemes and connection
     * classes. Supported configuration values are:
     *
     * - "predis" returns the default command factory used by Predis
     * - "raw" returns a command factory that creates only raw commands
     * - "default" is simply an alias of "predis"
     *
     * @param OptionsInterface $options Client options container
     * @param string           $value   Descriptive string identifying the desired configuration
     *
     * @return FactoryInterface
     */
    protected function createFactoryByString(OptionsInterface $options, string $value)
    {
        switch (strtolower($value)) {
            case 'default':
            case 'predis':
                return $this->getDefault($options);

            case 'raw':
                return $this->createRawFactory($options);

            default:
                throw new InvalidArgumentException(sprintf(
                    '%s does not recognize `%s` as a supported configuration string',
                    static::class,
                    $value
                ));
        }
    }

    /**
     * Creates a new raw command factory instance.
     *
     * @param OptionsInterface $options Client options container
     */
    protected function createRawFactory(OptionsInterface $options): FactoryInterface
    {
        $commands = new RawFactory();

        if (isset($options->prefix)) {
            throw new InvalidArgumentException(sprintf(
                '%s does not support key prefixing', RawFactory::class
            ));
        }

        return $commands;
    }

    /**
     * {@inheritdoc}
     */
    public function getDefault(OptionsInterface $options)
    {
        $commands = new RedisFactory();

        if (isset($options->prefix)) {
            $commands->setProcessor($options->prefix);
        }

        return $commands;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\Option\Connections.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use InvalidArgumentException;
use Predis\Configuration\OptionInterface;
use Predis\Configuration\OptionsInterface;
use Predis\Connection\Factory;
use Predis\Connection\FactoryInterface;
use Predis\Connection\PhpiredisSocketConnection;
use Predis\Connection\PhpiredisStreamConnection;
use Predis\Connection\RelayConnection;

/**
 * Configures a new connection factory instance.
 *
 * The client uses the connection factory to create the underlying connections
 * to single redis nodes in a single-server configuration or in replication and
 * cluster configurations.
 */
class Connections implements OptionInterface
{
    /**
     * {@inheritdoc}
     */
    public function filter(OptionsInterface $options, $value)
    {
        if (is_callable($value)) {
            $value = call_user_func($value, $options);
        }

        if ($value instanceof FactoryInterface) {
            return $value;
        } elseif (is_array($value)) {
            return $this->createFactoryByArray($options, $value);
        } elseif (is_string($value)) {
            return $this->createFactoryByString($options, $value);
        } else {
            throw new InvalidArgumentException(sprintf(
                '%s expects a valid connection factory', static::class
            ));
        }
    }

    /**
     * Creates a new connection factory from a named array.
     *
     * The factory instance is configured according to the supplied named array
     * mapping URI schemes (passed as keys) to the FCQN of classes implementing
     * Predis\Connection\NodeConnectionInterface, or callable objects acting as
     * lazy initializers and returning new instances of classes implementing
     * Predis\Connection\NodeConnectionInterface.
     *
     * @param OptionsInterface $options Client options
     * @param array            $value   Named array mapping URI schemes to classes or callables
     *
     * @return FactoryInterface
     */
    protected function createFactoryByArray(OptionsInterface $options, array $value)
    {
        /**
         * @var FactoryInterface
         */
        $factory = $this->getDefault($options);

        foreach ($value as $scheme => $initializer) {
            $factory->define($scheme, $initializer);
        }

        return $factory;
    }

    /**
     * Creates a new connection factory from a descriptive string.
     *
     * The factory instance is configured according to the supplied descriptive
     * string that identifies specific configurations of schemes and connection
     * classes. Supported configuration values are:
     *
     * - "phpiredis-stream" maps tcp, redis, unix to PhpiredisStreamConnection
     * - "phpiredis-socket" maps tcp, redis, unix to PhpiredisSocketConnection
     * - "phpiredis" is an alias of "phpiredis-stream"
     * - "relay" maps tcp, redis, unix, tls, rediss to RelayConnection
     *
     * @param OptionsInterface $options Client options
     * @param string           $value   Descriptive string identifying the desired configuration
     *
     * @return FactoryInterface
     */
    protected function createFactoryByString(OptionsInterface $options, string $value)
    {
        /**
         * @var FactoryInterface
         */
        $factory = $this->getDefault($options);

        switch (strtolower($value)) {
            case 'phpiredis':
            case 'phpiredis-stream':
                $factory->define('tcp', PhpiredisStreamConnection::class);
                $factory->define('redis', PhpiredisStreamConnection::class);
                $factory->define('unix', PhpiredisStreamConnection::class);
                break;

            case 'phpiredis-socket':
                $factory->define('tcp', PhpiredisSocketConnection::class);
                $factory->define('redis', PhpiredisSocketConnection::class);
                $factory->define('unix', PhpiredisSocketConnection::class);
                break;

            case 'relay':
                $factory->define('tcp', RelayConnection::class);
                $factory->define('redis', RelayConnection::class);
                $factory->define('unix', RelayConnection::class);
                break;

            case 'default':
                return $factory;

            default:
                throw new InvalidArgumentException(sprintf(
                    '%s does not recognize `%s` as a supported configuration string', static::class, $value
                ));
        }

        return $factory;
    }

    /**
     * {@inheritdoc}
     */
    public function getDefault(OptionsInterface $options)
    {
        $factory = new Factory();

        if ($options->defined('parameters')) {
            $factory->setDefaultParameters($options->parameters);
        }

        return $factory;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\Option\CRC16.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use InvalidArgumentException;
use Predis\Cluster\Hash;
use Predis\Configuration\OptionInterface;
use Predis\Configuration\OptionsInterface;

/**
 * Configures an hash generator used by the redis-cluster connection backend.
 */
class CRC16 implements OptionInterface
{
    /**
     * Returns an hash generator instance from a descriptive name.
     *
     * @param OptionsInterface $options     Client options.
     * @param string           $description Identifier of a hash generator (`predis`, `phpiredis`)
     *
     * @return callable
     */
    protected function getHashGeneratorByDescription(OptionsInterface $options, $description)
    {
        if ($description === 'predis') {
            return new Hash\CRC16();
        } elseif ($description === 'phpiredis') {
            return new Hash\PhpiredisCRC16();
        } else {
            throw new InvalidArgumentException(
                'String value for the crc16 option must be either `predis` or `phpiredis`'
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    public function filter(OptionsInterface $options, $value)
    {
        if (is_callable($value)) {
            $value = call_user_func($value, $options);
        }

        if (is_string($value)) {
            return $this->getHashGeneratorByDescription($options, $value);
        } elseif ($value instanceof Hash\HashGeneratorInterface) {
            return $value;
        } else {
            $class = get_class($this);
            throw new InvalidArgumentException("$class expects a valid hash generator");
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getDefault(OptionsInterface $options)
    {
        return function_exists('phpiredis_utils_crc16')
            ? new Hash\PhpiredisCRC16()
            : new Hash\CRC16();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\Option\Exceptions.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use Predis\Configuration\OptionInterface;
use Predis\Configuration\OptionsInterface;

/**
 * Configures whether consumers (such as the client) should throw exceptions on
 * Redis errors (-ERR responses) or just return instances of error responses.
 */
class Exceptions implements OptionInterface
{
    /**
     * {@inheritdoc}
     */
    public function filter(OptionsInterface $options, $value)
    {
        return filter_var($value, FILTER_VALIDATE_BOOLEAN);
    }

    /**
     * {@inheritdoc}
     */
    public function getDefault(OptionsInterface $options)
    {
        return true;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\Option\Prefix.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use Predis\Command\Processor\KeyPrefixProcessor;
use Predis\Command\Processor\ProcessorInterface;
use Predis\Configuration\OptionInterface;
use Predis\Configuration\OptionsInterface;

/**
 * Configures a command processor that apply the specified prefix string to a
 * series of Redis commands considered prefixable.
 */
class Prefix implements OptionInterface
{
    /**
     * {@inheritdoc}
     */
    public function filter(OptionsInterface $options, $value)
    {
        if (is_callable($value)) {
            $value = call_user_func($value, $options);
        }

        if ($value instanceof ProcessorInterface) {
            return $value;
        }

        return new KeyPrefixProcessor((string) $value);
    }

    /**
     * {@inheritdoc}
     */
    public function getDefault(OptionsInterface $options)
    {
        // NOOP
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Configuration\Option\Replication.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use InvalidArgumentException;
use Predis\Configuration\OptionsInterface;
use Predis\Connection\AggregateConnectionInterface;
use Predis\Connection\Replication\MasterSlaveReplication;
use Predis\Connection\Replication\SentinelReplication;

/**
 * Configures an aggregate connection used for master/slave replication among
 * multiple Redis nodes.
 */
class Replication extends Aggregate
{
    /**
     * {@inheritdoc}
     */
    public function filter(OptionsInterface $options, $value)
    {
        if (is_string($value)) {
            $value = $this->getConnectionInitializerByString($options, $value);
        }

        if (is_callable($value)) {
            return $this->getConnectionInitializer($options, $value);
        } else {
            throw new InvalidArgumentException(sprintf(
                '%s expects either a string or a callable value, %s given',
                static::class,
                is_object($value) ? get_class($value) : gettype($value)
            ));
        }
    }

    /**
     * Returns a connection initializer (callable) from a descriptive string.
     *
     * Each connection initializer is specialized for the specified replication
     * backend so that all the necessary steps for the configuration of the new
     * aggregate connection are performed inside the initializer and the client
     * receives a ready-to-use connection.
     *
     * Supported configuration values are:
     *
     * - `predis` for unmanaged replication setups
     * - `redis-sentinel` for replication setups managed by redis-sentinel
     * - `sentinel` is an alias of `redis-sentinel`
     *
     * @param OptionsInterface $options     Client options
     * @param string           $description Identifier of a replication backend
     *
     * @return callable
     */
    protected function getConnectionInitializerByString(OptionsInterface $options, string $description)
    {
        switch ($description) {
            case 'sentinel':
            case 'redis-sentinel':
                return function ($parameters, $options) {
                    return new SentinelReplication($options->service, $parameters, $options->connections);
                };

            case 'predis':
                return $this->getDefaultConnectionInitializer();

            default:
                throw new InvalidArgumentException(sprintf(
                    '%s expects either `predis`, `sentinel` or `redis-sentinel` as valid string values, `%s` given',
                    static::class,
                    $description
                ));
        }
    }

    /**
     * Returns the default connection initializer.
     *
     * @return callable
     */
    protected function getDefaultConnectionInitializer()
    {
        return function ($parameters, $options) {
            $connection = new MasterSlaveReplication();

            if ($options->autodiscovery) {
                $connection->setConnectionFactory($options->connections);
                $connection->setAutoDiscovery(true);
            }

            return $connection;
        };
    }

    /**
     * {@inheritdoc}
     */
    public static function aggregate(OptionsInterface $options, AggregateConnectionInterface $connection, array $nodes)
    {
        if (!$connection instanceof SentinelReplication) {
            parent::aggregate($options, $connection, $nodes);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getDefault(OptionsInterface $options)
    {
        return $this->getConnectionInitializer(
            $options,
            $this->getDefaultConnectionInitializer()
        );
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\AbstractConnection.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use InvalidArgumentException;
use Predis\Command\CommandInterface;
use Predis\Command\RawCommand;
use Predis\CommunicationException;
use Predis\Protocol\ProtocolException;

/**
 * Base class with the common logic used by connection classes to communicate
 * with Redis.
 */
abstract class AbstractConnection implements NodeConnectionInterface
{
    private $resource;
    private $cachedId;

    protected $parameters;

    /**
     * @var RawCommand[]
     */
    protected $initCommands = [];

    /**
     * @param ParametersInterface $parameters Initialization parameters for the connection.
     */
    public function __construct(ParametersInterface $parameters)
    {
        $this->parameters = $this->assertParameters($parameters);
    }

    /**
     * Disconnects from the server and destroys the underlying resource when
     * PHP's garbage collector kicks in.
     */
    public function __destruct()
    {
        $this->disconnect();
    }

    /**
     * Checks some of the parameters used to initialize the connection.
     *
     * @param ParametersInterface $parameters Initialization parameters for the connection.
     *
     * @return ParametersInterface
     * @throws InvalidArgumentException
     */
    abstract protected function assertParameters(ParametersInterface $parameters);

    /**
     * Creates the underlying resource used to communicate with Redis.
     *
     * @return mixed
     */
    abstract protected function createResource();

    /**
     * {@inheritdoc}
     */
    public function isConnected()
    {
        return isset($this->resource);
    }

    /**
     * {@inheritdoc}
     */
    public function connect()
    {
        if (!$this->isConnected()) {
            $this->resource = $this->createResource();

            return true;
        }

        return false;
    }

    /**
     * {@inheritdoc}
     */
    public function disconnect()
    {
        unset($this->resource);
    }

    /**
     * {@inheritdoc}
     */
    public function addConnectCommand(CommandInterface $command)
    {
        $this->initCommands[] = $command;
    }

    /**
     * {@inheritdoc}
     */
    public function getInitCommands(): array
    {
        return $this->initCommands;
    }

    /**
     * {@inheritdoc}
     */
    public function executeCommand(CommandInterface $command)
    {
        $this->writeRequest($command);

        return $this->readResponse($command);
    }

    /**
     * {@inheritdoc}
     */
    public function readResponse(CommandInterface $command)
    {
        return $this->read();
    }

    /**
     * Helper method to handle connection errors.
     *
     * @param string $message Error message.
     * @param int    $code    Error code.
     */
    protected function onConnectionError($message, $code = 0)
    {
        CommunicationException::handle(
            new ConnectionException($this, "$message [{$this->getParameters()}]", $code)
        );
    }

    /**
     * Helper method to handle protocol errors.
     *
     * @param string $message Error message.
     */
    protected function onProtocolError($message)
    {
        CommunicationException::handle(
            new ProtocolException($this, "$message [{$this->getParameters()}]")
        );
    }

    /**
     * {@inheritdoc}
     */
    public function getResource()
    {
        if (isset($this->resource)) {
            return $this->resource;
        }

        $this->connect();

        return $this->resource;
    }

    /**
     * {@inheritdoc}
     */
    public function getParameters()
    {
        return $this->parameters;
    }

    /**
     * Gets an identifier for the connection.
     *
     * @return string
     */
    protected function getIdentifier()
    {
        if ($this->parameters->scheme === 'unix') {
            return $this->parameters->path;
        }

        return "{$this->parameters->host}:{$this->parameters->port}";
    }

    /**
     * {@inheritdoc}
     */
    public function __toString()
    {
        if (!isset($this->cachedId)) {
            $this->cachedId = $this->getIdentifier();
        }

        return $this->cachedId;
    }

    /**
     * {@inheritdoc}
     */
    public function __sleep()
    {
        return ['parameters', 'initCommands'];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\AggregateConnectionInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use Predis\Command\CommandInterface;

/**
 * Defines a virtual connection composed of multiple connection instances to
 * single Redis nodes.
 */
interface AggregateConnectionInterface extends ConnectionInterface
{
    /**
     * Adds a connection instance to the aggregate connection.
     *
     * @param NodeConnectionInterface $connection Connection instance.
     */
    public function add(NodeConnectionInterface $connection);

    /**
     * Removes the specified connection instance from the aggregate connection.
     *
     * @param NodeConnectionInterface $connection Connection instance.
     *
     * @return bool Returns true if the connection was in the pool.
     */
    public function remove(NodeConnectionInterface $connection);

    /**
     * Returns the connection instance in charge for the given command.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return NodeConnectionInterface
     */
    public function getConnectionByCommand(CommandInterface $command);

    /**
     * Returns a connection instance from the aggregate connection by its alias.
     *
     * @param string $connectionID Connection alias.
     *
     * @return NodeConnectionInterface|null
     */
    public function getConnectionById($connectionID);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\CompositeConnectionInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

/**
 * Defines a connection to communicate with a single Redis server that leverages
 * an external protocol processor to handle pluggable protocol handlers.
 */
interface CompositeConnectionInterface extends NodeConnectionInterface
{
    /**
     * Returns the protocol processor used by the connection.
     */
    public function getProtocol();

    /**
     * Writes the buffer containing over the connection.
     *
     * @param string $buffer String buffer to be sent over the connection.
     */
    public function writeBuffer($buffer);

    /**
     * Reads the given number of bytes from the connection.
     *
     * @param int $length Number of bytes to read from the connection.
     *
     * @return string
     */
    public function readBuffer($length);

    /**
     * Reads a line from the connection.
     *
     * @return string
     */
    public function readLine();
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\CompositeStreamConnection.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use InvalidArgumentException;
use Predis\Command\CommandInterface;
use Predis\Protocol\ProtocolProcessorInterface;
use Predis\Protocol\Text\ProtocolProcessor as TextProtocolProcessor;

/**
 * Connection abstraction to Redis servers based on PHP's stream that uses an
 * external protocol processor defining the protocol used for the communication.
 */
class CompositeStreamConnection extends StreamConnection implements CompositeConnectionInterface
{
    protected $protocol;

    /**
     * @param ParametersInterface             $parameters Initialization parameters for the connection.
     * @param ProtocolProcessorInterface|null $protocol   Protocol processor.
     */
    public function __construct(
        ParametersInterface $parameters,
        ?ProtocolProcessorInterface $protocol = null
    ) {
        $this->parameters = $this->assertParameters($parameters);
        $this->protocol = $protocol ?: new TextProtocolProcessor();
    }

    /**
     * {@inheritdoc}
     */
    public function getProtocol()
    {
        return $this->protocol;
    }

    /**
     * {@inheritdoc}
     */
    public function writeBuffer($buffer)
    {
        $this->write($buffer);
    }

    /**
     * {@inheritdoc}
     */
    public function readBuffer($length)
    {
        if ($length <= 0) {
            throw new InvalidArgumentException('Length parameter must be greater than 0.');
        }

        $value = '';
        $socket = $this->getResource();

        do {
            $chunk = fread($socket, $length);

            if ($chunk === false || $chunk === '') {
                $this->onConnectionError('Error while reading bytes from the server.');
            }

            $value .= $chunk;
        } while (($length -= strlen($chunk)) > 0);

        return $value;
    }

    /**
     * {@inheritdoc}
     */
    public function readLine()
    {
        $value = '';
        $socket = $this->getResource();

        do {
            $chunk = fgets($socket);

            if ($chunk === false || $chunk === '') {
                $this->onConnectionError('Error while reading line from the server.');
            }

            $value .= $chunk;
        } while (substr($value, -2) !== "\r\n");

        return substr($value, 0, -2);
    }

    /**
     * {@inheritdoc}
     */
    public function writeRequest(CommandInterface $command)
    {
        $this->protocol->write($this, $command);
    }

    /**
     * {@inheritdoc}
     */
    public function read()
    {
        return $this->protocol->read($this);
    }

    /**
     * {@inheritdoc}
     */
    public function __sleep()
    {
        return array_merge(parent::__sleep(), ['protocol']);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\ConnectionException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use Predis\CommunicationException;

/**
 * Exception class that identifies connection-related errors.
 */
class ConnectionException extends CommunicationException
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\ConnectionInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use Predis\Command\CommandInterface;

/**
 * Defines a connection object used to communicate with one or multiple
 * Redis servers.
 */
interface ConnectionInterface
{
    /**
     * Opens the connection to Redis.
     */
    public function connect();

    /**
     * Closes the connection to Redis.
     */
    public function disconnect();

    /**
     * Checks if the connection to Redis is considered open.
     *
     * @return bool
     */
    public function isConnected();

    /**
     * Writes the request for the given command over the connection.
     *
     * @param CommandInterface $command Command instance.
     */
    public function writeRequest(CommandInterface $command);

    /**
     * Reads the response to the given command from the connection.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return mixed
     */
    public function readResponse(CommandInterface $command);

    /**
     * Writes a request for the given command over the connection and reads back
     * the response returned by Redis.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return mixed
     */
    public function executeCommand(CommandInterface $command);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\Factory.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use InvalidArgumentException;
use Predis\Client;
use Predis\Command\RawCommand;
use ReflectionClass;
use UnexpectedValueException;

/**
 * Standard connection factory for creating connections to Redis nodes.
 */
class Factory implements FactoryInterface
{
    private $defaults = [];

    protected $schemes = [
        'tcp' => 'Predis\Connection\StreamConnection',
        'unix' => 'Predis\Connection\StreamConnection',
        'tls' => 'Predis\Connection\StreamConnection',
        'redis' => 'Predis\Connection\StreamConnection',
        'rediss' => 'Predis\Connection\StreamConnection',
        'http' => 'Predis\Connection\WebdisConnection',
    ];

    /**
     * Checks if the provided argument represents a valid connection class
     * implementing Predis\Connection\NodeConnectionInterface. Optionally,
     * callable objects are used for lazy initialization of connection objects.
     *
     * @param mixed $initializer FQN of a connection class or a callable for lazy initialization.
     *
     * @return mixed
     * @throws InvalidArgumentException
     */
    protected function checkInitializer($initializer)
    {
        if (is_callable($initializer)) {
            return $initializer;
        }

        $class = new ReflectionClass($initializer);

        if (!$class->isSubclassOf('Predis\Connection\NodeConnectionInterface')) {
            throw new InvalidArgumentException(
                'A connection initializer must be a valid connection class or a callable object.'
            );
        }

        return $initializer;
    }

    /**
     * {@inheritdoc}
     */
    public function define($scheme, $initializer)
    {
        $this->schemes[$scheme] = $this->checkInitializer($initializer);
    }

    /**
     * {@inheritdoc}
     */
    public function undefine($scheme)
    {
        unset($this->schemes[$scheme]);
    }

    /**
     * {@inheritdoc}
     */
    public function create($parameters)
    {
        if (!$parameters instanceof ParametersInterface) {
            $parameters = $this->createParameters($parameters);
        }

        $scheme = $parameters->scheme;

        if (!isset($this->schemes[$scheme])) {
            throw new InvalidArgumentException("Unknown connection scheme: '$scheme'.");
        }

        $initializer = $this->schemes[$scheme];

        if (is_callable($initializer)) {
            $connection = call_user_func($initializer, $parameters, $this);
        } else {
            $connection = new $initializer($parameters);
            $this->prepareConnection($connection);
        }

        if (!$connection instanceof NodeConnectionInterface) {
            throw new UnexpectedValueException(
                'Objects returned by connection initializers must implement ' .
                "'Predis\Connection\NodeConnectionInterface'."
            );
        }

        return $connection;
    }

    /**
     * Assigns a default set of parameters applied to new connections.
     *
     * The set of parameters passed to create a new connection have precedence
     * over the default values set for the connection factory.
     *
     * @param array $parameters Set of connection parameters.
     */
    public function setDefaultParameters(array $parameters)
    {
        $this->defaults = $parameters;
    }

    /**
     * Returns the default set of parameters applied to new connections.
     *
     * @return array
     */
    public function getDefaultParameters()
    {
        return $this->defaults;
    }

    /**
     * Creates a connection parameters instance from the supplied argument.
     *
     * @param mixed $parameters Original connection parameters.
     *
     * @return ParametersInterface
     */
    protected function createParameters($parameters)
    {
        if (is_string($parameters)) {
            $parameters = Parameters::parse($parameters);
        } else {
            $parameters = $parameters ?: [];
        }

        if ($this->defaults) {
            $parameters += $this->defaults;
        }

        return new Parameters($parameters);
    }

    /**
     * Prepares a connection instance after its initialization.
     *
     * @param NodeConnectionInterface $connection Connection instance.
     */
    protected function prepareConnection(NodeConnectionInterface $connection)
    {
        $parameters = $connection->getParameters();

        if (isset($parameters->password) && strlen($parameters->password)) {
            $cmdAuthArgs = isset($parameters->username) && strlen($parameters->username)
                ? [$parameters->username, $parameters->password]
                : [$parameters->password];

            $connection->addConnectCommand(
                new RawCommand('AUTH', $cmdAuthArgs)
            );
        }

        if (($parameters->client_info ?? false) && !$connection instanceof RelayConnection) {
            $connection->addConnectCommand(
                new RawCommand('CLIENT', ['SETINFO', 'LIB-NAME', 'predis'])
            );

            $connection->addConnectCommand(
                new RawCommand('CLIENT', ['SETINFO', 'LIB-VER', Client::VERSION])
            );
        }

        if (isset($parameters->database) && strlen($parameters->database)) {
            $connection->addConnectCommand(
                new RawCommand('SELECT', [$parameters->database])
            );
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\FactoryInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

/**
 * Interface for classes providing a factory of connections to Redis nodes.
 */
interface FactoryInterface
{
    /**
     * Defines or overrides the connection class identified by a scheme prefix.
     *
     * @param string $scheme      Target connection scheme.
     * @param mixed  $initializer Fully-qualified name of a class or a callable for lazy initialization.
     */
    public function define($scheme, $initializer);

    /**
     * Undefines the connection identified by a scheme prefix.
     *
     * @param string $scheme Target connection scheme.
     */
    public function undefine($scheme);

    /**
     * Creates a new connection object.
     *
     * @param mixed $parameters Initialization parameters for the connection.
     *
     * @return NodeConnectionInterface
     */
    public function create($parameters);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\NodeConnectionInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use Predis\Command\CommandInterface;

/**
 * Defines a connection used to communicate with a single Redis node.
 */
interface NodeConnectionInterface extends ConnectionInterface
{
    /**
     * Returns a string representation of the connection.
     *
     * @return string
     */
    public function __toString();

    /**
     * Returns the underlying resource used to communicate with Redis.
     *
     * @return mixed
     */
    public function getResource();

    /**
     * Returns the parameters used to initialize the connection.
     *
     * @return ParametersInterface
     */
    public function getParameters();

    /**
     * Pushes the given command into a queue of commands executed when
     * establishing the actual connection to Redis.
     *
     * @param CommandInterface $command Instance of a Redis command.
     */
    public function addConnectCommand(CommandInterface $command);

    /**
     * Reads a response from the server.
     *
     * @return mixed
     */
    public function read();
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\Parameters.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use InvalidArgumentException;

/**
 * Container for connection parameters used to initialize connections to Redis.
 *
 * {@inheritdoc}
 */
class Parameters implements ParametersInterface
{
    protected static $defaults = [
        'scheme' => 'tcp',
        'host' => '127.0.0.1',
        'port' => 6379,
    ];

    /**
     * Set of connection parameters already filtered
     * for NULL or 0-length string values.
     *
     * @var array
     */
    protected $parameters;

    /**
     * @param array $parameters Named array of connection parameters.
     */
    public function __construct(array $parameters = [])
    {
        $this->parameters = $this->filter($parameters + static::$defaults);
    }

    /**
     * Filters parameters removing entries with NULL or 0-length string values.
     *
     * @params array $parameters Array of parameters to be filtered
     *
     * @return array
     */
    protected function filter(array $parameters)
    {
        return array_filter($parameters, function ($value) {
            return $value !== null && $value !== '';
        });
    }

    /**
     * Creates a new instance by supplying the initial parameters either in the
     * form of an URI string or a named array.
     *
     * @param array|string $parameters Set of connection parameters.
     *
     * @return Parameters
     */
    public static function create($parameters)
    {
        if (is_string($parameters)) {
            $parameters = static::parse($parameters);
        }

        return new static($parameters ?: []);
    }

    /**
     * Parses an URI string returning an array of connection parameters.
     *
     * When using the "redis" and "rediss" schemes the URI is parsed according
     * to the rules defined by the provisional registration documents approved
     * by IANA. If the URI has a password in its "user-information" part or a
     * database number in the "path" part these values override the values of
     * "password" and "database" if they are present in the "query" part.
     *
     * @see http://www.iana.org/assignments/uri-schemes/prov/redis
     * @see http://www.iana.org/assignments/uri-schemes/prov/rediss
     *
     * @param string $uri URI string.
     *
     * @return array
     * @throws InvalidArgumentException
     */
    public static function parse($uri)
    {
        if (stripos($uri, 'unix://') === 0) {
            // parse_url() can parse unix:/path/to/sock so we do not need the
            // unix:///path/to/sock hack, we will support it anyway until 2.0.
            $uri = str_ireplace('unix://', 'unix:', $uri);
        }

        if (!$parsed = parse_url($uri)) {
            throw new InvalidArgumentException("Invalid parameters URI: $uri");
        }

        if (
            isset($parsed['host'])
            && false !== strpos($parsed['host'], '[')
            && false !== strpos($parsed['host'], ']')
        ) {
            $parsed['host'] = substr($parsed['host'], 1, -1);
        }

        if (isset($parsed['query'])) {
            parse_str($parsed['query'], $queryarray);
            unset($parsed['query']);

            $parsed = array_merge($parsed, $queryarray);
        }

        if (stripos($uri, 'redis') === 0) {
            if (isset($parsed['user'])) {
                if (strlen($parsed['user'])) {
                    $parsed['username'] = $parsed['user'];
                }
                unset($parsed['user']);
            }

            if (isset($parsed['pass'])) {
                if (strlen($parsed['pass'])) {
                    $parsed['password'] = $parsed['pass'];
                }
                unset($parsed['pass']);
            }

            if (isset($parsed['path']) && preg_match('/^\/(\d+)(\/.*)?/', $parsed['path'], $path)) {
                $parsed['database'] = $path[1];

                if (isset($path[2])) {
                    $parsed['path'] = $path[2];
                } else {
                    unset($parsed['path']);
                }
            }
        }

        return $parsed;
    }

    /**
     * {@inheritdoc}
     */
    public function toArray()
    {
        return $this->parameters;
    }

    /**
     * {@inheritdoc}
     */
    public function __get($parameter)
    {
        if (isset($this->parameters[$parameter])) {
            return $this->parameters[$parameter];
        }
    }

    /**
     * {@inheritdoc}
     */
    public function __isset($parameter)
    {
        return isset($this->parameters[$parameter]);
    }

    /**
     * {@inheritdoc}
     */
    public function __toString()
    {
        if ($this->scheme === 'unix') {
            return "$this->scheme:$this->path";
        }

        if (filter_var($this->host, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            return "$this->scheme://[$this->host]:$this->port";
        }

        return "$this->scheme://$this->host:$this->port";
    }

    /**
     * {@inheritdoc}
     */
    public function __sleep()
    {
        return ['parameters'];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\ParametersInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

/**
 * Interface defining a container for connection parameters.
 *
 * The actual list of connection parameters depends on the features supported by
 * each connection backend class (please refer to their specific documentation),
 * but the most common parameters used through the library are:
 *
 * @property string $scheme             Connection scheme, such as 'tcp' or 'unix'.
 * @property string $host               IP address or hostname of Redis.
 * @property int    $port               TCP port on which Redis is listening to.
 * @property string $path               Path of a UNIX domain socket file.
 * @property string $alias              Alias for the connection.
 * @property float  $timeout            Timeout for the connect() operation.
 * @property float  $read_write_timeout Timeout for read() and write() operations.
 * @property bool   $persistent         Leaves the connection open after a GC collection.
 * @property string $password           Password to access Redis (see the AUTH command).
 * @property string $database           Database index (see the SELECT command).
 * @property bool   $async_connect      Performs the connect() operation asynchronously.
 * @property bool   $tcp_nodelay        Toggles the Nagle's algorithm for coalescing.
 * @property bool   $client_info        Whether to set LIB-NAME and LIB-VER when connecting.
 * @property bool   $cache              (Relay only) Whether to use in-memory caching.
 * @property string $serializer         (Relay only) Serializer used for data serialization.
 * @property string $compression        (Relay only) Algorithm used for data compression.
 */
interface ParametersInterface
{
    /**
     * Checks if the specified parameters is set.
     *
     * @param string $parameter Name of the parameter.
     *
     * @return bool
     */
    public function __isset($parameter);

    /**
     * Returns the value of the specified parameter.
     *
     * @param string $parameter Name of the parameter.
     *
     * @return mixed|null
     */
    public function __get($parameter);

    /**
     * Returns basic connection parameters as a valid URI string.
     *
     * @return string
     */
    public function __toString();

    /**
     * Returns an array representation of the connection parameters.
     *
     * @return array
     */
    public function toArray();
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\PhpiredisSocketConnection.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use Closure;
use InvalidArgumentException;
use Predis\Command\CommandInterface;
use Predis\NotSupportedException;
use Predis\Response\Error as ErrorResponse;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use Predis\Response\Status as StatusResponse;

/**
 * This class provides the implementation of a Predis connection that uses the
 * PHP socket extension for network communication and wraps the phpiredis C
 * extension (PHP bindings for hiredis) to parse the Redis protocol.
 *
 * This class is intended to provide an optional low-overhead alternative for
 * processing responses from Redis compared to the standard pure-PHP classes.
 * Differences in speed when dealing with short inline responses are practically
 * nonexistent, the actual speed boost is for big multibulk responses when this
 * protocol processor can parse and return responses very fast.
 *
 * For instructions on how to build and install the phpiredis extension, please
 * consult the repository of the project.
 *
 * The connection parameters supported by this class are:
 *
 *  - scheme: it can be either 'redis', 'tcp' or 'unix'.
 *  - host: hostname or IP address of the server.
 *  - port: TCP port of the server.
 *  - path: path of a UNIX domain socket when scheme is 'unix'.
 *  - timeout: timeout to perform the connection (default is 5 seconds).
 *  - read_write_timeout: timeout of read / write operations.
 *
 * @see http://github.com/nrk/phpiredis
 * @deprecated 2.1.2
 */
class PhpiredisSocketConnection extends AbstractConnection
{
    private $reader;

    /**
     * {@inheritdoc}
     */
    public function __construct(ParametersInterface $parameters)
    {
        $this->assertExtensions();

        parent::__construct($parameters);

        $this->reader = $this->createReader();
    }

    /**
     * Disconnects from the server and destroys the underlying resource and the
     * protocol reader resource when PHP's garbage collector kicks in.
     */
    public function __destruct()
    {
        parent::__destruct();

        phpiredis_reader_destroy($this->reader);
    }

    /**
     * Checks if the socket and phpiredis extensions are loaded in PHP.
     */
    protected function assertExtensions()
    {
        if (!extension_loaded('sockets')) {
            throw new NotSupportedException(
                'The "sockets" extension is required by this connection backend.'
            );
        }

        if (!extension_loaded('phpiredis')) {
            throw new NotSupportedException(
                'The "phpiredis" extension is required by this connection backend.'
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    protected function assertParameters(ParametersInterface $parameters)
    {
        switch ($parameters->scheme) {
            case 'tcp':
            case 'redis':
            case 'unix':
                break;

            default:
                throw new InvalidArgumentException("Invalid scheme: '$parameters->scheme'.");
        }

        if (isset($parameters->persistent)) {
            throw new NotSupportedException(
                'Persistent connections are not supported by this connection backend.'
            );
        }

        return $parameters;
    }

    /**
     * Creates a new instance of the protocol reader resource.
     *
     * @return resource
     */
    private function createReader()
    {
        $reader = phpiredis_reader_create();

        phpiredis_reader_set_status_handler($reader, $this->getStatusHandler());
        phpiredis_reader_set_error_handler($reader, $this->getErrorHandler());

        return $reader;
    }

    /**
     * Returns the underlying protocol reader resource.
     *
     * @return resource
     */
    protected function getReader()
    {
        return $this->reader;
    }

    /**
     * Returns the handler used by the protocol reader for inline responses.
     *
     * @return Closure
     */
    protected function getStatusHandler()
    {
        static $statusHandler;

        if (!$statusHandler) {
            $statusHandler = function ($payload) {
                return StatusResponse::get($payload);
            };
        }

        return $statusHandler;
    }

    /**
     * Returns the handler used by the protocol reader for error responses.
     *
     * @return Closure
     */
    protected function getErrorHandler()
    {
        static $errorHandler;

        if (!$errorHandler) {
            $errorHandler = function ($errorMessage) {
                return new ErrorResponse($errorMessage);
            };
        }

        return $errorHandler;
    }

    /**
     * Helper method used to throw exceptions on socket errors.
     */
    private function emitSocketError()
    {
        $errno = socket_last_error();
        $errstr = socket_strerror($errno);

        $this->disconnect();

        $this->onConnectionError(trim($errstr), $errno);
    }

    /**
     * Gets the address of an host from connection parameters.
     *
     * @param ParametersInterface $parameters Parameters used to initialize the connection.
     *
     * @return string
     */
    protected static function getAddress(ParametersInterface $parameters)
    {
        if (filter_var($host = $parameters->host, FILTER_VALIDATE_IP)) {
            return $host;
        }

        if ($host === $address = gethostbyname($host)) {
            return false;
        }

        return $address;
    }

    /**
     * {@inheritdoc}
     */
    protected function createResource()
    {
        $parameters = $this->parameters;

        if ($parameters->scheme === 'unix') {
            $address = $parameters->path;
            $domain = AF_UNIX;
            $protocol = 0;
        } else {
            if (false === $address = self::getAddress($parameters)) {
                $this->onConnectionError("Cannot resolve the address of '$parameters->host'.");
            }

            $domain = filter_var($address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) ? AF_INET6 : AF_INET;
            $protocol = SOL_TCP;
        }

        if (false === $socket = @socket_create($domain, SOCK_STREAM, $protocol)) {
            $this->emitSocketError();
        }

        $this->setSocketOptions($socket, $parameters);
        $this->connectWithTimeout($socket, $address, $parameters);

        return $socket;
    }

    /**
     * Sets options on the socket resource from the connection parameters.
     *
     * @param resource            $socket     Socket resource.
     * @param ParametersInterface $parameters Parameters used to initialize the connection.
     */
    private function setSocketOptions($socket, ParametersInterface $parameters)
    {
        if ($parameters->scheme !== 'unix') {
            if (!socket_set_option($socket, SOL_TCP, TCP_NODELAY, 1)) {
                $this->emitSocketError();
            }

            if (!socket_set_option($socket, SOL_SOCKET, SO_REUSEADDR, 1)) {
                $this->emitSocketError();
            }
        }

        if (isset($parameters->read_write_timeout)) {
            $rwtimeout = (float) $parameters->read_write_timeout;
            $timeoutSec = floor($rwtimeout);
            $timeoutUsec = ($rwtimeout - $timeoutSec) * 1000000;

            $timeout = [
                'sec' => $timeoutSec,
                'usec' => $timeoutUsec,
            ];

            if (!socket_set_option($socket, SOL_SOCKET, SO_SNDTIMEO, $timeout)) {
                $this->emitSocketError();
            }

            if (!socket_set_option($socket, SOL_SOCKET, SO_RCVTIMEO, $timeout)) {
                $this->emitSocketError();
            }
        }
    }

    /**
     * Opens the actual connection to the server with a timeout.
     *
     * @param resource            $socket     Socket resource.
     * @param string              $address    IP address (DNS-resolved from hostname)
     * @param ParametersInterface $parameters Parameters used to initialize the connection.
     *
     * @return void
     */
    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)
    {
        socket_set_nonblock($socket);

        if (@socket_connect($socket, $address, (int) $parameters->port) === false) {
            $error = socket_last_error();

            if ($error != SOCKET_EINPROGRESS && $error != SOCKET_EALREADY) {
                $this->emitSocketError();
            }
        }

        socket_set_block($socket);

        $null = null;
        $selectable = [$socket];

        $timeout = (isset($parameters->timeout) ? (float) $parameters->timeout : 5.0);
        $timeoutSecs = floor($timeout);
        $timeoutUSecs = ($timeout - $timeoutSecs) * 1000000;

        $selected = socket_select($selectable, $selectable, $null, $timeoutSecs, $timeoutUSecs);

        if ($selected === 2) {
            $this->onConnectionError('Connection refused.', SOCKET_ECONNREFUSED);
        }

        if ($selected === 0) {
            $this->onConnectionError('Connection timed out.', SOCKET_ETIMEDOUT);
        }

        if ($selected === false) {
            $this->emitSocketError();
        }
    }

    /**
     * {@inheritdoc}
     */
    public function connect()
    {
        if (parent::connect() && $this->initCommands) {
            foreach ($this->initCommands as $command) {
                $response = $this->executeCommand($command);

                if ($response instanceof ErrorResponseInterface) {
                    $this->onConnectionError("`{$command->getId()}` failed: {$response->getMessage()}", 0);
                }
            }
        }
    }

    /**
     * {@inheritdoc}
     */
    public function disconnect()
    {
        if ($this->isConnected()) {
            phpiredis_reader_reset($this->reader);
            socket_close($this->getResource());

            parent::disconnect();
        }
    }

    /**
     * {@inheritdoc}
     */
    protected function write($buffer)
    {
        $socket = $this->getResource();

        while (($length = strlen($buffer)) > 0) {
            $written = socket_write($socket, $buffer, $length);

            if ($length === $written) {
                return;
            }

            if ($written === false) {
                $this->onConnectionError('Error while writing bytes to the server.');
            }

            $buffer = substr($buffer, $written);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function read()
    {
        $socket = $this->getResource();
        $reader = $this->reader;

        while (PHPIREDIS_READER_STATE_INCOMPLETE === $state = phpiredis_reader_get_state($reader)) {
            if (@socket_recv($socket, $buffer, 4096, 0) === false || $buffer === '' || $buffer === null) {
                $this->emitSocketError();
            }

            phpiredis_reader_feed($reader, $buffer);
        }

        if ($state === PHPIREDIS_READER_STATE_COMPLETE) {
            return phpiredis_reader_get_reply($reader);
        } else {
            $this->onProtocolError(phpiredis_reader_get_error($reader));

            return;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function writeRequest(CommandInterface $command)
    {
        $arguments = $command->getArguments();
        array_unshift($arguments, $command->getId());

        $this->write(phpiredis_format_command($arguments));
    }

    /**
     * {@inheritdoc}
     */
    public function __wakeup()
    {
        $this->assertExtensions();
        $this->reader = $this->createReader();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\PhpiredisStreamConnection.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use Closure;
use InvalidArgumentException;
use Predis\Command\CommandInterface;
use Predis\NotSupportedException;
use Predis\Response\Error as ErrorResponse;
use Predis\Response\Status as StatusResponse;

/**
 * This class provides the implementation of a Predis connection that uses PHP's
 * streams for network communication and wraps the phpiredis C extension (PHP
 * bindings for hiredis) to parse and serialize the Redis protocol.
 *
 * This class is intended to provide an optional low-overhead alternative for
 * processing responses from Redis compared to the standard pure-PHP classes.
 * Differences in speed when dealing with short inline responses are practically
 * nonexistent, the actual speed boost is for big multibulk responses when this
 * protocol processor can parse and return responses very fast.
 *
 * For instructions on how to build and install the phpiredis extension, please
 * consult the repository of the project.
 *
 * The connection parameters supported by this class are:
 *
 *  - scheme: it can be either 'redis', 'tcp' or 'unix'.
 *  - host: hostname or IP address of the server.
 *  - port: TCP port of the server.
 *  - path: path of a UNIX domain socket when scheme is 'unix'.
 *  - timeout: timeout to perform the connection.
 *  - read_write_timeout: timeout of read / write operations.
 *  - async_connect: performs the connection asynchronously.
 *  - tcp_nodelay: enables or disables Nagle's algorithm for coalescing.
 *  - persistent: the connection is left intact after a GC collection.
 *
 * @see https://github.com/nrk/phpiredis
 * @deprecated 2.1.2
 */
class PhpiredisStreamConnection extends StreamConnection
{
    private $reader;

    /**
     * {@inheritdoc}
     */
    public function __construct(ParametersInterface $parameters)
    {
        $this->assertExtensions();

        parent::__construct($parameters);

        $this->reader = $this->createReader();
    }

    /**
     * {@inheritdoc}
     */
    public function __destruct()
    {
        parent::__destruct();

        phpiredis_reader_destroy($this->reader);
    }

    /**
     * {@inheritdoc}
     */
    public function disconnect()
    {
        phpiredis_reader_reset($this->reader);

        parent::disconnect();
    }

    /**
     * Checks if the phpiredis extension is loaded in PHP.
     */
    private function assertExtensions()
    {
        if (!extension_loaded('phpiredis')) {
            throw new NotSupportedException(
                'The "phpiredis" extension is required by this connection backend.'
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    protected function assertParameters(ParametersInterface $parameters)
    {
        switch ($parameters->scheme) {
            case 'tcp':
            case 'redis':
            case 'unix':
                break;

            case 'tls':
            case 'rediss':
                throw new InvalidArgumentException('SSL encryption is not supported by this connection backend.');
            default:
                throw new InvalidArgumentException("Invalid scheme: '$parameters->scheme'.");
        }

        return $parameters;
    }

    /**
     * {@inheritdoc}
     */
    protected function createStreamSocket(ParametersInterface $parameters, $address, $flags)
    {
        $socket = null;
        $timeout = (isset($parameters->timeout) ? (float) $parameters->timeout : 5.0);
        $context = stream_context_create(['socket' => ['tcp_nodelay' => (bool) $parameters->tcp_nodelay]]);

        if (!$resource = @stream_socket_client($address, $errno, $errstr, $timeout, $flags, $context)) {
            $this->onConnectionError(trim($errstr), $errno);
        }

        if (isset($parameters->read_write_timeout) && function_exists('socket_import_stream')) {
            $rwtimeout = (float) $parameters->read_write_timeout;
            $rwtimeout = $rwtimeout > 0 ? $rwtimeout : -1;

            $timeout = [
                'sec' => $timeoutSeconds = floor($rwtimeout),
                'usec' => ($rwtimeout - $timeoutSeconds) * 1000000,
            ];

            $socket = $socket ?: socket_import_stream($resource);
            @socket_set_option($socket, SOL_SOCKET, SO_SNDTIMEO, $timeout);
            @socket_set_option($socket, SOL_SOCKET, SO_RCVTIMEO, $timeout);
        }

        if (isset($parameters->tcp_nodelay) && function_exists('socket_import_stream')) {
            $socket = $socket ?: socket_import_stream($resource);
            socket_set_option($socket, SOL_TCP, TCP_NODELAY, (int) $parameters->tcp_nodelay);
        }

        return $resource;
    }

    /**
     * Creates a new instance of the protocol reader resource.
     *
     * @return resource
     */
    private function createReader()
    {
        $reader = phpiredis_reader_create();

        phpiredis_reader_set_status_handler($reader, $this->getStatusHandler());
        phpiredis_reader_set_error_handler($reader, $this->getErrorHandler());

        return $reader;
    }

    /**
     * Returns the underlying protocol reader resource.
     *
     * @return resource
     */
    protected function getReader()
    {
        return $this->reader;
    }

    /**
     * Returns the handler used by the protocol reader for inline responses.
     *
     * @return Closure
     */
    protected function getStatusHandler()
    {
        static $statusHandler;

        if (!$statusHandler) {
            $statusHandler = function ($payload) {
                return StatusResponse::get($payload);
            };
        }

        return $statusHandler;
    }

    /**
     * Returns the handler used by the protocol reader for error responses.
     *
     * @return Closure
     */
    protected function getErrorHandler()
    {
        static $errorHandler;

        if (!$errorHandler) {
            $errorHandler = function ($errorMessage) {
                return new ErrorResponse($errorMessage);
            };
        }

        return $errorHandler;
    }

    /**
     * {@inheritdoc}
     */
    public function read()
    {
        $socket = $this->getResource();
        $reader = $this->reader;

        while (PHPIREDIS_READER_STATE_INCOMPLETE === $state = phpiredis_reader_get_state($reader)) {
            $buffer = stream_socket_recvfrom($socket, 4096);

            if ($buffer === false || $buffer === '') {
                $this->onConnectionError('Error while reading bytes from the server.');
            }

            phpiredis_reader_feed($reader, $buffer);
        }

        if ($state === PHPIREDIS_READER_STATE_COMPLETE) {
            return phpiredis_reader_get_reply($reader);
        } else {
            $this->onProtocolError(phpiredis_reader_get_error($reader));

            return;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function writeRequest(CommandInterface $command)
    {
        $arguments = $command->getArguments();
        array_unshift($arguments, $command->getId());

        $this->write(phpiredis_format_command($arguments));
    }

    /**
     * {@inheritdoc}
     */
    public function __wakeup()
    {
        $this->assertExtensions();
        $this->reader = $this->createReader();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\RelayConnection.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use InvalidArgumentException;
use Predis\ClientException;
use Predis\Command\CommandInterface;
use Predis\NotSupportedException;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use Predis\Response\ServerException;
use Relay\Exception as RelayException;
use Relay\Relay;

/**
 * This class provides the implementation of a Predis connection that
 * uses Relay for network communication and in-memory caching.
 *
 * Using Relay allows for:
 * 1) significantly faster reads thanks to in-memory caching
 * 2) fast data serialization using igbinary
 * 3) fast data compression using lzf, lz4 or zstd
 *
 * Usage of igbinary serialization and zstd compresses reduces
 * network traffic and Redis memory usage by ~75%.
 *
 * For instructions on how to install the Relay extension, please consult
 * the repository of the project: https://relay.so/docs/installation
 *
 * The connection parameters supported by this class are:
 *
 *  - scheme: it can be either 'tcp', 'tls' or 'unix'.
 *  - host: hostname or IP address of the server.
 *  - port: TCP port of the server.
 *  - path: path of a UNIX domain socket when scheme is 'unix'.
 *  - timeout: timeout to perform the connection.
 *  - read_write_timeout: timeout of read / write operations.
 *  - cache: whether to use in-memory caching
 *  - serializer: data serializer
 *  - compression: data compression algorithm
 *
 * @see https://github.com/cachewerk/relay
 */
class RelayConnection extends StreamConnection
{
    use RelayMethods;

    /**
     * The Relay instance.
     *
     * @var Relay
     */
    protected $client;

    /**
     * These commands must be called on the client, not using `Relay::rawCommand()`.
     *
     * @var string[]
     */
    public $atypicalCommands = [
        'AUTH',
        'SELECT',

        'TYPE',

        'MULTI',
        'EXEC',
        'DISCARD',

        'WATCH',
        'UNWATCH',

        'SUBSCRIBE',
        'UNSUBSCRIBE',
        'PSUBSCRIBE',
        'PUNSUBSCRIBE',
        'SSUBSCRIBE',
        'SUNSUBSCRIBE',
    ];

    /**
     * {@inheritdoc}
     */
    public function __construct(ParametersInterface $parameters)
    {
        $this->assertExtensions();

        $this->parameters = $this->assertParameters($parameters);
        $this->client = $this->createClient();
    }

    /**
     * {@inheritdoc}
     */
    public function isConnected()
    {
        return $this->client->isConnected();
    }

    /**
     * {@inheritdoc}
     */
    public function disconnect()
    {
        if ($this->client->isConnected()) {
            $this->client->close();
        }
    }

    /**
     * Checks if the Relay extension is loaded in PHP.
     */
    private function assertExtensions()
    {
        if (!extension_loaded('relay')) {
            throw new NotSupportedException(
                'The "relay" extension is required by this connection backend.'
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    protected function assertParameters(ParametersInterface $parameters)
    {
        if (!in_array($parameters->scheme, ['tcp', 'tls', 'unix', 'redis', 'rediss'])) {
            throw new InvalidArgumentException("Invalid scheme: '{$parameters->scheme}'.");
        }

        if (!in_array($parameters->serializer, [null, 'php', 'igbinary', 'msgpack', 'json'])) {
            throw new InvalidArgumentException("Invalid serializer: '{$parameters->serializer}'.");
        }

        if (!in_array($parameters->compression, [null, 'lzf', 'lz4', 'zstd'])) {
            throw new InvalidArgumentException("Invalid compression algorithm: '{$parameters->compression}'.");
        }

        return $parameters;
    }

    /**
     * Creates a new instance of the client.
     *
     * @return Relay
     */
    private function createClient()
    {
        $client = new Relay();

        // throw when errors occur and return `null` for non-existent keys
        $client->setOption(Relay::OPT_PHPREDIS_COMPATIBILITY, false);

        // use reply literals
        $client->setOption(Relay::OPT_REPLY_LITERAL, true);

        // disable Relay's command/connection retry
        $client->setOption(Relay::OPT_MAX_RETRIES, 0);

        // whether to use in-memory caching
        $client->setOption(Relay::OPT_USE_CACHE, $this->parameters->cache ?? true);

        // set data serializer
        $client->setOption(Relay::OPT_SERIALIZER, constant(sprintf(
            '%s::SERIALIZER_%s',
            Relay::class,
            strtoupper($this->parameters->serializer ?? 'none')
        )));

        // set data compression algorithm
        $client->setOption(Relay::OPT_COMPRESSION, constant(sprintf(
            '%s::COMPRESSION_%s',
            Relay::class,
            strtoupper($this->parameters->compression ?? 'none')
        )));

        return $client;
    }

    /**
     * Returns the underlying client.
     *
     * @return Relay
     */
    public function getClient()
    {
        return $this->client;
    }

    /**
     * {@inheritdoc}
     */
    public function getIdentifier()
    {
        try {
            return $this->client->endpointId();
        } catch (RelayException $ex) {
            return parent::getIdentifier();
        }
    }

    /**
     * {@inheritdoc}
     */
    protected function createStreamSocket(ParametersInterface $parameters, $address, $flags)
    {
        $timeout = isset($parameters->timeout) ? (float) $parameters->timeout : 5.0;

        $retry_interval = 0;
        $read_timeout = 5.0;

        if (isset($parameters->read_write_timeout)) {
            $read_timeout = (float) $parameters->read_write_timeout;
            $read_timeout = $read_timeout > 0 ? $read_timeout : 0;
        }

        try {
            $this->client->connect(
                $parameters->path ?? $parameters->host,
                isset($parameters->path) ? 0 : $parameters->port,
                $timeout,
                null,
                $retry_interval,
                $read_timeout
            );
        } catch (RelayException $ex) {
            $this->onConnectionError($ex->getMessage(), $ex->getCode());
        }

        return $this->client;
    }

    /**
     * {@inheritdoc}
     */
    public function executeCommand(CommandInterface $command)
    {
        if (!$this->client->isConnected()) {
            $this->getResource();
        }

        try {
            $name = $command->getId();

            // When using compression or a serializer, we'll need a dedicated
            // handler for `Predis\Command\RawCommand` calls, currently both
            // parameters are unsupported until a future Relay release
            return in_array($name, $this->atypicalCommands)
                ? $this->client->{$name}(...$command->getArguments())
                : $this->client->rawCommand($name, ...$command->getArguments());
        } catch (RelayException $ex) {
            $exception = $this->onCommandError($ex, $command);

            if ($exception instanceof ErrorResponseInterface) {
                return $exception;
            }

            throw $exception;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function onCommandError(RelayException $exception, CommandInterface $command)
    {
        $code = $exception->getCode();
        $message = $exception->getMessage();

        if (strpos($message, 'RELAY_ERR_IO') !== false) {
            return new ConnectionException($this, $message, $code, $exception);
        }

        if (strpos($message, 'RELAY_ERR_REDIS') !== false) {
            return new ServerException($message, $code, $exception);
        }

        if (strpos($message, 'RELAY_ERR_WRONGTYPE') !== false && strpos($message, "Got reply-type 'status'") !== false) {
            $message = 'Operation against a key holding the wrong kind of value';
        }

        return new ClientException($message, $code, $exception);
    }

    /**
     * Applies the configured serializer and compression to given value.
     *
     * @param  mixed  $value
     * @return string
     */
    public function pack($value)
    {
        return $this->client->_pack($value);
    }

    /**
     * Deserializes and decompresses to given value.
     *
     * @param  mixed  $value
     * @return string
     */
    public function unpack($value)
    {
        return $this->client->_unpack($value);
    }

    /**
     * {@inheritdoc}
     */
    public function writeRequest(CommandInterface $command)
    {
        throw new NotSupportedException('The "relay" extension does not support writing requests.');
    }

    /**
     * {@inheritdoc}
     */
    public function readResponse(CommandInterface $command)
    {
        throw new NotSupportedException('The "relay" extension does not support reading responses.');
    }

    /**
     * {@inheritdoc}
     */
    public function __destruct()
    {
        $this->disconnect();
    }

    /**
     * {@inheritdoc}
     */
    public function __wakeup()
    {
        $this->assertExtensions();
        $this->client = $this->createClient();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\RelayMethods.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

trait RelayMethods
{
    /**
     * Registers a new `flushed` event listener.
     *
     * @param  callable $callback
     * @return bool
     */
    public function onFlushed(?callable $callback)
    {
        return $this->client->onFlushed($callback);
    }

    /**
     * Registers a new `invalidated` event listener.
     *
     * @param  callable    $callback
     * @param  string|null $pattern
     * @return bool
     */
    public function onInvalidated(?callable $callback, ?string $pattern = null)
    {
        return $this->client->onInvalidated($callback, $pattern);
    }

    /**
     * Dispatches all pending events.
     *
     * @return int|false
     */
    public function dispatchEvents()
    {
        return $this->client->dispatchEvents();
    }

    /**
     * Adds ignore pattern(s). Matching keys will not be cached in memory.
     *
     * @param  string $pattern,...
     * @return int
     */
    public function addIgnorePatterns(string ...$pattern)
    {
        return $this->client->addIgnorePatterns(...$pattern);
    }

    /**
     * Adds allow pattern(s). Only matching keys will be cached in memory.
     *
     * @param  string $pattern,...
     * @return int
     */
    public function addAllowPatterns(string ...$pattern)
    {
        return $this->client->addAllowPatterns(...$pattern);
    }

    /**
     * Returns the connection's endpoint identifier.
     *
     * @return string|false
     */
    public function endpointId()
    {
        return $this->client->endpointId();
    }

    /**
     * Returns a unique representation of the underlying socket connection identifier.
     *
     * @return string|false
     */
    public function socketId()
    {
        return $this->client->socketId();
    }

    /**
     * Returns information about the license.
     *
     * @return array<string, mixed>
     */
    public function license()
    {
        return $this->client->license();
    }

    /**
     * Returns statistics about Relay.
     *
     * @return array<string, array<string, mixed>>
     */
    public function stats()
    {
        return $this->client->stats();
    }

    /**
     * Returns the number of bytes allocated, or `0` in client-only mode.
     *
     * @return int
     */
    public function maxMemory()
    {
        return $this->client->maxMemory();
    }

    /**
     * Flushes Relay's in-memory cache of all databases.
     * When given an endpoint, only that connection will be flushed.
     * When given an endpoint and database index, only that database
     * for that connection will be flushed.
     *
     * @param  ?string $endpointId
     * @param  ?int    $db
     * @return bool
     */
    public function flushMemory(?string $endpointId = null, ?int $db = null)
    {
        return $this->client->flushMemory($endpointId, $db);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\StreamConnection.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use InvalidArgumentException;
use Predis\Command\CommandInterface;
use Predis\Response\Error as ErrorResponse;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use Predis\Response\Status as StatusResponse;

/**
 * Standard connection to Redis servers implemented on top of PHP's streams.
 * The connection parameters supported by this class are:.
 *
 *  - scheme: it can be either 'redis', 'tcp', 'rediss', 'tls' or 'unix'.
 *  - host: hostname or IP address of the server.
 *  - port: TCP port of the server.
 *  - path: path of a UNIX domain socket when scheme is 'unix'.
 *  - timeout: timeout to perform the connection (default is 5 seconds).
 *  - read_write_timeout: timeout of read / write operations.
 *  - async_connect: performs the connection asynchronously.
 *  - tcp_nodelay: enables or disables Nagle's algorithm for coalescing.
 *  - persistent: the connection is left intact after a GC collection.
 *  - ssl: context options array (see http://php.net/manual/en/context.ssl.php)
 */
class StreamConnection extends AbstractConnection
{
    /**
     * Disconnects from the server and destroys the underlying resource when the
     * garbage collector kicks in only if the connection has not been marked as
     * persistent.
     */
    public function __destruct()
    {
        if (isset($this->parameters->persistent) && $this->parameters->persistent) {
            return;
        }

        $this->disconnect();
    }

    /**
     * {@inheritdoc}
     */
    protected function assertParameters(ParametersInterface $parameters)
    {
        switch ($parameters->scheme) {
            case 'tcp':
            case 'redis':
            case 'unix':
            case 'tls':
            case 'rediss':
                break;

            default:
                throw new InvalidArgumentException("Invalid scheme: '$parameters->scheme'.");
        }

        return $parameters;
    }

    /**
     * {@inheritdoc}
     */
    protected function createResource()
    {
        switch ($this->parameters->scheme) {
            case 'tcp':
            case 'redis':
                return $this->tcpStreamInitializer($this->parameters);

            case 'unix':
                return $this->unixStreamInitializer($this->parameters);

            case 'tls':
            case 'rediss':
                return $this->tlsStreamInitializer($this->parameters);

            default:
                throw new InvalidArgumentException("Invalid scheme: '{$this->parameters->scheme}'.");
        }
    }

    /**
     * Creates a connected stream socket resource.
     *
     * @param ParametersInterface $parameters Connection parameters.
     * @param string              $address    Address for stream_socket_client().
     * @param int                 $flags      Flags for stream_socket_client().
     *
     * @return resource
     */
    protected function createStreamSocket(ParametersInterface $parameters, $address, $flags)
    {
        $timeout = (isset($parameters->timeout) ? (float) $parameters->timeout : 5.0);
        $context = stream_context_create(['socket' => ['tcp_nodelay' => (bool) $parameters->tcp_nodelay]]);

        if (!$resource = @stream_socket_client($address, $errno, $errstr, $timeout, $flags, $context)) {
            $this->onConnectionError(trim($errstr), $errno);
        }

        if (isset($parameters->read_write_timeout)) {
            $rwtimeout = (float) $parameters->read_write_timeout;
            $rwtimeout = $rwtimeout > 0 ? $rwtimeout : -1;
            $timeoutSeconds = floor($rwtimeout);
            $timeoutUSeconds = ($rwtimeout - $timeoutSeconds) * 1000000;
            stream_set_timeout($resource, $timeoutSeconds, $timeoutUSeconds);
        }

        return $resource;
    }

    /**
     * Initializes a TCP stream resource.
     *
     * @param ParametersInterface $parameters Initialization parameters for the connection.
     *
     * @return resource
     */
    protected function tcpStreamInitializer(ParametersInterface $parameters)
    {
        if (!filter_var($parameters->host, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            $address = "tcp://$parameters->host:$parameters->port";
        } else {
            $address = "tcp://[$parameters->host]:$parameters->port";
        }

        $flags = STREAM_CLIENT_CONNECT;

        if (isset($parameters->async_connect) && $parameters->async_connect) {
            $flags |= STREAM_CLIENT_ASYNC_CONNECT;
        }

        if (isset($parameters->persistent)) {
            if (false !== $persistent = filter_var($parameters->persistent, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)) {
                $flags |= STREAM_CLIENT_PERSISTENT;

                if ($persistent === null) {
                    $address = "{$address}/{$parameters->persistent}";
                }
            }
        }

        return $this->createStreamSocket($parameters, $address, $flags);
    }

    /**
     * Initializes a UNIX stream resource.
     *
     * @param ParametersInterface $parameters Initialization parameters for the connection.
     *
     * @return resource
     */
    protected function unixStreamInitializer(ParametersInterface $parameters)
    {
        if (!isset($parameters->path)) {
            throw new InvalidArgumentException('Missing UNIX domain socket path.');
        }

        $flags = STREAM_CLIENT_CONNECT;

        if (isset($parameters->persistent)) {
            if (false !== $persistent = filter_var($parameters->persistent, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)) {
                $flags |= STREAM_CLIENT_PERSISTENT;

                if ($persistent === null) {
                    throw new InvalidArgumentException(
                        'Persistent connection IDs are not supported when using UNIX domain sockets.'
                    );
                }
            }
        }

        return $this->createStreamSocket($parameters, "unix://{$parameters->path}", $flags);
    }

    /**
     * Initializes a SSL-encrypted TCP stream resource.
     *
     * @param ParametersInterface $parameters Initialization parameters for the connection.
     *
     * @return resource
     */
    protected function tlsStreamInitializer(ParametersInterface $parameters)
    {
        $resource = $this->tcpStreamInitializer($parameters);
        $metadata = stream_get_meta_data($resource);

        // Detect if crypto mode is already enabled for this stream (PHP >= 7.0.0).
        if (isset($metadata['crypto'])) {
            return $resource;
        }

        if (isset($parameters->ssl) && is_array($parameters->ssl)) {
            $options = $parameters->ssl;
        } else {
            $options = [];
        }

        if (!isset($options['crypto_type'])) {
            $options['crypto_type'] = STREAM_CRYPTO_METHOD_TLS_CLIENT;
        }

        if (!stream_context_set_option($resource, ['ssl' => $options])) {
            $this->onConnectionError('Error while setting SSL context options');
        }

        if (!stream_socket_enable_crypto($resource, true, $options['crypto_type'])) {
            $this->onConnectionError('Error while switching to encrypted communication');
        }

        return $resource;
    }

    /**
     * {@inheritdoc}
     */
    public function connect()
    {
        if (parent::connect() && $this->initCommands) {
            foreach ($this->initCommands as $command) {
                $response = $this->executeCommand($command);

                if ($response instanceof ErrorResponseInterface && $command->getId() === 'CLIENT') {
                    // Do nothing on CLIENT SETINFO command failure
                } elseif ($response instanceof ErrorResponseInterface) {
                    $this->onConnectionError("`{$command->getId()}` failed: {$response->getMessage()}", 0);
                }
            }
        }
    }

    /**
     * {@inheritdoc}
     */
    public function disconnect()
    {
        if ($this->isConnected()) {
            $resource = $this->getResource();
            if (is_resource($resource)) {
                fclose($resource);
            }
            parent::disconnect();
        }
    }

    /**
     * Performs a write operation over the stream of the buffer containing a
     * command serialized with the Redis wire protocol.
     *
     * @param string $buffer Representation of a command in the Redis wire protocol.
     */
    protected function write($buffer)
    {
        $socket = $this->getResource();

        while (($length = strlen($buffer)) > 0) {
            $written = is_resource($socket) ? @fwrite($socket, $buffer) : false;

            if ($length === $written) {
                return;
            }

            if ($written === false || $written === 0) {
                $this->onConnectionError('Error while writing bytes to the server.');
            }

            $buffer = substr($buffer, $written);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function read()
    {
        $socket = $this->getResource();
        $chunk = fgets($socket);

        if ($chunk === false || $chunk === '') {
            $this->onConnectionError('Error while reading line from the server.');
        }

        $prefix = $chunk[0];
        $payload = substr($chunk, 1, -2);

        switch ($prefix) {
            case '+':
                return StatusResponse::get($payload);

            case '$':
                $size = (int) $payload;

                if ($size === -1) {
                    return;
                }

                $bulkData = '';
                $bytesLeft = ($size += 2);

                do {
                    $chunk = is_resource($socket) ? fread($socket, min($bytesLeft, 4096)) : false;

                    if ($chunk === false || $chunk === '') {
                        $this->onConnectionError('Error while reading bytes from the server.');
                    }

                    $bulkData .= $chunk;
                    $bytesLeft = $size - strlen($bulkData);
                } while ($bytesLeft > 0);

                return substr($bulkData, 0, -2);

            case '*':
                $count = (int) $payload;

                if ($count === -1) {
                    return;
                }

                $multibulk = [];

                for ($i = 0; $i < $count; ++$i) {
                    $multibulk[$i] = $this->read();
                }

                return $multibulk;

            case ':':
                $integer = (int) $payload;

                return $integer == $payload ? $integer : $payload;

            case '-':
                return new ErrorResponse($payload);

            default:
                $this->onProtocolError("Unknown response prefix: '$prefix'.");

                return;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function writeRequest(CommandInterface $command)
    {
        $commandID = $command->getId();
        $arguments = $command->getArguments();

        $cmdlen = strlen($commandID);
        $reqlen = count($arguments) + 1;

        $buffer = "*{$reqlen}\r\n\${$cmdlen}\r\n{$commandID}\r\n";

        foreach ($arguments as $argument) {
            $arglen = strlen(strval($argument));
            $buffer .= "\${$arglen}\r\n{$argument}\r\n";
        }

        $this->write($buffer);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\WebdisConnection.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use Closure;
use InvalidArgumentException;
use Predis\Command\CommandInterface;
use Predis\NotSupportedException;
use Predis\Protocol\ProtocolException;
use Predis\Response\Error as ErrorResponse;
use Predis\Response\Status as StatusResponse;

/**
 * This class implements a Predis connection that actually talks with Webdis
 * instead of connecting directly to Redis. It relies on the cURL extension to
 * communicate with the web server and the phpiredis extension to parse the
 * protocol for responses returned in the http response bodies.
 *
 * Some features are not yet available or they simply cannot be implemented:
 *   - Pipelining commands.
 *   - Publish / Subscribe.
 *   - MULTI / EXEC transactions (not yet supported by Webdis).
 *
 * The connection parameters supported by this class are:
 *
 *  - scheme: must be 'http'.
 *  - host: hostname or IP address of the server.
 *  - port: TCP port of the server.
 *  - timeout: timeout to perform the connection (default is 5 seconds).
 *  - user: username for authentication.
 *  - pass: password for authentication.
 *
 * @see http://webd.is
 * @see http://github.com/nicolasff/webdis
 * @see http://github.com/seppo0010/phpiredis
 * @deprecated 2.1.2
 */
class WebdisConnection implements NodeConnectionInterface
{
    private $parameters;
    private $resource;
    private $reader;

    /**
     * @param ParametersInterface $parameters Initialization parameters for the connection.
     *
     * @throws InvalidArgumentException
     */
    public function __construct(ParametersInterface $parameters)
    {
        $this->assertExtensions();

        if ($parameters->scheme !== 'http') {
            throw new InvalidArgumentException("Invalid scheme: '{$parameters->scheme}'.");
        }

        $this->parameters = $parameters;

        $this->resource = $this->createCurl();
        $this->reader = $this->createReader();
    }

    /**
     * Frees the underlying cURL and protocol reader resources when the garbage
     * collector kicks in.
     */
    public function __destruct()
    {
        curl_close($this->resource);
        phpiredis_reader_destroy($this->reader);
    }

    /**
     * Helper method used to throw on unsupported methods.
     *
     * @param string $method Name of the unsupported method.
     *
     * @throws NotSupportedException
     */
    private function throwNotSupportedException($method)
    {
        $class = __CLASS__;
        throw new NotSupportedException("The method $class::$method() is not supported.");
    }

    /**
     * Checks if the cURL and phpiredis extensions are loaded in PHP.
     */
    private function assertExtensions()
    {
        if (!extension_loaded('curl')) {
            throw new NotSupportedException(
                'The "curl" extension is required by this connection backend.'
            );
        }

        if (!extension_loaded('phpiredis')) {
            throw new NotSupportedException(
                'The "phpiredis" extension is required by this connection backend.'
            );
        }
    }

    /**
     * Initializes cURL.
     *
     * @return resource
     */
    private function createCurl()
    {
        $parameters = $this->getParameters();
        $timeout = (isset($parameters->timeout) ? (float) $parameters->timeout : 5.0) * 1000;

        if (filter_var($host = $parameters->host, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            $host = "[$host]";
        }

        $options = [
            CURLOPT_FAILONERROR => true,
            CURLOPT_CONNECTTIMEOUT_MS => $timeout,
            CURLOPT_URL => "$parameters->scheme://$host:$parameters->port",
            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
            CURLOPT_POST => true,
            CURLOPT_WRITEFUNCTION => [$this, 'feedReader'],
        ];

        if (isset($parameters->user, $parameters->pass)) {
            $options[CURLOPT_USERPWD] = "{$parameters->user}:{$parameters->pass}";
        }

        curl_setopt_array($resource = curl_init(), $options);

        return $resource;
    }

    /**
     * Initializes the phpiredis protocol reader.
     *
     * @return resource
     */
    private function createReader()
    {
        $reader = phpiredis_reader_create();

        phpiredis_reader_set_status_handler($reader, $this->getStatusHandler());
        phpiredis_reader_set_error_handler($reader, $this->getErrorHandler());

        return $reader;
    }

    /**
     * Returns the handler used by the protocol reader for inline responses.
     *
     * @return Closure
     */
    protected function getStatusHandler()
    {
        static $statusHandler;

        if (!$statusHandler) {
            $statusHandler = function ($payload) {
                return StatusResponse::get($payload);
            };
        }

        return $statusHandler;
    }

    /**
     * Returns the handler used by the protocol reader for error responses.
     *
     * @return Closure
     */
    protected function getErrorHandler()
    {
        static $errorHandler;

        if (!$errorHandler) {
            $errorHandler = function ($errorMessage) {
                return new ErrorResponse($errorMessage);
            };
        }

        return $errorHandler;
    }

    /**
     * Feeds the phpredis reader resource with the data read from the network.
     *
     * @param resource $resource Reader resource.
     * @param string   $buffer   Buffer of data read from a connection.
     *
     * @return int
     */
    protected function feedReader($resource, $buffer)
    {
        phpiredis_reader_feed($this->reader, $buffer);

        return strlen($buffer);
    }

    /**
     * {@inheritdoc}
     */
    public function connect()
    {
        // NOOP
    }

    /**
     * {@inheritdoc}
     */
    public function disconnect()
    {
        // NOOP
    }

    /**
     * {@inheritdoc}
     */
    public function isConnected()
    {
        return true;
    }

    /**
     * Checks if the specified command is supported by this connection class.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return string
     * @throws NotSupportedException
     */
    protected function getCommandId(CommandInterface $command)
    {
        switch ($commandID = $command->getId()) {
            case 'AUTH':
            case 'SELECT':
            case 'MULTI':
            case 'EXEC':
            case 'WATCH':
            case 'UNWATCH':
            case 'DISCARD':
            case 'MONITOR':
                throw new NotSupportedException("Command '$commandID' is not allowed by Webdis.");
            default:
                return $commandID;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function writeRequest(CommandInterface $command)
    {
        $this->throwNotSupportedException(__FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function readResponse(CommandInterface $command)
    {
        $this->throwNotSupportedException(__FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function executeCommand(CommandInterface $command)
    {
        $resource = $this->resource;
        $commandId = $this->getCommandId($command);

        if ($arguments = $command->getArguments()) {
            $arguments = implode('/', array_map('urlencode', $arguments));
            $serializedCommand = "$commandId/$arguments.raw";
        } else {
            $serializedCommand = "$commandId.raw";
        }

        curl_setopt($resource, CURLOPT_POSTFIELDS, $serializedCommand);

        if (curl_exec($resource) === false) {
            $error = trim(curl_error($resource));
            $errno = curl_errno($resource);

            throw new ConnectionException($this, "$error{$this->getParameters()}]", $errno);
        }

        if (phpiredis_reader_get_state($this->reader) !== PHPIREDIS_READER_STATE_COMPLETE) {
            throw new ProtocolException($this, phpiredis_reader_get_error($this->reader));
        }

        return phpiredis_reader_get_reply($this->reader);
    }

    /**
     * {@inheritdoc}
     */
    public function getResource()
    {
        return $this->resource;
    }

    /**
     * {@inheritdoc}
     */
    public function getParameters()
    {
        return $this->parameters;
    }

    /**
     * {@inheritdoc}
     */
    public function addConnectCommand(CommandInterface $command)
    {
        $this->throwNotSupportedException(__FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function read()
    {
        $this->throwNotSupportedException(__FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function __toString()
    {
        return "{$this->parameters->host}:{$this->parameters->port}";
    }

    /**
     * {@inheritdoc}
     */
    public function __sleep()
    {
        return ['parameters'];
    }

    /**
     * {@inheritdoc}
     */
    public function __wakeup()
    {
        $this->assertExtensions();

        $this->resource = $this->createCurl();
        $this->reader = $this->createReader();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\Cluster\ClusterInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection\Cluster;

use Predis\Connection\AggregateConnectionInterface;

/**
 * Defines a cluster of Redis servers formed by aggregating multiple connection
 * instances to single Redis nodes.
 */
interface ClusterInterface extends AggregateConnectionInterface
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\Cluster\PredisCluster.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection\Cluster;

use ArrayIterator;
use Countable;
use IteratorAggregate;
use Predis\Cluster\PredisStrategy;
use Predis\Cluster\StrategyInterface;
use Predis\Command\CommandInterface;
use Predis\Connection\NodeConnectionInterface;
use Predis\NotSupportedException;
use ReturnTypeWillChange;
use Traversable;

/**
 * Abstraction for a cluster of aggregate connections to various Redis servers
 * implementing client-side sharding based on pluggable distribution strategies.
 */
class PredisCluster implements ClusterInterface, IteratorAggregate, Countable
{
    /**
     * @var NodeConnectionInterface[]
     */
    private $pool = [];

    /**
     * @var NodeConnectionInterface[]
     */
    private $aliases = [];

    /**
     * @var StrategyInterface
     */
    private $strategy;

    /**
     * @var \Predis\Cluster\Distributor\DistributorInterface
     */
    private $distributor;

    /**
     * @param StrategyInterface|null $strategy Optional cluster strategy.
     */
    public function __construct(?StrategyInterface $strategy = null)
    {
        $this->strategy = $strategy ?: new PredisStrategy();
        $this->distributor = $this->strategy->getDistributor();
    }

    /**
     * {@inheritdoc}
     */
    public function isConnected()
    {
        foreach ($this->pool as $connection) {
            if ($connection->isConnected()) {
                return true;
            }
        }

        return false;
    }

    /**
     * {@inheritdoc}
     */
    public function connect()
    {
        foreach ($this->pool as $connection) {
            $connection->connect();
        }
    }

    /**
     * {@inheritdoc}
     */
    public function disconnect()
    {
        foreach ($this->pool as $connection) {
            $connection->disconnect();
        }
    }

    /**
     * {@inheritdoc}
     */
    public function add(NodeConnectionInterface $connection)
    {
        $parameters = $connection->getParameters();

        $this->pool[(string) $connection] = $connection;

        if (isset($parameters->alias)) {
            $this->aliases[$parameters->alias] = $connection;
        }

        $this->distributor->add($connection, $parameters->weight);
    }

    /**
     * {@inheritdoc}
     */
    public function remove(NodeConnectionInterface $connection)
    {
        if (false !== $id = array_search($connection, $this->pool, true)) {
            unset($this->pool[$id]);
            $this->distributor->remove($connection);

            if ($this->aliases && $alias = $connection->getParameters()->alias) {
                unset($this->aliases[$alias]);
            }

            return true;
        }

        return false;
    }

    /**
     * {@inheritdoc}
     */
    public function getConnectionByCommand(CommandInterface $command)
    {
        $slot = $this->strategy->getSlot($command);

        if (!isset($slot)) {
            throw new NotSupportedException(
                "Cannot use '{$command->getId()}' over clusters of connections."
            );
        }

        return $this->distributor->getBySlot($slot);
    }

    /**
     * {@inheritdoc}
     */
    public function getConnectionById($id)
    {
        return $this->pool[$id] ?? null;
    }

    /**
     * Returns a connection instance by its alias.
     *
     * @param string $alias Connection alias.
     *
     * @return NodeConnectionInterface|null
     */
    public function getConnectionByAlias($alias)
    {
        return $this->aliases[$alias] ?? null;
    }

    /**
     * Retrieves a connection instance by slot.
     *
     * @param string $slot Slot name.
     *
     * @return NodeConnectionInterface|null
     */
    public function getConnectionBySlot($slot)
    {
        return $this->distributor->getBySlot($slot);
    }

    /**
     * Retrieves a connection instance from the cluster using a key.
     *
     * @param string $key Key string.
     *
     * @return NodeConnectionInterface
     */
    public function getConnectionByKey($key)
    {
        $hash = $this->strategy->getSlotByKey($key);

        return $this->distributor->getBySlot($hash);
    }

    /**
     * Returns the underlying command hash strategy used to hash commands by
     * using keys found in their arguments.
     *
     * @return StrategyInterface
     */
    public function getClusterStrategy()
    {
        return $this->strategy;
    }

    /**
     * @return int
     */
    #[ReturnTypeWillChange]
    public function count()
    {
        return count($this->pool);
    }

    /**
     * @return Traversable<string, NodeConnectionInterface>
     */
    #[ReturnTypeWillChange]
    public function getIterator()
    {
        return new ArrayIterator($this->pool);
    }

    /**
     * {@inheritdoc}
     */
    public function writeRequest(CommandInterface $command)
    {
        $this->getConnectionByCommand($command)->writeRequest($command);
    }

    /**
     * {@inheritdoc}
     */
    public function readResponse(CommandInterface $command)
    {
        return $this->getConnectionByCommand($command)->readResponse($command);
    }

    /**
     * {@inheritdoc}
     */
    public function executeCommand(CommandInterface $command)
    {
        return $this->getConnectionByCommand($command)->executeCommand($command);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\Cluster\RedisCluster.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection\Cluster;

use ArrayIterator;
use Countable;
use IteratorAggregate;
use OutOfBoundsException;
use Predis\ClientException;
use Predis\Cluster\RedisStrategy as RedisClusterStrategy;
use Predis\Cluster\SlotMap;
use Predis\Cluster\StrategyInterface;
use Predis\Command\CommandInterface;
use Predis\Command\RawCommand;
use Predis\Connection\ConnectionException;
use Predis\Connection\FactoryInterface;
use Predis\Connection\NodeConnectionInterface;
use Predis\NotSupportedException;
use Predis\Response\Error as ErrorResponse;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use Predis\Response\ServerException;
use ReturnTypeWillChange;
use Throwable;
use Traversable;

/**
 * Abstraction for a Redis-backed cluster of nodes (Redis >= 3.0.0).
 *
 * This connection backend offers smart support for redis-cluster by handling
 * automatic slots map (re)generation upon -MOVED or -ASK responses returned by
 * Redis when redirecting a client to a different node.
 *
 * The cluster can be pre-initialized using only a subset of the actual nodes in
 * the cluster, Predis will do the rest by adjusting the slots map and creating
 * the missing underlying connection instances on the fly.
 *
 * It is possible to pre-associate connections to a slots range with the "slots"
 * parameter in the form "$first-$last". This can greatly reduce runtime node
 * guessing and redirections.
 *
 * It is also possible to ask for the full and updated slots map directly to one
 * of the nodes and optionally enable such a behaviour upon -MOVED redirections.
 * Asking for the cluster configuration to Redis is actually done by issuing a
 * CLUSTER SLOTS command to a random node in the pool.
 */
class RedisCluster implements ClusterInterface, IteratorAggregate, Countable
{
    private $useClusterSlots = true;
    private $pool = [];
    private $slots = [];
    private $slotmap;
    private $strategy;
    private $connections;
    private $retryLimit = 5;
    private $retryInterval = 10;

    /**
     * @param FactoryInterface       $connections Optional connection factory.
     * @param StrategyInterface|null $strategy    Optional cluster strategy.
     */
    public function __construct(
        FactoryInterface $connections,
        ?StrategyInterface $strategy = null
    ) {
        $this->connections = $connections;
        $this->strategy = $strategy ?: new RedisClusterStrategy();
        $this->slotmap = new SlotMap();
    }

    /**
     * Sets the maximum number of retries for commands upon server failure.
     *
     * -1 = unlimited retry attempts
     *  0 = no retry attempts (fails immediately)
     *  n = fail only after n retry attempts
     *
     * @param int $retry Number of retry attempts.
     */
    public function setRetryLimit($retry)
    {
        $this->retryLimit = (int) $retry;
    }

    /**
     * Sets the initial retry interval (milliseconds).
     *
     * @param int $retryInterval Milliseconds between retries.
     */
    public function setRetryInterval($retryInterval)
    {
        $this->retryInterval = (int) $retryInterval;
    }

    /**
     * Returns the retry interval (milliseconds).
     *
     * @return int Milliseconds between retries.
     */
    public function getRetryInterval()
    {
        return (int) $this->retryInterval;
    }

    /**
     * {@inheritdoc}
     */
    public function isConnected()
    {
        foreach ($this->pool as $connection) {
            if ($connection->isConnected()) {
                return true;
            }
        }

        return false;
    }

    /**
     * {@inheritdoc}
     */
    public function connect()
    {
        if ($connection = $this->getRandomConnection()) {
            $connection->connect();
        }
    }

    /**
     * {@inheritdoc}
     */
    public function disconnect()
    {
        foreach ($this->pool as $connection) {
            $connection->disconnect();
        }
    }

    /**
     * {@inheritdoc}
     */
    public function add(NodeConnectionInterface $connection)
    {
        $this->pool[(string) $connection] = $connection;
        $this->slotmap->reset();
    }

    /**
     * {@inheritdoc}
     */
    public function remove(NodeConnectionInterface $connection)
    {
        if (false !== $id = array_search($connection, $this->pool, true)) {
            $this->slotmap->reset();
            $this->slots = array_diff($this->slots, [$connection]);
            unset($this->pool[$id]);

            return true;
        }

        return false;
    }

    /**
     * Removes a connection instance by using its identifier.
     *
     * @param string $connectionID Connection identifier.
     *
     * @return bool True if the connection was in the pool.
     */
    public function removeById($connectionID)
    {
        if (isset($this->pool[$connectionID])) {
            $this->slotmap->reset();
            $this->slots = array_diff($this->slots, [$connectionID]);
            unset($this->pool[$connectionID]);

            return true;
        }

        return false;
    }

    /**
     * Generates the current slots map by guessing the cluster configuration out
     * of the connection parameters of the connections in the pool.
     *
     * Generation is based on the same algorithm used by Redis to generate the
     * cluster, so it is most effective when all of the connections supplied on
     * initialization have the "slots" parameter properly set accordingly to the
     * current cluster configuration.
     */
    public function buildSlotMap()
    {
        $this->slotmap->reset();

        foreach ($this->pool as $connectionID => $connection) {
            $parameters = $connection->getParameters();

            if (!isset($parameters->slots)) {
                continue;
            }

            foreach (explode(',', $parameters->slots) as $slotRange) {
                $slots = explode('-', $slotRange, 2);

                if (!isset($slots[1])) {
                    $slots[1] = $slots[0];
                }

                $this->slotmap->setSlots($slots[0], $slots[1], $connectionID);
            }
        }
    }

    /**
     * Queries the specified node of the cluster to fetch the updated slots map.
     *
     * When the connection fails, this method tries to execute the same command
     * on a different connection picked at random from the pool of known nodes,
     * up until the retry limit is reached.
     *
     * @param NodeConnectionInterface $connection Connection to a node of the cluster.
     *
     * @return mixed
     */
    private function queryClusterNodeForSlotMap(NodeConnectionInterface $connection)
    {
        $retries = 0;
        $retryAfter = $this->retryInterval;
        $command = RawCommand::create('CLUSTER', 'SLOTS');

        while ($retries <= $this->retryLimit) {
            try {
                $response = $connection->executeCommand($command);
                break;
            } catch (ConnectionException $exception) {
                $connection = $exception->getConnection();
                $connection->disconnect();

                $this->remove($connection);

                if ($retries === $this->retryLimit) {
                    throw $exception;
                }

                if (!$connection = $this->getRandomConnection()) {
                    throw new ClientException('No connections left in the pool for `CLUSTER SLOTS`');
                }

                usleep($retryAfter * 1000);
                $retryAfter *= 2;
                ++$retries;
            }
        }

        return $response;
    }

    /**
     * Generates an updated slots map fetching the cluster configuration using
     * the CLUSTER SLOTS command against the specified node or a random one from
     * the pool.
     *
     * @param NodeConnectionInterface|null $connection Optional connection instance.
     */
    public function askSlotMap(?NodeConnectionInterface $connection = null)
    {
        if (!$connection && !$connection = $this->getRandomConnection()) {
            return;
        }

        $this->slotmap->reset();

        $response = $this->queryClusterNodeForSlotMap($connection);

        foreach ($response as $slots) {
            // We only support master servers for now, so we ignore subsequent
            // elements in the $slots array identifying slaves.
            [$start, $end, $master] = $slots;

            if ($master[0] === '') {
                $this->slotmap->setSlots($start, $end, (string) $connection);
            } else {
                $this->slotmap->setSlots($start, $end, "{$master[0]}:{$master[1]}");
            }
        }
    }

    /**
     * Guesses the correct node associated to a given slot using a precalculated
     * slots map, falling back to the same logic used by Redis to initialize a
     * cluster (best-effort).
     *
     * @param int $slot Slot index.
     *
     * @return string Connection ID.
     */
    protected function guessNode($slot)
    {
        if (!$this->pool) {
            throw new ClientException('No connections available in the pool');
        }

        if ($this->slotmap->isEmpty()) {
            $this->buildSlotMap();
        }

        if ($node = $this->slotmap[$slot]) {
            return $node;
        }

        $count = count($this->pool);
        $index = min((int) ($slot / (int) (16384 / $count)), $count - 1);
        $nodes = array_keys($this->pool);

        return $nodes[$index];
    }

    /**
     * Creates a new connection instance from the given connection ID.
     *
     * @param string $connectionID Identifier for the connection.
     *
     * @return NodeConnectionInterface
     */
    protected function createConnection($connectionID)
    {
        $separator = strrpos($connectionID, ':');

        return $this->connections->create([
            'host' => substr($connectionID, 0, $separator),
            'port' => substr($connectionID, $separator + 1),
        ]);
    }

    /**
     * {@inheritdoc}
     */
    public function getConnectionByCommand(CommandInterface $command)
    {
        $slot = $this->strategy->getSlot($command);

        if (!isset($slot)) {
            throw new NotSupportedException(
                "Cannot use '{$command->getId()}' with redis-cluster."
            );
        }

        if (isset($this->slots[$slot])) {
            return $this->slots[$slot];
        } else {
            return $this->getConnectionBySlot($slot);
        }
    }

    /**
     * Returns the connection currently associated to a given slot.
     *
     * @param int $slot Slot index.
     *
     * @return NodeConnectionInterface
     * @throws OutOfBoundsException
     */
    public function getConnectionBySlot($slot)
    {
        if (!SlotMap::isValid($slot)) {
            throw new OutOfBoundsException("Invalid slot [$slot].");
        }

        if (isset($this->slots[$slot])) {
            return $this->slots[$slot];
        }

        $connectionID = $this->guessNode($slot);

        if (!$connection = $this->getConnectionById($connectionID)) {
            $connection = $this->createConnection($connectionID);
            $this->pool[$connectionID] = $connection;
        }

        return $this->slots[$slot] = $connection;
    }

    /**
     * {@inheritdoc}
     */
    public function getConnectionById($connectionID)
    {
        return $this->pool[$connectionID] ?? null;
    }

    /**
     * Returns a random connection from the pool.
     *
     * @return NodeConnectionInterface|null
     */
    protected function getRandomConnection()
    {
        if (!$this->pool) {
            return null;
        }

        return $this->pool[array_rand($this->pool)];
    }

    /**
     * Permanently associates the connection instance to a new slot.
     * The connection is added to the connections pool if not yet included.
     *
     * @param NodeConnectionInterface $connection Connection instance.
     * @param int                     $slot       Target slot index.
     */
    protected function move(NodeConnectionInterface $connection, $slot)
    {
        $this->pool[(string) $connection] = $connection;
        $this->slots[(int) $slot] = $connection;
        $this->slotmap[(int) $slot] = $connection;
    }

    /**
     * Handles -ERR responses returned by Redis.
     *
     * @param CommandInterface       $command Command that generated the -ERR response.
     * @param ErrorResponseInterface $error   Redis error response object.
     *
     * @return mixed
     */
    protected function onErrorResponse(CommandInterface $command, ErrorResponseInterface $error)
    {
        $details = explode(' ', $error->getMessage(), 2);

        switch ($details[0]) {
            case 'MOVED':
                return $this->onMovedResponse($command, $details[1]);

            case 'ASK':
                return $this->onAskResponse($command, $details[1]);

            default:
                return $error;
        }
    }

    /**
     * Handles -MOVED responses by executing again the command against the node
     * indicated by the Redis response.
     *
     * @param CommandInterface $command Command that generated the -MOVED response.
     * @param string           $details Parameters of the -MOVED response.
     *
     * @return mixed
     */
    protected function onMovedResponse(CommandInterface $command, $details)
    {
        [$slot, $connectionID] = explode(' ', $details, 2);

        // Handle connection ID in the form of "IP:port (details about exception)"
        // by trimming everything after first space (including the space)
        $startPositionOfExtraDetails = strpos($connectionID, ' ');

        if ($startPositionOfExtraDetails !== false) {
            $connectionID = substr($connectionID, 0, $startPositionOfExtraDetails);
        }

        if (!$connection = $this->getConnectionById($connectionID)) {
            $connection = $this->createConnection($connectionID);
        }

        if ($this->useClusterSlots) {
            $this->askSlotMap($connection);
        }

        $this->move($connection, $slot);

        return $this->executeCommand($command);
    }

    /**
     * Handles -ASK responses by executing again the command against the node
     * indicated by the Redis response.
     *
     * @param CommandInterface $command Command that generated the -ASK response.
     * @param string           $details Parameters of the -ASK response.
     *
     * @return mixed
     */
    protected function onAskResponse(CommandInterface $command, $details)
    {
        [$slot, $connectionID] = explode(' ', $details, 2);

        if (!$connection = $this->getConnectionById($connectionID)) {
            $connection = $this->createConnection($connectionID);
        }

        $connection->executeCommand(RawCommand::create('ASKING'));

        return $connection->executeCommand($command);
    }

    /**
     * Ensures that a command is executed one more time on connection failure.
     *
     * The connection to the node that generated the error is evicted from the
     * pool before trying to fetch an updated slots map from another node. If
     * the new slots map points to an unreachable server the client gives up and
     * throws the exception as the nodes participating in the cluster may still
     * have to agree that something changed in the configuration of the cluster.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $method  Actual method.
     *
     * @return mixed
     */
    private function retryCommandOnFailure(CommandInterface $command, $method)
    {
        $retries = 0;
        $retryAfter = $this->retryInterval;

        while ($retries <= $this->retryLimit) {
            try {
                $response = $this->getConnectionByCommand($command)->$method($command);

                if ($response instanceof ErrorResponse) {
                    $message = $response->getMessage();

                    if (strpos($message, 'CLUSTERDOWN') !== false) {
                        throw new ServerException($message);
                    }
                }

                break;
            } catch (Throwable $exception) {
                usleep($retryAfter * 1000);
                $retryAfter *= 2;

                if ($exception instanceof ConnectionException) {
                    $connection = $exception->getConnection();

                    if ($connection) {
                        $connection->disconnect();
                        $this->remove($connection);
                    }
                }

                if ($retries === $this->retryLimit) {
                    throw $exception;
                }

                if ($this->useClusterSlots) {
                    $this->askSlotMap();
                }

                ++$retries;
            }
        }

        return $response;
    }

    /**
     * {@inheritdoc}
     */
    public function writeRequest(CommandInterface $command)
    {
        $this->retryCommandOnFailure($command, __FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function readResponse(CommandInterface $command)
    {
        return $this->retryCommandOnFailure($command, __FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function executeCommand(CommandInterface $command)
    {
        $response = $this->retryCommandOnFailure($command, __FUNCTION__);

        if ($response instanceof ErrorResponseInterface) {
            return $this->onErrorResponse($command, $response);
        }

        return $response;
    }

    /**
     * @return int
     */
    #[ReturnTypeWillChange]
    public function count()
    {
        return count($this->pool);
    }

    /**
     * @return Traversable<string, NodeConnectionInterface>
     */
    #[ReturnTypeWillChange]
    public function getIterator()
    {
        if ($this->slotmap->isEmpty()) {
            $this->useClusterSlots ? $this->askSlotMap() : $this->buildSlotMap();
        }

        $connections = [];

        foreach ($this->slotmap->getNodes() as $node) {
            if (!$connection = $this->getConnectionById($node)) {
                $this->add($connection = $this->createConnection($node));
            }

            $connections[] = $connection;
        }

        return new ArrayIterator($connections);
    }

    /**
     * Returns the underlying slot map.
     *
     * @return SlotMap
     */
    public function getSlotMap()
    {
        return $this->slotmap;
    }

    /**
     * Returns the underlying command hash strategy used to hash commands by
     * using keys found in their arguments.
     *
     * @return StrategyInterface
     */
    public function getClusterStrategy()
    {
        return $this->strategy;
    }

    /**
     * Returns the underlying connection factory used to create new connection
     * instances to Redis nodes indicated by redis-cluster.
     *
     * @return FactoryInterface
     */
    public function getConnectionFactory()
    {
        return $this->connections;
    }

    /**
     * Enables automatic fetching of the current slots map from one of the nodes
     * using the CLUSTER SLOTS command. This option is enabled by default as
     * asking the current slots map to Redis upon -MOVED responses may reduce
     * overhead by eliminating the trial-and-error nature of the node guessing
     * procedure, mostly when targeting many keys that would end up in a lot of
     * redirections.
     *
     * The slots map can still be manually fetched using the askSlotMap()
     * method whether or not this option is enabled.
     *
     * @param bool $value Enable or disable the use of CLUSTER SLOTS.
     */
    public function useClusterSlots($value)
    {
        $this->useClusterSlots = (bool) $value;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\Replication\MasterSlaveReplication.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection\Replication;

use InvalidArgumentException;
use Predis\ClientException;
use Predis\Command\CommandInterface;
use Predis\Command\RawCommand;
use Predis\Connection\ConnectionException;
use Predis\Connection\FactoryInterface;
use Predis\Connection\NodeConnectionInterface;
use Predis\Replication\MissingMasterException;
use Predis\Replication\ReplicationStrategy;
use Predis\Response\ErrorInterface as ResponseErrorInterface;

/**
 * Aggregate connection handling replication of Redis nodes configured in a
 * single master / multiple slaves setup.
 */
class MasterSlaveReplication implements ReplicationInterface
{
    /**
     * @var ReplicationStrategy
     */
    protected $strategy;

    /**
     * @var NodeConnectionInterface
     */
    protected $master;

    /**
     * @var NodeConnectionInterface[]
     */
    protected $slaves = [];

    /**
     * @var NodeConnectionInterface[]
     */
    protected $pool = [];

    /**
     * @var NodeConnectionInterface[]
     */
    protected $aliases = [];

    /**
     * @var NodeConnectionInterface
     */
    protected $current;

    /**
     * @var bool
     */
    protected $autoDiscovery = false;

    /**
     * @var FactoryInterface
     */
    protected $connectionFactory;

    /**
     * {@inheritdoc}
     */
    public function __construct(?ReplicationStrategy $strategy = null)
    {
        $this->strategy = $strategy ?: new ReplicationStrategy();
    }

    /**
     * Configures the automatic discovery of the replication configuration on failure.
     *
     * @param bool $value Enable or disable auto discovery.
     */
    public function setAutoDiscovery($value)
    {
        if (!$this->connectionFactory) {
            throw new ClientException('Automatic discovery requires a connection factory');
        }

        $this->autoDiscovery = (bool) $value;
    }

    /**
     * Sets the connection factory used to create the connections by the auto
     * discovery procedure.
     *
     * @param FactoryInterface $connectionFactory Connection factory instance.
     */
    public function setConnectionFactory(FactoryInterface $connectionFactory)
    {
        $this->connectionFactory = $connectionFactory;
    }

    /**
     * Resets the connection state.
     */
    protected function reset()
    {
        $this->current = null;
    }

    /**
     * {@inheritdoc}
     */
    public function add(NodeConnectionInterface $connection)
    {
        $parameters = $connection->getParameters();

        if ('master' === $parameters->role) {
            $this->master = $connection;
        } else {
            // everything else is considered a slvave.
            $this->slaves[] = $connection;
        }

        if (isset($parameters->alias)) {
            $this->aliases[$parameters->alias] = $connection;
        }

        $this->pool[(string) $connection] = $connection;

        $this->reset();
    }

    /**
     * {@inheritdoc}
     */
    public function remove(NodeConnectionInterface $connection)
    {
        if ($connection === $this->master) {
            $this->master = null;
        } elseif (false !== $id = array_search($connection, $this->slaves, true)) {
            unset($this->slaves[$id]);
        } else {
            return false;
        }

        unset($this->pool[(string) $connection]);

        if ($this->aliases && $alias = $connection->getParameters()->alias) {
            unset($this->aliases[$alias]);
        }

        $this->reset();

        return true;
    }

    /**
     * {@inheritdoc}
     */
    public function getConnectionByCommand(CommandInterface $command)
    {
        if (!$this->current) {
            if ($this->strategy->isReadOperation($command) && $slave = $this->pickSlave()) {
                $this->current = $slave;
            } else {
                $this->current = $this->getMasterOrDie();
            }

            return $this->current;
        }

        if ($this->current === $master = $this->getMasterOrDie()) {
            return $master;
        }

        if (!$this->strategy->isReadOperation($command) || !$this->slaves) {
            $this->current = $master;
        }

        return $this->current;
    }

    /**
     * {@inheritdoc}
     */
    public function getConnectionById($id)
    {
        return $this->pool[$id] ?? null;
    }

    /**
     * Returns a connection instance by its alias.
     *
     * @param string $alias Connection alias.
     *
     * @return NodeConnectionInterface|null
     */
    public function getConnectionByAlias($alias)
    {
        return $this->aliases[$alias] ?? null;
    }

    /**
     * Returns a connection by its role.
     *
     * @param string $role Connection role (`master` or `slave`)
     *
     * @return NodeConnectionInterface|null
     */
    public function getConnectionByRole($role)
    {
        if ($role === 'master') {
            return $this->getMaster();
        } elseif ($role === 'slave') {
            return $this->pickSlave();
        }

        return null;
    }

    /**
     * Switches the internal connection in use by the backend.
     *
     * @param NodeConnectionInterface $connection Connection instance in the pool.
     */
    public function switchTo(NodeConnectionInterface $connection)
    {
        if ($connection && $connection === $this->current) {
            return;
        }

        if ($connection !== $this->master && !in_array($connection, $this->slaves, true)) {
            throw new InvalidArgumentException('Invalid connection or connection not found.');
        }

        $this->current = $connection;
    }

    /**
     * {@inheritdoc}
     */
    public function switchToMaster()
    {
        if (!$connection = $this->getConnectionByRole('master')) {
            throw new InvalidArgumentException('Invalid connection or connection not found.');
        }

        $this->switchTo($connection);
    }

    /**
     * {@inheritdoc}
     */
    public function switchToSlave()
    {
        if (!$connection = $this->getConnectionByRole('slave')) {
            throw new InvalidArgumentException('Invalid connection or connection not found.');
        }

        $this->switchTo($connection);
    }

    /**
     * {@inheritdoc}
     */
    public function getCurrent()
    {
        return $this->current;
    }

    /**
     * {@inheritdoc}
     */
    public function getMaster()
    {
        return $this->master;
    }

    /**
     * Returns the connection associated to the master server.
     *
     * @return NodeConnectionInterface
     */
    private function getMasterOrDie()
    {
        if (!$connection = $this->getMaster()) {
            throw new MissingMasterException('No master server available for replication');
        }

        return $connection;
    }

    /**
     * {@inheritdoc}
     */
    public function getSlaves()
    {
        return $this->slaves;
    }

    /**
     * Returns the underlying replication strategy.
     *
     * @return ReplicationStrategy
     */
    public function getReplicationStrategy()
    {
        return $this->strategy;
    }

    /**
     * Returns a random slave.
     *
     * @return NodeConnectionInterface|null
     */
    protected function pickSlave()
    {
        if (!$this->slaves) {
            return null;
        }

        return $this->slaves[array_rand($this->slaves)];
    }

    /**
     * {@inheritdoc}
     */
    public function isConnected()
    {
        return $this->current ? $this->current->isConnected() : false;
    }

    /**
     * {@inheritdoc}
     */
    public function connect()
    {
        if (!$this->current) {
            if (!$this->current = $this->pickSlave()) {
                if (!$this->current = $this->getMaster()) {
                    throw new ClientException('No available connection for replication');
                }
            }
        }

        $this->current->connect();
    }

    /**
     * {@inheritdoc}
     */
    public function disconnect()
    {
        foreach ($this->pool as $connection) {
            $connection->disconnect();
        }
    }

    /**
     * Handles response from INFO.
     *
     * @param string $response
     *
     * @return array
     */
    private function handleInfoResponse($response)
    {
        $info = [];

        foreach (preg_split('/\r?\n/', $response) as $row) {
            if (strpos($row, ':') === false) {
                continue;
            }

            [$k, $v] = explode(':', $row, 2);
            $info[$k] = $v;
        }

        return $info;
    }

    /**
     * Fetches the replication configuration from one of the servers.
     */
    public function discover()
    {
        if (!$this->connectionFactory) {
            throw new ClientException('Discovery requires a connection factory');
        }

        while (true) {
            try {
                if ($connection = $this->getMaster()) {
                    $this->discoverFromMaster($connection, $this->connectionFactory);
                    break;
                } elseif ($connection = $this->pickSlave()) {
                    $this->discoverFromSlave($connection, $this->connectionFactory);
                    break;
                } else {
                    throw new ClientException('No connection available for discovery');
                }
            } catch (ConnectionException $exception) {
                $this->remove($connection);
            }
        }
    }

    /**
     * Discovers the replication configuration by contacting the master node.
     *
     * @param NodeConnectionInterface $connection        Connection to the master node.
     * @param FactoryInterface        $connectionFactory Connection factory instance.
     */
    protected function discoverFromMaster(NodeConnectionInterface $connection, FactoryInterface $connectionFactory)
    {
        $response = $connection->executeCommand(RawCommand::create('INFO', 'REPLICATION'));
        $replication = $this->handleInfoResponse($response);

        if ($replication['role'] !== 'master') {
            throw new ClientException("Role mismatch (expected master, got slave) [$connection]");
        }

        $this->slaves = [];

        foreach ($replication as $k => $v) {
            $parameters = null;

            if (strpos($k, 'slave') === 0 && preg_match('/ip=(?P<host>.*),port=(?P<port>\d+)/', $v, $parameters)) {
                $slaveConnection = $connectionFactory->create([
                    'host' => $parameters['host'],
                    'port' => $parameters['port'],
                    'role' => 'slave',
                ]);

                $this->add($slaveConnection);
            }
        }
    }

    /**
     * Discovers the replication configuration by contacting one of the slaves.
     *
     * @param NodeConnectionInterface $connection        Connection to one of the slaves.
     * @param FactoryInterface        $connectionFactory Connection factory instance.
     */
    protected function discoverFromSlave(NodeConnectionInterface $connection, FactoryInterface $connectionFactory)
    {
        $response = $connection->executeCommand(RawCommand::create('INFO', 'REPLICATION'));
        $replication = $this->handleInfoResponse($response);

        if ($replication['role'] !== 'slave') {
            throw new ClientException("Role mismatch (expected slave, got master) [$connection]");
        }

        $masterConnection = $connectionFactory->create([
            'host' => $replication['master_host'],
            'port' => $replication['master_port'],
            'role' => 'master',
        ]);

        $this->add($masterConnection);

        $this->discoverFromMaster($masterConnection, $connectionFactory);
    }

    /**
     * Retries the execution of a command upon slave failure.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $method  Actual method.
     *
     * @return mixed
     */
    private function retryCommandOnFailure(CommandInterface $command, $method)
    {
        while (true) {
            try {
                $connection = $this->getConnectionByCommand($command);
                $response = $connection->$method($command);

                if ($response instanceof ResponseErrorInterface && $response->getErrorType() === 'LOADING') {
                    throw new ConnectionException($connection, "Redis is loading the dataset in memory [$connection]");
                }

                break;
            } catch (ConnectionException $exception) {
                $connection = $exception->getConnection();
                $connection->disconnect();

                if ($connection === $this->master && !$this->autoDiscovery) {
                    // Throw immediately when master connection is failing, even
                    // when the command represents a read-only operation, unless
                    // automatic discovery has been enabled.
                    throw $exception;
                } else {
                    // Otherwise remove the failing slave and attempt to execute
                    // the command again on one of the remaining slaves...
                    $this->remove($connection);
                }

                // ... that is, unless we have no more connections to use.
                if (!$this->slaves && !$this->master) {
                    throw $exception;
                } elseif ($this->autoDiscovery) {
                    $this->discover();
                }
            } catch (MissingMasterException $exception) {
                if ($this->autoDiscovery) {
                    $this->discover();
                } else {
                    throw $exception;
                }
            }
        }

        return $response;
    }

    /**
     * {@inheritdoc}
     */
    public function writeRequest(CommandInterface $command)
    {
        $this->retryCommandOnFailure($command, __FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function readResponse(CommandInterface $command)
    {
        return $this->retryCommandOnFailure($command, __FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function executeCommand(CommandInterface $command)
    {
        return $this->retryCommandOnFailure($command, __FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function __sleep()
    {
        return ['master', 'slaves', 'pool', 'aliases', 'strategy'];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\Replication\ReplicationInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection\Replication;

use Predis\Connection\AggregateConnectionInterface;
use Predis\Connection\NodeConnectionInterface;

/**
 * Defines a group of Redis nodes in a master / slave replication setup.
 */
interface ReplicationInterface extends AggregateConnectionInterface
{
    /**
     * Switches the internal connection in use to the master server.
     */
    public function switchToMaster();

    /**
     * Switches the internal connection in use to a random slave server.
     */
    public function switchToSlave();

    /**
     * Returns the connection in use by the replication backend.
     *
     * @return NodeConnectionInterface
     */
    public function getCurrent();

    /**
     * Returns the connection to the master server.
     *
     * @return NodeConnectionInterface
     */
    public function getMaster();

    /**
     * Returns a list of connections to slave servers.
     *
     * @return NodeConnectionInterface[]
     */
    public function getSlaves();
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Connection\Replication\SentinelReplication.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection\Replication;

use InvalidArgumentException;
use Predis\Command\CommandInterface;
use Predis\Command\RawCommand;
use Predis\CommunicationException;
use Predis\Connection\ConnectionException;
use Predis\Connection\FactoryInterface as ConnectionFactoryInterface;
use Predis\Connection\NodeConnectionInterface;
use Predis\Connection\Parameters;
use Predis\Replication\ReplicationStrategy;
use Predis\Replication\RoleException;
use Predis\Response\Error;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use Predis\Response\ServerException;

/**
 * @author Daniele Alessandri <suppakilla@gmail.com>
 * @author Ville Mattila <ville@eventio.fi>
 */
class SentinelReplication implements ReplicationInterface
{
    /**
     * @var NodeConnectionInterface
     */
    protected $master;

    /**
     * @var NodeConnectionInterface[]
     */
    protected $slaves = [];

    /**
     * @var NodeConnectionInterface[]
     */
    protected $pool = [];

    /**
     * @var NodeConnectionInterface
     */
    protected $current;

    /**
     * @var string
     */
    protected $service;

    /**
     * @var ConnectionFactoryInterface
     */
    protected $connectionFactory;

    /**
     * @var ReplicationStrategy
     */
    protected $strategy;

    /**
     * @var NodeConnectionInterface[]
     */
    protected $sentinels = [];

    /**
     * @var int
     */
    protected $sentinelIndex = 0;

    /**
     * @var NodeConnectionInterface
     */
    protected $sentinelConnection;

    /**
     * @var float
     */
    protected $sentinelTimeout = 0.100;

    /**
     * Max number of automatic retries of commands upon server failure.
     *
     * -1 = unlimited retry attempts
     *  0 = no retry attempts (fails immediately)
     *  n = fail only after n retry attempts
     *
     * @var int
     */
    protected $retryLimit = 20;

    /**
     * Time to wait in milliseconds before fetching a new configuration from one
     * of the sentinel servers.
     *
     * @var int
     */
    protected $retryWait = 1000;

    /**
     * Flag for automatic fetching of available sentinels.
     *
     * @var bool
     */
    protected $updateSentinels = false;

    /**
     * @param string                     $service           Name of the service for autodiscovery.
     * @param array                      $sentinels         Sentinel servers connection parameters.
     * @param ConnectionFactoryInterface $connectionFactory Connection factory instance.
     * @param ReplicationStrategy|null   $strategy          Replication strategy instance.
     */
    public function __construct(
        $service,
        array $sentinels,
        ConnectionFactoryInterface $connectionFactory,
        ?ReplicationStrategy $strategy = null
    ) {
        $this->sentinels = $sentinels;
        $this->service = $service;
        $this->connectionFactory = $connectionFactory;
        $this->strategy = $strategy ?: new ReplicationStrategy();
    }

    /**
     * Sets a default timeout for connections to sentinels.
     *
     * When "timeout" is present in the connection parameters of sentinels, its
     * value overrides the default sentinel timeout.
     *
     * @param float $timeout Timeout value.
     */
    public function setSentinelTimeout($timeout)
    {
        $this->sentinelTimeout = (float) $timeout;
    }

    /**
     * Sets the maximum number of retries for commands upon server failure.
     *
     * -1 = unlimited retry attempts
     *  0 = no retry attempts (fails immediately)
     *  n = fail only after n retry attempts
     *
     * @param int $retry Number of retry attempts.
     */
    public function setRetryLimit($retry)
    {
        $this->retryLimit = (int) $retry;
    }

    /**
     * Sets the time to wait (in milliseconds) before fetching a new configuration
     * from one of the sentinels.
     *
     * @param float $milliseconds Time to wait before the next attempt.
     */
    public function setRetryWait($milliseconds)
    {
        $this->retryWait = (float) $milliseconds;
    }

    /**
     * Set automatic fetching of available sentinels.
     *
     * @param bool $update Enable or disable automatic updates.
     */
    public function setUpdateSentinels($update)
    {
        $this->updateSentinels = (bool) $update;
    }

    /**
     * Resets the current connection.
     */
    protected function reset()
    {
        $this->current = null;
    }

    /**
     * Wipes the current list of master and slaves nodes.
     */
    protected function wipeServerList()
    {
        $this->reset();

        $this->master = null;
        $this->slaves = [];
        $this->pool = [];
    }

    /**
     * {@inheritdoc}
     */
    public function add(NodeConnectionInterface $connection)
    {
        $parameters = $connection->getParameters();
        $role = $parameters->role;

        if ('master' === $role) {
            $this->master = $connection;
        } elseif ('sentinel' === $role) {
            $this->sentinels[] = $connection;

            // sentinels are not considered part of the pool.
            return;
        } else {
            // everything else is considered a slave.
            $this->slaves[] = $connection;
        }

        $this->pool[(string) $connection] = $connection;

        $this->reset();
    }

    /**
     * {@inheritdoc}
     */
    public function remove(NodeConnectionInterface $connection)
    {
        if ($connection === $this->master) {
            $this->master = null;
        } elseif (false !== $id = array_search($connection, $this->slaves, true)) {
            unset($this->slaves[$id]);
        } elseif (false !== $id = array_search($connection, $this->sentinels, true)) {
            unset($this->sentinels[$id]);

            return true;
        } else {
            return false;
        }

        unset($this->pool[(string) $connection]);

        $this->reset();

        return true;
    }

    /**
     * Creates a new connection to a sentinel server.
     *
     * @return NodeConnectionInterface
     */
    protected function createSentinelConnection($parameters)
    {
        if ($parameters instanceof NodeConnectionInterface) {
            return $parameters;
        }

        if (is_string($parameters)) {
            $parameters = Parameters::parse($parameters);
        }

        if (is_array($parameters)) {
            // NOTE: sentinels do not accept AUTH and SELECT commands so we must
            // explicitly set them to NULL to avoid problems when using default
            // parameters set via client options. Actually AUTH is supported for
            // sentinels starting with Redis 5 but we have to differentiate from
            // sentinels passwords and nodes passwords, this will be implemented
            // in a later release.
            $parameters['database'] = null;
            $parameters['username'] = null;

            // don't leak password from between configurations
            // https://github.com/predis/predis/pull/807/#discussion_r985764770
            if (!isset($parameters['password'])) {
                $parameters['password'] = null;
            }

            if (!isset($parameters['timeout'])) {
                $parameters['timeout'] = $this->sentinelTimeout;
            }
        }

        return $this->connectionFactory->create($parameters);
    }

    /**
     * Returns the current sentinel connection.
     *
     * If there is no active sentinel connection, a new connection is created.
     *
     * @return NodeConnectionInterface
     */
    public function getSentinelConnection()
    {
        if (!$this->sentinelConnection) {
            if ($this->sentinelIndex >= count($this->sentinels)) {
                $this->sentinelIndex = 0;
                throw new \Predis\ClientException('No sentinel server available for autodiscovery.');
            }

            $sentinel = $this->sentinels[$this->sentinelIndex];
            ++$this->sentinelIndex;
            $this->sentinelConnection = $this->createSentinelConnection($sentinel);
        }

        return $this->sentinelConnection;
    }

    /**
     * Fetches an updated list of sentinels from a sentinel.
     */
    public function updateSentinels()
    {
        SENTINEL_QUERY: {
            $sentinel = $this->getSentinelConnection();

            try {
                $payload = $sentinel->executeCommand(
                    RawCommand::create('SENTINEL', 'sentinels', $this->service)
                );

                $this->sentinels = [];
                $this->sentinelIndex = 0;
                // NOTE: sentinel server does not return itself, so we add it back.
                $this->sentinels[] = $sentinel->getParameters()->toArray();

                foreach ($payload as $sentinel) {
                    $this->sentinels[] = [
                        'host' => $sentinel[3],
                        'port' => $sentinel[5],
                        'role' => 'sentinel',
                    ];
                }
            } catch (ConnectionException $exception) {
                $this->sentinelConnection = null;

                goto SENTINEL_QUERY;
            }
        }
    }

    /**
     * Fetches the details for the master and slave servers from a sentinel.
     */
    public function querySentinel()
    {
        $this->wipeServerList();

        $this->updateSentinels();
        $this->getMaster();
        $this->getSlaves();
    }

    /**
     * Handles error responses returned by redis-sentinel.
     *
     * @param NodeConnectionInterface $sentinel Connection to a sentinel server.
     * @param ErrorResponseInterface  $error    Error response.
     */
    private function handleSentinelErrorResponse(NodeConnectionInterface $sentinel, ErrorResponseInterface $error)
    {
        if ($error->getErrorType() === 'IDONTKNOW') {
            throw new ConnectionException($sentinel, $error->getMessage());
        } else {
            throw new ServerException($error->getMessage());
        }
    }

    /**
     * Fetches the details for the master server from a sentinel.
     *
     * @param NodeConnectionInterface $sentinel Connection to a sentinel server.
     * @param string                  $service  Name of the service.
     *
     * @return array
     */
    protected function querySentinelForMaster(NodeConnectionInterface $sentinel, $service)
    {
        $payload = $sentinel->executeCommand(
            RawCommand::create('SENTINEL', 'get-master-addr-by-name', $service)
        );

        if ($payload === null) {
            throw new ServerException('ERR No such master with that name');
        }

        if ($payload instanceof ErrorResponseInterface) {
            $this->handleSentinelErrorResponse($sentinel, $payload);
        }

        return [
            'host' => $payload[0],
            'port' => $payload[1],
            'role' => 'master',
        ];
    }

    /**
     * Fetches the details for the slave servers from a sentinel.
     *
     * @param NodeConnectionInterface $sentinel Connection to a sentinel server.
     * @param string                  $service  Name of the service.
     *
     * @return array
     */
    protected function querySentinelForSlaves(NodeConnectionInterface $sentinel, $service)
    {
        $slaves = [];

        $payload = $sentinel->executeCommand(
            RawCommand::create('SENTINEL', 'slaves', $service)
        );

        if ($payload instanceof ErrorResponseInterface) {
            $this->handleSentinelErrorResponse($sentinel, $payload);
        }

        foreach ($payload as $slave) {
            $flags = explode(',', $slave[9]);

            if (array_intersect($flags, ['s_down', 'o_down', 'disconnected'])) {
                continue;
            }

            // ensure `master-link-status` is ok
            if (isset($slave[31]) && $slave[31] === 'err') {
                continue;
            }

            $slaves[] = [
                'host' => $slave[3],
                'port' => $slave[5],
                'role' => 'slave',
            ];
        }

        return $slaves;
    }

    /**
     * {@inheritdoc}
     */
    public function getCurrent()
    {
        return $this->current;
    }

    /**
     * {@inheritdoc}
     */
    public function getMaster()
    {
        if ($this->master) {
            return $this->master;
        }

        if ($this->updateSentinels) {
            $this->updateSentinels();
        }

        SENTINEL_QUERY: {
            $sentinel = $this->getSentinelConnection();

            try {
                $masterParameters = $this->querySentinelForMaster($sentinel, $this->service);
                $masterConnection = $this->connectionFactory->create($masterParameters);

                $this->add($masterConnection);
            } catch (ConnectionException $exception) {
                $this->sentinelConnection = null;

                goto SENTINEL_QUERY;
            }
        }

        return $masterConnection;
    }

    /**
     * {@inheritdoc}
     */
    public function getSlaves()
    {
        if ($this->slaves) {
            return array_values($this->slaves);
        }

        if ($this->updateSentinels) {
            $this->updateSentinels();
        }

        SENTINEL_QUERY: {
            $sentinel = $this->getSentinelConnection();

            try {
                $slavesParameters = $this->querySentinelForSlaves($sentinel, $this->service);

                foreach ($slavesParameters as $slaveParameters) {
                    $this->add($this->connectionFactory->create($slaveParameters));
                }
            } catch (ConnectionException $exception) {
                $this->sentinelConnection = null;

                goto SENTINEL_QUERY;
            }
        }

        return array_values($this->slaves);
    }

    /**
     * Returns a random slave.
     *
     * @return NodeConnectionInterface|null
     */
    protected function pickSlave()
    {
        $slaves = $this->getSlaves();

        return $slaves
            ? $slaves[rand(1, count($slaves)) - 1]
            : null;
    }

    /**
     * Returns the connection instance in charge for the given command.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return NodeConnectionInterface
     */
    private function getConnectionInternal(CommandInterface $command)
    {
        if (!$this->current) {
            if ($this->strategy->isReadOperation($command) && $slave = $this->pickSlave()) {
                $this->current = $slave;
            } else {
                $this->current = $this->getMaster();
            }

            return $this->current;
        }

        if ($this->current === $this->master) {
            return $this->current;
        }

        if (!$this->strategy->isReadOperation($command)) {
            $this->current = $this->getMaster();
        }

        return $this->current;
    }

    /**
     * Asserts that the specified connection matches an expected role.
     *
     * @param NodeConnectionInterface $connection Connection to a redis server.
     * @param string                  $role       Expected role of the server ("master", "slave" or "sentinel").
     *
     * @throws RoleException|ConnectionException
     */
    protected function assertConnectionRole(NodeConnectionInterface $connection, $role)
    {
        $role = strtolower($role);
        $actualRole = $connection->executeCommand(RawCommand::create('ROLE'));

        if ($actualRole instanceof Error) {
            throw new ConnectionException($connection, $actualRole->getMessage());
        }

        if ($role !== $actualRole[0]) {
            throw new RoleException($connection, "Expected $role but got $actualRole[0] [$connection]");
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getConnectionByCommand(CommandInterface $command)
    {
        $connection = $this->getConnectionInternal($command);

        if (!$connection->isConnected()) {
            // When we do not have any available slave in the pool we can expect
            // read-only operations to hit the master server.
            $expectedRole = $this->strategy->isReadOperation($command) && $this->slaves ? 'slave' : 'master';
            $this->assertConnectionRole($connection, $expectedRole);
        }

        return $connection;
    }

    /**
     * {@inheritdoc}
     */
    public function getConnectionById($id)
    {
        return $this->pool[$id] ?? null;
    }

    /**
     * Returns a connection by its role.
     *
     * @param string $role Connection role (`master`, `slave` or `sentinel`)
     *
     * @return NodeConnectionInterface|null
     */
    public function getConnectionByRole($role)
    {
        if ($role === 'master') {
            return $this->getMaster();
        } elseif ($role === 'slave') {
            return $this->pickSlave();
        } elseif ($role === 'sentinel') {
            return $this->getSentinelConnection();
        } else {
            return null;
        }
    }

    /**
     * Switches the internal connection in use by the backend.
     *
     * Sentinel connections are not considered as part of the pool, meaning that
     * trying to switch to a sentinel will throw an exception.
     *
     * @param NodeConnectionInterface $connection Connection instance in the pool.
     */
    public function switchTo(NodeConnectionInterface $connection)
    {
        if ($connection && $connection === $this->current) {
            return;
        }

        if ($connection !== $this->master && !in_array($connection, $this->slaves, true)) {
            throw new InvalidArgumentException('Invalid connection or connection not found.');
        }

        $connection->connect();

        if ($this->current) {
            $this->current->disconnect();
        }

        $this->current = $connection;
    }

    /**
     * {@inheritdoc}
     */
    public function switchToMaster()
    {
        $connection = $this->getConnectionByRole('master');
        $this->switchTo($connection);
    }

    /**
     * {@inheritdoc}
     */
    public function switchToSlave()
    {
        $connection = $this->getConnectionByRole('slave');
        $this->switchTo($connection);
    }

    /**
     * {@inheritdoc}
     */
    public function isConnected()
    {
        return $this->current ? $this->current->isConnected() : false;
    }

    /**
     * {@inheritdoc}
     */
    public function connect()
    {
        if (!$this->current) {
            if (!$this->current = $this->pickSlave()) {
                $this->current = $this->getMaster();
            }
        }

        $this->current->connect();
    }

    /**
     * {@inheritdoc}
     */
    public function disconnect()
    {
        foreach ($this->pool as $connection) {
            $connection->disconnect();
        }
    }

    /**
     * Retries the execution of a command upon server failure after asking a new
     * configuration to one of the sentinels.
     *
     * @param CommandInterface $command Command instance.
     * @param string           $method  Actual method.
     *
     * @return mixed
     */
    private function retryCommandOnFailure(CommandInterface $command, $method)
    {
        $retries = 0;

        while ($retries <= $this->retryLimit) {
            try {
                $response = $this->getConnectionByCommand($command)->$method($command);
                break;
            } catch (CommunicationException $exception) {
                $this->wipeServerList();
                $exception->getConnection()->disconnect();

                if ($retries === $this->retryLimit) {
                    throw $exception;
                }

                usleep($this->retryWait * 1000);

                ++$retries;
            }
        }

        return $response;
    }

    /**
     * {@inheritdoc}
     */
    public function writeRequest(CommandInterface $command)
    {
        $this->retryCommandOnFailure($command, __FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function readResponse(CommandInterface $command)
    {
        return $this->retryCommandOnFailure($command, __FUNCTION__);
    }

    /**
     * {@inheritdoc}
     */
    public function executeCommand(CommandInterface $command)
    {
        return $this->retryCommandOnFailure($command, __FUNCTION__);
    }

    /**
     * Returns the underlying replication strategy.
     *
     * @return ReplicationStrategy
     */
    public function getReplicationStrategy()
    {
        return $this->strategy;
    }

    /**
     * {@inheritdoc}
     */
    public function __sleep()
    {
        return [
            'master', 'slaves', 'pool', 'service', 'sentinels', 'connectionFactory', 'strategy',
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Monitor\Consumer.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Monitor;

use Iterator;
use Predis\ClientInterface;
use Predis\Connection\Cluster\ClusterInterface;
use Predis\NotSupportedException;
use ReturnTypeWillChange;

/**
 * Redis MONITOR consumer.
 */
class Consumer implements Iterator
{
    private $client;
    private $valid;
    private $position;

    /**
     * @param ClientInterface $client Client instance used by the consumer.
     */
    public function __construct(ClientInterface $client)
    {
        $this->assertClient($client);

        $this->client = $client;

        $this->start();
    }

    /**
     * Automatically stops the consumer when the garbage collector kicks in.
     */
    public function __destruct()
    {
        $this->stop();
    }

    /**
     * Checks if the passed client instance satisfies the required conditions
     * needed to initialize a monitor consumer.
     *
     * @param ClientInterface $client Client instance used by the consumer.
     *
     * @throws NotSupportedException
     */
    private function assertClient(ClientInterface $client)
    {
        if ($client->getConnection() instanceof ClusterInterface) {
            throw new NotSupportedException(
                'Cannot initialize a monitor consumer over cluster connections.'
            );
        }

        if (!$client->getCommandFactory()->supports('MONITOR')) {
            throw new NotSupportedException("'MONITOR' is not supported by the current command factory.");
        }
    }

    /**
     * Initializes the consumer and sends the MONITOR command to the server.
     */
    protected function start()
    {
        $this->client->executeCommand(
            $this->client->createCommand('MONITOR')
        );
        $this->valid = true;
    }

    /**
     * Stops the consumer. Internally this is done by disconnecting from server
     * since there is no way to terminate the stream initialized by MONITOR.
     */
    public function stop()
    {
        $this->client->disconnect();
        $this->valid = false;
    }

    /**
     * @return void
     */
    #[ReturnTypeWillChange]
    public function rewind()
    {
        // NOOP
    }

    /**
     * Returns the last message payload retrieved from the server.
     *
     * @return object
     */
    #[ReturnTypeWillChange]
    public function current()
    {
        return $this->getValue();
    }

    /**
     * @return int|null
     */
    #[ReturnTypeWillChange]
    public function key()
    {
        return $this->position;
    }

    /**
     * @return void
     */
    #[ReturnTypeWillChange]
    public function next()
    {
        ++$this->position;
    }

    /**
     * Checks if the the consumer is still in a valid state to continue.
     *
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function valid()
    {
        return $this->valid;
    }

    /**
     * Waits for a new message from the server generated by MONITOR and returns
     * it when available.
     *
     * @return object
     */
    private function getValue()
    {
        $database = 0;
        $client = null;
        $event = $this->client->getConnection()->read();

        $callback = function ($matches) use (&$database, &$client) {
            if (2 === $count = count($matches)) {
                // Redis <= 2.4
                $database = (int) $matches[1];
            }

            if (4 === $count) {
                // Redis >= 2.6
                $database = (int) $matches[2];
                $client = $matches[3];
            }

            return ' ';
        };

        $event = preg_replace_callback('/ \(db (\d+)\) | \[(\d+) (.*?)\] /', $callback, $event, 1);
        @[$timestamp, $command, $arguments] = explode(' ', $event, 3);

        return (object) [
            'timestamp' => (float) $timestamp,
            'database' => $database,
            'client' => $client,
            'command' => substr($command, 1, -1),
            'arguments' => $arguments,
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Pipeline\Atomic.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Pipeline;

use Predis\ClientException;
use Predis\ClientInterface;
use Predis\Connection\ConnectionInterface;
use Predis\Connection\NodeConnectionInterface;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use Predis\Response\ResponseInterface;
use Predis\Response\ServerException;
use SplQueue;

/**
 * Command pipeline wrapped into a MULTI / EXEC transaction.
 */
class Atomic extends Pipeline
{
    /**
     * {@inheritdoc}
     */
    public function __construct(ClientInterface $client)
    {
        if (!$client->getCommandFactory()->supports('multi', 'exec', 'discard')) {
            throw new ClientException(
                "'MULTI', 'EXEC' and 'DISCARD' are not supported by the current command factory."
            );
        }

        parent::__construct($client);
    }

    /**
     * {@inheritdoc}
     */
    protected function getConnection()
    {
        $connection = $this->getClient()->getConnection();

        if (!$connection instanceof NodeConnectionInterface) {
            $class = __CLASS__;

            throw new ClientException("The class '$class' does not support aggregate connections.");
        }

        return $connection;
    }

    /**
     * {@inheritdoc}
     */
    protected function executePipeline(ConnectionInterface $connection, SplQueue $commands)
    {
        $commandFactory = $this->getClient()->getCommandFactory();
        $connection->executeCommand($commandFactory->create('multi'));

        foreach ($commands as $command) {
            $connection->writeRequest($command);
        }

        foreach ($commands as $command) {
            $response = $connection->readResponse($command);

            if ($response instanceof ErrorResponseInterface) {
                $connection->executeCommand($commandFactory->create('discard'));
                throw new ServerException($response->getMessage());
            }
        }

        $executed = $connection->executeCommand($commandFactory->create('exec'));

        if (!isset($executed)) {
            throw new ClientException(
                'The underlying transaction has been aborted by the server.'
            );
        }

        if (count($executed) !== count($commands)) {
            $expected = count($commands);
            $received = count($executed);

            throw new ClientException(
                "Invalid number of responses [expected $expected, received $received]."
            );
        }

        $responses = [];
        $sizeOfPipe = count($commands);
        $exceptions = $this->throwServerExceptions();

        for ($i = 0; $i < $sizeOfPipe; ++$i) {
            $command = $commands->dequeue();
            $response = $executed[$i];

            if (!$response instanceof ResponseInterface) {
                $responses[] = $command->parseResponse($response);
            } elseif ($response instanceof ErrorResponseInterface && $exceptions) {
                $this->exception($connection, $response);
            } else {
                $responses[] = $response;
            }

            unset($executed[$i]);
        }

        return $responses;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Pipeline\ConnectionErrorProof.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Pipeline;

use Predis\CommunicationException;
use Predis\Connection\Cluster\ClusterInterface;
use Predis\Connection\ConnectionInterface;
use Predis\Connection\NodeConnectionInterface;
use Predis\NotSupportedException;
use SplQueue;

/**
 * Command pipeline that does not throw exceptions on connection errors, but
 * returns the exception instances as the rest of the response elements.
 */
class ConnectionErrorProof extends Pipeline
{
    /**
     * {@inheritdoc}
     */
    protected function getConnection()
    {
        return $this->getClient()->getConnection();
    }

    /**
     * {@inheritdoc}
     */
    protected function executePipeline(ConnectionInterface $connection, SplQueue $commands)
    {
        if ($connection instanceof NodeConnectionInterface) {
            return $this->executeSingleNode($connection, $commands);
        } elseif ($connection instanceof ClusterInterface) {
            return $this->executeCluster($connection, $commands);
        } else {
            $class = get_class($connection);

            throw new NotSupportedException("The connection class '$class' is not supported.");
        }
    }

    /**
     * {@inheritdoc}
     */
    protected function executeSingleNode(NodeConnectionInterface $connection, SplQueue $commands)
    {
        $responses = [];
        $sizeOfPipe = count($commands);

        foreach ($commands as $command) {
            try {
                $connection->writeRequest($command);
            } catch (CommunicationException $exception) {
                return array_fill(0, $sizeOfPipe, $exception);
            }
        }

        for ($i = 0; $i < $sizeOfPipe; ++$i) {
            $command = $commands->dequeue();

            try {
                $responses[$i] = $connection->readResponse($command);
            } catch (CommunicationException $exception) {
                $add = count($commands) - count($responses);
                $responses = array_merge($responses, array_fill(0, $add, $exception));

                break;
            }
        }

        return $responses;
    }

    /**
     * {@inheritdoc}
     */
    protected function executeCluster(ClusterInterface $connection, SplQueue $commands)
    {
        $responses = [];
        $sizeOfPipe = count($commands);
        $exceptions = [];

        foreach ($commands as $command) {
            $cmdConnection = $connection->getConnectionByCommand($command);

            if (isset($exceptions[spl_object_hash($cmdConnection)])) {
                continue;
            }

            try {
                $cmdConnection->writeRequest($command);
            } catch (CommunicationException $exception) {
                $exceptions[spl_object_hash($cmdConnection)] = $exception;
            }
        }

        for ($i = 0; $i < $sizeOfPipe; ++$i) {
            $command = $commands->dequeue();

            $cmdConnection = $connection->getConnectionByCommand($command);
            $connectionHash = spl_object_hash($cmdConnection);

            if (isset($exceptions[$connectionHash])) {
                $responses[$i] = $exceptions[$connectionHash];
                continue;
            }

            try {
                $responses[$i] = $cmdConnection->readResponse($command);
            } catch (CommunicationException $exception) {
                $responses[$i] = $exception;
                $exceptions[$connectionHash] = $exception;
            }
        }

        return $responses;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Pipeline\FireAndForget.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Pipeline;

use Predis\Connection\ConnectionInterface;
use SplQueue;

/**
 * Command pipeline that writes commands to the servers but discards responses.
 */
class FireAndForget extends Pipeline
{
    /**
     * {@inheritdoc}
     */
    protected function executePipeline(ConnectionInterface $connection, SplQueue $commands)
    {
        while (!$commands->isEmpty()) {
            $connection->writeRequest($commands->dequeue());
        }

        $connection->disconnect();

        return [];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Pipeline\Pipeline.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Pipeline;

use Exception;
use InvalidArgumentException;
use Predis\ClientContextInterface;
use Predis\ClientException;
use Predis\ClientInterface;
use Predis\Command\CommandInterface;
use Predis\Connection\ConnectionInterface;
use Predis\Connection\Replication\ReplicationInterface;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use Predis\Response\ResponseInterface;
use Predis\Response\ServerException;
use SplQueue;

/**
 * Implementation of a command pipeline in which write and read operations of
 * Redis commands are pipelined to alleviate the effects of network round-trips.
 *
 * {@inheritdoc}
 */
class Pipeline implements ClientContextInterface
{
    protected $client;
    private $pipeline;

    private $responses = [];
    private $running = false;

    /**
     * @param ClientInterface $client Client instance used by the context.
     */
    public function __construct(ClientInterface $client)
    {
        $this->client = $client;
        $this->pipeline = new SplQueue();
    }

    /**
     * Queues a command into the pipeline buffer.
     *
     * @param string $method    Command ID.
     * @param array  $arguments Arguments for the command.
     *
     * @return $this
     */
    public function __call($method, $arguments)
    {
        $command = $this->client->createCommand($method, $arguments);
        $this->recordCommand($command);

        return $this;
    }

    /**
     * Queues a command instance into the pipeline buffer.
     *
     * @param CommandInterface $command Command to be queued in the buffer.
     */
    protected function recordCommand(CommandInterface $command)
    {
        $this->pipeline->enqueue($command);
    }

    /**
     * Queues a command instance into the pipeline buffer.
     *
     * @param CommandInterface $command Command instance to be queued in the buffer.
     *
     * @return $this
     */
    public function executeCommand(CommandInterface $command)
    {
        $this->recordCommand($command);

        return $this;
    }

    /**
     * Throws an exception on -ERR responses returned by Redis.
     *
     * @param ConnectionInterface    $connection Redis connection that returned the error.
     * @param ErrorResponseInterface $response   Instance of the error response.
     *
     * @throws ServerException
     */
    protected function exception(ConnectionInterface $connection, ErrorResponseInterface $response)
    {
        $connection->disconnect();
        $message = $response->getMessage();

        throw new ServerException($message);
    }

    /**
     * Returns the underlying connection to be used by the pipeline.
     *
     * @return ConnectionInterface
     */
    protected function getConnection()
    {
        $connection = $this->getClient()->getConnection();

        if ($connection instanceof ReplicationInterface) {
            $connection->switchToMaster();
        }

        return $connection;
    }

    /**
     * Implements the logic to flush the queued commands and read the responses
     * from the current connection.
     *
     * @param ConnectionInterface $connection Current connection instance.
     * @param SplQueue            $commands   Queued commands.
     *
     * @return array
     */
    protected function executePipeline(ConnectionInterface $connection, SplQueue $commands)
    {
        foreach ($commands as $command) {
            $connection->writeRequest($command);
        }

        $responses = [];
        $exceptions = $this->throwServerExceptions();

        while (!$commands->isEmpty()) {
            $command = $commands->dequeue();
            $response = $connection->readResponse($command);

            if (!$response instanceof ResponseInterface) {
                $responses[] = $command->parseResponse($response);
            } elseif ($response instanceof ErrorResponseInterface && $exceptions) {
                $this->exception($connection, $response);
            } else {
                $responses[] = $response;
            }
        }

        return $responses;
    }

    /**
     * Flushes the buffer holding all of the commands queued so far.
     *
     * @param bool $send Specifies if the commands in the buffer should be sent to Redis.
     *
     * @return $this
     */
    public function flushPipeline($send = true)
    {
        if ($send && !$this->pipeline->isEmpty()) {
            $responses = $this->executePipeline($this->getConnection(), $this->pipeline);
            $this->responses = array_merge($this->responses, $responses);
        } else {
            $this->pipeline = new SplQueue();
        }

        return $this;
    }

    /**
     * Marks the running status of the pipeline.
     *
     * @param bool $bool Sets the running status of the pipeline.
     *
     * @throws ClientException
     */
    private function setRunning($bool)
    {
        if ($bool && $this->running) {
            throw new ClientException('The current pipeline context is already being executed.');
        }

        $this->running = $bool;
    }

    /**
     * Handles the actual execution of the whole pipeline.
     *
     * @param mixed $callable Optional callback for execution.
     *
     * @return array
     * @throws Exception
     * @throws InvalidArgumentException
     */
    public function execute($callable = null)
    {
        if ($callable && !is_callable($callable)) {
            throw new InvalidArgumentException('The argument must be a callable object.');
        }

        $exception = null;
        $this->setRunning(true);

        try {
            if ($callable) {
                call_user_func($callable, $this);
            }

            $this->flushPipeline();
        } catch (Exception $exception) {
            // NOOP
        }

        $this->setRunning(false);

        if ($exception) {
            throw $exception;
        }

        return $this->responses;
    }

    /**
     * Returns if the pipeline should throw exceptions on server errors.
     *
     * @return bool
     */
    protected function throwServerExceptions()
    {
        return (bool) $this->client->getOptions()->exceptions;
    }

    /**
     * Returns the underlying client instance used by the pipeline object.
     *
     * @return ClientInterface
     */
    public function getClient()
    {
        return $this->client;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Pipeline\RelayAtomic.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Pipeline;

use Predis\Connection\ConnectionInterface;
use Predis\Response\Error;
use Predis\Response\ServerException;
use Relay\Exception as RelayException;
use SplQueue;

class RelayAtomic extends Atomic
{
    /**
     * {@inheritdoc}
     */
    protected function executePipeline(ConnectionInterface $connection, SplQueue $commands)
    {
        /** @var \Predis\Connection\RelayConnection $connection */
        $client = $connection->getClient();

        $throw = $this->client->getOptions()->exceptions;

        try {
            $transaction = $client->multi();

            foreach ($commands as $command) {
                $name = $command->getId();

                in_array($name, $connection->atypicalCommands)
                    ? $transaction->{$name}(...$command->getArguments())
                    : $transaction->rawCommand($name, ...$command->getArguments());
            }

            $responses = $transaction->exec();

            if (!is_array($responses)) {
                return $responses;
            }

            foreach ($responses as $key => $response) {
                if ($response instanceof RelayException) {
                    if ($throw) {
                        throw $response;
                    }

                    $responses[$key] = new Error($response->getMessage());
                }
            }

            return $responses;
        } catch (RelayException $ex) {
            if ($client->getMode() !== $client::ATOMIC) {
                $client->discard();
            }

            throw new ServerException($ex->getMessage(), $ex->getCode(), $ex);
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Pipeline\RelayPipeline.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Pipeline;

use Predis\Connection\ConnectionInterface;
use Predis\Connection\RelayConnection;
use Predis\Response\Error;
use Predis\Response\ServerException;
use Relay\Exception as RelayException;
use SplQueue;

class RelayPipeline extends Pipeline
{
    /**
     * Implements the logic to flush the queued commands and read the responses
     * from the current connection.
     *
     * @param  RelayConnection $connection Current connection instance.
     * @param  SplQueue        $commands   Queued commands.
     * @return array
     */
    protected function executePipeline(ConnectionInterface $connection, SplQueue $commands)
    {
        /** @var RelayConnection $connection */
        $client = $connection->getClient();

        $throw = $this->client->getOptions()->exceptions;

        try {
            $pipeline = $client->pipeline();

            foreach ($commands as $command) {
                $name = $command->getId();

                in_array($name, $connection->atypicalCommands)
                    ? $pipeline->{$name}(...$command->getArguments())
                    : $pipeline->rawCommand($name, ...$command->getArguments());
            }

            $responses = $pipeline->exec();

            if (!is_array($responses)) {
                return $responses;
            }

            foreach ($responses as $key => $response) {
                if ($response instanceof RelayException) {
                    if ($throw) {
                        throw $response;
                    }

                    $responses[$key] = new Error($response->getMessage());
                }
            }

            return $responses;
        } catch (RelayException $ex) {
            if ($client->getMode() !== $client::ATOMIC) {
                $client->discard();
            }

            throw new ServerException($ex->getMessage(), $ex->getCode(), $ex);
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\ProtocolException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol;

use Predis\CommunicationException;

/**
 * Exception used to identify errors encountered while parsing the Redis wire
 * protocol.
 */
class ProtocolException extends CommunicationException
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\ProtocolProcessorInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol;

use Predis\Command\CommandInterface;
use Predis\Connection\CompositeConnectionInterface;

/**
 * Defines a pluggable protocol processor capable of serializing commands and
 * deserializing responses into PHP objects directly from a connection.
 */
interface ProtocolProcessorInterface
{
    /**
     * Writes a request over a connection to Redis.
     *
     * @param CompositeConnectionInterface $connection Redis connection.
     * @param CommandInterface             $command    Command instance.
     */
    public function write(CompositeConnectionInterface $connection, CommandInterface $command);

    /**
     * Reads a response from a connection to Redis.
     *
     * @param CompositeConnectionInterface $connection Redis connection.
     *
     * @return mixed
     */
    public function read(CompositeConnectionInterface $connection);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\RequestSerializerInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol;

use Predis\Command\CommandInterface;

/**
 * Defines a pluggable serializer for Redis commands.
 */
interface RequestSerializerInterface
{
    /**
     * Serializes a Redis command.
     *
     * @param CommandInterface $command Redis command.
     *
     * @return string
     */
    public function serialize(CommandInterface $command);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\ResponseReaderInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol;

use Predis\Connection\CompositeConnectionInterface;

/**
 * Defines a pluggable reader capable of parsing responses returned by Redis and
 * deserializing them to PHP objects.
 */
interface ResponseReaderInterface
{
    /**
     * Reads a response from a connection to Redis.
     *
     * @param CompositeConnectionInterface $connection Redis connection.
     *
     * @return mixed
     */
    public function read(CompositeConnectionInterface $connection);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\CompositeProtocolProcessor.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use Predis\Command\CommandInterface;
use Predis\Connection\CompositeConnectionInterface;
use Predis\Protocol\ProtocolProcessorInterface;
use Predis\Protocol\RequestSerializerInterface;
use Predis\Protocol\ResponseReaderInterface;

/**
 * Composite protocol processor for the standard Redis wire protocol using
 * pluggable handlers to serialize requests and deserialize responses.
 *
 * @see http://redis.io/topics/protocol
 */
class CompositeProtocolProcessor implements ProtocolProcessorInterface
{
    /*
     * @var RequestSerializerInterface
     */
    protected $serializer;

    /*
     * @var ResponseReaderInterface
     */
    protected $reader;

    /**
     * @param RequestSerializerInterface|null $serializer Request serializer.
     * @param ResponseReaderInterface|null    $reader     Response reader.
     */
    public function __construct(
        ?RequestSerializerInterface $serializer = null,
        ?ResponseReaderInterface $reader = null
    ) {
        $this->setRequestSerializer($serializer ?: new RequestSerializer());
        $this->setResponseReader($reader ?: new ResponseReader());
    }

    /**
     * {@inheritdoc}
     */
    public function write(CompositeConnectionInterface $connection, CommandInterface $command)
    {
        $connection->writeBuffer($this->serializer->serialize($command));
    }

    /**
     * {@inheritdoc}
     */
    public function read(CompositeConnectionInterface $connection)
    {
        return $this->reader->read($connection);
    }

    /**
     * Sets the request serializer used by the protocol processor.
     *
     * @param RequestSerializerInterface $serializer Request serializer.
     */
    public function setRequestSerializer(RequestSerializerInterface $serializer)
    {
        $this->serializer = $serializer;
    }

    /**
     * Returns the request serializer used by the protocol processor.
     *
     * @return RequestSerializerInterface
     */
    public function getRequestSerializer()
    {
        return $this->serializer;
    }

    /**
     * Sets the response reader used by the protocol processor.
     *
     * @param ResponseReaderInterface $reader Response reader.
     */
    public function setResponseReader(ResponseReaderInterface $reader)
    {
        $this->reader = $reader;
    }

    /**
     * Returns the Response reader used by the protocol processor.
     *
     * @return ResponseReaderInterface
     */
    public function getResponseReader()
    {
        return $this->reader;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\ProtocolProcessor.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use Predis\Command\CommandInterface;
use Predis\CommunicationException;
use Predis\Connection\CompositeConnectionInterface;
use Predis\Protocol\ProtocolException;
use Predis\Protocol\ProtocolProcessorInterface;
use Predis\Response\Error as ErrorResponse;
use Predis\Response\Iterator\MultiBulk as MultiBulkIterator;
use Predis\Response\Status as StatusResponse;

/**
 * Protocol processor for the standard Redis wire protocol.
 *
 * @see http://redis.io/topics/protocol
 */
class ProtocolProcessor implements ProtocolProcessorInterface
{
    protected $mbiterable;
    protected $serializer;

    public function __construct()
    {
        $this->mbiterable = false;
        $this->serializer = new RequestSerializer();
    }

    /**
     * {@inheritdoc}
     */
    public function write(CompositeConnectionInterface $connection, CommandInterface $command)
    {
        $request = $this->serializer->serialize($command);
        $connection->writeBuffer($request);
    }

    /**
     * {@inheritdoc}
     */
    public function read(CompositeConnectionInterface $connection)
    {
        $chunk = $connection->readLine();
        $prefix = $chunk[0];
        $payload = substr($chunk, 1);

        switch ($prefix) {
            case '+':
                return new StatusResponse($payload);

            case '$':
                $size = (int) $payload;
                if ($size === -1) {
                    return;
                }

                return substr($connection->readBuffer($size + 2), 0, -2);

            case '*':
                $count = (int) $payload;

                if ($count === -1) {
                    return;
                }
                if ($this->mbiterable) {
                    return new MultiBulkIterator($connection, $count);
                }

                $multibulk = [];

                for ($i = 0; $i < $count; ++$i) {
                    $multibulk[$i] = $this->read($connection);
                }

                return $multibulk;

            case ':':
                $integer = (int) $payload;

                return $integer == $payload ? $integer : $payload;

            case '-':
                return new ErrorResponse($payload);

            default:
                CommunicationException::handle(new ProtocolException(
                    $connection, "Unknown response prefix: '$prefix' [{$connection->getParameters()}]"
                ));

                return;
        }
    }

    /**
     * Enables or disables returning multibulk responses as specialized PHP
     * iterators used to stream bulk elements of a multibulk response instead
     * returning a plain array.
     *
     * Streamable multibulk responses are not globally supported by the
     * abstractions built-in into Predis, such as transactions or pipelines.
     * Use them with care!
     *
     * @param bool $value Enable or disable streamable multibulk responses.
     */
    public function useIterableMultibulk($value)
    {
        $this->mbiterable = (bool) $value;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\RequestSerializer.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use Predis\Command\CommandInterface;
use Predis\Protocol\RequestSerializerInterface;

/**
 * Request serializer for the standard Redis wire protocol.
 *
 * @see http://redis.io/topics/protocol
 */
class RequestSerializer implements RequestSerializerInterface
{
    /**
     * {@inheritdoc}
     */
    public function serialize(CommandInterface $command)
    {
        $commandID = $command->getId();
        $arguments = $command->getArguments();

        $cmdlen = strlen($commandID);
        $reqlen = count($arguments) + 1;

        $buffer = "*{$reqlen}\r\n\${$cmdlen}\r\n{$commandID}\r\n";

        foreach ($arguments as $argument) {
            $arglen = strlen($argument);
            $buffer .= "\${$arglen}\r\n{$argument}\r\n";
        }

        return $buffer;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\ResponseReader.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use Predis\CommunicationException;
use Predis\Connection\CompositeConnectionInterface;
use Predis\Protocol\ProtocolException;
use Predis\Protocol\ResponseReaderInterface;

/**
 * Response reader for the standard Redis wire protocol.
 *
 * @see http://redis.io/topics/protocol
 */
class ResponseReader implements ResponseReaderInterface
{
    protected $handlers;

    public function __construct()
    {
        $this->handlers = $this->getDefaultHandlers();
    }

    /**
     * Returns the default handlers for the supported type of responses.
     *
     * @return array
     */
    protected function getDefaultHandlers()
    {
        return [
            '+' => new Handler\StatusResponse(),
            '-' => new Handler\ErrorResponse(),
            ':' => new Handler\IntegerResponse(),
            '$' => new Handler\BulkResponse(),
            '*' => new Handler\MultiBulkResponse(),
        ];
    }

    /**
     * Sets the handler for the specified prefix identifying the response type.
     *
     * @param string                           $prefix  Identifier of the type of response.
     * @param Handler\ResponseHandlerInterface $handler Response handler.
     */
    public function setHandler($prefix, Handler\ResponseHandlerInterface $handler)
    {
        $this->handlers[$prefix] = $handler;
    }

    /**
     * Returns the response handler associated to a certain type of response.
     *
     * @param string $prefix Identifier of the type of response.
     *
     * @return Handler\ResponseHandlerInterface
     */
    public function getHandler($prefix)
    {
        if (isset($this->handlers[$prefix])) {
            return $this->handlers[$prefix];
        }

        return;
    }

    /**
     * {@inheritdoc}
     */
    public function read(CompositeConnectionInterface $connection)
    {
        $header = $connection->readLine();

        if ($header === '') {
            $this->onProtocolError($connection, 'Unexpected empty response header');
        }

        $prefix = $header[0];

        if (!isset($this->handlers[$prefix])) {
            $this->onProtocolError($connection, "Unknown response prefix: '$prefix'");
        }

        return $this->handlers[$prefix]->handle($connection, substr($header, 1));
    }

    /**
     * Handles protocol errors generated while reading responses from a
     * connection.
     *
     * @param CompositeConnectionInterface $connection Redis connection that generated the error.
     * @param string                       $message    Error message.
     */
    protected function onProtocolError(CompositeConnectionInterface $connection, $message)
    {
        CommunicationException::handle(
            new ProtocolException($connection, "$message [{$connection->getParameters()}]")
        );
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\Handler\BulkResponse.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text\Handler;

use Predis\CommunicationException;
use Predis\Connection\CompositeConnectionInterface;
use Predis\Protocol\ProtocolException;

/**
 * Handler for the bulk response type in the standard Redis wire protocol.
 * It translates the payload to a string or a NULL.
 *
 * @see http://redis.io/topics/protocol
 */
class BulkResponse implements ResponseHandlerInterface
{
    /**
     * {@inheritdoc}
     */
    public function handle(CompositeConnectionInterface $connection, $payload)
    {
        $length = (int) $payload;

        if ("$length" !== $payload) {
            CommunicationException::handle(new ProtocolException(
                $connection, "Cannot parse '$payload' as a valid length for a bulk response [{$connection->getParameters()}]"
            ));
        }

        if ($length >= 0) {
            return substr($connection->readBuffer($length + 2), 0, -2);
        }

        if ($length == -1) {
            return;
        }

        CommunicationException::handle(new ProtocolException(
            $connection, "Value '$payload' is not a valid length for a bulk response [{$connection->getParameters()}]"
        ));

        return;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\Handler\ErrorResponse.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text\Handler;

use Predis\Connection\CompositeConnectionInterface;
use Predis\Response\Error;

/**
 * Handler for the error response type in the standard Redis wire protocol.
 * It translates the payload to a complex response object for Predis.
 *
 * @see http://redis.io/topics/protocol
 */
class ErrorResponse implements ResponseHandlerInterface
{
    /**
     * {@inheritdoc}
     */
    public function handle(CompositeConnectionInterface $connection, $payload)
    {
        return new Error($payload);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\Handler\IntegerResponse.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text\Handler;

use Predis\CommunicationException;
use Predis\Connection\CompositeConnectionInterface;
use Predis\Protocol\ProtocolException;

/**
 * Handler for the integer response type in the standard Redis wire protocol.
 * It translates the payload an integer or NULL.
 *
 * @see http://redis.io/topics/protocol
 */
class IntegerResponse implements ResponseHandlerInterface
{
    /**
     * {@inheritdoc}
     */
    public function handle(CompositeConnectionInterface $connection, $payload)
    {
        if (is_numeric($payload)) {
            $integer = (int) $payload;

            return $integer == $payload ? $integer : $payload;
        }

        if ($payload !== 'nil') {
            CommunicationException::handle(new ProtocolException(
                $connection, "Cannot parse '$payload' as a valid numeric response [{$connection->getParameters()}]"
            ));
        }

        return;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\Handler\MultiBulkResponse.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text\Handler;

use Predis\CommunicationException;
use Predis\Connection\CompositeConnectionInterface;
use Predis\Protocol\ProtocolException;

/**
 * Handler for the multibulk response type in the standard Redis wire protocol.
 * It returns multibulk responses as PHP arrays.
 *
 * @see http://redis.io/topics/protocol
 */
class MultiBulkResponse implements ResponseHandlerInterface
{
    /**
     * {@inheritdoc}
     */
    public function handle(CompositeConnectionInterface $connection, $payload)
    {
        $length = (int) $payload;

        if ("$length" !== $payload) {
            CommunicationException::handle(new ProtocolException(
                $connection, "Cannot parse '$payload' as a valid length of a multi-bulk response [{$connection->getParameters()}]"
            ));
        }

        if ($length === -1) {
            return;
        }

        $list = [];

        if ($length > 0) {
            $handlersCache = [];
            $reader = $connection->getProtocol()->getResponseReader();

            for ($i = 0; $i < $length; ++$i) {
                $header = $connection->readLine();
                $prefix = $header[0];

                if (isset($handlersCache[$prefix])) {
                    $handler = $handlersCache[$prefix];
                } else {
                    $handler = $reader->getHandler($prefix);
                    $handlersCache[$prefix] = $handler;
                }

                $list[$i] = $handler->handle($connection, substr($header, 1));
            }
        }

        return $list;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\Handler\ResponseHandlerInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text\Handler;

use Predis\Connection\CompositeConnectionInterface;

/**
 * Defines a pluggable handler used to parse a particular type of response.
 */
interface ResponseHandlerInterface
{
    /**
     * Deserializes a response returned by Redis and reads more data from the
     * connection if needed.
     *
     * @param CompositeConnectionInterface $connection Redis connection.
     * @param string                       $payload    String payload.
     *
     * @return mixed
     */
    public function handle(CompositeConnectionInterface $connection, $payload);
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\Handler\StatusResponse.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text\Handler;

use Predis\Connection\CompositeConnectionInterface;
use Predis\Response\Status;

/**
 * Handler for the status response type in the standard Redis wire protocol. It
 * translates certain classes of status response to PHP objects or just returns
 * the payload as a string.
 *
 * @see http://redis.io/topics/protocol
 */
class StatusResponse implements ResponseHandlerInterface
{
    /**
     * {@inheritdoc}
     */
    public function handle(CompositeConnectionInterface $connection, $payload)
    {
        return Status::get($payload);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Protocol\Text\Handler\StreamableMultiBulkResponse.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text\Handler;

use Predis\CommunicationException;
use Predis\Connection\CompositeConnectionInterface;
use Predis\Protocol\ProtocolException;
use Predis\Response\Iterator\MultiBulk as MultiBulkIterator;

/**
 * Handler for the multibulk response type in the standard Redis wire protocol.
 * It returns multibulk responses as iterators that can stream bulk elements.
 *
 * Streamable multibulk responses are not globally supported by the abstractions
 * built-in into Predis, such as transactions or pipelines. Use them with care!
 *
 * @see http://redis.io/topics/protocol
 */
class StreamableMultiBulkResponse implements ResponseHandlerInterface
{
    /**
     * {@inheritdoc}
     */
    public function handle(CompositeConnectionInterface $connection, $payload)
    {
        $length = (int) $payload;

        if ("$length" != $payload) {
            CommunicationException::handle(new ProtocolException(
                $connection, "Cannot parse '$payload' as a valid length for a multi-bulk response [{$connection->getParameters()}]"
            ));
        }

        return new MultiBulkIterator($connection, $length);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\PubSub\AbstractConsumer.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\PubSub;

use Iterator;
use ReturnTypeWillChange;

/**
 * Base implementation of a PUB/SUB consumer abstraction based on PHP iterators.
 */
abstract class AbstractConsumer implements Iterator
{
    public const SUBSCRIBE = 'subscribe';
    public const UNSUBSCRIBE = 'unsubscribe';
    public const PSUBSCRIBE = 'psubscribe';
    public const PUNSUBSCRIBE = 'punsubscribe';
    public const MESSAGE = 'message';
    public const PMESSAGE = 'pmessage';
    public const PONG = 'pong';

    public const STATUS_VALID = 1;       // 0b0001
    public const STATUS_SUBSCRIBED = 2;  // 0b0010
    public const STATUS_PSUBSCRIBED = 4; // 0b0100

    protected $position;
    protected $statusFlags = self::STATUS_VALID;

    /**
     * Automatically stops the consumer when the garbage collector kicks in.
     */
    public function __destruct()
    {
        $this->stop(true);
    }

    /**
     * Checks if the specified flag is valid based on the state of the consumer.
     *
     * @param int $value Flag.
     *
     * @return bool
     */
    protected function isFlagSet($value)
    {
        return ($this->statusFlags & $value) === $value;
    }

    /**
     * Subscribes to the specified channels.
     *
     * @param string ...$channel One or more channel names.
     */
    public function subscribe($channel /* , ... */)
    {
        $this->writeRequest(self::SUBSCRIBE, func_get_args());
        $this->statusFlags |= self::STATUS_SUBSCRIBED;
    }

    /**
     * Unsubscribes from the specified channels.
     *
     * @param string ...$channel One or more channel names.
     */
    public function unsubscribe(...$channel)
    {
        $this->writeRequest(self::UNSUBSCRIBE, func_get_args());
    }

    /**
     * Subscribes to the specified channels using a pattern.
     *
     * @param string ...$pattern One or more channel name patterns.
     */
    public function psubscribe(...$pattern)
    {
        $this->writeRequest(self::PSUBSCRIBE, func_get_args());
        $this->statusFlags |= self::STATUS_PSUBSCRIBED;
    }

    /**
     * Unsubscribes from the specified channels using a pattern.
     *
     * @param string ...$pattern One or more channel name patterns.
     */
    public function punsubscribe(...$pattern)
    {
        $this->writeRequest(self::PUNSUBSCRIBE, func_get_args());
    }

    /**
     * PING the server with an optional payload that will be echoed as a
     * PONG message in the pub/sub loop.
     *
     * @param string $payload Optional PING payload.
     */
    public function ping($payload = null)
    {
        $this->writeRequest('PING', [$payload]);
    }

    /**
     * Closes the context by unsubscribing from all the subscribed channels. The
     * context can be forcefully closed by dropping the underlying connection.
     *
     * @param bool $drop Indicates if the context should be closed by dropping the connection.
     *
     * @return bool Returns false when there are no pending messages.
     */
    public function stop($drop = false)
    {
        if (!$this->valid()) {
            return false;
        }

        if ($drop) {
            $this->invalidate();
            $this->disconnect();
        } else {
            if ($this->isFlagSet(self::STATUS_SUBSCRIBED)) {
                $this->unsubscribe();
            }
            if ($this->isFlagSet(self::STATUS_PSUBSCRIBED)) {
                $this->punsubscribe();
            }
        }

        return !$drop;
    }

    /**
     * Closes the underlying connection when forcing a disconnection.
     */
    abstract protected function disconnect();

    /**
     * Writes a Redis command on the underlying connection.
     *
     * @param string $method    Command ID.
     * @param array  $arguments Arguments for the command.
     */
    abstract protected function writeRequest($method, $arguments);

    /**
     * @return void
     */
    #[ReturnTypeWillChange]
    public function rewind()
    {
        // NOOP
    }

    /**
     * Returns the last message payload retrieved from the server and generated
     * by one of the active subscriptions.
     *
     * @return array
     */
    #[ReturnTypeWillChange]
    public function current()
    {
        return $this->getValue();
    }

    /**
     * @return int|null
     */
    #[ReturnTypeWillChange]
    public function key()
    {
        return $this->position;
    }

    /**
     * @return int|null
     */
    #[ReturnTypeWillChange]
    public function next()
    {
        if ($this->valid()) {
            ++$this->position;
        }

        return $this->position;
    }

    /**
     * Checks if the the consumer is still in a valid state to continue.
     *
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function valid()
    {
        $isValid = $this->isFlagSet(self::STATUS_VALID);
        $subscriptionFlags = self::STATUS_SUBSCRIBED | self::STATUS_PSUBSCRIBED;
        $hasSubscriptions = ($this->statusFlags & $subscriptionFlags) > 0;

        return $isValid && $hasSubscriptions;
    }

    /**
     * Resets the state of the consumer.
     */
    protected function invalidate()
    {
        $this->statusFlags = 0;    // 0b0000;
    }

    /**
     * Waits for a new message from the server generated by one of the active
     * subscriptions and returns it when available.
     *
     * @return array
     */
    abstract protected function getValue();
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\PubSub\Consumer.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\PubSub;

use Predis\ClientException;
use Predis\ClientInterface;
use Predis\Command\Command;
use Predis\Connection\Cluster\ClusterInterface;
use Predis\NotSupportedException;

/**
 * PUB/SUB consumer.
 */
class Consumer extends AbstractConsumer
{
    protected $client;
    protected $options;

    /**
     * @param ClientInterface $client  Client instance used by the consumer.
     * @param array|null      $options Options for the consumer initialization.
     */
    public function __construct(ClientInterface $client, ?array $options = null)
    {
        $this->checkCapabilities($client);

        $this->options = $options ?: [];
        $this->client = $client;

        $this->genericSubscribeInit('subscribe');
        $this->genericSubscribeInit('psubscribe');
    }

    /**
     * Returns the underlying client instance used by the pub/sub iterator.
     *
     * @return ClientInterface
     */
    public function getClient()
    {
        return $this->client;
    }

    /**
     * Checks if the client instance satisfies the required conditions needed to
     * initialize a PUB/SUB consumer.
     *
     * @param ClientInterface $client Client instance used by the consumer.
     *
     * @throws NotSupportedException
     */
    protected function checkCapabilities(ClientInterface $client)
    {
        if ($client->getConnection() instanceof ClusterInterface) {
            throw new NotSupportedException(
                'Cannot initialize a PUB/SUB consumer over cluster connections.'
            );
        }

        $commands = ['publish', 'subscribe', 'unsubscribe', 'psubscribe', 'punsubscribe'];

        if (!$client->getCommandFactory()->supports(...$commands)) {
            throw new NotSupportedException(
                'PUB/SUB commands are not supported by the current command factory.'
            );
        }
    }

    /**
     * This method shares the logic to handle both SUBSCRIBE and PSUBSCRIBE.
     *
     * @param string $subscribeAction Type of subscription.
     */
    protected function genericSubscribeInit($subscribeAction)
    {
        if (isset($this->options[$subscribeAction])) {
            $this->$subscribeAction($this->options[$subscribeAction]);
        }
    }

    /**
     * {@inheritdoc}
     */
    protected function writeRequest($method, $arguments)
    {
        $this->client->getConnection()->writeRequest(
            $this->client->createCommand($method,
                Command::normalizeArguments($arguments)
            )
        );
    }

    /**
     * {@inheritdoc}
     */
    protected function disconnect()
    {
        $this->client->disconnect();
    }

    /**
     * {@inheritdoc}
     */
    protected function getValue()
    {
        $response = $this->client->getConnection()->read();

        switch ($response[0]) {
            case self::SUBSCRIBE:
            case self::UNSUBSCRIBE:
            case self::PSUBSCRIBE:
            case self::PUNSUBSCRIBE:
                if ($response[2] === 0) {
                    $this->invalidate();
                }
                // The missing break here is intentional as we must process
                // subscriptions and unsubscriptions as standard messages.
                // no break

            case self::MESSAGE:
                return (object) [
                    'kind' => $response[0],
                    'channel' => $response[1],
                    'payload' => $response[2],
                ];

            case self::PMESSAGE:
                return (object) [
                    'kind' => $response[0],
                    'pattern' => $response[1],
                    'channel' => $response[2],
                    'payload' => $response[3],
                ];

            case self::PONG:
                return (object) [
                    'kind' => $response[0],
                    'payload' => $response[1],
                ];

            default:
                throw new ClientException(
                    "Unknown message type '{$response[0]}' received in the PUB/SUB context."
                );
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\PubSub\DispatcherLoop.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\PubSub;

use InvalidArgumentException;

/**
 * Method-dispatcher loop built around the client-side abstraction of a Redis
 * PUB / SUB context.
 */
class DispatcherLoop
{
    private $pubsub;

    protected $callbacks;
    protected $defaultCallback;
    protected $subscriptionCallback;

    /**
     * @param Consumer $pubsub PubSub consumer instance used by the loop.
     */
    public function __construct(Consumer $pubsub)
    {
        $this->callbacks = [];
        $this->pubsub = $pubsub;
    }

    /**
     * Checks if the passed argument is a valid callback.
     *
     * @param mixed $callable A callback.
     *
     * @throws InvalidArgumentException
     */
    protected function assertCallback($callable)
    {
        if (!is_callable($callable)) {
            throw new InvalidArgumentException('The given argument must be a callable object.');
        }
    }

    /**
     * Returns the underlying PUB / SUB context.
     *
     * @return Consumer
     */
    public function getPubSubConsumer()
    {
        return $this->pubsub;
    }

    /**
     * Sets a callback that gets invoked upon new subscriptions.
     *
     * @param mixed $callable A callback.
     */
    public function subscriptionCallback($callable = null)
    {
        if (isset($callable)) {
            $this->assertCallback($callable);
        }

        $this->subscriptionCallback = $callable;
    }

    /**
     * Sets a callback that gets invoked when a message is received on a
     * channel that does not have an associated callback.
     *
     * @param mixed $callable A callback.
     */
    public function defaultCallback($callable = null)
    {
        if (isset($callable)) {
            $this->assertCallback($callable);
        }

        $this->subscriptionCallback = $callable;
    }

    /**
     * Binds a callback to a channel.
     *
     * @param string   $channel  Channel name.
     * @param callable $callback A callback.
     */
    public function attachCallback($channel, $callback)
    {
        $callbackName = $this->getPrefixKeys() . $channel;

        $this->assertCallback($callback);
        $this->callbacks[$callbackName] = $callback;
        $this->pubsub->subscribe($channel);
    }

    /**
     * Stops listening to a channel and removes the associated callback.
     *
     * @param string $channel Redis channel.
     */
    public function detachCallback($channel)
    {
        $callbackName = $this->getPrefixKeys() . $channel;

        if (isset($this->callbacks[$callbackName])) {
            unset($this->callbacks[$callbackName]);
            $this->pubsub->unsubscribe($channel);
        }
    }

    /**
     * Starts the dispatcher loop.
     */
    public function run()
    {
        foreach ($this->pubsub as $message) {
            $kind = $message->kind;

            if ($kind !== Consumer::MESSAGE && $kind !== Consumer::PMESSAGE) {
                if (isset($this->subscriptionCallback)) {
                    $callback = $this->subscriptionCallback;
                    call_user_func($callback, $message, $this);
                }

                continue;
            }

            if (isset($this->callbacks[$message->channel])) {
                $callback = $this->callbacks[$message->channel];
                call_user_func($callback, $message->payload, $this);
            } elseif (isset($this->defaultCallback)) {
                $callback = $this->defaultCallback;
                call_user_func($callback, $message, $this);
            }
        }
    }

    /**
     * Terminates the dispatcher loop.
     */
    public function stop()
    {
        $this->pubsub->stop();
    }

    /**
     * Return the prefix used for keys.
     *
     * @return string
     */
    protected function getPrefixKeys()
    {
        $options = $this->pubsub->getClient()->getOptions();

        if (isset($options->prefix)) {
            return $options->prefix->getPrefix();
        }

        return '';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\PubSub\RelayConsumer.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\PubSub;

use Predis\NotSupportedException;

/**
 * Relay PUB/SUB consumer.
 */
class RelayConsumer extends Consumer
{
    /**
     * Subscribes to the specified channels.
     *
     * @param string   ...$channel One or more channel names.
     * @param callable $callback   The message callback.
     */
    public function subscribe($channel) // @phpstan-ignore-line
    {
        $channels = func_get_args();
        $callback = array_pop($channels);

        $this->statusFlags |= self::STATUS_SUBSCRIBED;

        $command = $this->client->createCommand('subscribe', [
            $channels,
            function ($relay, $channel, $message) use ($callback) {
                $callback((object) [
                    'kind' => is_null($message) ? self::SUBSCRIBE : self::MESSAGE,
                    'channel' => $channel,
                    'payload' => $message,
                ], $relay);
            },
        ]);

        $this->client->getConnection()->executeCommand($command);

        $this->invalidate();
    }

    /**
     * Subscribes to the specified channels using a pattern.
     *
     * @param string   ...$pattern One or more channel name patterns.
     * @param callable $callback   The message callback.
     */
    public function psubscribe(...$pattern) // @phpstan-ignore-line
    {
        $patterns = func_get_args();
        $callback = array_pop($patterns);

        $this->statusFlags |= self::STATUS_PSUBSCRIBED;

        $command = $this->client->createCommand('psubscribe', [
            $patterns,
            function ($relay, $pattern, $channel, $message) use ($callback) {
                $callback((object) [
                    'kind' => is_null($message) ? self::PSUBSCRIBE : self::PMESSAGE,
                    'pattern' => $pattern,
                    'channel' => $channel,
                    'payload' => $message,
                ], $relay);
            },
        ]);

        $this->client->getConnection()->executeCommand($command);

        $this->invalidate();
    }

    /**
     * {@inheritDoc}
     */
    protected function genericSubscribeInit($subscribeAction)
    {
        if (isset($this->options[$subscribeAction])) {
            throw new NotSupportedException('Relay does not support Pub/Sub constructor options.');
        }
    }

    /**
     * {@inheritDoc}
     */
    public function ping($payload = null)
    {
        throw new NotSupportedException('Relay does not support PING in Pub/Sub.');
    }

    /**
     * {@inheritDoc}
     */
    public function stop($drop = false)
    {
        return false;
    }

    /**
     * {@inheritDoc}
     */
    public function __destruct()
    {
        // NOOP
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Replication\MissingMasterException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Replication;

use Predis\ClientException;

/**
 * Exception class that identifies when master is missing in a replication setup.
 */
class MissingMasterException extends ClientException
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Replication\ReplicationStrategy.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Replication;

use Predis\Command\CommandInterface;
use Predis\NotSupportedException;

/**
 * Defines a strategy for master/slave replication.
 */
class ReplicationStrategy
{
    protected $disallowed;
    protected $readonly;
    protected $readonlySHA1;
    protected $loadBalancing = true;

    public function __construct()
    {
        $this->disallowed = $this->getDisallowedOperations();
        $this->readonly = $this->getReadOnlyOperations();
        $this->readonlySHA1 = [];
    }

    /**
     * Returns if the specified command will perform a read-only operation
     * on Redis or not.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return bool
     * @throws NotSupportedException
     */
    public function isReadOperation(CommandInterface $command)
    {
        if (!$this->loadBalancing) {
            return false;
        }

        if (isset($this->disallowed[$id = $command->getId()])) {
            throw new NotSupportedException(
                "The command '$id' is not allowed in replication mode."
            );
        }

        if (isset($this->readonly[$id])) {
            if (true === $readonly = $this->readonly[$id]) {
                return true;
            }

            return call_user_func($readonly, $command);
        }

        if (($eval = $id === 'EVAL') || $id === 'EVALSHA') {
            $argument = $command->getArgument(0);
            $sha1 = $eval ? sha1(strval($argument)) : $argument;

            if (isset($this->readonlySHA1[$sha1])) {
                if (true === $readonly = $this->readonlySHA1[$sha1]) {
                    return true;
                }

                return call_user_func($readonly, $command);
            }
        }

        return false;
    }

    /**
     * Returns if the specified command is not allowed for execution in a master
     * / slave replication context.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return bool
     */
    public function isDisallowedOperation(CommandInterface $command)
    {
        return isset($this->disallowed[$command->getId()]);
    }

    /**
     * Checks if BITFIELD performs a read-only operation by looking for certain
     * SET and INCRYBY modifiers in the arguments array of the command.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return bool
     */
    protected function isBitfieldReadOnly(CommandInterface $command)
    {
        $arguments = $command->getArguments();
        $argc = count($arguments);

        if ($argc >= 2) {
            for ($i = 1; $i < $argc; ++$i) {
                $argument = strtoupper($arguments[$i]);
                if ($argument === 'SET' || $argument === 'INCRBY') {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Checks if a GEORADIUS command is a readable operation by parsing the
     * arguments array of the specified command instance.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return bool
     */
    protected function isGeoradiusReadOnly(CommandInterface $command)
    {
        $arguments = $command->getArguments();
        $argc = count($arguments);
        $startIndex = $command->getId() === 'GEORADIUS' ? 5 : 4;

        if ($argc > $startIndex) {
            for ($i = $startIndex; $i < $argc; ++$i) {
                $argument = strtoupper($arguments[$i]);
                if ($argument === 'STORE' || $argument === 'STOREDIST') {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Marks a command as a read-only operation.
     *
     * When the behavior of a command can be decided only at runtime depending
     * on its arguments, a callable object can be provided to dynamically check
     * if the specified command performs a read or a write operation.
     *
     * @param string $commandID Command ID.
     * @param mixed  $readonly  A boolean value or a callable object.
     */
    public function setCommandReadOnly($commandID, $readonly = true)
    {
        $commandID = strtoupper($commandID);

        if ($readonly) {
            $this->readonly[$commandID] = $readonly;
        } else {
            unset($this->readonly[$commandID]);
        }
    }

    /**
     * Marks a Lua script for EVAL and EVALSHA as a read-only operation. When
     * the behaviour of a script can be decided only at runtime depending on
     * its arguments, a callable object can be provided to dynamically check
     * if the passed instance of EVAL or EVALSHA performs write operations or
     * not.
     *
     * @param string $script   Body of the Lua script.
     * @param mixed  $readonly A boolean value or a callable object.
     */
    public function setScriptReadOnly($script, $readonly = true)
    {
        $sha1 = sha1($script);

        if ($readonly) {
            $this->readonlySHA1[$sha1] = $readonly;
        } else {
            unset($this->readonlySHA1[$sha1]);
        }
    }

    /**
     * Returns the default list of disallowed commands.
     *
     * @return array
     */
    protected function getDisallowedOperations()
    {
        return [
            'SHUTDOWN' => true,
            'INFO' => true,
            'DBSIZE' => true,
            'LASTSAVE' => true,
            'CONFIG' => true,
            'MONITOR' => true,
            'SLAVEOF' => true,
            'SAVE' => true,
            'BGSAVE' => true,
            'BGREWRITEAOF' => true,
            'SLOWLOG' => true,
        ];
    }

    /**
     * Returns the default list of commands performing read-only operations.
     *
     * @return array
     */
    protected function getReadOnlyOperations()
    {
        return [
            'EXISTS' => true,
            'TYPE' => true,
            'KEYS' => true,
            'SCAN' => true,
            'RANDOMKEY' => true,
            'TTL' => true,
            'GET' => true,
            'MGET' => true,
            'SUBSTR' => true,
            'STRLEN' => true,
            'GETRANGE' => true,
            'GETBIT' => true,
            'LLEN' => true,
            'LRANGE' => true,
            'LINDEX' => true,
            'SCARD' => true,
            'SISMEMBER' => true,
            'SINTER' => true,
            'SUNION' => true,
            'SDIFF' => true,
            'SMEMBERS' => true,
            'SSCAN' => true,
            'SRANDMEMBER' => true,
            'ZRANGE' => true,
            'ZREVRANGE' => true,
            'ZRANGEBYSCORE' => true,
            'ZREVRANGEBYSCORE' => true,
            'ZCARD' => true,
            'ZSCORE' => true,
            'ZCOUNT' => true,
            'ZRANK' => true,
            'ZREVRANK' => true,
            'ZSCAN' => true,
            'ZLEXCOUNT' => true,
            'ZRANGEBYLEX' => true,
            'ZREVRANGEBYLEX' => true,
            'HGET' => true,
            'HMGET' => true,
            'HEXISTS' => true,
            'HLEN' => true,
            'HKEYS' => true,
            'HVALS' => true,
            'HGETALL' => true,
            'HSCAN' => true,
            'HSTRLEN' => true,
            'PING' => true,
            'AUTH' => true,
            'SELECT' => true,
            'ECHO' => true,
            'QUIT' => true,
            'OBJECT' => true,
            'BITCOUNT' => true,
            'BITPOS' => true,
            'TIME' => true,
            'PFCOUNT' => true,
            'BITFIELD' => [$this, 'isBitfieldReadOnly'],
            'GEOHASH' => true,
            'GEOPOS' => true,
            'GEODIST' => true,
            'GEORADIUS' => [$this, 'isGeoradiusReadOnly'],
            'GEORADIUSBYMEMBER' => [$this, 'isGeoradiusReadOnly'],
        ];
    }

    /**
     * Disables reads to slaves when using
     * a replication topology.
     *
     * @return self
     */
    public function disableLoadBalancing(): self
    {
        $this->loadBalancing = false;

        return $this;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Replication\RoleException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Replication;

use Predis\CommunicationException;

/**
 * Exception class that identifies a role mismatch when connecting to node
 * managed by redis-sentinel.
 */
class RoleException extends CommunicationException
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Response\Error.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response;

/**
 * Represents an error returned by Redis (-ERR responses) during the execution
 * of a command on the server.
 */
class Error implements ErrorInterface
{
    private $message;

    /**
     * @param string $message Error message returned by Redis
     */
    public function __construct($message)
    {
        $this->message = $message;
    }

    /**
     * {@inheritdoc}
     */
    public function getMessage()
    {
        return $this->message;
    }

    /**
     * {@inheritdoc}
     */
    public function getErrorType()
    {
        [$errorType] = explode(' ', $this->getMessage(), 2);

        return $errorType;
    }

    /**
     * Converts the object to its string representation.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->getMessage();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Response\ErrorInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response;

/**
 * Represents an error returned by Redis (responses identified by "-" in the
 * Redis protocol) during the execution of an operation on the server.
 */
interface ErrorInterface extends ResponseInterface
{
    /**
     * Returns the error message.
     *
     * @return string
     */
    public function getMessage();

    /**
     * Returns the error type (e.g. ERR, ASK, MOVED).
     *
     * @return string
     */
    public function getErrorType();
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Response\ResponseInterface.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response;

/**
 * Represents a complex response object from Redis.
 */
interface ResponseInterface
{
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Response\ServerException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response;

use Predis\PredisException;

/**
 * Exception class that identifies server-side Redis errors.
 */
class ServerException extends PredisException implements ErrorInterface
{
    /**
     * Gets the type of the error returned by Redis.
     *
     * @return string
     */
    public function getErrorType()
    {
        [$errorType] = explode(' ', $this->getMessage(), 2);

        return $errorType;
    }

    /**
     * Converts the exception to an instance of Predis\Response\Error.
     *
     * @return Error
     */
    public function toErrorResponse()
    {
        return new Error($this->getMessage());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Response\Status.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response;

/**
 * Represents a status response returned by Redis.
 */
class Status implements ResponseInterface
{
    private static $OK;
    private static $QUEUED;

    private $payload;

    /**
     * @param string $payload Payload of the status response as returned by Redis.
     */
    public function __construct($payload)
    {
        $this->payload = $payload;
    }

    /**
     * Converts the response object to its string representation.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->payload;
    }

    /**
     * Returns the payload of status response.
     *
     * @return string
     */
    public function getPayload()
    {
        return $this->payload;
    }

    /**
     * Returns an instance of a status response object.
     *
     * Common status responses such as OK or QUEUED are cached in order to lower
     * the global memory usage especially when using pipelines.
     *
     * @param string $payload Status response payload.
     *
     * @return self
     */
    public static function get($payload)
    {
        switch ($payload) {
            case 'OK':
            case 'QUEUED':
                if (isset(self::$$payload)) {
                    return self::$$payload;
                }

                return self::$$payload = new self($payload);

            default:
                return new self($payload);
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Response\Iterator\MultiBulk.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response\Iterator;

use Predis\Connection\NodeConnectionInterface;

/**
 * Streamable multibulk response.
 */
class MultiBulk extends MultiBulkIterator
{
    private $connection;

    /**
     * @param NodeConnectionInterface $connection Connection to Redis.
     * @param int                     $size       Number of elements of the multibulk response.
     */
    public function __construct(NodeConnectionInterface $connection, $size)
    {
        $this->connection = $connection;
        $this->size = $size;
        $this->position = 0;
        $this->current = $size > 0 ? $this->getValue() : null;
    }

    /**
     * Handles the synchronization of the client with the Redis protocol when
     * the garbage collector kicks in (e.g. when the iterator goes out of the
     * scope of a foreach or it is unset).
     */
    public function __destruct()
    {
        $this->drop(true);
    }

    /**
     * Drop queued elements that have not been read from the connection either
     * by consuming the rest of the multibulk response or quickly by closing the
     * underlying connection.
     *
     * @param bool $disconnect Consume the iterator or drop the connection.
     */
    public function drop($disconnect = false)
    {
        if ($disconnect) {
            if ($this->valid()) {
                $this->position = $this->size;
                $this->connection->disconnect();
            }
        } else {
            while ($this->valid()) {
                $this->next();
            }
        }
    }

    /**
     * Reads the next item of the multibulk response from the connection.
     *
     * @return mixed
     */
    protected function getValue()
    {
        return $this->connection->read();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Response\Iterator\MultiBulkIterator.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response\Iterator;

use Countable;
use Iterator;
use Predis\Response\ResponseInterface;
use ReturnTypeWillChange;

/**
 * Iterator that abstracts the access to multibulk responses allowing them to be
 * consumed in a streamable fashion without keeping the whole payload in memory.
 *
 * This iterator does not support rewinding which means that the iteration, once
 * consumed, cannot be restarted.
 *
 * Always make sure that the whole iteration is consumed (or dropped) to prevent
 * protocol desynchronization issues.
 */
abstract class MultiBulkIterator implements Iterator, Countable, ResponseInterface
{
    protected $current;
    protected $position;
    protected $size;

    /**
     * @return void
     */
    #[ReturnTypeWillChange]
    public function rewind()
    {
        // NOOP
    }

    /**
     * @return mixed
     */
    #[ReturnTypeWillChange]
    public function current()
    {
        return $this->current;
    }

    /**
     * @return int|null
     */
    #[ReturnTypeWillChange]
    public function key()
    {
        return $this->position;
    }

    /**
     * @return void
     */
    #[ReturnTypeWillChange]
    public function next()
    {
        if (++$this->position < $this->size) {
            $this->current = $this->getValue();
        }
    }

    /**
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function valid()
    {
        return $this->position < $this->size;
    }

    /**
     * Returns the number of items comprising the whole multibulk response.
     *
     * This method should be used instead of iterator_count() to get the size of
     * the current multibulk response since the former consumes the iteration to
     * count the number of elements, but our iterators do not support rewinding.
     *
     * @return int
     */
    #[ReturnTypeWillChange]
    public function count()
    {
        return $this->size;
    }

    /**
     * Returns the current position of the iterator.
     *
     * @return int
     */
    public function getPosition()
    {
        return $this->position;
    }

    /**
     * {@inheritdoc}
     */
    abstract protected function getValue();
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Response\Iterator\MultiBulkTuple.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response\Iterator;

use InvalidArgumentException;
use OuterIterator;
use ReturnTypeWillChange;
use UnexpectedValueException;

/**
 * Outer iterator consuming streamable multibulk responses by yielding tuples of
 * keys and values.
 *
 * This wrapper is useful for responses to commands such as `HGETALL` that can
 * be iterator as $key => $value pairs.
 */
class MultiBulkTuple extends MultiBulk implements OuterIterator
{
    private $iterator;

    /**
     * @param MultiBulk $iterator Inner multibulk response iterator.
     */
    public function __construct(MultiBulk $iterator)
    {
        $this->checkPreconditions($iterator);

        $this->size = count($iterator) / 2;
        $this->iterator = $iterator;
        $this->position = $iterator->getPosition();
        $this->current = $this->size > 0 ? $this->getValue() : null;
    }

    /**
     * Checks for valid preconditions.
     *
     * @param MultiBulk $iterator Inner multibulk response iterator.
     *
     * @throws InvalidArgumentException
     * @throws UnexpectedValueException
     */
    protected function checkPreconditions(MultiBulk $iterator)
    {
        if ($iterator->getPosition() !== 0) {
            throw new InvalidArgumentException(
                'Cannot initialize a tuple iterator using an already initiated iterator.'
            );
        }

        if (($size = count($iterator)) % 2 !== 0) {
            throw new UnexpectedValueException('Invalid response size for a tuple iterator.');
        }
    }

    /**
     * @return MultiBulk
     */
    #[ReturnTypeWillChange]
    public function getInnerIterator()
    {
        return $this->iterator;
    }

    /**
     * {@inheritdoc}
     */
    public function __destruct()
    {
        $this->iterator->drop(true);
    }

    /**
     * {@inheritdoc}
     */
    protected function getValue()
    {
        $k = $this->iterator->current();
        $this->iterator->next();

        $v = $this->iterator->current();
        $this->iterator->next();

        return [$k, $v];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Session\Handler.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Session;

use Predis\ClientInterface;
use ReturnTypeWillChange;
use SessionHandlerInterface;

/**
 * Session handler class that relies on Predis\Client to store PHP's sessions
 * data into one or multiple Redis servers.
 *
 * This class is mostly intended for PHP 5.4 but it can be used under PHP 5.3
 * provided that a polyfill for `SessionHandlerInterface` is defined by either
 * you or an external package such as `symfony/http-foundation`.
 */
class Handler implements SessionHandlerInterface
{
    protected $client;
    protected $ttl;

    /**
     * @param ClientInterface $client  Fully initialized client instance.
     * @param array           $options Session handler options.
     */
    public function __construct(ClientInterface $client, array $options = [])
    {
        $this->client = $client;

        if (isset($options['gc_maxlifetime'])) {
            $this->ttl = (int) $options['gc_maxlifetime'];
        } else {
            $this->ttl = ini_get('session.gc_maxlifetime');
        }
    }

    /**
     * Registers this instance as the current session handler.
     */
    public function register()
    {
        session_set_save_handler($this, true);
    }

    /**
     * @param  string $save_path
     * @param  string $session_id
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function open($save_path, $session_id)
    {
        // NOOP
        return true;
    }

    /**
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function close()
    {
        // NOOP
        return true;
    }

    /**
     * @param  int  $maxlifetime
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function gc($maxlifetime)
    {
        // NOOP
        return true;
    }

    /**
     * @param  string $session_id
     * @return string
     */
    #[ReturnTypeWillChange]
    public function read($session_id)
    {
        if ($data = $this->client->get($session_id)) {
            return $data;
        }

        return '';
    }

    /**
     * @param  string $session_id
     * @param  string $session_data
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function write($session_id, $session_data)
    {
        $this->client->setex($session_id, $this->ttl, $session_data);

        return true;
    }

    /**
     * @param  string $session_id
     * @return bool
     */
    #[ReturnTypeWillChange]
    public function destroy($session_id)
    {
        $this->client->del($session_id);

        return true;
    }

    /**
     * Returns the underlying client instance.
     *
     * @return ClientInterface
     */
    public function getClient()
    {
        return $this->client;
    }

    /**
     * Returns the session max lifetime value.
     *
     * @return int
     */
    public function getMaxLifeTime()
    {
        return $this->ttl;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Transaction\AbortedMultiExecException.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Transaction;

use Predis\PredisException;

/**
 * Exception class that identifies a MULTI / EXEC transaction aborted by Redis.
 */
class AbortedMultiExecException extends PredisException
{
    private $transaction;

    /**
     * @param MultiExec $transaction Transaction that generated the exception.
     * @param string    $message     Error message.
     * @param int       $code        Error code.
     */
    public function __construct(MultiExec $transaction, $message, $code = 0)
    {
        parent::__construct($message, is_null($code) ? 0 : $code);

        $this->transaction = $transaction;
    }

    /**
     * Returns the transaction that generated the exception.
     *
     * @return MultiExec
     */
    public function getTransaction()
    {
        return $this->transaction;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Transaction\MultiExec.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Transaction;

use Exception;
use InvalidArgumentException;
use Predis\ClientContextInterface;
use Predis\ClientException;
use Predis\ClientInterface;
use Predis\Command\CommandInterface;
use Predis\CommunicationException;
use Predis\Connection\Cluster\ClusterInterface;
use Predis\Connection\RelayConnection;
use Predis\NotSupportedException;
use Predis\Protocol\ProtocolException;
use Predis\Response\Error;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use Predis\Response\ServerException;
use Predis\Response\Status as StatusResponse;
use Relay\Exception as RelayException;
use Relay\Relay;
use SplQueue;

/**
 * Client-side abstraction of a Redis transaction based on MULTI / EXEC.
 *
 * {@inheritdoc}
 */
class MultiExec implements ClientContextInterface
{
    private $state;

    protected $client;
    protected $commands;
    protected $exceptions = true;
    protected $attempts = 0;
    protected $watchKeys = [];
    protected $modeCAS = false;

    /**
     * @param ClientInterface $client  Client instance used by the transaction.
     * @param array|null      $options Initialization options.
     */
    public function __construct(ClientInterface $client, ?array $options = null)
    {
        $this->assertClient($client);

        $this->client = $client;
        $this->state = new MultiExecState();

        $this->configure($client, $options ?: []);
        $this->reset();
    }

    /**
     * Checks if the passed client instance satisfies the required conditions
     * needed to initialize the transaction object.
     *
     * @param ClientInterface $client Client instance used by the transaction object.
     *
     * @throws NotSupportedException
     */
    private function assertClient(ClientInterface $client)
    {
        if ($client->getConnection() instanceof ClusterInterface) {
            throw new NotSupportedException(
                'Cannot initialize a MULTI/EXEC transaction over cluster connections.'
            );
        }

        if (!$client->getCommandFactory()->supports('MULTI', 'EXEC', 'DISCARD')) {
            throw new NotSupportedException(
                'MULTI, EXEC and DISCARD are not supported by the current command factory.'
            );
        }
    }

    /**
     * Configures the transaction using the provided options.
     *
     * @param ClientInterface $client  Underlying client instance.
     * @param array           $options Array of options for the transaction.
     **/
    protected function configure(ClientInterface $client, array $options)
    {
        if (isset($options['exceptions'])) {
            $this->exceptions = (bool) $options['exceptions'];
        } else {
            $this->exceptions = $client->getOptions()->exceptions;
        }

        if (isset($options['cas'])) {
            $this->modeCAS = (bool) $options['cas'];
        }

        if (isset($options['watch']) && $keys = $options['watch']) {
            $this->watchKeys = $keys;
        }

        if (isset($options['retry'])) {
            $this->attempts = (int) $options['retry'];
        }
    }

    /**
     * Resets the state of the transaction.
     */
    protected function reset()
    {
        $this->state->reset();
        $this->commands = new SplQueue();
    }

    /**
     * Initializes the transaction context.
     */
    protected function initialize()
    {
        if ($this->state->isInitialized()) {
            return;
        }

        if ($this->modeCAS) {
            $this->state->flag(MultiExecState::CAS);
        }

        if ($this->watchKeys) {
            $this->watch($this->watchKeys);
        }

        $cas = $this->state->isCAS();
        $discarded = $this->state->isDiscarded();

        if (!$cas || ($cas && $discarded)) {
            $this->call('MULTI');

            if ($discarded) {
                $this->state->unflag(MultiExecState::CAS);
            }
        }

        $this->state->unflag(MultiExecState::DISCARDED);
        $this->state->flag(MultiExecState::INITIALIZED);
    }

    /**
     * Dynamically invokes a Redis command with the specified arguments.
     *
     * @param string $method    Command ID.
     * @param array  $arguments Arguments for the command.
     *
     * @return mixed
     */
    public function __call($method, $arguments)
    {
        return $this->executeCommand(
            $this->client->createCommand($method, $arguments)
        );
    }

    /**
     * Executes a Redis command bypassing the transaction logic.
     *
     * @param string $commandID Command ID.
     * @param array  $arguments Arguments for the command.
     *
     * @return mixed
     * @throws ServerException
     */
    protected function call($commandID, array $arguments = [])
    {
        try {
            $response = $this->client->executeCommand(
                $this->client->createCommand($commandID, $arguments)
            );
        } catch (ServerException $exception) {
            if (!$this->client->getConnection() instanceof RelayConnection) {
                throw $exception;
            }

            if (strcasecmp($commandID, 'EXEC') != 0) {
                throw $exception;
            }

            if (!strpos($exception->getMessage(), 'RELAY_ERR_REDIS')) {
                throw $exception;
            }

            return null;
        }

        if ($response instanceof ErrorResponseInterface) {
            throw new ServerException($response->getMessage());
        }

        return $response;
    }

    /**
     * Executes the specified Redis command.
     *
     * @param CommandInterface $command Command instance.
     *
     * @return $this|mixed
     * @throws AbortedMultiExecException
     * @throws CommunicationException
     */
    public function executeCommand(CommandInterface $command)
    {
        $this->initialize();

        if ($this->state->isCAS()) {
            return $this->client->executeCommand($command);
        }

        $response = $this->client->getConnection()->executeCommand($command);

        if ($response instanceof StatusResponse && $response == 'QUEUED') {
            $this->commands->enqueue($command);
        } elseif ($response instanceof Relay) {
            $this->commands->enqueue($command);
        } elseif ($response instanceof ErrorResponseInterface) {
            throw new AbortedMultiExecException($this, $response->getMessage());
        } else {
            $this->onProtocolError('The server did not return a +QUEUED status response.');
        }

        return $this;
    }

    /**
     * Executes WATCH against one or more keys.
     *
     * @param string|array $keys One or more keys.
     *
     * @return mixed
     * @throws NotSupportedException
     * @throws ClientException
     */
    public function watch($keys)
    {
        if (!$this->client->getCommandFactory()->supports('WATCH')) {
            throw new NotSupportedException('WATCH is not supported by the current command factory.');
        }

        if ($this->state->isWatchAllowed()) {
            throw new ClientException('Sending WATCH after MULTI is not allowed.');
        }

        $response = $this->call('WATCH', is_array($keys) ? $keys : [$keys]);
        $this->state->flag(MultiExecState::WATCH);

        return $response;
    }

    /**
     * Finalizes the transaction by executing MULTI on the server.
     *
     * @return MultiExec
     */
    public function multi()
    {
        if ($this->state->check(MultiExecState::INITIALIZED | MultiExecState::CAS)) {
            $this->state->unflag(MultiExecState::CAS);
            $this->call('MULTI');
        } else {
            $this->initialize();
        }

        return $this;
    }

    /**
     * Executes UNWATCH.
     *
     * @return MultiExec
     * @throws NotSupportedException
     */
    public function unwatch()
    {
        if (!$this->client->getCommandFactory()->supports('UNWATCH')) {
            throw new NotSupportedException(
                'UNWATCH is not supported by the current command factory.'
            );
        }

        $this->state->unflag(MultiExecState::WATCH);
        $this->__call('UNWATCH', []);

        return $this;
    }

    /**
     * Resets the transaction by UNWATCH-ing the keys that are being WATCHed and
     * DISCARD-ing pending commands that have been already sent to the server.
     *
     * @return MultiExec
     */
    public function discard()
    {
        if ($this->state->isInitialized()) {
            $this->call($this->state->isCAS() ? 'UNWATCH' : 'DISCARD');

            $this->reset();
            $this->state->flag(MultiExecState::DISCARDED);
        }

        return $this;
    }

    /**
     * Executes the whole transaction.
     *
     * @return mixed
     */
    public function exec()
    {
        return $this->execute();
    }

    /**
     * Checks the state of the transaction before execution.
     *
     * @param mixed $callable Callback for execution.
     *
     * @throws InvalidArgumentException
     * @throws ClientException
     */
    private function checkBeforeExecution($callable)
    {
        if ($this->state->isExecuting()) {
            throw new ClientException(
                'Cannot invoke "execute" or "exec" inside an active transaction context.'
            );
        }

        if ($callable) {
            if (!is_callable($callable)) {
                throw new InvalidArgumentException('The argument must be a callable object.');
            }

            if (!$this->commands->isEmpty()) {
                $this->discard();

                throw new ClientException(
                    'Cannot execute a transaction block after using fluent interface.'
                );
            }
        } elseif ($this->attempts) {
            $this->discard();

            throw new ClientException(
                'Automatic retries are supported only when a callable block is provided.'
            );
        }
    }

    /**
     * Handles the actual execution of the whole transaction.
     *
     * @param mixed $callable Optional callback for execution.
     *
     * @return array
     * @throws CommunicationException
     * @throws AbortedMultiExecException
     * @throws ServerException
     */
    public function execute($callable = null)
    {
        $this->checkBeforeExecution($callable);

        $execResponse = null;
        $attempts = $this->attempts;

        do {
            if ($callable) {
                $this->executeTransactionBlock($callable);
            }

            if ($this->commands->isEmpty()) {
                if ($this->state->isWatching()) {
                    $this->discard();
                }

                return;
            }

            $execResponse = $this->call('EXEC');

            // The additional `false` check is needed for Relay,
            // let's hope it won't break anything
            if ($execResponse === null || $execResponse === false) {
                if ($attempts === 0) {
                    throw new AbortedMultiExecException(
                        $this, 'The current transaction has been aborted by the server.'
                    );
                }

                $this->reset();

                continue;
            }

            break;
        } while ($attempts-- > 0);

        $response = [];
        $commands = $this->commands;
        $size = count($execResponse);

        if ($size !== count($commands)) {
            $this->onProtocolError('EXEC returned an unexpected number of response items.');
        }

        for ($i = 0; $i < $size; ++$i) {
            $cmdResponse = $execResponse[$i];

            if ($this->exceptions && $cmdResponse instanceof ErrorResponseInterface) {
                throw new ServerException($cmdResponse->getMessage());
            }

            if ($cmdResponse instanceof RelayException) {
                if ($this->exceptions) {
                    throw new ServerException($cmdResponse->getMessage(), $cmdResponse->getCode(), $cmdResponse);
                }

                $commands->dequeue();
                $response[$i] = new Error($cmdResponse->getMessage());
                continue;
            }

            $response[$i] = $commands->dequeue()->parseResponse($cmdResponse);
        }

        return $response;
    }

    /**
     * Passes the current transaction object to a callable block for execution.
     *
     * @param mixed $callable Callback.
     *
     * @throws CommunicationException
     * @throws ServerException
     */
    protected function executeTransactionBlock($callable)
    {
        $exception = null;
        $this->state->flag(MultiExecState::INSIDEBLOCK);

        try {
            call_user_func($callable, $this);
        } catch (CommunicationException $exception) {
            // NOOP
        } catch (ServerException $exception) {
            // NOOP
        } catch (Exception $exception) {
            $this->discard();
        }

        $this->state->unflag(MultiExecState::INSIDEBLOCK);

        if ($exception) {
            throw $exception;
        }
    }

    /**
     * Helper method for protocol errors encountered inside the transaction.
     *
     * @param string $message Error message.
     */
    private function onProtocolError($message)
    {
        // Since a MULTI/EXEC block cannot be initialized when using aggregate
        // connections we can safely assume that Predis\Client::getConnection()
        // will return a Predis\Connection\NodeConnectionInterface instance.
        CommunicationException::handle(new ProtocolException(
            $this->client->getConnection(), $message
        ));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\src\Transaction\MultiExecState.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Transaction;

/**
 * Utility class used to track the state of a MULTI / EXEC transaction.
 */
class MultiExecState
{
    public const INITIALIZED = 1;    // 0b00001
    public const INSIDEBLOCK = 2;    // 0b00010
    public const DISCARDED = 4;    // 0b00100
    public const CAS = 8;    // 0b01000
    public const WATCH = 16;   // 0b10000

    private $flags;

    public function __construct()
    {
        $this->flags = 0;
    }

    /**
     * Sets the internal state flags.
     *
     * @param int $flags Set of flags
     */
    public function set($flags)
    {
        $this->flags = $flags;
    }

    /**
     * Gets the internal state flags.
     *
     * @return int
     */
    public function get()
    {
        return $this->flags;
    }

    /**
     * Sets one or more flags.
     *
     * @param int $flags Set of flags
     */
    public function flag($flags)
    {
        $this->flags |= $flags;
    }

    /**
     * Resets one or more flags.
     *
     * @param int $flags Set of flags
     */
    public function unflag($flags)
    {
        $this->flags &= ~$flags;
    }

    /**
     * Returns if the specified flag or set of flags is set.
     *
     * @param int $flags Flag
     *
     * @return bool
     */
    public function check($flags)
    {
        return ($this->flags & $flags) === $flags;
    }

    /**
     * Resets the state of a transaction.
     */
    public function reset()
    {
        $this->flags = 0;
    }

    /**
     * Returns the state of the RESET flag.
     *
     * @return bool
     */
    public function isReset()
    {
        return $this->flags === 0;
    }

    /**
     * Returns the state of the INITIALIZED flag.
     *
     * @return bool
     */
    public function isInitialized()
    {
        return $this->check(self::INITIALIZED);
    }

    /**
     * Returns the state of the INSIDEBLOCK flag.
     *
     * @return bool
     */
    public function isExecuting()
    {
        return $this->check(self::INSIDEBLOCK);
    }

    /**
     * Returns the state of the CAS flag.
     *
     * @return bool
     */
    public function isCAS()
    {
        return $this->check(self::CAS);
    }

    /**
     * Returns if WATCH is allowed in the current state.
     *
     * @return bool
     */
    public function isWatchAllowed()
    {
        return $this->check(self::INITIALIZED) && !$this->check(self::CAS);
    }

    /**
     * Returns the state of the WATCH flag.
     *
     * @return bool
     */
    public function isWatching()
    {
        return $this->check(self::WATCH);
    }

    /**
     * Returns the state of the DISCARDED flag.
     *
     * @return bool
     */
    public function isDiscarded()
    {
        return $this->check(self::DISCARDED);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\bootstrap.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

if (file_exists(__DIR__ . '/../autoload.php')) {
    require __DIR__ . '/../autoload.php';
} elseif (@include ('Predis/Autoloader.php')) {
    Predis\Autoloader::register();
} else {
    exit('ERROR: Unable to find a suitable mean to register Predis\Autoloader.');
}

require __DIR__ . '/PHPUnit/ArrayHasSameValuesConstraint.php';
require __DIR__ . '/PHPUnit/OneOfConstraint.php';
require __DIR__ . '/PHPUnit/AssertSameWithPrecisionConstraint.php';
require __DIR__ . '/PHPUnit/RedisCommandConstraint.php';
require __DIR__ . '/PHPUnit/PredisTestCase.php';
require __DIR__ . '/PHPUnit/PredisCommandTestCase.php';
require __DIR__ . '/PHPUnit/PredisConnectionTestCase.php';
require __DIR__ . '/PHPUnit/PredisDistributorTestCase.php';


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\PHPUnit\ArrayHasSameValuesConstraint.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * PHPUnit constraint matching arrays with same elements even in different order.
 */
class ArrayHasSameValuesConstraint extends PHPUnit\Framework\Constraint\Constraint
{
    protected $array;

    /**
     * @param array $array
     */
    public function __construct(array $array)
    {
        $this->array = $array;
    }

    /**
     * {@inheritdoc}
     */
    public function matches($other): bool
    {
        if (count($this->array) !== count($other)) {
            return false;
        }

        if (array_diff($this->array, $other)) {
            return false;
        }

        return true;
    }

    /**
     * {@inheritdoc}
     */
    public function toString(): string
    {
        return 'two arrays contain the same elements.';
    }

    /**
     * {@inheritdoc}
     */
    protected function failureDescription($other): string
    {
        return $this->toString();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\PHPUnit\AssertSameWithPrecisionConstraint.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace PHPUnit;

use PHPUnit\Framework\Constraint\Constraint;

class AssertSameWithPrecisionConstraint extends Constraint
{
    /**
     * @var mixed
     */
    private $expectedValue;

    /**
     * @var int
     */
    private $precision;

    public function __construct($expectedValue, int $precision)
    {
        $this->expectedValue = $expectedValue;
        $this->precision = $precision;
    }

    /**
     * {@inheritdoc}
     */
    public function matches($other): bool
    {
        if (gettype($this->expectedValue) !== gettype($other)) {
            return false;
        }

        if (is_array($other)) {
            $other = array_map([$this, 'roundToPrecision'], $other);
            $this->expectedValue = array_map([$this, 'roundToPrecision'], $this->expectedValue);

            return !array_diff($this->expectedValue, $other);
        }

        $other = $this->roundToPrecision($other);
        $this->expectedValue = $this->roundToPrecision($this->expectedValue);

        return $other === $this->expectedValue;
    }

    /**
     * {@inheritDoc}
     */
    public function toString(): string
    {
        return 'given value matches another value with given precision';
    }

    /**
     * {@inheritdoc}
     */
    protected function failureDescription($other): string
    {
        return $this->toString();
    }

    /**
     * @param  mixed $numeric
     * @return float
     */
    private function roundToPrecision($numeric): float
    {
        return round((float) $numeric, $this->precision);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\PHPUnit\OneOfConstraint.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace PHPUnit;

use PHPUnit\Framework\Constraint\Constraint;

class OneOfConstraint extends Constraint
{
    /**
     * @var array
     */
    protected $array;

    public function __construct(array $array)
    {
        $this->array = $array;
    }

    /**
     * @param  mixed $other
     * @return bool
     */
    protected function matches($other): bool
    {
        if (is_array($other)) {
            return !empty(array_intersect($other, $this->array));
        }

        if (in_array($other, $this->array, true)) {
            return true;
        }

        return false;
    }

    /**
     * @param  mixed  $other
     * @return string
     */
    protected function failureDescription($other): string
    {
        return $this->toString();
    }

    /**
     * {@inheritDoc}
     */
    public function toString(): string
    {
        return 'given value matches any values from array';
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\PHPUnit\PredisCommandTestCase.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Client;
use Predis\Command;
use Predis\Command\CommandInterface;
use PredisTestCase;

abstract class PredisCommandTestCase extends PredisTestCase
{
    /**
     * Returns the expected command for tests.
     *
     * @return CommandInterface|string Instance or FQCN of the expected command
     */
    abstract protected function getExpectedCommand(): string;

    /**
     * Returns the expected command ID for tests.
     *
     * @return string
     */
    abstract protected function getExpectedId(): string;

    /**
     * Returns a new command instance.
     *
     * @return CommandInterface
     */
    public function getCommand(): CommandInterface
    {
        $command = $this->getExpectedCommand();

        return $command instanceof CommandInterface ? $command : new $command();
    }

    /**
     * Returns a new client instance.
     *
     * @param  bool   $flushdb Flush selected database before returning the client
     * @return Client
     */
    public function getClient(bool $flushdb = true): Client
    {
        $commands = $this->getCommandFactory();

        if (!$commands->supports($id = $this->getExpectedId())) {
            $this->markTestSkipped(
                "The current command factory does not support command $id"
            );
        }

        if ($this->isClusterTest()) {
            $client = $this->createClient(null, ['cluster' => 'redis'], $flushdb);
        } else {
            $client = $this->createClient(null, null, $flushdb);
        }

        return $client;
    }

    /**
     * Verifies if the command implements the prefixable interface.
     *
     * @return bool
     */
    protected function isPrefixable(): bool
    {
        return $this->getCommand() instanceof Command\PrefixableCommandInterface;
    }

    /**
     * Returns a new command instance with the specified arguments.
     *
     * @param mixed ...$arguments List of arguments for the command
     *
     * @return CommandInterface
     */
    protected function getCommandWithArguments(...$arguments): CommandInterface
    {
        return $this->getCommandWithArgumentsArray($arguments);
    }

    /**
     * Returns a new command instance with the specified arguments.
     *
     * @param array $arguments Arguments for the command
     *
     * @return CommandInterface
     */
    protected function getCommandWithArgumentsArray(array $arguments): CommandInterface
    {
        $command = $this->getCommand();
        $command->setArguments($arguments);

        return $command;
    }

    /**
     * @group disconnected
     */
    public function testCommandId(): void
    {
        $command = $this->getCommand();
        $sanitizedCommandId = str_replace('.', '', $command->getId());

        $this->assertInstanceOf('Predis\Command\CommandInterface', $command);
        $this->assertEquals($this->getExpectedId(), $sanitizedCommandId);
    }

    /**
     * @group disconnected
     */
    public function testRawArguments(): void
    {
        $expected = ['1st', '2nd', '3rd', '4th'];

        $command = $this->getCommand();
        $command->setRawArguments($expected);

        $this->assertSame($expected, $command->getArguments());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\PHPUnit\PredisConnectionTestCase.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\CommandInterface;
use PredisTestCase;

/**
 * @group realm-connection
 */
abstract class PredisConnectionTestCase extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testConstructorDoesNotOpenConnection(): void
    {
        $connection = $this->createConnection();

        $this->assertFalse($connection->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testSupportsSchemeTCP(): void
    {
        $connection = $this->createConnectionWithParams(['scheme' => 'tcp']);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testSupportsSchemeRedis(): void
    {
        $connection = $this->createConnectionWithParams(['scheme' => 'redis']);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testSupportsSchemeTls(): void
    {
        $connection = $this->createConnectionWithParams(['scheme' => 'tls']);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testSupportsSchemeRediss(): void
    {
        $connection = $this->createConnectionWithParams(['scheme' => 'rediss']);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testSupportsSchemeUnix(): void
    {
        $connection = $this->createConnectionWithParams(['scheme' => 'unix']);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidScheme(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage("Invalid scheme: 'udp'");

        $this->createConnectionWithParams(['scheme' => 'udp']);
    }

    /**
     * @group disconnected
     */
    public function testExposesParameters(): void
    {
        $parameters = $this->getParameters();
        $connection = $this->createConnectionWithParams($parameters);

        $this->assertSame($parameters, $connection->getParameters());
    }

    /**
     * @group disconnected
     */
    public function testCanBeSerialized(): void
    {
        $parameters = $this->getParameters([
            'alias' => 'redis',
            'read_write_timeout' => 10,
        ]);

        $connection = $this->createConnectionWithParams($parameters);
        $unserialized = unserialize(serialize($connection));

        $this->assertInstanceOf($this->getConnectionClass(), $unserialized);
        $this->assertEquals($parameters, $unserialized->getParameters());
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testAcceptsTcpNodelayParameter(): void
    {
        $connection = $this->createConnectionWithParams(['tcp_nodelay' => false]);
        $connection->connect();
        $this->assertTrue($connection->isConnected());

        $connection = $this->createConnectionWithParams(['tcp_nodelay' => true]);
        $connection->connect();
        $this->assertTrue($connection->isConnected());
    }

    /**
     * @group connected
     */
    public function testConnectForcesConnection(): void
    {
        $connection = $this->createConnection();

        $this->assertFalse($connection->isConnected());
        $connection->connect();
        $this->assertTrue($connection->isConnected());
    }

    /**
     * @group connected
     */
    public function testDoesNotThrowExceptionOnConnectWhenAlreadyConnected(): void
    {
        $connection = $this->createConnection();

        $connection->connect();
        $this->assertTrue($connection->isConnected());

        $connection->connect();
        $this->assertTrue($connection->isConnected());
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testDisconnectForcesDisconnection(): void
    {
        $connection = $this->createConnection();

        $connection->connect();
        $this->assertTrue($connection->isConnected());

        $connection->disconnect();
        $this->assertFalse($connection->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testDoesNotThrowExceptionOnDisconnectWhenAlreadyDisconnected(): void
    {
        $connection = $this->createConnection();

        $this->assertFalse($connection->isConnected());
        $connection->disconnect();
        $this->assertFalse($connection->isConnected());
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testGetResourceForcesConnection(): void
    {
        $connection = $this->createConnection();

        $this->assertFalse($connection->isConnected());
        $this->assertIsResource($connection->getResource());
        $this->assertTrue($connection->isConnected());
    }

    /**
     * @group connected
     */
    public function testSendingCommandForcesConnection(): void
    {
        $connection = $this->createConnection();
        $commands = $this->getCommandFactory();

        $cmdPing = $commands->create('ping');

        $this->assertEquals('PONG', $connection->executeCommand($cmdPing));
        $this->assertTrue($connection->isConnected());
    }

    /**
     * @group connected
     */
    public function testExecutesCommandOnServer(): void
    {
        $commands = $this->getCommandFactory();

        /** @var CommandInterface|MockObject */
        $cmdPing = $this->getMockBuilder($commands->getCommandClass('ping'))
            ->onlyMethods(['parseResponse'])
            ->getMock();
        $cmdPing->expects($this->never())
            ->method('parseResponse');

        $connection = $this->createConnection();

        $this->assertEquals('PONG', $connection->executeCommand($cmdPing));
    }

    /**
     * @group connected
     */
    public function testExecutesCommandWithHolesInArguments(): void
    {
        $commands = $this->getCommandFactory();
        $cmdDel = $commands->create('mget', [0 => 'key:0', 2 => 'key:2']);

        $connection = $this->createConnection();

        $this->assertSame([null, null], $connection->executeCommand($cmdDel));
    }

    /**
     * @group connected
     */
    public function testExecutesMultipleCommandsOnServer(): void
    {
        $commands = $this->getCommandFactory();

        $cmdPing = $commands->create('ping');
        $cmdEcho = $commands->create('echo', ['echoed']);
        $cmdGet = $commands->create('get', ['foobar']);
        $cmdRpush = $commands->create('rpush', ['metavars', 'foo', 'hoge', 'lol']);
        $cmdLrange = $commands->create('lrange', ['metavars', 0, -1]);

        $connection = $this->createConnection(true);

        $this->assertEquals('PONG', $connection->executeCommand($cmdPing));
        $this->assertSame('echoed', $connection->executeCommand($cmdEcho));
        $this->assertNull($connection->executeCommand($cmdGet));
        $this->assertSame(3, $connection->executeCommand($cmdRpush));
        $this->assertSame(['foo', 'hoge', 'lol'], $connection->executeCommand($cmdLrange));
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testWritesCommandToServer(): void
    {
        $commands = $this->getCommandFactory();

        /** @var CommandInterface|MockObject */
        $cmdEcho = $this->getMockBuilder($commands->getCommandClass('echo'))
            ->onlyMethods(['parseResponse'])
            ->getMock();
        $cmdEcho->setArguments(['ECHOED']);
        $cmdEcho
            ->expects($this->never())
            ->method('parseResponse');

        $connection = $this->createConnection();
        $connection->writeRequest($cmdEcho);
        $connection->disconnect();
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testReadsCommandFromServer(): void
    {
        $commands = $this->getCommandFactory();

        /** @var CommandInterface|MockObject */
        $cmdEcho = $this->getMockBuilder($commands->getCommandClass('echo'))
            ->onlyMethods(['parseResponse'])
            ->getMock();
        $cmdEcho->setArguments(['ECHOED']);
        $cmdEcho
            ->expects($this->never())
            ->method('parseResponse');

        $connection = $this->createConnection();
        $connection->writeRequest($cmdEcho);

        $this->assertSame('ECHOED', $connection->readResponse($cmdEcho));
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testIsAbleToWriteMultipleCommandsAndReadThemBackForPipelining(): void
    {
        $commands = $this->getCommandFactory();

        /** @var CommandInterface|MockObject */
        $cmdPing = $this->getMockBuilder($commands->getCommandClass('ping'))
            ->onlyMethods(['parseResponse'])
            ->getMock();
        $cmdPing
            ->expects($this->never())
            ->method('parseResponse');

        /** @var CommandInterface|MockObject */
        $cmdEcho = $this->getMockBuilder($commands->getCommandClass('echo'))
            ->onlyMethods(['parseResponse'])
            ->getMock();
        $cmdEcho->setArguments(['ECHOED']);
        $cmdEcho
            ->expects($this->never())
            ->method('parseResponse');

        $connection = $this->createConnection();

        $connection->writeRequest($cmdPing);
        $connection->writeRequest($cmdEcho);

        $this->assertEquals('PONG', $connection->readResponse($cmdPing));
        $this->assertSame('ECHOED', $connection->readResponse($cmdEcho));
    }

    /**
     * @group connected
     */
    public function testSendsInitializationCommandsOnConnection(): void
    {
        $commands = $this->getCommandFactory();

        /** @var CommandInterface|MockObject */
        $cmdPing = $this->getMockBuilder($commands->getCommandClass('ping'))
            ->onlyMethods(['getArguments'])
            ->getMock();
        $cmdPing
            ->expects($this->once())
            ->method('getArguments')
            ->willReturn([]);

        /** @var CommandInterface|MockObject */
        $cmdEcho = $this->getMockBuilder($commands->getCommandClass('echo'))
            ->onlyMethods(['getArguments'])
            ->getMock();
        $cmdEcho->setArguments(['ECHOED']);
        $cmdEcho
            ->expects($this->once())
            ->method('getArguments')
            ->willReturn(['ECHOED']);

        $connection = $this->createConnection();
        $connection->addConnectCommand($cmdPing);
        $connection->addConnectCommand($cmdEcho);

        $connection->connect();
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testReadsStatusResponses(): void
    {
        $commands = $this->getCommandFactory();
        $connection = $this->createConnection(true);

        $connection->writeRequest($commands->create('set', ['foo', 'bar']));
        $this->assertInstanceOf('Predis\Response\Status', $connection->read());

        $connection->writeRequest($commands->create('ping'));
        $this->assertInstanceOf('Predis\Response\Status', $connection->read());

        $connection->writeRequest($commands->create('multi'));
        $connection->writeRequest($commands->create('ping'));
        $this->assertInstanceOf('Predis\Response\Status', $connection->read());
        $this->assertInstanceOf('Predis\Response\Status', $connection->read());
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testReadsBulkResponses(): void
    {
        $commands = $this->getCommandFactory();
        $connection = $this->createConnection(true);

        $connection->executeCommand($commands->create('set', ['foo', 'bar']));

        $connection->writeRequest($commands->create('get', ['foo']));
        $this->assertSame('bar', $connection->read());

        $connection->writeRequest($commands->create('get', ['hoge']));
        $this->assertNull($connection->read());
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testReadsIntegerResponses(): void
    {
        $commands = $this->getCommandFactory();
        $connection = $this->createConnection(true);

        $connection->executeCommand($commands->create('rpush', ['metavars', 'foo', 'hoge', 'lol']));
        $connection->writeRequest($commands->create('llen', ['metavars']));

        $this->assertSame(3, $connection->read());
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testReadsErrorResponsesAsResponseErrorObjects(): void
    {
        $commands = $this->getCommandFactory();
        $connection = $this->createConnection(true);

        $connection->executeCommand($commands->create('set', ['foo', 'bar']));
        $connection->writeRequest($commands->create('rpush', ['foo', 'baz']));

        $this->assertInstanceOf('Predis\Response\Error', $error = $connection->read());
        $this->assertMatchesRegularExpression(
            '/[ERR|WRONGTYPE] Operation against a key holding the wrong kind of value/', $error->getMessage()
        );
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testReadsMultibulkResponsesAsArrays(): void
    {
        $commands = $this->getCommandFactory();
        $connection = $this->createConnection(true);

        $connection->executeCommand($commands->create('rpush', ['metavars', 'foo', 'hoge', 'lol']));
        $connection->writeRequest($commands->create('lrange', ['metavars', 0, -1]));

        $this->assertSame(['foo', 'hoge', 'lol'], $connection->read());
    }

    /**
     * @group connected
     * @group slow
     */
    public function testThrowsExceptionOnConnectionTimeout(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');
        $this->expectExceptionMessageMatches('/.* \[tcp:\/\/169.254.10.10:6379\]/');

        $connection = $this->createConnectionWithParams([
            'host' => '169.254.10.10',
            'timeout' => 0.1,
        ], false);

        $connection->connect();
    }

    /**
     * @group connected
     * @group slow
     */
    public function testThrowsExceptionOnConnectionTimeoutIPv6(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');
        $this->expectExceptionMessageMatches('/.* \[tcp:\/\/\[0:0:0:0:0:ffff:a9fe:a0a\]:6379\]/');

        $connection = $this->createConnectionWithParams([
            'host' => '0:0:0:0:0:ffff:a9fe:a0a',
            'timeout' => 0.1,
        ], false);

        $connection->connect();
    }

    /**
     * @group connected
     * @group slow
     */
    public function testThrowsExceptionOnUnixDomainSocketNotFound(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');
        $this->expectExceptionMessageMatches('/.* \[unix:\/tmp\/nonexistent\/redis\.sock]/');

        $connection = $this->createConnectionWithParams([
            'scheme' => 'unix',
            'path' => '/tmp/nonexistent/redis.sock',
        ], false);

        $connection->connect();
    }

    /**
     * @group connected
     * @group slow
     */
    public function testThrowsExceptionOnReadWriteTimeout(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');

        $commands = $this->getCommandFactory();

        $connection = $this->createConnectionWithParams([
            'read_write_timeout' => 0.5,
        ], true);

        $connection->executeCommand($commands->create('brpop', ['foo', 3]));
    }

    /**
     * @medium
     * @group connected
     */
    public function testThrowsExceptionOnProtocolDesynchronizationErrors(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');

        $connection = $this->createConnection();
        $stream = $connection->getResource();

        $connection->writeRequest($this->getCommandFactory()->create('ping'));
        fread($stream, 1);

        $connection->read();
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns the fully-qualified class name of the connection used for tests.
     *
     * @return string
     */
    abstract protected function getConnectionClass(): string;

    /**
     * Returns a named array with the default connection parameters and their values.
     *
     * @return array Default connection parameters.
     */
    protected function getDefaultParametersArray(): array
    {
        return [
            'scheme' => 'tcp',
            'host' => constant('REDIS_SERVER_HOST'),
            'port' => constant('REDIS_SERVER_PORT'),
            'database' => constant('REDIS_SERVER_DBNUM'),
            'read_write_timeout' => 2,
        ];
    }

    /**
     * Asserts the connection is using a persistent resource stream.
     *
     * This assertion will trigger a connect() operation if the connection has
     * not been open yet.
     *
     * @param NodeConnectionInterface $connection Connection instance
     */
    protected function assertPersistentConnection(NodeConnectionInterface $connection): void
    {
        $this->assertSame('persistent stream', get_resource_type($connection->getResource()));
    }

    /**
     * Asserts the connection is not using a persistent resource stream.
     *
     * This assertion will trigger a connect() operation if the connection has
     * not been open yet.
     *
     * @param NodeConnectionInterface $connection Connection instance
     */
    protected function assertNonPersistentConnection(NodeConnectionInterface $connection): void
    {
        $this->assertSame('stream', get_resource_type($connection->getResource()));
    }

    /**
     * Creates a new connection instance.
     *
     * @param bool $initialize Push default initialization commands (SELECT and FLUSHDB)
     *
     * @return NodeConnectionInterface
     */
    protected function createConnection(bool $initialize = false): NodeConnectionInterface
    {
        return $this->createConnectionWithParams([], $initialize);
    }

    /**
     * Creates a new connection instance using additional connection parameters.
     *
     * @param string|array|ParametersInterface $parameters Additional connection parameters
     * @param bool                             $initialize Push default initialization commands (SELECT and FLUSHDB)
     *
     * @return NodeConnectionInterface
     */
    protected function createConnectionWithParams($parameters, $initialize = false): NodeConnectionInterface
    {
        $class = $this->getConnectionClass();
        $commands = $this->getCommandFactory();

        if (!$parameters instanceof ParametersInterface) {
            $parameters = $this->getParameters($parameters);
        }

        $connection = new $class($parameters);

        if ($initialize) {
            $connection->addConnectCommand(
                $commands->create('select', [$parameters->database])
            );

            $connection->addConnectCommand(
                $commands->create('flushdb')
            );
        }

        return $connection;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\PHPUnit\PredisDistributorTestCase.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Distributor;

use PredisTestCase;

abstract class PredisDistributorTestCase extends PredisTestCase
{
    /**
     * Returns a new instance of the tested distributor.
     *
     * @return DistributorInterface
     */
    abstract protected function getDistributorInstance(): DistributorInterface;

    /**
     * Returns a list of nodes from the hashring.
     *
     * @param DistributorInterface $distributor Distributor instance.
     * @param int                  $iterations  Number of nodes to fetch.
     *
     * @return array Nodes from the hashring.
     */
    protected function getNodes(DistributorInterface $distributor, int $iterations = 10): array
    {
        $nodes = [];

        for ($i = 0; $i < $iterations; ++$i) {
            $hash = $distributor->hash($i * $i);
            $nodes[] = $distributor->getByHash($hash);
        }

        return $nodes;
    }

    /**
     * Returns a distributor instance with the specified nodes added.
     *
     * @param array $nodes Nodes to add to the distributor.
     *
     * @return DistributorInterface
     */
    protected function getSampleDistribution(array $nodes): DistributorInterface
    {
        $distributor = $this->getDistributorInstance();

        foreach ($nodes as $node) {
            $distributor->add($node);
        }

        return $distributor;
    }

    /**
     * @group disconnected
     */
    public function testEmptyRingThrowsException(): void
    {
        $this->expectException('Predis\Cluster\Distributor\EmptyRingException');

        $distributor = $this->getDistributorInstance();
        $distributor->getByHash('nodehash');
    }

    /**
     * @group disconnected
     */
    public function testRemoveOnEmptyRingDoesNotThrowException(): void
    {
        $distributor = $this->getDistributorInstance();

        $this->assertNull($distributor->remove('node'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\PHPUnit\PredisTestCase.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use PHPUnit\AssertSameWithPrecisionConstraint;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\OneOfConstraint;
use PHPUnit\Util\Test as TestUtil;
use Predis\Client;
use Predis\Command;
use Predis\Connection;

/**
 * Base test case class for the Predis test suite.
 */
abstract class PredisTestCase extends PHPUnit\Framework\TestCase
{
    protected $redisServerVersion;
    protected $redisJsonVersion;

    /**
     * @var string[]
     */
    private $modulesMapping = [
        'json' => ['annotation' => 'requiresRedisJsonVersion', 'name' => 'ReJSON'],
        'bloomFilter' => ['annotation' => 'requiresRedisBfVersion', 'name' => 'bf'],
        'search' => ['annotation' => 'requiresRediSearchVersion', 'name' => 'search'],
        'timeSeries' => ['annotation' => 'requiresRedisTimeSeriesVersion', 'name' => 'timeseries'],
    ];

    /**
     * Info of current Redis instance.
     *
     * @var array
     */
    private $info;

    /**
     * {@inheritdoc}
     */
    protected function setUp(): void
    {
        $this->checkRequiredRedisServerVersion();

        foreach ($this->modulesMapping as $module => $config) {
            $this->checkRequiredRedisModuleVersion($module);
        }
    }

    /**
     * Pauses the test case for the specified amount of time in seconds.
     *
     * @param float $seconds Seconds to sleep
     */
    protected function sleep(float $seconds): void
    {
        usleep($seconds * 1000000);
    }

    /**
     * Verifies that a Redis command is a valid Predis\Command\CommandInterface
     * instance with the specified ID and command arguments.
     *
     * @param Command\CommandInterface|string $command   Expected command instance or command ID
     * @param ?array                          $arguments Expected command arguments
     *
     * @return RedisCommandConstraint
     */
    public function isRedisCommand($command = null, ?array $arguments = null): RedisCommandConstraint
    {
        return new RedisCommandConstraint($command, $arguments);
    }

    /**
     * Ensures that two Redis commands are similar.
     *
     * This method supports can test for different constraints by accepting a few
     * combinations of values as indicated below:
     *
     * - a string identifying a Redis command by its ID
     * - an instance of Predis\Command\CommandInterface
     * - an array of [(string) $commandID, (array) $commandArguments]
     *
     * Internally this method uses the RedisCommandConstraint class.
     *
     * @param Command\CommandInterface|string|array $expected Expected command instance or command ID
     * @param mixed                                 $actual   Actual command
     * @param string                                $message  Optional assertion message
     */
    public function assertRedisCommand($expected, $actual, string $message = ''): void
    {
        if (is_array($expected)) {
            @[$command, $arguments] = $expected;
        } else {
            $command = $expected;
            $arguments = null;
        }

        $this->assertThat($actual, new RedisCommandConstraint($command, $arguments), $message);
    }

    /**
     * Asserts that two arrays have the same values (even with different order).
     *
     * @param array  $expected Expected array
     * @param array  $actual   Actual array
     * @param string $message  Optional assertion message
     */
    public function assertSameValues(array $expected, array $actual, $message = ''): void
    {
        $this->assertThat($actual, new ArrayHasSameValuesConstraint($expected), $message);
    }

    /**
     * Asserts that actual value is one of the values from expected array.
     *
     * @param  mixed  $expected Expected array.
     * @param  mixed  $actual   Actual value. If array given searching for any matching value between two arrays.
     * @param  string $message  Optional assertion message
     * @return void
     */
    public function assertOneOf(array $expected, $actual, string $message = ''): void
    {
        $this->assertThat($actual, new OneOfConstraint($expected), $message);
    }

    /**
     * Asserts that two values (of the same type) have the same values with given precision.
     *
     * @param  mixed  $expected  Expected value
     * @param  mixed  $actual    Actual value
     * @param  int    $precision Precision value should be round to
     * @param  string $message   Optional assertion message
     * @return void
     */
    public function assertSameWithPrecision($expected, $actual, int $precision = 0, string $message = ''): void
    {
        $this->assertThat($actual, new AssertSameWithPrecisionConstraint($expected, $precision), $message);
    }

    /**
     * Asserts that a string matches a given regular expression.
     *
     * @throws ExpectationFailedException
     * @throws SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public static function assertMatchesRegularExpression(string $pattern, string $string, $message = ''): void
    {
        if (method_exists(get_parent_class(parent::class), __FUNCTION__)) {
            call_user_func([parent::class, __FUNCTION__], $pattern, $string, $message);
        } else {
            static::assertRegExp($pattern, $string, $message);
        }
    }

    /**
     * Returns a named array with default values for connection parameters.
     *
     * @return array Default connection parameters
     */
    protected function getDefaultParametersArray(): array
    {
        if ($this->isClusterTest()) {
            return $this->prepareClusterEndpoints();
        }

        return [
            'scheme' => 'tcp',
            'host' => constant('REDIS_SERVER_HOST'),
            'port' => constant('REDIS_SERVER_PORT'),
            'database' => constant('REDIS_SERVER_DBNUM'),
        ];
    }

    /**
     * Returns a named array with default values for client options.
     *
     * @return array Default connection parameters
     */
    protected function getDefaultOptionsArray(): array
    {
        return [
            'commands' => new Command\RedisFactory(),
        ];
    }

    /**
     * Merges a named array of connection parameters with current defaults.
     *
     * @param array $additional Additional connection parameters
     *
     * @return array
     */
    protected function getParametersArray(array $additional): array
    {
        return array_merge($this->getDefaultParametersArray(), $additional);
    }

    /**
     * Returns a new instance of connection parameters.
     *
     * Values in the optional $additional named array are merged with defaults.
     *
     * @param array $additional Additional connection parameters
     *
     * @return Connection\ParametersInterface
     */
    protected function getParameters($additional = []): Connection\ParametersInterface
    {
        $parameters = array_merge($this->getDefaultParametersArray(), $additional);
        $parameters = new Connection\Parameters($parameters);

        return $parameters;
    }

    /**
     * Returns a new instance of command factory.
     *
     * @return Command\Factory
     */
    protected function getCommandFactory(): Command\Factory
    {
        return new Command\RedisFactory();
    }

    /**
     * Returns a new instance of Predis\Client.
     *
     * Values in the optional $parameters named array are merged with defaults.
     * Values in the ottional $options named array are merged with defaults.
     *
     * @param array $parameters Additional connection parameters
     * @param array $options    Additional client options
     * @param bool  $flushdb    Flush selected database before returning the client
     *
     * @return Client
     */
    protected function createClient(?array $parameters = null, ?array $options = null, ?bool $flushdb = true): Client
    {
        $parameters = array_merge(
            $this->getDefaultParametersArray(),
            $parameters ?: []
        );

        $options = array_merge(
            ['commands' => $this->getCommandFactory()],
            $options ?: [],
            getenv('USE_RELAY') ? ['connections' => 'relay'] : []
        );

        if ($this->isClusterTest()) {
            $options = array_merge(
                [
                    'cluster' => 'redis',
                ],
                $options
            );
        }

        $client = new Client($parameters, $options);
        $client->connect();

        if ($flushdb) {
            $client->flushdb();
        }

        return $client;
    }

    /**
     * Returns a basic mock object of a connection to a single Redis node.
     *
     * The specified target interface used for the mock object must implement
     * Predis\Connection\NodeConnectionInterface.
     *
     * The mock object responds to getParameters() and __toString() by returning
     * the default connection parameters used by Predis or a set of connection
     * parameters specified in the optional second argument.
     *
     * @param string       $interface  Fully-qualified name of the target interface
     * @param array|string $parameters Optional connection parameters
     *
     * @return MockObject|Connection\NodeConnectionInterface
     */
    protected function getMockConnectionOfType(string $interface, $parameters = null)
    {
        if (!is_a($interface, '\Predis\Connection\NodeConnectionInterface', true)) {
            $method = __METHOD__;

            throw new InvalidArgumentException(
                "Argument `\$interface` for $method() expects a type implementing Predis\Connection\NodeConnectionInterface"
            );
        }

        $connection = $this->getMockBuilder($interface)->getMock();

        if ($parameters) {
            $parameters = Connection\Parameters::create($parameters);
            $hash = "{$parameters->host}:{$parameters->port}";

            $connection
                ->expects($this->any())
                ->method('getParameters')
                ->willReturn($parameters);
            $connection
                ->expects($this->any())
                ->method('__toString')
                ->willReturn($hash);
        }

        return $connection;
    }

    /**
     * Returns a basic mock object of a connection to a single Redis node.
     *
     * The mock object is based on Predis\Connection\NodeConnectionInterface.
     *
     * The mock object responds to getParameters() and __toString() by returning
     * the default connection parameters used by Predis or a set of connection
     * parameters specified in the optional second argument.
     *
     * @param array|string|null $parameters Optional connection parameters
     *
     * @return MockObject|Connection\NodeConnectionInterface
     */
    protected function getMockConnection($parameters = null)
    {
        return $this->getMockConnectionOfType('Predis\Connection\NodeConnectionInterface', $parameters);
    }

    /**
     * Returns the server version of the Redis instance used by the test suite.
     *
     * @return string
     * @throws RuntimeException When the client cannot retrieve the current server version
     */
    protected function getRedisServerVersion(): string
    {
        if (isset($this->redisServerVersion)) {
            return $this->redisServerVersion;
        }

        if (isset($this->info)) {
            $info = $this->info;
        } else {
            $client = $this->createClient(null, null, true);
            $info = array_change_key_case($client->info());
            $this->info = $info;
        }

        if (isset($info['server']['redis_version'])) {
            // Redis >= 2.6
            $version = $info['server']['redis_version'];
        } elseif (isset($info['redis_version'])) {
            // Redis < 2.6
            $version = $info['redis_version'];
        } else {
            $client = $this->createClient(null, null, true);
            $connection = $client->getConnection();
            throw new RuntimeException("Unable to retrieve a valid server info payload from $connection");
        }

        $this->redisServerVersion = $version;

        return $version;
    }

    /**
     * Returns the Redis server version required to run a @connected test.
     *
     * This value is retrieved from the @requiresRedisVersion annotation that
     * decorates the target test method.
     *
     * @return string
     */
    protected function getRequiredRedisServerVersion(): ?string
    {
        $annotations = TestUtil::parseTestMethodAnnotations(
            get_class($this),
            $this->getName(false)
        );

        if (isset($annotations['method']['requiresRedisVersion'], $annotations['method']['group'])
            && !empty($annotations['method']['requiresRedisVersion'])
            && in_array('connected', $annotations['method']['group'])
        ) {
            return $annotations['method']['requiresRedisVersion'][0];
        }

        return null;
    }

    /**
     * Compares the specified version string against the Redis server version in
     * use for integration tests.
     *
     * @param string $operator Comparison operator
     * @param string $version  Version to compare
     *
     * @return bool
     */
    public function isRedisServerVersion(string $operator, string $version): bool
    {
        $serverVersion = $this->getRedisServerVersion();
        $comparison = version_compare($serverVersion, $version);

        return (bool) eval("return $comparison $operator 0;");
    }

    /**
     * Ensures the current Redis server matches version requirements for tests.
     *
     * Requirements are retrieved from the @requiresRedisVersion annotation that
     * decorates test methods while the version of the Redis server used to run
     * integration tests is retrieved directly from the server by using `INFO`.
     *
     * @throws PHPUnit\Framework\SkippedTestError When the required Redis server version is not met
     */
    protected function checkRequiredRedisServerVersion(): void
    {
        if (!$requiredVersion = $this->getRequiredRedisServerVersion()) {
            return;
        }

        $requiredVersion = explode(' ', $requiredVersion, 2);

        if (count($requiredVersion) === 1) {
            $reqOperator = '>=';
            $reqVersion = $requiredVersion[0];
        } else {
            $reqOperator = $requiredVersion[0];
            $reqVersion = $requiredVersion[1];
        }

        if (!$this->isRedisServerVersion($reqOperator, $reqVersion)) {
            $serverVersion = $this->getRedisServerVersion();

            $this->markTestSkipped(
                "Test requires a Redis server instance $reqOperator $reqVersion but target server is $serverVersion"
            );
        }
    }

    /**
     * Ensures the current Redis JSON module matches version requirements for tests.
     *
     * @param  string $module
     * @return void
     */
    protected function checkRequiredRedisModuleVersion(string $module): void
    {
        if (null === $requiredVersion = $this->getRequiredModuleVersion($module)) {
            return;
        }

        if (version_compare($this->getRedisServerVersion(), '6.0.0', '<')) {
            $this->markTestSkipped(
                'Test skipped because Redis JSON module available since Redis 6.x'
            );
        }

        $requiredVersion = explode(' ', $requiredVersion, 2);

        if (count($requiredVersion) === 1) {
            $reqVersion = $requiredVersion[0];
        } else {
            $reqVersion = $requiredVersion[1];
        }

        if (!$this->isSatisfiedRedisModuleVersion($reqVersion, $module)) {
            $redisModuleVersion = $this->getRedisModuleVersion($module);
            $module = strtoupper($module);

            $this->markTestSkipped(
                "Test requires a Redis $module module >= $reqVersion but target module is $redisModuleVersion"
            );
        }
    }

    /**
     * @param  string $versionToCheck
     * @param  string $module
     * @return bool
     */
    protected function isSatisfiedRedisModuleVersion(string $versionToCheck, string $module): bool
    {
        $currentVersion = $this->getRedisModuleVersion($this->modulesMapping[$module]['name']);
        $versionToCheck = str_replace('.', '', $versionToCheck);

        return $currentVersion >= (int) $versionToCheck;
    }

    /**
     * Returns version of Redis JSON module if it's available.
     *
     * @param  string $module
     * @return string
     */
    protected function getRedisModuleVersion(string $module): string
    {
        if (isset($this->info)) {
            $info = $this->info;
        } else {
            $client = $this->createClient(null, null, true);
            $info = array_change_key_case($client->info());
            $this->info = $info;
        }

        if (isset($info['modules'][$module]['ver'])) {
            $this->redisJsonVersion = $info['modules'][$module]['ver'];

            return $info['modules'][$module]['ver'];
        }

        return '0';
    }

    /**
     * Returns version of given module for current Redis instance.
     * Runs if command belong to one of modules and marked with appropriate annotation
     * Runs on @connected tests.
     *
     * @param  string $module
     * @return string
     */
    protected function getRequiredModuleVersion(string $module): ?string
    {
        if (!isset($this->modulesMapping[$module])) {
            throw new InvalidArgumentException('No existing annotation for given module');
        }

        $moduleAnnotation = $this->modulesMapping[$module]['annotation'];
        $annotations = TestUtil::parseTestMethodAnnotations(
            get_class($this),
            $this->getName(false)
        );

        if (isset($annotations['method'][$moduleAnnotation], $annotations['method']['group'])
            && !empty($annotations['method'][$moduleAnnotation])
            && in_array('connected', $annotations['method']['group'], true)
        ) {
            return $annotations['method'][$moduleAnnotation][0];
        }

        return null;
    }

    /**
     * Marks current test skipped when test suite is running on CI environments.
     *
     * @param string $message
     */
    protected function markTestSkippedOnCIEnvironment(string $message = 'Test skipped on CI environment'): void
    {
        if (getenv('GITHUB_ACTIONS') || getenv('TRAVIS')) {
            $this->markTestSkipped($message);
        }
    }

    /**
     * Check annotations if it's matches to cluster test scenario.
     *
     * @return bool
     */
    protected function isClusterTest(): bool
    {
        $annotations = TestUtil::parseTestMethodAnnotations(
            get_class($this),
            $this->getName(false)
        );

        return isset($annotations['method']['requiresRedisVersion'], $annotations['method']['group'])
            && !empty($annotations['method']['requiresRedisVersion'])
            && in_array('connected', $annotations['method']['group'], true)
            && in_array('cluster', $annotations['method']['group'], true);
    }

    /**
     * Parse comma-separated cluster endpoints and convert them into tcp strings.
     *
     * @return array
     */
    protected function prepareClusterEndpoints(): array
    {
        $endpoints = explode(',', constant('REDIS_CLUSTER_ENDPOINTS'));

        return array_map(static function (string $elem) {
            return 'tcp://' . $elem;
        }, $endpoints);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\PHPUnit\RedisCommandConstraint.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Predis\Command\CommandInterface;
use SebastianBergmann\Exporter\Exporter;

/**
 * PHPUnit constraint to verify that a Redis command matches certain conditions.
 */
class RedisCommandConstraint extends PHPUnit\Framework\Constraint\Constraint
{
    protected $commandID;
    protected $arguments;

    /**
     * @param string|CommandInterface $command   Expected command instance or command ID
     * @param ?array                  $arguments Expected command arguments
     */
    public function __construct($command, ?array $arguments = null)
    {
        if ($command instanceof CommandInterface) {
            $this->commandID = strtoupper($command->getId());
            $this->arguments = $arguments ?: $command->getArguments();
        } else {
            $this->commandID = strtoupper($command);
            $this->arguments = $arguments;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function matches($other): bool
    {
        if (!$other instanceof CommandInterface) {
            return false;
        }

        if ($this->commandID && strtoupper($other->getId()) !== $this->commandID) {
            return false;
        }

        if ($this->arguments !== null) {
            $otherArguments = $other->getArguments();

            if (count($this->arguments) !== count($otherArguments)) {
                return false;
            }

            for ($i = 0; $i < count($this->arguments); ++$i) {
                if (((string) $this->arguments[$i]) !== ((string) $otherArguments[$i])) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * {@inheritdoc}
     *
     * @todo Improve output using diff when expected and actual do not match.
     */
    public function toString(): string
    {
        $exporter = new Exporter();
        $string = 'is a Redis command';

        if ($this->commandID) {
            $string .= " with ID '{$this->commandID}'";
        }

        if ($this->arguments) {
            $string .= " and the following arguments:\n\n";
            $string .= $exporter->export($this->arguments);
        }

        return $string;
    }

    /**
     * {@inheritdoc}
     */
    protected function failureDescription($other): string
    {
        $string = is_object($other) ? get_class($other) : $other;

        return "$string {$this->toString()}";
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\ClientExceptionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

use PredisTestCase;

class ClientExceptionTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testExceptionMessage(): void
    {
        $message = 'This is a client exception.';

        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage($message);

        throw new ClientException($message);
    }

    /**
     * @group disconnected
     */
    public function testExceptionClass(): void
    {
        $exception = new ClientException();

        $this->assertInstanceOf('Predis\ClientException', $exception);
        $this->assertInstanceOf('Predis\PredisException', $exception);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\ClientTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

use Iterator;
use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\Factory as CommandFactory;
use Predis\Command\Processor\KeyPrefixProcessor;
use Predis\Connection\NodeConnectionInterface;
use Predis\Connection\ParametersInterface;
use Predis\Connection\Replication\MasterSlaveReplication;
use PredisTestCase;
use ReflectionProperty;
use stdClass;

class ClientTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testConstructorWithoutArguments(): void
    {
        $client = new Client();

        /** @var NodeConnectionInterface */
        $connection = $client->getConnection();
        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);

        $parameters = $connection->getParameters();
        $this->assertSame($parameters->host, '127.0.0.1');
        $this->assertSame($parameters->port, 6379);

        $options = $client->getOptions();
        $this->assertSame($options->commands, $client->getCommandFactory());

        $this->assertFalse($client->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithNullArgument(): void
    {
        $client = new Client(null);

        /** @var NodeConnectionInterface */
        $connection = $client->getConnection();
        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);

        $parameters = $connection->getParameters();
        $this->assertSame($parameters->host, '127.0.0.1');
        $this->assertSame($parameters->port, 6379);

        $options = $client->getOptions();
        $this->assertSame($options->commands, $client->getCommandFactory());

        $this->assertFalse($client->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithNullAndNullArguments(): void
    {
        $client = new Client(null, null);

        /** @var NodeConnectionInterface */
        $connection = $client->getConnection();
        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);

        $parameters = $connection->getParameters();
        $this->assertSame($parameters->host, '127.0.0.1');
        $this->assertSame($parameters->port, 6379);

        $options = $client->getOptions();
        $this->assertSame($options->commands, $client->getCommandFactory());

        $this->assertFalse($client->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithArrayArgument(): void
    {
        $client = new Client($arg1 = ['host' => 'localhost', 'port' => 7000]);

        /** @var NodeConnectionInterface */
        $connection = $client->getConnection();
        $parameters = $connection->getParameters();

        $this->assertSame($parameters->host, $arg1['host']);
        $this->assertSame($parameters->port, $arg1['port']);
    }

    /**
     * @group disconnected
     */
    public function testConstructorThrowsExceptionWithArrayOfParametersArgumentAndMissingOption(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Array of connection parameters requires `cluster`, `replication` or `aggregate` client option');

        $arg1 = [
            ['host' => 'localhost', 'port' => 7000],
            ['host' => 'localhost', 'port' => 7001],
        ];

        $client = new Client($arg1);
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithArrayOfArrayArgumentAndClusterOption(): void
    {
        $arg1 = [
            ['host' => 'localhost', 'port' => 7000],
            ['host' => 'localhost', 'port' => 7001],
        ];

        $client = new Client($arg1, [
            'aggregate' => $this->getAggregateInitializer($arg1),
        ]);

        $this->assertInstanceOf('Predis\Connection\AggregateConnectionInterface', $client->getConnection());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithStringArgument(): void
    {
        $client = new Client('tcp://localhost:7000');

        /** @var NodeConnectionInterface */
        $connection = $client->getConnection();
        $parameters = $connection->getParameters();

        $this->assertSame($parameters->host, 'localhost');
        $this->assertSame($parameters->port, 7000);
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithArrayOfStringArgument(): void
    {
        $arg1 = ['tcp://localhost:7000', 'tcp://localhost:7001'];

        $client = new Client($arg1, [
            'aggregate' => $this->getAggregateInitializer($arg1),
        ]);

        $this->assertInstanceOf('Predis\Connection\AggregateConnectionInterface', $client->getConnection());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithArrayOfConnectionsArgument(): void
    {
        $arg1 = [
            $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock(),
            $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock(),
        ];

        $client = new Client($arg1, [
            'aggregate' => $this->getAggregateInitializer($arg1),
        ]);

        $this->assertInstanceOf('Predis\Connection\AggregateConnectionInterface', $client->getConnection());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithConnectionArgument(): void
    {
        $factory = new Connection\Factory();
        $connection = $factory->create('tcp://localhost:7000');

        $client = new Client($connection);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $client->getConnection());
        $this->assertSame($connection, $client->getConnection());

        /** @var NodeConnectionInterface */
        $connection = $client->getConnection();
        $parameters = $connection->getParameters();

        $this->assertSame($parameters->host, 'localhost');
        $this->assertSame($parameters->port, 7000);
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithClusterArgument(): void
    {
        $cluster = new Connection\Cluster\PredisCluster();

        $factory = new Connection\Factory();
        $cluster->add($factory->create('tcp://localhost:7000'));
        $cluster->add($factory->create('tcp://localhost:7001'));

        $client = new Client($cluster);

        $this->assertInstanceOf('Predis\Connection\Cluster\ClusterInterface', $client->getConnection());
        $this->assertSame($cluster, $client->getConnection());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithReplicationArgument(): void
    {
        $replication = new MasterSlaveReplication();

        $factory = new Connection\Factory();
        $replication->add($factory->create('tcp://host1?alias=master'));
        $replication->add($factory->create('tcp://host2?alias=slave'));

        $client = new Client($replication);

        $this->assertInstanceOf('Predis\Connection\Replication\ReplicationInterface', $client->getConnection());
        $this->assertSame($replication, $client->getConnection());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithCallableArgument(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn($connection);

        $client = new Client($callable);

        $this->assertSame($connection, $client->getConnection());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithCallableConnectionInitializerThrowsExceptionOnInvalidReturnType(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Callable parameters must return a valid connection');

        $wrongType = $this->getMockBuilder('stdClass')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn($wrongType);

        new Client($callable);
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithNullAndArrayArgument(): void
    {
        $connections = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();

        $arg2 = ['prefix' => 'prefix:', 'connections' => $connections];
        $client = new Client(null, $arg2);

        /** @var CommandFactory */
        $commands = $client->getCommandFactory();
        $this->assertInstanceOf('Predis\Command\FactoryInterface', $commands);

        /** @var KeyPrefixProcessor */
        $processor = $commands->getProcessor();
        $this->assertInstanceOf('Predis\Command\Processor\KeyPrefixProcessor', $processor);
        $this->assertSame('prefix:', $processor->getPrefix());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithArrayAndOptionReplication(): void
    {
        $arg1 = ['tcp://127.0.0.1:6379?role=master', 'tcp://127.0.0.1:6380?role=slave'];
        $arg2 = ['replication' => 'predis'];
        $client = new Client($arg1, $arg2);

        /** @var MasterSlaveReplication */
        $connection = $client->getConnection();

        $this->assertInstanceOf('Predis\Connection\Replication\ReplicationInterface', $connection);
        $this->assertSame('127.0.0.1:6379', (string) $connection->getConnectionByRole('master'));
        $this->assertSame('127.0.0.1:6380', (string) $connection->getConnectionByRole('slave'));
    }

    /**
     * @group disconnected
     */
    public function testClusterOptionHasPrecedenceOverReplicationOptionAndAggregateOption(): void
    {
        $arg1 = ['tcp://host1', 'tcp://host2'];

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();

        $fncluster = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $fncluster
            ->expects($this->once())
            ->method('__invoke')
            ->with(
                $arg1,
                $this->isInstanceOf('Predis\Configuration\OptionsInterface'),
                $this->isInstanceOf('Predis\Configuration\OptionInterface')
            )
            ->willReturn($connection);

        $fnreplication = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $fnreplication
            ->expects($this->never())
            ->method('__invoke');

        $fnaggregate = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $fnaggregate
            ->expects($this->never())
            ->method('__invoke');

        $arg2 = [
            'cluster' => $fncluster,
            'replication' => $fnreplication,
            'aggregate' => $fnaggregate,
        ];

        $client = new Client($arg1, $arg2);

        $this->assertSame($connection, $client->getConnection());
    }

    /**
     * @group disconnected
     */
    public function testReplicationOptionHasPrecedenceOverAggregateOption(): void
    {
        $arg1 = ['tcp://host1', 'tcp://host2'];

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();

        $fnreplication = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $fnreplication
            ->expects($this->once())
            ->method('__invoke')
            ->with(
                $arg1,
                $this->isInstanceOf('Predis\Configuration\OptionsInterface'),
                $this->isInstanceOf('Predis\Configuration\OptionInterface')
            )
            ->willReturn($connection);

        $fnaggregate = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $fnaggregate
            ->expects($this->never())
            ->method('__invoke');

        $arg2 = [
            'replication' => $fnreplication,
            'aggregate' => $fnaggregate,
        ];

        $client = new Client($arg1, $arg2);
    }

    /**
     * @group disconnected
     */
    public function testAggregateOptionDoesNotTriggerAggregationInClient(): void
    {
        $arg1 = ['tcp://host1', 'tcp://host2'];

        $connections = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $connections
            ->expects($this->never())
            ->method('create');

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')
            ->getMock();
        $connection
            ->expects($this->never())
            ->method('add');

        $fnaggregate = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $fnaggregate
            ->expects($this->once())
            ->method('__invoke')
            ->with(
                $arg1,
                $this->isInstanceOf('Predis\Configuration\OptionsInterface'),
                $this->isInstanceOf('Predis\Configuration\OptionInterface')
            )
            ->willReturn($connection);

        $arg2 = ['aggregate' => $fnaggregate, 'connections' => $connections];

        $client = new Client($arg1, $arg2);

        $this->assertSame($connection, $client->getConnection());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithInvalidArgumentType(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Invalid type for connection parameters');

        $client = new Client(new stdClass());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithInvalidOptionType(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Invalid type for client options');

        $client = new Client('tcp://host1', new stdClass());
    }

    /**
     * @group disconnected
     */
    public function testConnectAndDisconnect(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('connect');
        $connection
            ->expects($this->once())
            ->method('disconnect');

        $client = new Client($connection);
        $client->connect();
        $client->disconnect();
    }

    /**
     * @group disconnected
     */
    public function testIsConnectedChecksConnectionState(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('isConnected');

        $client = new Client($connection);
        $client->isConnected();
    }

    /**
     * @group disconnected
     */
    public function testQuitIsAliasForDisconnect(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('disconnect');

        $client = new Client($connection);
        $client->quit();
    }

    /**
     * @group disconnected
     */
    public function testCreatesNewCommandUsingSpecifiedCommandFactory(): void
    {
        $ping = $this->getCommandFactory()->create('ping', []);

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->once())
            ->method('create')
            ->with('ping', [])
            ->willReturn($ping);

        $client = new Client(null, ['commands' => $commands]);
        $this->assertSame($ping, $client->createCommand('ping', []));
    }

    /**
     * @group disconnected
     */
    public function testExecuteCommandReturnsParsedResponses(): void
    {
        $commands = $this->getCommandFactory();

        $ping = $commands->create('ping', []);
        $hgetall = $commands->create('hgetall', ['metavars', 'foo', 'hoge']);

        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$ping],
                [$hgetall]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Status('PONG'),
                ['foo', 'bar', 'hoge', 'piyo']
            );

        $client = new Client($connection);

        $this->assertEquals('PONG', $client->executeCommand($ping));
        $this->assertSame(['foo' => 'bar', 'hoge' => 'piyo'], $client->executeCommand($hgetall));
    }

    /**
     * @group disconnected
     */
    public function testExecuteCommandThrowsExceptionOnRedisError(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $ping = $this->getCommandFactory()->create('ping', []);
        $expectedResponse = new Response\Error('ERR Operation against a key holding the wrong kind of value');

        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('executeCommand')
            ->willReturn($expectedResponse);

        $client = new Client($connection);
        $client->executeCommand($ping);
    }

    /**
     * @group disconnected
     */
    public function testExecuteCommandReturnsErrorResponseOnRedisError(): void
    {
        $ping = $this->getCommandFactory()->create('ping', []);
        $expectedResponse = new Response\Error('ERR Operation against a key holding the wrong kind of value');

        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('executeCommand')
            ->willReturn($expectedResponse);

        $client = new Client($connection, ['exceptions' => false]);
        $response = $client->executeCommand($ping);

        $this->assertSame($response, $expectedResponse);
    }

    /**
     * @group disconnected
     */
    public function testCallingRedisCommandExecutesInstanceOfCommand(): void
    {
        $ping = $this->getCommandFactory()->create('ping', []);

        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isInstanceOf('Predis\Command\Redis\PING'))
            ->willReturn('PONG');

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->once())
            ->method('create')
            ->with('ping', [])
            ->willReturn($ping);

        $options = ['commands' => $commands];

        /** @var ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods([])
            ->setConstructorArgs([$connection, $options])
            ->getMock();

        $this->assertEquals('PONG', $client->ping());
    }

    /**
     * @group disconnected
     */
    public function testCallingRedisCommandThrowsExceptionOnServerError(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $expectedResponse = new Response\Error('ERR Operation against a key holding the wrong kind of value');

        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand('PING'))
            ->willReturn($expectedResponse);

        $client = new Client($connection);
        $client->ping();
    }

    /**
     * @group disconnected
     */
    public function testCallingRedisCommandReturnsErrorResponseOnRedisError(): void
    {
        $expectedResponse = new Response\Error('ERR Operation against a key holding the wrong kind of value');

        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand('PING'))
            ->willReturn($expectedResponse);

        $client = new Client($connection, ['exceptions' => false]);
        $response = $client->ping();

        $this->assertSame($response, $expectedResponse);
    }

    /**
     * @group disconnected
     */
    public function testRawCommand(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(3))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('SET', ['foo', 'bar'])],
                [$this->isRedisCommand('GET', ['foo'])],
                [$this->isRedisCommand('PING')]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Status('OK'),
                'bar',
                'PONG'
            );

        $client = new Client($connection);

        $this->assertSame('OK', $client->executeRaw(['SET', 'foo', 'bar']));
        $this->assertSame('bar', $client->executeRaw(['GET', 'foo']));

        $error = true;  // $error is always populated by reference.
        $this->assertSame('PONG', $client->executeRaw(['PING'], $error));
        $this->assertFalse($error);
    }

    /**
     * @group disconnected
     */
    public function testRawCommandNeverAppliesPrefix(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('SET', ['foo', 'bar'])],
                [$this->isRedisCommand('GET', ['foo'])]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Status('OK'),
                'bar'
            );

        $client = new Client($connection, ['prefix' => 'predis:']);

        $this->assertSame('OK', $client->executeRaw(['SET', 'foo', 'bar']));
        $this->assertSame('bar', $client->executeRaw(['GET', 'foo']));
    }

    /**
     * @group disconnected
     */
    public function testRawCommandNeverThrowsExceptions(): void
    {
        $message = 'ERR Mock error response';
        $response = new Response\Error($message);

        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand('PING'))
            ->willReturn($response);

        $client = new Client($connection, ['exceptions' => true]);

        $this->assertSame($message, $client->executeRaw(['PING'], $error));
        $this->assertTrue($error);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnNonRegisteredRedisCommand(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('Command `INVALIDCOMMAND` is not a registered Redis command');

        $client = new Client();
        $client->invalidCommand();
    }

    /**
     * @group disconnected
     */
    public function testGetClientByMethodReturnsInstanceOfSubclass(): void
    {
        /** @var Client */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods([])
            ->setConstructorArgs([
                ['tcp://host1?alias=node01', 'tcp://host2?alias=node02'],
                ['cluster' => 'predis'],
            ])
            ->setMockClassName('SubclassedClient')
            ->getMock();

        $this->assertInstanceOf('SubclassedClient', $client->getClientBy('alias', 'node02'));
    }

    /**
     * @group disconnected
     */
    public function testGetClientByMethodSupportsSelectingConnectionById(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();

        $aggregate = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')
            ->onlyMethods(['getConnectionById'])
            ->getMockForAbstractClass();
        $aggregate
            ->expects($this->once())
            ->method('getConnectionById')
            ->with('127.0.0.1:6379')
            ->willReturn($connection);

        $client = new Client($aggregate);
        $nodeClient = $client->getClientBy('id', '127.0.0.1:6379');

        $this->assertSame($connection, $nodeClient->getConnection());
        $this->assertSame($client->getOptions(), $nodeClient->getOptions());
    }

    /**
     * @group disconnected
     */
    public function testGetClientByMethodThrowsExceptionSelectingConnectionByUnknownId(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Cannot find a connection by id matching `127.0.0.1:7000`');

        $aggregate = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $aggregate
            ->expects($this->once())
            ->method('getConnectionById')
            ->with('127.0.0.1:7000')
            ->willReturn(null);

        $client = new Client($aggregate);
        $client->getClientBy('id', '127.0.0.1:7000');
    }

    /**
     * @group disconnected
     */
    public function testGetClientByMethodSupportsSelectingConnectionByAlias(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();

        $aggregate = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')
            ->addMethods(['getConnectionByAlias'])
            ->getMockForAbstractClass();
        $aggregate
            ->expects($this->once())
            ->method('getConnectionByAlias')
            ->with('myalias')
            ->willReturn($connection);

        $client = new Client($aggregate);
        $nodeClient = $client->getClientBy('alias', 'myalias');

        $this->assertSame($connection, $nodeClient->getConnection());
        $this->assertSame($client->getOptions(), $nodeClient->getOptions());
    }

    /**
     * @group disconnected
     */
    public function testGetClientByMethodSupportsSelectingConnectionByKey(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();

        $aggregate = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')
            ->addMethods(['getConnectionByKey'])
            ->getMockForAbstractClass();
        $aggregate
            ->expects($this->once())
            ->method('getConnectionByKey')
            ->with('key:1')
            ->willReturn($connection);

        $client = new Client($aggregate);
        $nodeClient = $client->getClientBy('key', 'key:1');

        $this->assertSame($connection, $nodeClient->getConnection());
        $this->assertSame($client->getOptions(), $nodeClient->getOptions());
    }

    /**
     * @group disconnected
     */
    public function testGetClientByMethodSupportsSelectingConnectionBySlot(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();

        $aggregate = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')
            ->addMethods(['getConnectionBySlot'])
            ->getMockForAbstractClass();
        $aggregate
            ->expects($this->once())
            ->method('getConnectionBySlot')
            ->with(5460)
            ->willReturn($connection);

        $client = new Client($aggregate);
        $nodeClient = $client->getClientBy('slot', 5460);

        $this->assertSame($connection, $nodeClient->getConnection());
        $this->assertSame($client->getOptions(), $nodeClient->getOptions());
    }

    /**
     * @group disconnected
     */
    public function testGetClientByMethodSupportsSelectingConnectionByRole(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();

        $aggregate = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')
            ->addMethods(['getConnectionByRole'])
            ->getMockForAbstractClass();
        $aggregate
            ->expects($this->once())
            ->method('getConnectionByRole')
            ->with('master')
            ->willReturn($connection);

        $client = new Client($aggregate);
        $nodeClient = $client->getClientBy('role', 'master');

        $this->assertSame($connection, $nodeClient->getConnection());
        $this->assertSame($client->getOptions(), $nodeClient->getOptions());
    }

    /**
     * @group disconnected
     */
    public function testGetClientByMethodSupportsSelectingConnectionByCommand(): void
    {
        $command = Command\RawCommand::create('GET', 'key');
        $connection = $this->getMockBuilder('Predis\Connection\ConnectionInterface')->getMock();

        $aggregate = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')
            ->onlyMethods(['getConnectionByCommand'])
            ->getMockForAbstractClass();
        $aggregate
            ->expects($this->once())
            ->method('getConnectionByCommand')
            ->with($command)
            ->willReturn($connection);

        $client = new Client($aggregate);
        $nodeClient = $client->getClientBy('command', $command);

        $this->assertSame($connection, $nodeClient->getConnection());
        $this->assertSame($client->getOptions(), $nodeClient->getOptions());
    }

    /**
     * @group disconnected
     */
    public function testGetClientByMethodThrowsExceptionWhenSelectingConnectionByUnknownType(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Invalid selector type: `unknown`');

        $client = new Client('tcp://127.0.0.1?alias=node01');

        $client->getClientBy('unknown', 'test');
    }

    /**
     * @group disconnected
     */
    public function testGetClientByMethodThrowsExceptionWhenConnectionDoesNotSupportSelectorType(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Selecting connection by id is not supported by Predis\Connection\StreamConnection');

        $client = new Client('tcp://127.0.0.1?alias=node01');

        $client->getClientBy('id', 'node01');
    }

    /**
     * @group disconnected
     */
    public function testPipelineWithoutArgumentsReturnsPipeline(): void
    {
        $client = new Client();

        $this->assertInstanceOf('Predis\Pipeline\Pipeline', $client->pipeline());
    }

    /**
     * @group disconnected
     */
    public function testPipelineWithArrayReturnsPipeline(): void
    {
        $client = new Client();

        $this->assertInstanceOf('Predis\Pipeline\Pipeline', $client->pipeline([]));
        $this->assertInstanceOf('Predis\Pipeline\Atomic', $client->pipeline(['atomic' => true]));
        $this->assertInstanceOf('Predis\Pipeline\FireAndForget', $client->pipeline(['fire-and-forget' => true]));
    }

    /**
     * @group disconnected
     */
    public function testPipelineWithCallableExecutesPipeline(): void
    {
        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Pipeline\Pipeline'));

        $client = new Client();
        $client->pipeline($callable);
    }

    /**
     * @group disconnected
     */
    public function testPubSubLoopWithoutArgumentsReturnsPubSubConsumer(): void
    {
        $client = new Client();

        $this->assertInstanceOf('Predis\PubSub\Consumer', $client->pubSubLoop());
    }

    /**
     * @group disconnected
     */
    public function testPubSubLoopWithArrayReturnsPubSubConsumerWithOptions(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $options = ['subscribe' => 'channel'];

        $client = new Client($connection);

        $this->assertInstanceOf('Predis\PubSub\Consumer', $pubsub = $client->pubSubLoop($options));

        $reflection = new ReflectionProperty($pubsub, 'options');
        $reflection->setAccessible(true);

        $this->assertSame($options, $reflection->getValue($pubsub));
    }

    /**
     * @group disconnected
     */
    public function testPubSubLoopWithArrayAndCallableExecutesPubSub(): void
    {
        // NOTE: we use a subscribe count of 0 in the message payload to trick
        //       the context and forcing it to be closed since there are no more
        //       active subscriptions.
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('read')
            ->willReturn(['subscribe', 'channel', 0]);

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke');

        $client = new Client($connection);
        $this->assertNull($client->pubSubLoop(['subscribe' => 'channel'], $callable));
    }

    /**
     * @group disconnected
     */
    public function testPubSubLoopWithCallableReturningFalseStopsPubSubConsumer(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('read')
            ->willReturnOnConsecutiveCalls(
                ['subscribe', 'channel', 1],
                ['unsubscribe', 'channel', 0]
            );
        $connection
            ->expects($this->exactly(2))
            ->method('writeRequest')
            ->withConsecutive(
                [$this->isRedisCommand('SUBSCRIBE')],
                [$this->isRedisCommand('UNSUBSCRIBE')]
            );

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->exactly(2))
            ->method('__invoke')
            ->withConsecutive(
                [
                    $this->isInstanceOf('Predis\PubSub\Consumer'),
                    (object) ['kind' => 'subscribe', 'channel' => 'channel', 'payload' => 1],
                ],
                [
                    $this->isInstanceOf('Predis\PubSub\Consumer'),
                    (object) ['kind' => 'unsubscribe', 'channel' => 'channel', 'payload' => 0],
                ]
            )
            ->willReturnOnConsecutiveCalls(
                false,
                null // <-- this value would be ignored as it is the callback to UNSUBSCRIBE
            );

        $client = new Client($connection);

        $this->assertNull($client->pubSubLoop(['subscribe' => 'channel'], $callable));
    }

    /**
     * @group disconnected
     */
    public function testTransactionWithoutArgumentsReturnsMultiExec(): void
    {
        $client = new Client();

        $this->assertInstanceOf('Predis\Transaction\MultiExec', $client->transaction());
    }

    /**
     * @group disconnected
     */
    public function testTransactionWithArrayReturnsMultiExecTransactionWithOptions(): void
    {
        $options = ['cas' => true, 'retry' => 3];

        $client = new Client();

        $this->assertInstanceOf('Predis\Transaction\MultiExec', $tx = $client->transaction($options));

        // I hate this part but reflection is the easiest way in this case.
        $property = new ReflectionProperty($tx, 'modeCAS');
        $property->setAccessible(true);
        $this->assertSame($options['cas'], $property->getValue($tx));

        $property = new ReflectionProperty($tx, 'attempts');
        $property->setAccessible(true);
        $this->assertSame($options['retry'], $property->getValue($tx));
    }

    /**
     * @group disconnected
     */
    public function testTransactionWithArrayAndCallableExecutesMultiExec(): void
    {
        // We use CAS here as we don't care about the actual MULTI/EXEC context.
        $options = ['cas' => true, 'retry' => 3];

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('executeCommand')
            ->willReturn(new Response\Status('QUEUED'));

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->willReturnCallback(function ($tx) { $tx->ping(); });

        $client = new Client($connection);
        $client->transaction($options, $callable);
    }

    /**
     * @group disconnected
     */
    public function testMonitorReturnsMonitorConsumer(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $client = new Client($connection);

        $this->assertInstanceOf('Predis\Monitor\Consumer', $monitor = $client->monitor());
    }

    /**
     * @group disconnected
     */
    public function testClientResendScriptCommandUsingEvalOnNoScriptErrors(): void
    {
        $luaScriptBody = 'return redis.call(\'exists\', KEYS[1])';

        $command = $this->getMockForAbstractClass('Predis\Command\ScriptCommand', [], '', true, true, true, ['parseResponse']);
        $command
            ->expects($this->once())
            ->method('getScript')
            ->willReturn($luaScriptBody);
        $command
            ->expects($this->once())
            ->method('parseResponse')
            ->with('OK')
            ->willReturn(true);

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$command],
                [$this->isRedisCommand('EVAL', [$luaScriptBody])]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Error('NOSCRIPT'),
                'OK'
            );

        $client = new Client($connection);

        $this->assertTrue($client->executeCommand($command));
    }

    /**
     * @group disconnected
     */
    public function testGetIteratorWithTraversableConnections(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6381');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6382');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6383');

        $aggregate = new Connection\Cluster\PredisCluster();

        $aggregate->add($connection1);
        $aggregate->add($connection2);
        $aggregate->add($connection3);

        $client = new Client($aggregate);

        /** @var Iterator */
        $iterator = $client->getIterator();

        $this->assertInstanceOf('\Predis\Client', $nodeClient = $iterator->current());
        $this->assertSame($connection1, $nodeClient->getConnection());
        $this->assertSame('127.0.0.1:6381', $iterator->key());

        $iterator->next();

        $this->assertInstanceOf('\Predis\Client', $nodeClient = $iterator->current());
        $this->assertSame($connection2, $nodeClient->getConnection());
        $this->assertSame('127.0.0.1:6382', $iterator->key());

        $iterator->next();

        $this->assertInstanceOf('\Predis\Client', $nodeClient = $iterator->current());
        $this->assertSame($connection3, $nodeClient->getConnection());
        $this->assertSame('127.0.0.1:6383', $iterator->key());
    }

    /**
     * @group disconnected
     */
    public function testGetIteratorWithNonTraversableConnectionNoException(): void
    {
        $connection = $this->getMockConnection('tcp://127.0.0.1:6381');
        $client = new Client($connection);

        /** @var Iterator */
        $iterator = $client->getIterator();

        $this->assertInstanceOf('\Predis\Client', $nodeClient = $iterator->current());
        $this->assertSame($connection, $nodeClient->getConnection());
        $this->assertSame('127.0.0.1:6381', $iterator->key());
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requiresRedisVersion >= 7.2.0
     */
    public function testDoNoSetClientInfoOnConnection(): void
    {
        $client = new Client($this->getParameters());
        $libName = $client->client('LIST')[0]['lib-name'];
        $libVer = $client->client('LIST')[0]['lib-ver'];

        $this->assertEmpty($libName);
        $this->assertEmpty($libVer);
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requiresRedisVersion >= 7.2.0
     */
    public function testSetClientInfoOnConnectionWhenEnabled(): void
    {
        $client = new Client($this->getParameters(['client_info' => true]));
        $libName = $client->client('LIST')[0]['lib-name'];
        $libVer = $client->client('LIST')[0]['lib-ver'];

        $this->assertSame('predis', $libName);
        $this->assertSame(Client::VERSION, $libVer);
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns an URI string representation of the specified connection parameters.
     *
     * @param array $parameters Array of connection parameters.
     *
     * @return string URI string.
     */
    protected function getParametersString(array $parameters): string
    {
        $defaults = $this->getDefaultParametersArray();

        $scheme = $parameters['scheme'] ?? $defaults['scheme'];
        $host = $parameters['host'] ?? $defaults['host'];
        $port = $parameters['port'] ?? $defaults['port'];

        unset($parameters['scheme'], $parameters['host'], $parameters['port']);
        $uriString = "$scheme://$host:$port/?";

        foreach ($parameters as $k => $v) {
            $uriString .= "$k=$v&";
        }

        return $uriString;
    }

    /**
     * Returns a mock object simulating an aggregate connection initializer.
     *
     * @param ParametersInterface|array|string $parameters Expected connection parameters
     *
     * @return callable|MockObject
     */
    protected function getAggregateInitializer($parameters)
    {
        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with(
                $parameters,
                $this->isInstanceOf('Predis\Configuration\OptionsInterface'),
                $this->isInstanceOf('Predis\Configuration\OptionInterface')
            )
            ->willReturn($connection);

        return $callable;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\CommunicationExceptionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

use Exception;
use PHPUnit\Framework\MockObject\MockObject;
use PredisTestCase;

class CommunicationExceptionTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testExceptionReturnsInnerConnection(): void
    {
        $connection = $this->getMockConnection();
        $exception = $this->createMockException($connection, 'Communication error message');

        $this->assertSame($connection, $exception->getConnection());
    }

    /**
     * @group disconnected
     */
    public function testExceptionMessage(): void
    {
        $connection = $this->getMockConnection();
        $exception = $this->createMockException($connection, $message = 'Connection error message');

        $this->expectException('Predis\CommunicationException');
        $this->expectExceptionMessage($message);

        throw $exception;
    }

    /**
     * @group disconnected
     */
    public function testShouldResetConnectionIsTrue(): void
    {
        $connection = $this->getMockConnection();
        $exception = $this->createMockException($connection, 'Communication error message');

        $this->assertTrue($exception->shouldResetConnection());
    }

    /**
     * @group disconnected
     */
    public function testCommunicationExceptionHandling(): void
    {
        $connection = $this->getMockConnection();
        $connection
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(true);
        $connection
            ->expects($this->once())
            ->method('disconnect');

        $exception = $this->createMockException($connection, $message = 'Communication error message');

        $this->expectException('Predis\CommunicationException');
        $this->expectExceptionMessage($message);

        CommunicationException::handle($exception);
    }

    /**
     * @group disconnected
     */
    public function testCommunicationExceptionHandlingWhenShouldResetConnectionIsFalse(): void
    {
        $connection = $this->getMockConnection();
        $connection
            ->expects($this->never())
            ->method('isConnected');
        $connection
            ->expects($this->never())
            ->method('disconnect');

        /** @var CommunicationException|MockObject */
        $exception = $this->getMockBuilder('Predis\CommunicationException')
            ->setConstructorArgs([$connection, 'Communication error message'])
            ->onlyMethods(['shouldResetConnection'])
            ->getMockForAbstractClass();
        $exception
            ->expects($this->once())
            ->method('shouldResetConnection')
            ->willReturn(false);

        $this->expectException('Predis\CommunicationException');
        $this->expectExceptionMessage('Communication error message');

        CommunicationException::handle($exception);
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns a connection exception instance.
     *
     * @param Connection\NodeConnectionInterface $connection Connection instance.
     * @param string                             $message    Exception message.
     * @param int                                $code       Exception code.
     * @param Exception                          $inner      Inner exception.
     *
     * @return CommunicationException
     */
    protected function createMockException(
        Connection\NodeConnectionInterface $connection,
        string $message,
        int $code = 0,
        ?Exception $inner = null
    ) {
        return $this->getMockBuilder('Predis\CommunicationException')
            ->setConstructorArgs([$connection, $message, $code, $inner])
            ->getMockForAbstractClass();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\PredisExceptionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis;

use PredisTestCase;

class PredisExceptionTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testExceptionMessage(): void
    {
        $message = 'Predis exception message';
        $exception = $this->getMockForAbstractClass('Predis\PredisException', [$message]);

        $this->expectException('Predis\PredisException');
        $this->expectExceptionMessage($message);

        throw $exception;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Cluster\PredisStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster;

use PHPUnit\Framework\MockObject\MockObject;
use PredisTestCase;

class PredisStrategyTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testSupportsKeyTags(): void
    {
        // NOTE: 32 and 64 bits PHP runtimes can produce different hash values.
        $expected = PHP_INT_SIZE == 4 ? -1954026732 : 2340940564;
        $strategy = $this->getClusterStrategy();

        $this->assertSame($expected, $strategy->getSlotByKey('{foo}'));
        $this->assertSame($expected, $strategy->getSlotByKey('{foo}:bar'));
        $this->assertSame($expected, $strategy->getSlotByKey('{foo}:baz'));
        $this->assertSame($expected, $strategy->getSlotByKey('bar:{foo}:baz'));
        $this->assertSame($expected, $strategy->getSlotByKey('bar:{foo}:{baz}'));

        $this->assertSame($expected, $strategy->getSlotByKey('bar:{foo}:baz{}'));
        $this->assertSame(PHP_INT_SIZE == 4 ? -1355751440 : 2939215856, $strategy->getSlotByKey('{}bar:{foo}:baz'));

        $this->assertSame(PHP_INT_SIZE == 4 ? -18873278 : 4276094018, $strategy->getSlotByKey(''));
        $this->assertSame(PHP_INT_SIZE == 4 ? -1574052038 : 2720915258, $strategy->getSlotByKey('{}'));
    }

    /**
     * @group disconnected
     */
    public function testSupportedCommands(): void
    {
        /** @var PredisStrategy */
        $strategy = $this->getClusterStrategy();

        $this->assertSame($this->getExpectedCommands(), $strategy->getSupportedCommands());
    }

    /**
     * @group disconnected
     */
    public function testReturnsNullOnUnsupportedCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $command = $this->getCommandFactory()->create('ping');

        $this->assertNull($strategy->getSlot($command));
    }

    /**
     * @group disconnected
     */
    public function testFirstKeyCommands(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['key'];

        foreach ($this->getExpectedCommands('keys-first') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testAllKeysCommands(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['{key}:1', '{key}:2', '{key}:3', '{key}:4'];

        foreach ($this->getExpectedCommands('keys-all') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testInterleavedKeysCommands(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['{key}:1', 'value1', '{key}:2', 'value2'];

        foreach ($this->getExpectedCommands('keys-interleaved') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testFakeKeyCommandsWithOneKey(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = [];

        foreach ($this->getExpectedCommands('keys-fake') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testKeysForSortCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['{key}:1', 'value1', '{key}:2', 'value2'];

        $commandID = 'SORT';

        $command = $commands->create($commandID, ['{key}:1']);
        $this->assertNotNull($strategy->getSlot($command), $commandID);

        $command = $commands->create($commandID, ['{key}:1', ['STORE' => '{key}:2']]);
        $this->assertNotNull($strategy->getSlot($command), $commandID);
    }

    /**
     * @group disconnected
     */
    public function testKeysForBlockingListCommands(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['{key}:1', '{key}:2', 10];

        foreach ($this->getExpectedCommands('keys-blockinglist') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testKeysForZsetAggregationCommands(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['{key}:destination', ['{key}:1', '{key}:1'], [], 'sum'];

        foreach ($this->getExpectedCommands('keys-zaggregated') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testKeysForBitOpCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['AND', '{key}:destination', '{key}:src:1', '{key}:src:2'];

        foreach ($this->getExpectedCommands('keys-bitop') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testKeysForGeoradiusCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $commandID = 'GEORADIUS';

        $command = $commands->create($commandID, ['{key}:1', 10, 10, 1, 'km']);
        $this->assertNotNull($strategy->getSlot($command), $commandID);

        $command = $commands->create($commandID, ['{key}:1', 10, 10, 1, 'km', 'store', '{key}:2', 'storedist', '{key}:3']);
        $this->assertNotNull($strategy->getSlot($command), $commandID);
    }

    /**
     * @group disconnected
     */
    public function testKeysForGeoradiusByMemberCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $commandID = 'GEORADIUSBYMEMBER';

        $command = $commands->create($commandID, ['{key}:1', 'member', 1, 'km']);
        $this->assertNotNull($strategy->getSlot($command), $commandID);

        $command = $commands->create($commandID, ['{key}:1', 'member', 1, 'km', 'store', '{key}:2', 'storedist', '{key}:3']);
        $this->assertNotNull($strategy->getSlot($command), $commandID);
    }

    /**
     * @group disconnected
     */
    public function testKeysForEvalCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['%SCRIPT%', 2, '{key}:1', '{key}:2', 'value1', 'value2'];

        foreach ($this->getExpectedCommands('keys-script') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testKeysForScriptCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $arguments = ['{key}:1', '{key}:2', 'value1', 'value2'];

        /** @var \Predis\Command\CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript', 'getKeysCount'])
            ->getMock();
        $command
            ->expects($this->once())
            ->method('getScript')
            ->willReturn('return true');
        $command
            ->expects($this->exactly(2))
            ->method('getKeysCount')
            ->willReturn(2);
        $command->setArguments($arguments);

        $this->assertNotNull($strategy->getSlot($command), "Script Command [{$command->getId()}]");
    }

    /**
     * @group disconnected
     */
    public function testUnsettingCommandHandler(): void
    {
        /** @var PredisStrategy */
        $strategy = $this->getClusterStrategy();
        $strategy->setCommandHandler('set');
        $strategy->setCommandHandler('get', null);

        $commands = $this->getCommandFactory();

        $command = $commands->create('set', ['key', 'value']);
        $this->assertNull($strategy->getSlot($command));

        $command = $commands->create('get', ['key']);
        $this->assertNull($strategy->getSlot($command));
    }

    /**
     * @group disconnected
     */
    public function testSettingCustomCommandHandler(): void
    {
        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Command\CommandInterface'))
            ->willReturn('key');

        /** @var PredisStrategy */
        $strategy = $this->getClusterStrategy();
        $strategy->setCommandHandler('get', $callable);

        $commands = $this->getCommandFactory();
        $command = $commands->create('get', ['key']);

        $this->assertNotNull($strategy->getSlot($command));
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Creates the default cluster strategy object.
     *
     * @return StrategyInterface
     */
    protected function getClusterStrategy(): StrategyInterface
    {
        $strategy = new PredisStrategy();

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $strategy->getDistributor()->add($connection);

        return $strategy;
    }

    /**
     * Returns the list of expected supported commands.
     *
     * @param ?string $type Optional type of command (based on its keys)
     *
     * @return array
     */
    protected function getExpectedCommands(?string $type = null): array
    {
        $commands = [
            /* commands operating on the key space */
            'EXISTS' => 'keys-all',
            'DEL' => 'keys-all',
            'TYPE' => 'keys-first',
            'EXPIRE' => 'keys-first',
            'EXPIREAT' => 'keys-first',
            'PERSIST' => 'keys-first',
            'PEXPIRE' => 'keys-first',
            'PEXPIREAT' => 'keys-first',
            'TTL' => 'keys-first',
            'PTTL' => 'keys-first',
            'SORT' => 'variable',
            'DUMP' => 'keys-first',
            'RESTORE' => 'keys-first',
            'FLUSHDB' => 'keys-fake',

            /* commands operating on string values */
            'APPEND' => 'keys-first',
            'DECR' => 'keys-first',
            'DECRBY' => 'keys-first',
            'GET' => 'keys-first',
            'GETBIT' => 'keys-first',
            'MGET' => 'keys-all',
            'SET' => 'keys-first',
            'GETRANGE' => 'keys-first',
            'GETSET' => 'keys-first',
            'INCR' => 'keys-first',
            'INCRBY' => 'keys-first',
            'INCRBYFLOAT' => 'keys-first',
            'SETBIT' => 'keys-first',
            'SETEX' => 'keys-first',
            'MSET' => 'keys-interleaved',
            'MSETNX' => 'keys-interleaved',
            'SETNX' => 'keys-first',
            'SETRANGE' => 'keys-first',
            'STRLEN' => 'keys-first',
            'SUBSTR' => 'keys-first',
            'BITOP' => 'keys-bitop',
            'BITCOUNT' => 'keys-first',
            'BITFIELD' => 'keys-first',

            /* commands operating on lists */
            'LINSERT' => 'keys-first',
            'LINDEX' => 'keys-first',
            'LLEN' => 'keys-first',
            'LPOP' => 'keys-first',
            'RPOP' => 'keys-first',
            'RPOPLPUSH' => 'keys-all',
            'BLPOP' => 'keys-blockinglist',
            'BRPOP' => 'keys-blockinglist',
            'BRPOPLPUSH' => 'keys-blockinglist',
            'LPUSH' => 'keys-first',
            'LPUSHX' => 'keys-first',
            'RPUSH' => 'keys-first',
            'RPUSHX' => 'keys-first',
            'LRANGE' => 'keys-first',
            'LREM' => 'keys-first',
            'LSET' => 'keys-first',
            'LTRIM' => 'keys-first',

            /* commands operating on sets */
            'SADD' => 'keys-first',
            'SCARD' => 'keys-first',
            'SDIFF' => 'keys-all',
            'SDIFFSTORE' => 'keys-all',
            'SINTER' => 'keys-all',
            'SINTERSTORE' => 'keys-all',
            'SUNION' => 'keys-all',
            'SUNIONSTORE' => 'keys-all',
            'SISMEMBER' => 'keys-first',
            'SMEMBERS' => 'keys-first',
            'SSCAN' => 'keys-first',
            'SPOP' => 'keys-first',
            'SRANDMEMBER' => 'keys-first',
            'SREM' => 'keys-first',

            /* commands operating on sorted sets */
            'ZADD' => 'keys-first',
            'ZCARD' => 'keys-first',
            'ZCOUNT' => 'keys-first',
            'ZINCRBY' => 'keys-first',
            'ZINTERSTORE' => 'keys-zaggregated',
            'ZRANGE' => 'keys-first',
            'ZRANGEBYSCORE' => 'keys-first',
            'ZRANK' => 'keys-first',
            'ZREM' => 'keys-first',
            'ZREMRANGEBYRANK' => 'keys-first',
            'ZREMRANGEBYSCORE' => 'keys-first',
            'ZREVRANGE' => 'keys-first',
            'ZREVRANGEBYSCORE' => 'keys-first',
            'ZREVRANK' => 'keys-first',
            'ZSCORE' => 'keys-first',
            'ZUNIONSTORE' => 'keys-zaggregated',
            'ZSCAN' => 'keys-first',
            'ZLEXCOUNT' => 'keys-first',
            'ZRANGEBYLEX' => 'keys-first',
            'ZREMRANGEBYLEX' => 'keys-first',
            'ZREVRANGEBYLEX' => 'keys-first',

            /* commands operating on hashes */
            'HDEL' => 'keys-first',
            'HEXISTS' => 'keys-first',
            'HGET' => 'keys-first',
            'HGETALL' => 'keys-first',
            'HMGET' => 'keys-first',
            'HMSET' => 'keys-first',
            'HINCRBY' => 'keys-first',
            'HINCRBYFLOAT' => 'keys-first',
            'HKEYS' => 'keys-first',
            'HLEN' => 'keys-first',
            'HSET' => 'keys-first',
            'HSETNX' => 'keys-first',
            'HVALS' => 'keys-first',
            'HSCAN' => 'keys-first',
            'HSTRLEN' => 'keys-first',

            /* commands operating on HyperLogLog */
            'PFADD' => 'keys-first',
            'PFCOUNT' => 'keys-all',
            'PFMERGE' => 'keys-all',

            /* scripting */
            'EVAL' => 'keys-script',
            'EVALSHA' => 'keys-script',

            /* server */
            'INFO' => 'keys-fake',

            /* commands performing geospatial operations */
            'GEOADD' => 'keys-first',
            'GEOHASH' => 'keys-first',
            'GEOPOS' => 'keys-first',
            'GEODIST' => 'keys-first',
            'GEORADIUS' => 'keys-georadius',
            'GEORADIUSBYMEMBER' => 'keys-georadius',

            /* cluster */
            'CLUSTER' => 'keys-fake',
        ];

        if (isset($type)) {
            $commands = array_filter($commands, function (string $expectedType) use ($type) {
                return $expectedType === $type;
            });
        }

        return array_keys($commands);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Cluster\RedisStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster;

use PHPUnit\Framework\MockObject\MockObject;
use PredisTestCase;

class RedisStrategyTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testSupportsKeyTags(): void
    {
        $strategy = $this->getClusterStrategy();

        $this->assertSame(12182, $strategy->getSlotByKey('{foo}'));
        $this->assertSame(12182, $strategy->getSlotByKey('{foo}:bar'));
        $this->assertSame(12182, $strategy->getSlotByKey('{foo}:baz'));
        $this->assertSame(12182, $strategy->getSlotByKey('bar:{foo}:baz'));
        $this->assertSame(12182, $strategy->getSlotByKey('bar:{foo}:{baz}'));

        $this->assertSame(12182, $strategy->getSlotByKey('bar:{foo}:baz{}'));
        $this->assertSame(9415, $strategy->getSlotByKey('{}bar:{foo}:baz'));

        $this->assertSame(0, $strategy->getSlotByKey(''));
        $this->assertSame(15257, $strategy->getSlotByKey('{}'));
    }

    /**
     * @group disconnected
     */
    public function testSupportedCommands(): void
    {
        /** @var RedisStrategy */
        $strategy = $this->getClusterStrategy();

        $this->assertSame($this->getExpectedCommands(), $strategy->getSupportedCommands());
    }

    /**
     * @group disconnected
     */
    public function testReturnsNullOnUnsupportedCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $command = $this->getCommandFactory()->create('ping');

        $this->assertNull($strategy->getSlot($command));
    }

    /**
     * @group disconnected
     */
    public function testFirstKeyCommands(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['key'];

        foreach ($this->getExpectedCommands('keys-first') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testAllKeysCommandsWithOneKey(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['key'];

        foreach ($this->getExpectedCommands('keys-all') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testAllKeysCommandsWithMoreKeys(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['key1', 'key2'];

        foreach ($this->getExpectedCommands('keys-all') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testInterleavedKeysCommandsWithOneKey(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['key:1', 'value1'];

        foreach ($this->getExpectedCommands('keys-interleaved') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testInterleavedKeysCommandsWithMoreKeys(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['key:1', 'value1', 'key:2', 'value2'];

        foreach ($this->getExpectedCommands('keys-interleaved') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testFakeKeyCommandsWithOneKey(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = [];

        foreach ($this->getExpectedCommands('keys-fake') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testKeysForSortCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['{key}:1', 'value1', '{key}:2', 'value2'];

        $commandID = 'SORT';

        $command = $commands->create($commandID, ['{key}:1']);
        $this->assertNotNull($strategy->getSlot($command), $commandID);

        $command = $commands->create($commandID, ['{key}:1', ['STORE' => '{key}:2']]);
        $this->assertNotNull($strategy->getSlot($command), $commandID);
    }

    /**
     * @group disconnected
     */
    public function testKeysForBlockingListCommandsWithOneKey(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['key:1', 10];

        foreach ($this->getExpectedCommands('keys-blockinglist') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testKeysForBlockingListCommandsWithMoreKeys(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['key:1', 'key:2', 10];

        foreach ($this->getExpectedCommands('keys-blockinglist') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testKeysForGeoradiusCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();

        $commandID = 'GEORADIUS';

        $command = $commands->create($commandID, ['{key}:1', 10, 10, 1, 'km']);
        $this->assertNotNull($strategy->getSlot($command), $commandID);

        $command = $commands->create($commandID, ['{key}:1', 10, 10, 1, 'km', 'store', '{key}:2', 'storedist', '{key}:3']);
        $this->assertNotNull($strategy->getSlot($command), $commandID);
    }

    /**
     * @group disconnected
     */
    public function testKeysForGeoradiusByMemberCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();

        $commandID = 'GEORADIUSBYMEMBER';

        $command = $commands->create($commandID, ['{key}:1', 'member', 1, 'km']);
        $this->assertNotNull($strategy->getSlot($command), $commandID);

        $command = $commands->create($commandID, ['{key}:1', 'member', 1, 'km', 'store', '{key}:2', 'storedist', '{key}:3']);
        $this->assertNotNull($strategy->getSlot($command), $commandID);
    }

    /**
     * @group disconnected
     */
    public function testKeysForEvalCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $commands = $this->getCommandFactory();
        $arguments = ['%SCRIPT%', 1, 'key:1', 'value1'];

        foreach ($this->getExpectedCommands('keys-script') as $commandID) {
            $command = $commands->create($commandID, $arguments);
            $this->assertNotNull($strategy->getSlot($command), $commandID);
        }
    }

    /**
     * @group disconnected
     */
    public function testKeysForScriptCommand(): void
    {
        $strategy = $this->getClusterStrategy();
        $arguments = ['key:1', 'value1'];

        /** @var \Predis\Command\CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript', 'getKeysCount'])
            ->getMock();
        $command
            ->expects($this->once())
            ->method('getScript')
            ->willReturn('return true');
        $command
            ->expects($this->exactly(2))
            ->method('getKeysCount')
            ->willReturn(1);
        $command->setArguments($arguments);

        $this->assertNotNull($strategy->getSlot($command), "Script Command [{$command->getId()}]");
    }

    /**
     * @group disconnected
     */
    public function testUnsettingCommandHandler(): void
    {
        /** @var RedisStrategy */
        $strategy = $this->getClusterStrategy();
        $strategy->setCommandHandler('set');
        $strategy->setCommandHandler('get', null);

        $commands = $this->getCommandFactory();
        $command = $commands->create('set', ['key', 'value']);
        $this->assertNull($strategy->getSlot($command));

        $command = $commands->create('get', ['key']);
        $this->assertNull($strategy->getSlot($command));
    }

    /**
     * @group disconnected
     */
    public function testSettingCustomCommandHandler(): void
    {
        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Command\CommandInterface'))
            ->willReturn('key');

        /** @var RedisStrategy */
        $strategy = $this->getClusterStrategy();
        $strategy->setCommandHandler('get', $callable);

        $commands = $this->getCommandFactory();
        $command = $commands->create('get', ['key']);

        $this->assertNotNull($strategy->getSlot($command));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnGetDistributorMethod(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage('Predis\Cluster\RedisStrategy does not provide an external distributor');

        $strategy = $this->getClusterStrategy();
        $strategy->getDistributor();
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Creates the default cluster strategy object.
     *
     * @return StrategyInterface
     */
    protected function getClusterStrategy(): StrategyInterface
    {
        $strategy = new RedisStrategy();

        return $strategy;
    }

    /**
     * Returns the list of expected supported commands.
     *
     * @param ?string $type Optional type of command (based on its keys)
     *
     * @return array
     */
    protected function getExpectedCommands(?string $type = null): array
    {
        $commands = [
            /* commands operating on the key space */
            'EXISTS' => 'keys-all',
            'DEL' => 'keys-all',
            'TYPE' => 'keys-first',
            'EXPIRE' => 'keys-first',
            'EXPIREAT' => 'keys-first',
            'PERSIST' => 'keys-first',
            'PEXPIRE' => 'keys-first',
            'PEXPIREAT' => 'keys-first',
            'TTL' => 'keys-first',
            'PTTL' => 'keys-first',
            'SORT' => 'keys-first', // TODO
            'DUMP' => 'keys-first',
            'RESTORE' => 'keys-first',
            'FLUSHDB' => 'keys-fake',

            /* commands operating on string values */
            'APPEND' => 'keys-first',
            'DECR' => 'keys-first',
            'DECRBY' => 'keys-first',
            'GET' => 'keys-first',
            'GETBIT' => 'keys-first',
            'MGET' => 'keys-all',
            'SET' => 'keys-first',
            'GETRANGE' => 'keys-first',
            'GETSET' => 'keys-first',
            'INCR' => 'keys-first',
            'INCRBY' => 'keys-first',
            'INCRBYFLOAT' => 'keys-first',
            'SETBIT' => 'keys-first',
            'SETEX' => 'keys-first',
            'MSET' => 'keys-interleaved',
            'MSETNX' => 'keys-interleaved',
            'SETNX' => 'keys-first',
            'SETRANGE' => 'keys-first',
            'STRLEN' => 'keys-first',
            'SUBSTR' => 'keys-first',
            'BITOP' => 'keys-bitop',
            'BITCOUNT' => 'keys-first',
            'BITFIELD' => 'keys-first',

            /* commands operating on lists */
            'LINSERT' => 'keys-first',
            'LINDEX' => 'keys-first',
            'LLEN' => 'keys-first',
            'LPOP' => 'keys-first',
            'RPOP' => 'keys-first',
            'RPOPLPUSH' => 'keys-all',
            'BLPOP' => 'keys-blockinglist',
            'BRPOP' => 'keys-blockinglist',
            'BRPOPLPUSH' => 'keys-blockinglist',
            'LPUSH' => 'keys-first',
            'LPUSHX' => 'keys-first',
            'RPUSH' => 'keys-first',
            'RPUSHX' => 'keys-first',
            'LRANGE' => 'keys-first',
            'LREM' => 'keys-first',
            'LSET' => 'keys-first',
            'LTRIM' => 'keys-first',

            /* commands operating on sets */
            'SADD' => 'keys-first',
            'SCARD' => 'keys-first',
            'SDIFF' => 'keys-all',
            'SDIFFSTORE' => 'keys-all',
            'SINTER' => 'keys-all',
            'SINTERSTORE' => 'keys-all',
            'SUNION' => 'keys-all',
            'SUNIONSTORE' => 'keys-all',
            'SISMEMBER' => 'keys-first',
            'SMEMBERS' => 'keys-first',
            'SSCAN' => 'keys-first',
            'SPOP' => 'keys-first',
            'SRANDMEMBER' => 'keys-first',
            'SREM' => 'keys-first',

            /* commands operating on sorted sets */
            'ZADD' => 'keys-first',
            'ZCARD' => 'keys-first',
            'ZCOUNT' => 'keys-first',
            'ZINCRBY' => 'keys-first',
            'ZINTERSTORE' => 'keys-zaggregated',
            'ZRANGE' => 'keys-first',
            'ZRANGEBYSCORE' => 'keys-first',
            'ZRANK' => 'keys-first',
            'ZREM' => 'keys-first',
            'ZREMRANGEBYRANK' => 'keys-first',
            'ZREMRANGEBYSCORE' => 'keys-first',
            'ZREVRANGE' => 'keys-first',
            'ZREVRANGEBYSCORE' => 'keys-first',
            'ZREVRANK' => 'keys-first',
            'ZSCORE' => 'keys-first',
            'ZUNIONSTORE' => 'keys-zaggregated',
            'ZSCAN' => 'keys-first',
            'ZLEXCOUNT' => 'keys-first',
            'ZRANGEBYLEX' => 'keys-first',
            'ZREMRANGEBYLEX' => 'keys-first',
            'ZREVRANGEBYLEX' => 'keys-first',

            /* commands operating on hashes */
            'HDEL' => 'keys-first',
            'HEXISTS' => 'keys-first',
            'HGET' => 'keys-first',
            'HGETALL' => 'keys-first',
            'HMGET' => 'keys-first',
            'HMSET' => 'keys-first',
            'HINCRBY' => 'keys-first',
            'HINCRBYFLOAT' => 'keys-first',
            'HKEYS' => 'keys-first',
            'HLEN' => 'keys-first',
            'HSET' => 'keys-first',
            'HSETNX' => 'keys-first',
            'HVALS' => 'keys-first',
            'HSCAN' => 'keys-first',
            'HSTRLEN' => 'keys-first',

            /* commands operating on HyperLogLog */
            'PFADD' => 'keys-first',
            'PFCOUNT' => 'keys-all',
            'PFMERGE' => 'keys-all',

            /* scripting */
            'EVAL' => 'keys-script',
            'EVALSHA' => 'keys-script',

            /* server */
            'INFO' => 'keys-fake',

            /* commands performing geospatial operations */
            'GEOADD' => 'keys-first',
            'GEOHASH' => 'keys-first',
            'GEOPOS' => 'keys-first',
            'GEODIST' => 'keys-first',
            'GEORADIUS' => 'keys-georadius',
            'GEORADIUSBYMEMBER' => 'keys-georadius',

            /* cluster */
            'CLUSTER' => 'keys-fake',
        ];

        if (isset($type)) {
            $commands = array_filter($commands, function (string $expectedType) use ($type) {
                return $expectedType === $type;
            });
        }

        return array_keys($commands);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Cluster\SlotMapTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster;

use PredisTestCase;

class SlotMapTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testIsValidReturnsTrueOnValidSlot(): void
    {
        $this->assertTrue(SlotMap::isValid(0));
        $this->assertTrue(SlotMap::isValid(16383));

        $this->assertTrue(SlotMap::isValid(5000));
        $this->assertTrue(SlotMap::isValid('5000'));
    }

    /**
     * @group disconnected
     */
    public function testIsValidReturnsFalseOnInvalidSlot(): void
    {
        $this->assertFalse(SlotMap::isValid(-1));
        $this->assertFalse(SlotMap::isValid(16384));
    }

    /**
     * @group disconnected
     */
    public function testIsValidRangeReturnsTrueOnValidSlotRange(): void
    {
        $this->assertTrue(SlotMap::isValidRange(0, 16383));
        $this->assertTrue(SlotMap::isValidRange(2000, 2999));
        $this->assertTrue(SlotMap::isValidRange(3000, 3000));
    }

    /**
     * @group disconnected
     */
    public function testIsValidRangeReturnsFalseOnInvalidSlotRange(): void
    {
        $this->assertFalse(SlotMap::isValidRange(0, 16384));
        $this->assertFalse(SlotMap::isValidRange(-1, 16383));
        $this->assertFalse(SlotMap::isValidRange(-1, 16384));
        $this->assertFalse(SlotMap::isValidRange(2999, 2000));
    }

    /**
     * @group disconnected
     */
    public function testToArrayReturnsEmptyArrayOnEmptySlotMap(): void
    {
        $slotmap = new SlotMap();

        $this->assertEmpty($slotmap->toArray());
    }

    /**
     * @group disconnected
     */
    public function testSetSlotsAssignsSpecifiedNodeToSlotRange(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');
        $slotmap->setSlots(5461, 10922, '127.0.0.1:6380');
        $slotmap->setSlots(10923, 16383, '127.0.0.1:6381');

        $expectedMap = array_merge(
            array_fill(0, 5461, '127.0.0.1:6379'),
            array_fill(5461, 5462, '127.0.0.1:6380'),
            array_fill(10923, 5461, '127.0.0.1:6381')
        );

        $this->assertSame($expectedMap, $slotmap->toArray());
    }

    /**
     * @group disconnected
     */
    public function testSetSlotsOverwritesSlotRange(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');
        $slotmap->setSlots(1000, 2000, '127.0.0.1:6380');

        $expectedMap =
            array_fill(0, 5461, '127.0.0.1:6379') +
            array_fill(1000, 2000, '127.0.0.1:6380');

        $this->assertSame($expectedMap, $slotmap->toArray());
    }

    /**
     * @group disconnected
     */
    public function testSetSlotsAssignsSingleSlotWhenFirstAndLastSlotMatch(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(10, 10, '127.0.0.1:6379');

        $this->assertSame([10 => '127.0.0.1:6379'], $slotmap->toArray());
    }

    /**
     * @group disconnected
     */
    public function testSetSlotsCastsValueToString(): void
    {
        $slotmap = new SlotMap();

        $connection = $this->getMockConnection();
        $connection
            ->expects($this->once())
            ->method('__toString')
            ->willReturn('127.0.0.1:6379');

        $slotmap->setSlots(10, 10, $connection);

        $this->assertSame([10 => '127.0.0.1:6379'], $slotmap->toArray());
    }

    /**
     * @group disconnected
     */
    public function testSetSlotsThrowsExceptionOnInvalidSlotRange(): void
    {
        $this->expectException('OutOfBoundsException');
        $this->expectExceptionMessage('Invalid slot range 0-16384 for `127.0.0.1:6379`');

        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 16384, '127.0.0.1:6379');
    }

    /**
     * @group disconnected
     */
    public function testGetSlotsReturnsEmptyArrayOnEmptySlotMap(): void
    {
        $slotmap = new SlotMap();

        $this->assertEmpty($slotmap->getSlots(3, 11));
    }

    /**
     * @group disconnected
     */
    public function testGetSlotsReturnsDictionaryOfSlotsWithAssignedNodes(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5, '127.0.0.1:6379');
        $slotmap->setSlots(10, 13, '127.0.0.1:6380');

        $expectedMap = [
            3 => '127.0.0.1:6379',
            4 => '127.0.0.1:6379',
            5 => '127.0.0.1:6379',
            10 => '127.0.0.1:6380',
            11 => '127.0.0.1:6380',
        ];

        $this->assertSame($expectedMap, $slotmap->getSlots(3, 11));
    }

    /**
     * @group disconnected
     */
    public function testGetSlotsReturnsEmptyArrayOnEmptySlotRange(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5, '127.0.0.1:6379');
        $slotmap->setSlots(10, 13, '127.0.0.1:6380');

        $this->assertEmpty($slotmap->getSlots(100, 200));
    }

    /**
     * @group disconnected
     */
    public function testGetSlotsThrowsExceptionOnInvalidSlotRange(): void
    {
        $this->expectException('OutOfBoundsException');
        $this->expectExceptionMessage('Invalid slot range 0-16384');

        $slotmap = new SlotMap();

        $slotmap->getSlots(0, 16384);
    }

    /**
     * @group disconnected
     */
    public function testIsEmptyReturnsTrueOnEmptySlotMap(): void
    {
        $slotmap = new SlotMap();

        $this->assertTrue($slotmap->isEmpty());
    }

    /**
     * @group disconnected
     */
    public function testIsEmptyReturnsFalseOnNonEmptySlotMap(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');

        $this->assertFalse($slotmap->isEmpty());
    }

    /**
     * @group disconnected
     */
    public function testCountReturnsZeroOnEmptySlotMap(): void
    {
        $slotmap = new SlotMap();

        $this->assertCount(0, $slotmap);
    }

    /**
     * @group disconnected
     */
    public function testCountReturnsAssignedSlotsInSlotMap(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');
        $this->assertCount(5461, $slotmap);

        $slotmap->setSlots(5461, 10922, '127.0.0.1:6380');
        $this->assertCount(10923, $slotmap);

        $slotmap->setSlots(10923, 16383, '127.0.0.1:6381');
        $this->assertCount(16384, $slotmap);
    }

    /**
     * @group disconnected
     */
    public function testResetEmptiesSlotMap(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');
        $slotmap->setSlots(5461, 10922, '127.0.0.1:6380');
        $slotmap->setSlots(10923, 16383, '127.0.0.1:6381');

        $this->assertFalse($slotmap->isEmpty());

        $slotmap->reset();

        $this->assertTrue($slotmap->isEmpty());
    }

    /**
     * @group disconnected
     */
    public function testGetNodesReturnsEmptyArrayOnEmptySlotMap(): void
    {
        $slotmap = new SlotMap();

        $this->assertEmpty($slotmap->getNodes());
    }

    /**
     * @group disconnected
     */
    public function testGetNodesReturnsArrayOfNodesInSlotMap(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');
        $slotmap->setSlots(5461, 10922, '127.0.0.1:6380');
        $slotmap->setSlots(10923, 16383, '127.0.0.1:6381');

        $this->assertSame(['127.0.0.1:6379', '127.0.0.1:6380', '127.0.0.1:6381'], $slotmap->getNodes());
    }

    /**
     * @group disconnected
     */
    public function testOffsetExistsReturnsTrueOnAssignedSlot(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');

        $this->assertTrue(isset($slotmap[0]));
        $this->assertTrue(isset($slotmap[2000]));
    }

    /**
     * @group disconnected
     */
    public function testOffsetExistsReturnsFalseOnAssignedSlot(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');

        $this->assertFalse(isset($slotmap[6000]));
    }

    /**
     * @group disconnected
     */
    public function testOffsetExistsReturnsFalseOnInvalidSlot(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');

        $this->assertFalse(isset($slotmap[-100]));
        $this->assertFalse(isset($slotmap[16384]));
    }

    /**
     * @group disconnected
     */
    public function testOffsetGetReturnsNodeOfAssignedSlot(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');
        $slotmap->setSlots(5461, 10922, '127.0.0.1:6380');
        $slotmap->setSlots(10923, 16383, '127.0.0.1:6381');

        $this->assertSame('127.0.0.1:6379', $slotmap[0]);
        $this->assertSame('127.0.0.1:6380', $slotmap[5461]);
        $this->assertSame('127.0.0.1:6381', $slotmap[10923]);
    }

    /**
     * @group disconnected
     */
    public function testOffsetGetReturnsNullOnUnassignedSlot(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');

        $this->assertNull($slotmap[5461]);
    }

    /**
     * @group disconnected
     */
    public function testOffsetGetReturnsNullOnInvalidSlot(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');

        $this->assertNull($slotmap[-100]);
        $this->assertNull($slotmap[16384]);
    }

    /**
     * @group disconnected
     */
    public function testOffsetUnsetRemovesSlotAssignment(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');

        $this->assertTrue(isset($slotmap[100]));
        unset($slotmap[100]);
        $this->assertFalse(isset($slotmap[100]));
    }

    /**
     * @group disconnected
     */
    public function testOffsetUnsetDoesNotDoAnythingOnUnassignedSlot(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');

        $this->assertFalse(isset($slotmap[5461]));
        unset($slotmap[5461]);
        $this->assertFalse(isset($slotmap[5461]));
    }

    /**
     * @group disconnected
     */
    public function testOffsetSetAssignsNodeToSlot(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');

        $this->assertSame('127.0.0.1:6380', $slotmap[100] = '127.0.0.1:6380');
        $this->assertSame('127.0.0.1:6380', $slotmap[100]);

        $this->assertNull($slotmap[5461]);
        $this->assertSame('127.0.0.1:6380', $slotmap[5461] = '127.0.0.1:6380');
        $this->assertSame('127.0.0.1:6380', $slotmap[5461]);
    }

    /**
     * @group disconnected
     */
    public function testOffsetSetCastsValueToString(): void
    {
        $slotmap = new SlotMap();

        $connection = $this->getMockConnection();
        $connection
            ->expects($this->once())
            ->method('__toString')
            ->willReturn('127.0.0.1:6379');

        $this->assertSame($connection, $slotmap[0] = $connection);
        $this->assertSame('127.0.0.1:6379', $slotmap[0]);
    }

    /**
     * @group disconnected
     */
    public function testOffsetSetThrowsExceptionOnInvalidSlot(): void
    {
        $this->expectException('OutOfBoundsException');
        $this->expectExceptionMessage('Invalid slot 16384 for `127.0.0.1:6379`');

        $slotmap = new SlotMap();

        $slotmap[16384] = '127.0.0.1:6379';
    }

    /**
     * @group disconnected
     */
    public function testGetIteratorReturnsIteratorOverSlotMap(): void
    {
        $slotmap = new SlotMap();

        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');
        $slotmap->setSlots(5461, 10922, '127.0.0.1:6380');
        $slotmap->setSlots(10923, 16383, '127.0.0.1:6381');

        $expectedMap = array_merge(
            array_fill(0, 5461, '127.0.0.1:6379'),
            array_fill(5461, 5462, '127.0.0.1:6380'),
            array_fill(10923, 5461, '127.0.0.1:6381')
        );

        $this->assertSame($expectedMap, iterator_to_array($slotmap));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Cluster\Distributor\EmptyRingExceptionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Distributor;

use PredisTestCase;

class EmptyRingExceptionTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testExceptionMessage(): void
    {
        $this->expectException('Predis\Cluster\Distributor\EmptyRingException');
        $this->expectExceptionMessage('Empty Ring');

        throw new EmptyRingException('Empty Ring');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Cluster\Distributor\HashRingTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Distributor;

class HashRingTest extends PredisDistributorTestCase
{
    /**
     * {@inheritdoc}
     */
    public function getDistributorInstance(): DistributorInterface
    {
        return new HashRing();
    }

    /**
     * @group disconnected
     */
    public function testHash(): void
    {
        /** @var HashGeneratorInterface */
        $ring = $this->getDistributorInstance();

        $this->assertEquals(crc32('foobar'), $ring->hash('foobar'));
    }

    /**
     * @group disconnected
     */
    public function testSingleNodeInRing(): void
    {
        $node = '127.0.0.1:7000';

        $ring = $this->getDistributorInstance();
        $ring->add($node);

        $expected = array_fill(0, 20, $node);
        $actual = $this->getNodes($ring, 20);

        $this->assertSame($expected, $actual);
    }

    /**
     * @group disconnected
     */
    public function testMultipleNodesInRing(): void
    {
        $ring = $this->getSampleDistribution([
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
        ]);

        $expected = [
            '127.0.0.1:7001',
            '127.0.0.1:7001',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
            '127.0.0.1:7002',
            '127.0.0.1:7001',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
            '127.0.0.1:7002',
            '127.0.0.1:7002',
            '127.0.0.1:7002',
            '127.0.0.1:7000',
            '127.0.0.1:7002',
            '127.0.0.1:7002',
            '127.0.0.1:7002',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
        ];

        $actual = $this->getNodes($ring, 20);

        $this->assertSame($expected, $actual);
    }

    /**
     * @group disconnected
     */
    public function testSubsequendAddAndRemoveFromRing(): void
    {
        $ring = $this->getDistributorInstance();

        $expected1 = array_fill(0, 10, '127.0.0.1:7000');
        $expected3 = array_fill(0, 10, '127.0.0.1:7001');
        $expected2 = [
            '127.0.0.1:7001',
            '127.0.0.1:7001',
            '127.0.0.1:7001',
            '127.0.0.1:7001',
            '127.0.0.1:7001',
            '127.0.0.1:7001',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
        ];

        $ring->add('127.0.0.1:7000');
        $actual1 = $this->getNodes($ring, 10);

        $ring->add('127.0.0.1:7001');
        $actual2 = $this->getNodes($ring, 10);

        $ring->remove('127.0.0.1:7000');
        $actual3 = $this->getNodes($ring, 10);

        $this->assertSame($expected1, $actual1);
        $this->assertSame($expected2, $actual2);
        $this->assertSame($expected3, $actual3);
    }

    /**
     * @group disconnected
     */
    public function testGetByValue(): void
    {
        $ring = $this->getSampleDistribution([
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
        ]);

        $this->assertSame('127.0.0.1:7001', $ring->get('uid:256'));
        $this->assertSame('127.0.0.1:7001', $ring->get('uid:281'));
        $this->assertSame('127.0.0.1:7000', $ring->get('uid:312'));
        $this->assertSame('127.0.0.1:7001', $ring->get('uid:432'));
        $this->assertSame('127.0.0.1:7002', $ring->get('uid:500'));
        $this->assertSame('127.0.0.1:7000', $ring->get('uid:641'));
    }

    /**
     * @group disconnected
     */
    public function testGetByHash(): void
    {
        $ring = $this->getSampleDistribution([
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
        ]);

        $this->assertSame('127.0.0.1:7001', $ring->getByHash(PHP_INT_SIZE == 4 ? -1249390087 : 3045577209)); // uid:256
        $this->assertSame('127.0.0.1:7001', $ring->getByHash(PHP_INT_SIZE == 4 ? -1639106025 : 2655861271)); // uid:281
        $this->assertSame('127.0.0.1:7000', $ring->getByHash(PHP_INT_SIZE == 4 ? -683361581 : 3611605715)); // uid:312
        $this->assertSame('127.0.0.1:7001', $ring->getByHash(PHP_INT_SIZE == 4 ? -532820268 : 3762147028)); // uid:432
        $this->assertSame('127.0.0.1:7002', $ring->getByHash(PHP_INT_SIZE == 4 ? 618436108 : 618436108)); // uid:500
        $this->assertSame('127.0.0.1:7000', $ring->getByHash(PHP_INT_SIZE == 4 ? 905043399 : 905043399)); // uid:641
    }

    /**
     * @group disconnected
     */
    public function testGetBySlot(): void
    {
        $ring = $this->getSampleDistribution([
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
        ]);

        $this->assertSame('127.0.0.1:7001', $ring->getBySlot(PHP_INT_SIZE == 4 ? -1255075679 : 3039891617)); // uid:256
        $this->assertSame('127.0.0.1:7001', $ring->getBySlot(PHP_INT_SIZE == 4 ? -1642314910 : 2652652386)); // uid:281
        $this->assertSame('127.0.0.1:7000', $ring->getBySlot(PHP_INT_SIZE == 4 ? -687739295 : 3607228001)); // uid:312
        $this->assertSame('127.0.0.1:7001', $ring->getBySlot(PHP_INT_SIZE == 4 ? -544842345 : 3750124951)); // uid:432
        $this->assertSame('127.0.0.1:7002', $ring->getBySlot(PHP_INT_SIZE == 4 ? 609245004 : 609245004)); // uid:500
        $this->assertSame('127.0.0.1:7000', $ring->getBySlot(PHP_INT_SIZE == 4 ? 902549909 : 902549909)); // uid:641

        // Test first and last slots
        $this->assertSame('127.0.0.1:7001', $ring->getBySlot(PHP_INT_SIZE == 4 ? -2096102881 : 2198864415));
        $this->assertSame('127.0.0.1:7002', $ring->getBySlot(PHP_INT_SIZE == 4 ? 2146453549 : 2146453549));

        // Test non-existing slot
        $this->assertNull($ring->getBySlot(0));
    }

    /**
     * @group disconnected
     */
    public function testCallbackToGetNodeHash(): void
    {
        $node = '127.0.0.1:7000';
        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();

        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($node)
            ->willReturn($node);

        $distributor = new HashRing(HashRing::DEFAULT_REPLICAS, $callable);
        $distributor->add($node);

        $this->getNodes($distributor);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Cluster\Distributor\KetamaRingTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Distributor;

class KetamaRingTest extends PredisDistributorTestCase
{
    /**
     * {@inheritdoc}
     */
    public function getDistributorInstance(): DistributorInterface
    {
        return new KetamaRing();
    }

    /**
     * @group disconnected
     */
    public function testHash(): void
    {
        /** @var HashGeneratorInterface */
        $ring = $this->getDistributorInstance();
        [, $hash] = unpack('V', md5('foobar', true));

        $this->assertEquals($hash, $ring->hash('foobar'));
    }

    /**
     * @group disconnected
     */
    public function testSingleNodeInRing(): void
    {
        $node = '127.0.0.1:7000';

        $ring = $this->getDistributorInstance();
        $ring->add($node);

        $expected = array_fill(0, 20, $node);
        $actual = $this->getNodes($ring, 20);

        $this->assertSame($expected, $actual);
    }

    /**
     * @group disconnected
     */
    public function testMultipleNodesInRing(): void
    {
        $ring = $this->getSampleDistribution([
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
        ]);

        $expected = [
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
            '127.0.0.1:7002',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
            '127.0.0.1:7002',
            '127.0.0.1:7000',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
            '127.0.0.1:7000',
            '127.0.0.1:7002',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
        ];

        $actual = $this->getNodes($ring, 20);

        $this->assertSame($expected, $actual);
    }

    /**
     * @group disconnected
     */
    public function testSubsequendAddAndRemoveFromRing(): void
    {
        $ring = $this->getDistributorInstance();

        $expected1 = array_fill(0, 10, '127.0.0.1:7000');
        $expected3 = array_fill(0, 10, '127.0.0.1:7001');
        $expected2 = [
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7000',
            '127.0.0.1:7001',
        ];

        $ring->add('127.0.0.1:7000');
        $actual1 = $this->getNodes($ring, 10);

        $ring->add('127.0.0.1:7001');
        $actual2 = $this->getNodes($ring, 10);

        $ring->remove('127.0.0.1:7000');
        $actual3 = $this->getNodes($ring, 10);

        $this->assertSame($expected1, $actual1);
        $this->assertSame($expected2, $actual2);
        $this->assertSame($expected3, $actual3);
    }

    /**
     * @group disconnected
     */
    public function testGetByValue(): void
    {
        $ring = $this->getSampleDistribution([
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
        ]);

        $this->assertSame('127.0.0.1:7001', $ring->get('uid:256'));
        $this->assertSame('127.0.0.1:7002', $ring->get('uid:281'));
        $this->assertSame('127.0.0.1:7001', $ring->get('uid:312'));
        $this->assertSame('127.0.0.1:7000', $ring->get('uid:432'));
        $this->assertSame('127.0.0.1:7000', $ring->get('uid:500'));
        $this->assertSame('127.0.0.1:7002', $ring->get('uid:641'));
    }

    /**
     * @group disconnected
     */
    public function testGetByHash(): void
    {
        $ring = $this->getSampleDistribution([
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
        ]);

        $this->assertSame('127.0.0.1:7001', $ring->getByHash(PHP_INT_SIZE == 4 ? -591277534 : 3703689762)); // uid:256
        $this->assertSame('127.0.0.1:7002', $ring->getByHash(PHP_INT_SIZE == 4 ? -1632011260 : 2662956036)); // uid:281
        $this->assertSame('127.0.0.1:7001', $ring->getByHash(PHP_INT_SIZE == 4 ? 345494622 : 345494622)); // uid:312
        $this->assertSame('127.0.0.1:7000', $ring->getByHash(PHP_INT_SIZE == 4 ? -1042625818 : 3252341478)); // uid:432
        $this->assertSame('127.0.0.1:7000', $ring->getByHash(PHP_INT_SIZE == 4 ? -465463623 : 3829503673)); // uid:500
        $this->assertSame('127.0.0.1:7002', $ring->getByHash(PHP_INT_SIZE == 4 ? 2141928822 : 2141928822)); // uid:641
    }

    /**
     * @group disconnected
     */
    public function testGetBySlot(): void
    {
        $ring = $this->getSampleDistribution([
            '127.0.0.1:7000',
            '127.0.0.1:7001',
            '127.0.0.1:7002',
        ]);

        $this->assertSame('127.0.0.1:7001', $ring->getBySlot(PHP_INT_SIZE == 4 ? -585685153 : 3709282143)); // uid:256
        $this->assertSame('127.0.0.1:7002', $ring->getBySlot(PHP_INT_SIZE == 4 ? -1617239533 : 2677727763)); // uid:281
        $this->assertSame('127.0.0.1:7001', $ring->getBySlot(PHP_INT_SIZE == 4 ? 353009954 : 353009954)); // uid:312
        $this->assertSame('127.0.0.1:7000', $ring->getBySlot(PHP_INT_SIZE == 4 ? -1037794023 : 3257173273)); // uid:432
        $this->assertSame('127.0.0.1:7000', $ring->getBySlot(PHP_INT_SIZE == 4 ? -458724341 : 3836242955)); // uid:500
        $this->assertSame('127.0.0.1:7002', $ring->getBySlot(PHP_INT_SIZE == 4 ? -2143763192 : 2151204104)); // uid:641

        // Test first and last slots
        $this->assertSame('127.0.0.1:7002', $ring->getBySlot(PHP_INT_SIZE == 4 ? -2135629153 : 2159338143));
        $this->assertSame('127.0.0.1:7000', $ring->getBySlot(PHP_INT_SIZE == 4 ? 2137506232 : 2137506232));

        // Test non-existing slot
        $this->assertNull($ring->getBySlot(0));
    }

    /**
     * @group disconnected
     */
    public function testCallbackToGetNodeHash(): void
    {
        $node = '127.0.0.1:7000';
        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();

        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($node)
            ->willReturn($node);

        $distributor = new KetamaRing($callable);
        $distributor->add($node);

        $this->getNodes($distributor);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Cluster\Hash\CRC16Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Hash;

use PredisTestCase;

class CRC16Test extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testHashGeneration(): void
    {
        $crc16 = new CRC16();

        $this->assertSame(58359, $crc16->hash('key:000'));
        $this->assertSame(62422, $crc16->hash('key:001'));
        $this->assertSame(50101, $crc16->hash('key:002'));
        $this->assertSame(54164, $crc16->hash('key:003'));
        $this->assertSame(41843, $crc16->hash('key:004'));
        $this->assertSame(45906, $crc16->hash('key:005'));
        $this->assertSame(33585, $crc16->hash('key:006'));
        $this->assertSame(37648, $crc16->hash('key:007'));
        $this->assertSame(25343, $crc16->hash('key:008'));
        $this->assertSame(29406, $crc16->hash('key:009'));
    }

    /**
     * @group disconnected
     */
    public function testHashGenerationWithIntegerValues(): void
    {
        $crc16 = new CRC16();

        $this->assertSame(13907, $crc16->hash(0));
        $this->assertSame(55177, $crc16->hash(1234));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Cluster\Hash\PhpiredisCRC16Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Cluster\Hash;

use PredisTestCase;

/**
 * @group ext-phpiredis
 * @requires extension phpiredis
 * @requires function phpiredis_utils_crc16
 */
class PhpiredisCRC16Test extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testHashGeneration(): void
    {
        $crc16 = new PhpiredisCRC16();

        $this->assertSame(58359, $crc16->hash('key:000'));
        $this->assertSame(62422, $crc16->hash('key:001'));
        $this->assertSame(50101, $crc16->hash('key:002'));
        $this->assertSame(54164, $crc16->hash('key:003'));
        $this->assertSame(41843, $crc16->hash('key:004'));
        $this->assertSame(45906, $crc16->hash('key:005'));
        $this->assertSame(33585, $crc16->hash('key:006'));
        $this->assertSame(37648, $crc16->hash('key:007'));
        $this->assertSame(25343, $crc16->hash('key:008'));
        $this->assertSame(29406, $crc16->hash('key:009'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Collection\Iterator\HashKeyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use PredisTestCase;

/**
 * @group realm-iterators
 */
class HashKeyTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnMissingCommand(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("'HSCAN' is not supported by the current command factory.");

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->any())
            ->method('supports')
            ->willReturn(false);

        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\ClientInterface')->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($commands);

        new HashKey($client, 'key:hash');
    }

    /**
     * @group disconnected
     */
    public function testIterationWithNoResults(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('hscan')
            ->with('key:hash', 0, [])
            ->willReturn(
                [0, [],
                ]);

        $iterator = new HashKey($client, 'key:hash');

        $iterator->rewind();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @see https://github.com/predis/predis/pull/330
     * @see https://github.com/predis/predis/issues/331
     * @group disconnected
     */
    public function testIterationWithIntegerFields(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('hscan')
            ->with('key:hash', 0, [])
            ->willReturn(
                [0, [1 => 'a', 2 => 'b', 3 => 100, 'foo' => 'bar']]
            );

        $iterator = new HashKey($client, 'key:hash');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('a', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('b', $iterator->current());
        $this->assertSame(2, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(100, $iterator->current());
        $this->assertSame(3, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('bar', $iterator->current());
        $this->assertSame('foo', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnSingleFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('hscan')
            ->with('key:hash', 0, [])
            ->willReturn(
                [0, ['field:1st' => 'value:1st', 'field:2nd' => 'value:2nd', 'field:3rd' => 'value:3rd']]
            );

        $iterator = new HashKey($client, 'key:hash');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:3rd', $iterator->current());
        $this->assertSame('field:3rd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('hscan')
            ->withConsecutive(
                ['key:hash', 0, []],
                ['key:hash', 2, []]
            )
            ->willReturnOnConsecutiveCalls(
                [2, ['field:1st' => 'value:1st', 'field:2nd' => 'value:2nd']],
                [0, ['field:3rd' => 'value:3rd']]
            );

        $iterator = new HashKey($client, 'key:hash');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:3rd', $iterator->current());
        $this->assertSame('field:3rd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetchesAndHoleInFirstFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('hscan')
            ->withConsecutive(
                ['key:hash', 0, []],
                ['key:hash', 4, []]
            )
            ->willReturnOnConsecutiveCalls(
                [4, []],
                [0, ['field:1st' => 'value:1st', 'field:2nd' => 'value:2nd']]
            );

        $iterator = new HashKey($client, 'key:hash');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetchesAndHoleInMidFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(3))
            ->method('hscan')
            ->withConsecutive(
                ['key:hash', 0, []],
                ['key:hash', 2, []],
                ['key:hash', 5, []]
            )
            ->willReturnOnConsecutiveCalls(
                [2, ['field:1st' => 'value:1st', 'field:2nd' => 'value:2nd']],
                [5, []],
                [0, ['field:3rd' => 'value:3rd']]
            );

        $iterator = new HashKey($client, 'key:hash');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:3rd', $iterator->current());
        $this->assertSame('field:3rd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionMatch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('hscan')
            ->withConsecutive(
                ['key:hash', 0, ['MATCH' => 'field:*']],
                ['key:hash', 2, ['MATCH' => 'field:*']]
            )
            ->willReturn(
                [2, ['field:1st' => 'value:1st', 'field:2nd' => 'value:2nd']],
                [0, []]
            );

        $iterator = new HashKey($client, 'key:hash', 'field:*');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionMatchOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('hscan')
            ->withConsecutive(
                ['key:hash', 0, ['MATCH' => 'field:*']],
                ['key:hash', 1, ['MATCH' => 'field:*']]
            )
            ->willReturn(
                [1, ['field:1st' => 'value:1st']],
                [0, ['field:2nd' => 'value:2nd']]
            );

        $iterator = new HashKey($client, 'key:hash', 'field:*');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionCount(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('hscan')
            ->withConsecutive(
                ['key:hash', 0, ['COUNT' => 2]]
            )
            ->willReturn(
                [0, ['field:1st' => 'value:1st', 'field:2nd' => 'value:2nd']]
            );

        $iterator = new HashKey($client, 'key:hash', null, 2);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionCountOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('hscan')
            ->withConsecutive(
                ['key:hash', 0, ['COUNT' => 1]],
                ['key:hash', 1, ['COUNT' => 1]]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['field:1st' => 'value:1st']],
                [0, ['field:2nd' => 'value:2nd']]
            );

        $iterator = new HashKey($client, 'key:hash', null, 1);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionsMatchAndCount(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('hscan')
            ->withConsecutive(
                ['key:hash', 0, ['MATCH' => 'field:*', 'COUNT' => 2]]
            )
            ->willReturnOnConsecutiveCalls(
                [0, ['field:1st' => 'value:1st', 'field:2nd' => 'value:2nd']]
            );

        $iterator = new HashKey($client, 'key:hash', 'field:*', 2);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionsMatchAndCountOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('hscan')
            ->withConsecutive(
                ['key:hash', 0, ['MATCH' => 'field:*', 'COUNT' => 1]],
                ['key:hash', 1, ['MATCH' => 'field:*', 'COUNT' => 1]]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['field:1st' => 'value:1st']],
                [0, ['field:2nd' => 'value:2nd']]
            );

        $iterator = new HashKey($client, 'key:hash', 'field:*', 1);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationRewindable(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['hscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('hscan')
            ->with('key:hash', 0, [])
            ->willReturn(
                [0, ['field:1st' => 'value:1st', 'field:2nd' => 'value:2nd']]
            );

        $iterator = new HashKey($client, 'key:hash');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:1st', $iterator->current());
        $this->assertSame('field:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('value:2nd', $iterator->current());
        $this->assertSame('field:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Collection\Iterator\KeyspaceTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use PredisTestCase;

/**
 * @group realm-iterators
 */
class KeyspaceTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnMissingCommand(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("'SCAN' is not supported by the current command factory.");

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->any())
            ->method('supports')
            ->willReturn(false);

        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\ClientInterface')->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($commands);

        new Keyspace($client);
    }

    /**
     * @group disconnected
     */
    public function testIterationWithNoResults(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('scan')
            ->with(0, [])
            ->willReturn(
                [0, []]
            );

        $iterator = new Keyspace($client);

        $iterator->rewind();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnSingleFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('scan')
            ->with(0, [])
            ->willReturn(
                [0, ['key:1st', 'key:2nd', 'key:3rd']]
            );

        $iterator = new Keyspace($client);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:3rd', $iterator->current());
        $this->assertSame(2, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('scan')
            ->withConsecutive(
                [0, []],
                [2, []]
            )
            ->willReturnOnConsecutiveCalls(
                [2, ['key:1st', 'key:2nd']],
                [0, ['key:3rd']]
            );

        $iterator = new Keyspace($client);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:3rd', $iterator->current());
        $this->assertSame(2, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetchesAndHoleInFirstFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('scan')
            ->withConsecutive(
                [0, []],
                [4, []]
            )
            ->willReturnOnConsecutiveCalls(
                [4, []],
                [0, ['key:1st', 'key:2nd']]
            );

        $iterator = new Keyspace($client);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetchesAndHoleInMidFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(3))
            ->method('scan')
            ->withConsecutive(
                [0, []],
                [2, []],
                [5, []]
            )
            ->willReturnOnConsecutiveCalls(
                [2, ['key:1st', 'key:2nd']],
                [5, []],
                [0, ['key:3rd']]
            );

        $iterator = new Keyspace($client);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:3rd', $iterator->current());
        $this->assertSame(2, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionMatch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('scan')
            ->withConsecutive(
                [0, ['MATCH' => 'key:*']]
            )
            ->willReturnOnConsecutiveCalls(
                [0, ['key:1st', 'key:2nd']]
            );

        $iterator = new Keyspace($client, 'key:*');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionMatchOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('scan')
            ->withConsecutive(
                [0, ['MATCH' => 'key:*']],
                [1, ['MATCH' => 'key:*']]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['key:1st']],
                [0, ['key:2nd']]
            );

        $iterator = new Keyspace($client, 'key:*');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionCount(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('scan')
            ->withConsecutive(
                [0, ['COUNT' => 2]]
            )
            ->willReturnOnConsecutiveCalls(
                [0, ['key:1st', 'key:2nd']]
            );

        $iterator = new Keyspace($client, null, 2);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionCountOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());

        $client
            ->expects($this->exactly(2))
            ->method('scan')
            ->withConsecutive(
                [0, ['COUNT' => 1]],
                [1, ['COUNT' => 1]]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['key:1st']],
                [0, ['key:2nd']]
            );

        $iterator = new Keyspace($client, null, 1);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionsMatchAndCount(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('scan')
            ->withConsecutive(
                [0, ['MATCH' => 'key:*', 'COUNT' => 2]]
            )
            ->willReturnOnConsecutiveCalls(
                [0, ['key:1st', 'key:2nd']]
            );

        $iterator = new Keyspace($client, 'key:*', 2);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionsMatchAndCountOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());

        $client
            ->expects($this->exactly(2))
            ->method('scan')
            ->withConsecutive(
                [0, ['MATCH' => 'key:*', 'COUNT' => 1]],
                [1, ['MATCH' => 'key:*', 'COUNT' => 1]]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['key:1st']],
                [0, ['key:2nd']]
            );

        $iterator = new Keyspace($client, 'key:*', 1);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationRewindable(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['scan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('scan')
            ->with(0, [])
            ->willReturn(
                [0, ['key:1st', 'key:2nd']]
            );

        $iterator = new Keyspace($client);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('key:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1, $iterator->key());
        $this->assertSame('key:2nd', $iterator->current());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Collection\Iterator\ListKeyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use PredisTestCase;

/**
 * @group realm-iterators
 */
class ListKeyTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnMissingCommand(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("'LRANGE' is not supported by the current command factory.");

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->any())
            ->method('supports')
            ->willReturn(false);

        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['lrange'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($commands);

        new ListKey($client, 'key:list');
    }

    /**
     * @group disconnected
     */
    public function testIterationWithNoResults(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['lrange'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('lrange')
            ->with('key:list', 0, 9)
            ->willReturn(
                []
            );

        $iterator = new ListKey($client, 'key:list');

        $iterator->rewind();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnSingleFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['lrange'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('lrange')
            ->with('key:list', 0, 9)
            ->willReturn(
                ['item:1', 'item:2', 'item:3']
            );

        $iterator = new ListKey($client, 'key:list');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('item:1', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('item:2', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('item:3', $iterator->current());
        $this->assertSame(2, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['lrange'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('lrange')
            ->withConsecutive(
                ['key:list', 0, 9],
                ['key:list', 10, 19]
            )
            ->willReturnOnConsecutiveCalls(
                [
                    'item:1', 'item:2', 'item:3', 'item:4', 'item:5',
                    'item:6', 'item:7', 'item:8', 'item:9', 'item:10',
                ],
                ['item:11', 'item:12']
            );

        $iterator = new ListKey($client, 'key:list');

        for ($i = 1, $iterator->rewind(); $i <= 12; $i++, $iterator->next()) {
            $this->assertTrue($iterator->valid());
            $this->assertSame("item:$i", $iterator->current());
            $this->assertSame($i - 1, $iterator->key());
        }

        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnConstructorWithNonIntegerCountParameter(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('The $count argument must be a positive integer');

        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());

        new ListKey($client, 'key:list', 'wrong');
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnConstructorWithNegativeCountParameter(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('The $count argument must be a positive integer');

        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());

        new ListKey($client, 'key:list', 'wrong');
    }

    /**
     * @group disconnected
     */
    public function testIterationWithCountParameter(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['lrange'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('lrange')
            ->with('key:list', 0, 4)
            ->willReturn(
                ['item:1', 'item:2']
            );

        $iterator = new ListKey($client, 'key:list', 5);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('item:1', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('item:2', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithCountParameterOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['lrange'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('lrange')
            ->withConsecutive(
                ['key:list', 0, 1],
                ['key:list', 2, 3]
            )
            ->willReturnOnConsecutiveCalls(
                ['item:1', 'item:2'],
                ['item:3']
            );

        $iterator = new ListKey($client, 'key:list', 2);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('item:1', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('item:2', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('item:3', $iterator->current());
        $this->assertSame(2, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationRewindable(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['lrange'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('lrange')
            ->with('key:list', 0, 9)
            ->willReturn(
                ['item:1', 'item:2']
            );

        $iterator = new ListKey($client, 'key:list');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('item:1', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('item:1', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1, $iterator->key());
        $this->assertSame('item:2', $iterator->current());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Collection\Iterator\SetKeyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use PredisTestCase;

/**
 * @group realm-iterators
 */
class SetKeyTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnMissingCommand(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("'SSCAN' is not supported by the current command factory.");

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->any())
            ->method('supports')
            ->willReturn(false);

        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\ClientInterface')->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($commands);

        new SetKey($client, 'key:set');
    }

    /**
     * @group disconnected
     */
    public function testIterationWithNoResults(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('sscan')
            ->with('key:set', 0, [])
            ->willReturn(
                [0, []]
            );

        $iterator = new SetKey($client, 'key:set');

        $iterator->rewind();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnSingleFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('sscan')
            ->with('key:set', 0, [])
            ->willReturn(
                [0, ['member:1st', 'member:2nd', 'member:3rd']]
            );

        $iterator = new SetKey($client, 'key:set');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:3rd', $iterator->current());
        $this->assertSame(2, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('sscan')
            ->withConsecutive(
                ['key:set', 0, []],
                ['key:set', 2, []]
            )
            ->willReturnOnConsecutiveCalls(
                [2, ['member:1st', 'member:2nd']],
                [0, ['member:3rd']]
            );

        $iterator = new SetKey($client, 'key:set');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:3rd', $iterator->current());
        $this->assertSame(2, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetchesAndHoleInFirstFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('sscan')
            ->withConsecutive(
                ['key:set', 0, []],
                ['key:set', 4, []]
            )
            ->willReturnOnConsecutiveCalls(
                [4, []],
                [0, ['member:1st', 'member:2nd']]
            );

        $iterator = new SetKey($client, 'key:set');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetchesAndHoleInMidFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(3))
            ->method('sscan')
            ->withConsecutive(
                ['key:set', 0, []],
                ['key:set', 2, []],
                ['key:set', 5, []]
            )
            ->willReturnOnConsecutiveCalls(
                [2, ['member:1st', 'member:2nd']],
                [5, []],
                [0, ['member:3rd']]
            );

        $iterator = new SetKey($client, 'key:set');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:3rd', $iterator->current());
        $this->assertSame(2, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionMatch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('sscan')
            ->withConsecutive(
                ['key:set', 0, ['MATCH' => 'member:*']]
            )
            ->willReturnOnConsecutiveCalls(
                [0, ['member:1st', 'member:2nd']]
            );

        $iterator = new SetKey($client, 'key:set', 'member:*');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionMatchOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('sscan')
            ->withConsecutive(
                ['key:set', 0, ['MATCH' => 'member:*']],
                ['key:set', 1, ['MATCH' => 'member:*']]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['member:1st']],
                [0, ['member:2nd']]
            );

        $iterator = new SetKey($client, 'key:set', 'member:*');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionCount(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('sscan')
            ->withConsecutive(
                ['key:set', 0, ['COUNT' => 2]]
            )
            ->willReturnOnConsecutiveCalls(
                [0, ['member:1st', 'member:2nd']]
            );

        $iterator = new SetKey($client, 'key:set', null, 2);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionCountOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('sscan')
            ->withConsecutive(
                ['key:set', 0, ['COUNT' => 1]],
                ['key:set', 1, ['COUNT' => 1]]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['member:1st']],
                [0, ['member:2nd']]
            );

        $iterator = new SetKey($client, 'key:set', null, 1);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionsMatchAndCount(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('sscan')
            ->withConsecutive(
                ['key:set', 0, ['MATCH' => 'member:*', 'COUNT' => 2]]
            )
            ->willReturnOnConsecutiveCalls(
                [0, ['member:1st', 'member:2nd']]
            );

        $iterator = new SetKey($client, 'key:set', 'member:*', 2);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionsMatchAndCountOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('sscan')
            ->withConsecutive(
                ['key:set', 0, ['MATCH' => 'member:*', 'COUNT' => 1]],
                ['key:set', 1, ['MATCH' => 'member:*', 'COUNT' => 1]]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['member:1st']],
                [0, ['member:2nd']]
            );

        $iterator = new SetKey($client, 'key:set', 'member:*', 1);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationRewindable(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['sscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('sscan')
            ->with('key:set', 0, [])
            ->willReturn(
                [0, ['member:1st', 'member:2nd']]
            );

        $iterator = new SetKey($client, 'key:set');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:1st', $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame('member:2nd', $iterator->current());
        $this->assertSame(1, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Collection\Iterator\SortedSetKeyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Collection\Iterator;

use PredisTestCase;

/**
 * @group realm-iterators
 */
class SortedSetKeyTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnMissingCommand(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("'ZSCAN' is not supported by the current command factory.");

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')
            ->getMock();
        $commands
            ->expects($this->any())
            ->method('supports')
            ->willReturn(false);

        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\ClientInterface')->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($commands);

        new SortedSetKey($client, 'key:zset');
    }

    /**
     * @group disconnected
     */
    public function testIterationWithNoResults(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('zscan')
            ->with('key:zset', 0, [])
            ->willReturn(
                [0, []]
            );

        $iterator = new SortedSetKey($client, 'key:zset');

        $iterator->rewind();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @see https://github.com/predis/predis/issues/216
     * @group disconnected
     */
    public function testIterationWithIntegerMembers(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('zscan')
            ->with('key:zset', 0, [])
            ->willReturn(
                [0, [0 => 0, 101 => 1, 102 => 2]]
            );

        $iterator = new SortedSetKey($client, 'key:zset');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(0, $iterator->current());
        $this->assertSame(0, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1, $iterator->current());
        $this->assertSame(101, $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2, $iterator->current());
        $this->assertSame(102, $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnSingleFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('zscan')
            ->with('key:zset', 0, [])
            ->willReturn(
                [0, ['member:1st' => 1.0, 'member:2nd' => 2.0, 'member:3rd' => 3.0]]
            );

        $iterator = new SortedSetKey($client, 'key:zset');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(3.0, $iterator->current());
        $this->assertSame('member:3rd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('zscan')
            ->withConsecutive(
                ['key:zset', 0, []],
                ['key:zset', 2, []]
            )
            ->willReturnOnConsecutiveCalls(
                [2, ['member:1st' => 1.0, 'member:2nd' => 2.0]],
                [0, ['member:3rd' => 3.0]]
            );

        $iterator = new SortedSetKey($client, 'key:zset');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(3.0, $iterator->current());
        $this->assertSame('member:3rd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetchesAndHoleInFirstFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('zscan')
            ->withConsecutive(
                ['key:zset', 0, []],
                ['key:zset', 4, []]
            )
            ->willReturnOnConsecutiveCalls(
                [4, []],
                [0, ['member:1st' => 1.0, 'member:2nd' => 2.0]]
            );

        $iterator = new SortedSetKey($client, 'key:zset');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationOnMultipleFetchesAndHoleInMidFetch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(3))
            ->method('zscan')
            ->withConsecutive(
                ['key:zset', 0, []],
                ['key:zset', 2, []],
                ['key:zset', 5, []]
            )
            ->willReturnOnConsecutiveCalls(
                [2, ['member:1st' => 1.0, 'member:2nd' => 2.0]],
                [5, []],
                [0, ['member:3rd' => 3.0]]
            );

        $iterator = new SortedSetKey($client, 'key:zset');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(3.0, $iterator->current());
        $this->assertSame('member:3rd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionMatch(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('zscan')
            ->withConsecutive(
                ['key:zset', 0, ['MATCH' => 'member:*']],
                ['key:zset', 2, ['MATCH' => 'member:*']]
            )
            ->willReturnOnConsecutiveCalls(
                [2, ['member:1st' => 1.0, 'member:2nd' => 2.0]],
                [0, []]
            );

        $iterator = new SortedSetKey($client, 'key:zset', 'member:*');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionMatchOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('zscan')
            ->withConsecutive(
                ['key:zset', 0, ['MATCH' => 'member:*']],
                ['key:zset', 1, ['MATCH' => 'member:*']]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['member:1st' => 1.0]],
                [0, ['member:2nd' => 2.0]]
            );

        $iterator = new SortedSetKey($client, 'key:zset', 'member:*');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionCount(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('zscan')
            ->withConsecutive(
                ['key:zset', 0, ['COUNT' => 2]]
            )
            ->willReturnOnConsecutiveCalls(
                [0, ['member:1st' => 1.0, 'member:2nd' => 2.0]]
            );

        $iterator = new SortedSetKey($client, 'key:zset', null, 2);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionCountOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('zscan')
            ->withConsecutive(
                ['key:zset', 0, ['COUNT' => 1]],
                ['key:zset', 1, ['COUNT' => 1]]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['member:1st' => 1.0]],
                [0, ['member:2nd' => 2.0]]
            );

        $iterator = new SortedSetKey($client, 'key:zset', null, 1);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionsMatchAndCount(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->once())
            ->method('zscan')
            ->withConsecutive(
                ['key:zset', 0, ['MATCH' => 'member:*', 'COUNT' => 2]]
            )
            ->willReturnOnConsecutiveCalls(
                [0, ['member:1st' => 1.0, 'member:2nd' => 2.0]]
            );

        $iterator = new SortedSetKey($client, 'key:zset', 'member:*', 2);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationWithOptionsMatchAndCountOnMultipleFetches(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('zscan')
            ->withConsecutive(
                ['key:zset', 0, ['MATCH' => 'member:*', 'COUNT' => 1]],
                ['key:zset', 1, ['MATCH' => 'member:*', 'COUNT' => 1]]
            )
            ->willReturnOnConsecutiveCalls(
                [1, ['member:1st' => 1.0]],
                [0, ['member:2nd' => 2.0]]
            );

        $iterator = new SortedSetKey($client, 'key:zset', 'member:*', 1);

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }

    /**
     * @group disconnected
     */
    public function testIterationRewindable(): void
    {
        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['getCommandFactory'])
            ->addMethods(['zscan'])
            ->getMock();
        $client
            ->expects($this->any())
            ->method('getCommandFactory')
            ->willReturn($this->getCommandFactory());
        $client
            ->expects($this->exactly(2))
            ->method('zscan')
            ->with('key:zset', 0, [])
            ->willReturn(
                [0, ['member:1st' => 1.0, 'member:2nd' => 2.0]]
            );

        $iterator = new SortedSetKey($client, 'key:zset');

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->rewind();
        $this->assertTrue($iterator->valid());
        $this->assertSame(1.0, $iterator->current());
        $this->assertSame('member:1st', $iterator->key());

        $iterator->next();
        $this->assertTrue($iterator->valid());
        $this->assertSame(2.0, $iterator->current());
        $this->assertSame('member:2nd', $iterator->key());

        $iterator->next();
        $this->assertFalse($iterator->valid());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\CommandTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

use PredisTestCase;
use stdClass;

class CommandTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testImplementsCorrectInterface(): void
    {
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        $this->assertInstanceOf('Predis\Command\CommandInterface', $command);
    }

    /**
     * @group disconnected
     */
    public function testGetEmptyArguments(): void
    {
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testSetRawArguments(): void
    {
        $arguments = ['1st', '2nd', '3rd'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        $this->assertEquals($arguments, $command->getArguments());
    }

    /**
     * @group disconnected
     *
     * @todo We cannot set an expectation for Command::filterArguments() when we
     *       invoke Command::setArguments() because it is protected.
     */
    public function testSetArguments(): void
    {
        $arguments = ['1st', '2nd', '3rd'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setArguments($arguments);

        $this->assertEquals($arguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testGetArgumentAtIndex(): void
    {
        $arguments = ['1st', '2nd', '3rd'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setArguments($arguments);

        $this->assertEquals($arguments[0], $command->getArgument(0));
        $this->assertEquals($arguments[2], $command->getArgument(2));
        $this->assertNull($command->getArgument(10));
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $response = 'response-buffer';
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        $this->assertEquals($response, $command->parseResponse($response));
    }

    /**
     * @group disconnected
     */
    public function testSetAndGetSlot(): void
    {
        $slot = 1024;

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments(['key']);

        $this->assertNull($command->getSlot());

        $command->setSlot($slot);
        $this->assertSame($slot, $command->getSlot());

        $command->setArguments(['key']);
        $this->assertNull($command->getSlot());

        $command->setSlot($slot);
        $command->setRawArguments(['key']);
        $this->assertNull($command->getSlot());
    }

    /**
     * @group disconnected
     */
    public function testNormalizeArguments(): void
    {
        $arguments = ['arg1', 'arg2', 'arg3', 'arg4'];

        $this->assertSame($arguments, Command::normalizeArguments($arguments));
        $this->assertSame($arguments, Command::normalizeArguments([$arguments]));

        $arguments = [[], []];
        $this->assertSame($arguments, Command::normalizeArguments($arguments));

        $arguments = [new stdClass()];
        $this->assertSame($arguments, Command::normalizeArguments($arguments));
    }

    /**
     * @group disconnected
     */
    public function testNormalizeVariadic(): void
    {
        $arguments = ['key', 'value1', 'value2', 'value3'];

        $this->assertSame($arguments, Command::normalizeVariadic($arguments));
        $this->assertSame($arguments, Command::normalizeVariadic(['key', ['value1', 'value2', 'value3']]));

        $arguments = [new stdClass()];
        $this->assertSame($arguments, Command::normalizeVariadic($arguments));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\RawCommandTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

use PredisTestCase;

class RawCommandTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testConstructorWithCommandID(): void
    {
        $commandID = 'PING';
        $command = new RawCommand($commandID);

        $this->assertSame($commandID, $command->getId());
        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithCommandIDAndArguments(): void
    {
        $commandID = 'SET';
        $commandArgs = ['foo', 'bar'];

        $command = new RawCommand($commandID, $commandArgs);

        $this->assertSame($commandID, $command->getId());
        $this->assertSame($commandArgs, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testStaticCreate(): void
    {
        $command = RawCommand::create('SET');
        $this->assertSame('SET', $command->getId());
        $this->assertEmpty($command->getArguments());

        $command = RawCommand::create('SET', 'foo', 'bar');
        $this->assertSame('SET', $command->getId());
        $this->assertSame(['foo', 'bar'], $command->getArguments());
    }

    /**
     * The signature of RawCommand::create() requires one argument which is the
     * ID of the command (other arguments are fetched dynamically). If the first
     * argument is missing a standard PHP exception is thrown on PHP >= 7.1.
     *
     * @group disconnected
     */
    public function testPHPExceptionOnMissingCommandIDWithStaticCreate(): void
    {
        $this->expectException('ArgumentCountError');

        RawCommand::create();
    }

    /**
     * @group disconnected
     */
    public function testSetArguments(): void
    {
        $commandID = 'SET';
        $command = new RawCommand($commandID);

        $command->setArguments($commandArgs = ['foo', 'bar']);
        $this->assertSame($commandArgs, $command->getArguments());

        $command->setArguments($commandArgs = ['hoge', 'piyo']);
        $this->assertSame($commandArgs, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testSetRawArguments(): void
    {
        $commandID = 'SET';
        $command = new RawCommand($commandID);

        $command->setRawArguments($commandArgs = ['foo', 'bar']);
        $this->assertSame($commandArgs, $command->getArguments());

        $command->setRawArguments($commandArgs = ['hoge', 'piyo']);
        $this->assertSame($commandArgs, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testGetArgumentAtIndex(): void
    {
        $command = new RawCommand('GET', ['key']);

        $this->assertSame('key', $command->getArgument(0));
        $this->assertNull($command->getArgument(1));
    }

    /**
     * @group disconnected
     */
    public function testSetAndGetHash(): void
    {
        $slot = 1024;
        $arguments = ['key', 'value'];
        $command = new RawCommand('SET', $arguments);

        $this->assertNull($command->getSlot());

        $command->setSlot($slot);
        $this->assertSame($slot, $command->getSlot());

        $command->setArguments(['hoge', 'piyo']);
        $this->assertNull($command->getSlot());
    }

    /**
     * @group disconnected
     */
    public function testNormalizesCommandIdentifiersToUppercase(): void
    {
        $command = new RawCommand('set', ['key', 'value']);

        $this->assertSame('SET', $command->getId());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\RawFactoryTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

use PredisTestCase;

class RawFactoryTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testSupportForAnyCommand(): void
    {
        $factory = new RawFactory();

        $this->assertTrue($factory->supports('info'));
        $this->assertTrue($factory->supports('INFO'));

        $this->assertTrue($factory->supports('unknown'));
        $this->assertTrue($factory->supports('UNKNOWN'));
    }

    /**
     * @group disconnected
     */
    public function testSupportForAnyCommands(): void
    {
        $factory = new RawFactory();

        $this->assertTrue($factory->supports('get', 'set'));
        $this->assertTrue($factory->supports('GET', 'SET'));

        $this->assertTrue($factory->supports('get', 'unknown'));

        $this->assertTrue($factory->supports('unknown1', 'unknown2'));
    }

    /**
     * @group disconnected
     */
    public function testCreateInstanceOfRawCommand(): void
    {
        $factory = new RawFactory();

        $command = $factory->create('info');
        $this->assertInstanceOf('Predis\Command\CommandInterface', $command);
        $this->assertInstanceOf('Predis\Command\RawCommand', $command);

        $command = $factory->create('unknown');
        $this->assertInstanceOf('Predis\Command\CommandInterface', $command);
        $this->assertInstanceOf('Predis\Command\RawCommand', $command);
    }

    /**
     * @group disconnected
     */
    public function testCreateCommandWithoutArguments(): void
    {
        $factory = new RawFactory();

        $command = $factory->create('info');

        $this->assertInstanceOf('Predis\Command\RawCommand', $command);
        $this->assertEquals('INFO', $command->getId());
        $this->assertEquals([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testCreateCommandWithArguments(): void
    {
        $factory = new RawFactory();

        $arguments = ['foo', 'bar'];
        $command = $factory->create('set', $arguments);

        $this->assertInstanceOf('Predis\Command\RawCommand', $command);
        $this->assertEquals('SET', $command->getId());
        $this->assertEquals($arguments, $command->getArguments());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\RedisFactoryTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

use Predis\Command\Processor\ProcessorChain;
use Predis\Command\Processor\ProcessorInterface;
use PredisTestCase;

class RedisFactoryTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testSupportedCommands(): void
    {
        $factory = new RedisFactory();

        foreach ($this->getExpectedCommands() as $commandID) {
            $this->assertTrue($factory->supports($commandID), "Command factory does not support $commandID");
        }
    }

    /**
     * @group disconnected
     */
    public function testSupportCommand(): void
    {
        $factory = new RedisFactory();

        $this->assertTrue($factory->supports('info'));
        $this->assertTrue($factory->supports('INFO'));

        $this->assertFalse($factory->supports('unknown'));
        $this->assertFalse($factory->supports('UNKNOWN'));
    }

    /**
     * @group disconnected
     */
    public function testSupportCommands(): void
    {
        $factory = new RedisFactory();

        $this->assertTrue($factory->supports('get', 'set'));
        $this->assertTrue($factory->supports('GET', 'SET'));

        $this->assertFalse($factory->supports('get', 'unknown'));

        $this->assertFalse($factory->supports('unknown1', 'unknown2'));
    }

    /**
     * @group disconnected
     */
    public function testGetCommandClass(): void
    {
        $factory = new RedisFactory();

        $this->assertSame('Predis\Command\Redis\PING', $factory->getCommandClass('ping'));
        $this->assertSame('Predis\Command\Redis\PING', $factory->getCommandClass('PING'));

        $this->assertNull($factory->getCommandClass('unknown'));
        $this->assertNull($factory->getCommandClass('UNKNOWN'));
    }

    /**
     * @group disconnected
     */
    public function testDefineCommand(): void
    {
        $factory = new RedisFactory();

        $command = $this->getMockBuilder('Predis\Command\CommandInterface')
            ->getMock();

        $factory->define('mock', get_class($command));

        $this->assertTrue($factory->supports('mock'));
        $this->assertTrue($factory->supports('MOCK'));

        $this->assertInstanceOf($factory->getCommandClass('mock'), $command);
    }

    /**
     * @group disconnected
     */
    public function testUndefineCommandInClassAutoload(): void
    {
        $factory = new RedisFactory();

        $this->assertTrue($factory->supports('PING'));
        $this->assertSame('Predis\Command\Redis\PING', $factory->getCommandClass('PING'));

        $factory->undefine('PING');

        $this->assertFalse($factory->supports('PING'));
        $this->assertNull($factory->getCommandClass('PING'));
    }

    /**
     * @group disconnected
     */
    public function testUndefineCommandInClassMap(): void
    {
        $factory = new RedisFactory();

        $commandClass = get_class($this->getMockBuilder('Predis\Command\CommandInterface')->getMock());
        $factory->define('MOCK', $commandClass);

        $this->assertTrue($factory->supports('MOCK'));
        $this->assertSame($commandClass, $factory->getCommandClass('MOCK'));

        $factory->undefine('MOCK');

        $this->assertFalse($factory->supports('MOCK'));
        $this->assertNull($factory->getCommandClass('MOCK'));
    }

    /**
     * @group disconnected
     */
    public function testDefineInvalidCommand(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage("Class stdClass must implement Predis\Command\CommandInterface");

        $factory = new RedisFactory();

        $factory->define('mock', 'stdClass');
    }

    /**
     * @group disconnected
     */
    public function testCreateCommandWithoutArguments(): void
    {
        $factory = new RedisFactory();

        $command = $factory->create('info');

        $this->assertInstanceOf('Predis\Command\CommandInterface', $command);
        $this->assertEquals('INFO', $command->getId());
        $this->assertEquals([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testCreateCommandWithArguments(): void
    {
        $factory = new RedisFactory();

        $arguments = ['foo', 'bar'];
        $command = $factory->create('set', $arguments);

        $this->assertInstanceOf('Predis\Command\CommandInterface', $command);
        $this->assertEquals('SET', $command->getId());
        $this->assertEquals($arguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testCreateUndefinedCommand(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('Command `UNKNOWN` is not a registered Redis command.');

        $factory = new RedisFactory();

        $factory->create('unknown');
    }

    /**
     * @group disconnected
     */
    public function testGetDefaultProcessor(): void
    {
        $factory = new RedisFactory();

        $this->assertNull($factory->getProcessor());
    }

    /**
     * @group disconnected
     */
    public function testSetProcessor(): void
    {
        /** @var ProcessorInterface */
        $processor = $this
            ->getMockBuilder('Predis\Command\Processor\ProcessorInterface')
            ->getMock();

        $factory = new RedisFactory();
        $factory->setProcessor($processor);

        $this->assertSame($processor, $factory->getProcessor());
    }

    /**
     * @group disconnected
     */
    public function testSetAndUnsetProcessor(): void
    {
        /** @var ProcessorInterface */
        $processor = $this
            ->getMockBuilder('Predis\Command\Processor\ProcessorInterface')
            ->getMock();

        $factory = new RedisFactory();

        $factory->setProcessor($processor);
        $this->assertSame($processor, $factory->getProcessor());

        $factory->setProcessor(null);
        $this->assertNull($factory->getProcessor());
    }

    /**
     * @group disconnected
     */
    public function testSingleProcessor(): void
    {
        // Could it be that objects passed to the return callback of a mocked
        // method are cloned instead of being passed by reference?
        $argsRef = null;

        /** @var ProcessorInterface */
        $processor = $this
            ->getMockBuilder('Predis\Command\Processor\ProcessorInterface')
            ->getMock();
        $processor
            ->expects($this->once())
            ->method('process')
            ->with($this->isInstanceOf('Predis\Command\CommandInterface'))
            ->willReturnCallback(
                function (CommandInterface $cmd) use (&$argsRef) {
                    $cmd->setRawArguments($argsRef = array_map('strtoupper', $cmd->getArguments()));
                }
            );

        $factory = new RedisFactory();
        $factory->setProcessor($processor);
        $factory->create('set', ['foo', 'bar']);

        $this->assertSame(['FOO', 'BAR'], $argsRef);
    }

    /**
     * @group disconnected
     */
    public function testChainOfProcessors(): void
    {
        /** @var ProcessorInterface */
        $processor = $this
            ->getMockBuilder('Predis\Command\Processor\ProcessorInterface')
            ->getMock();
        $processor
            ->expects($this->exactly(2))
            ->method('process');

        $chain = new ProcessorChain();
        $chain->add($processor);
        $chain->add($processor);

        $factory = new RedisFactory();
        $factory->setProcessor($chain);

        $factory->create('info');
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns the expected list of commands supported by the tested factory.
     *
     * @return array List of supported commands.
     */
    protected function getExpectedCommands(): array
    {
        return [
            0 => 'EXISTS',
            1 => 'DEL',
            2 => 'TYPE',
            3 => 'KEYS',
            4 => 'RANDOMKEY',
            5 => 'RENAME',
            6 => 'RENAMENX',
            7 => 'EXPIRE',
            8 => 'EXPIREAT',
            9 => 'TTL',
            10 => 'MOVE',
            11 => 'SORT',
            12 => 'DUMP',
            13 => 'RESTORE',
            14 => 'SET',
            15 => 'SETNX',
            16 => 'MSET',
            17 => 'MSETNX',
            18 => 'GET',
            19 => 'MGET',
            20 => 'GETSET',
            21 => 'INCR',
            22 => 'INCRBY',
            23 => 'DECR',
            24 => 'DECRBY',
            25 => 'RPUSH',
            26 => 'LPUSH',
            27 => 'LLEN',
            28 => 'LRANGE',
            29 => 'LTRIM',
            30 => 'LINDEX',
            31 => 'LSET',
            32 => 'LREM',
            33 => 'LPOP',
            34 => 'RPOP',
            35 => 'RPOPLPUSH',
            36 => 'SADD',
            37 => 'SREM',
            38 => 'SPOP',
            39 => 'SMOVE',
            40 => 'SCARD',
            41 => 'SISMEMBER',
            42 => 'SINTER',
            43 => 'SINTERSTORE',
            44 => 'SUNION',
            45 => 'SUNIONSTORE',
            46 => 'SDIFF',
            47 => 'SDIFFSTORE',
            48 => 'SMEMBERS',
            49 => 'SRANDMEMBER',
            50 => 'ZADD',
            51 => 'ZINCRBY',
            52 => 'ZREM',
            53 => 'ZRANGE',
            54 => 'ZREVRANGE',
            55 => 'ZRANGEBYSCORE',
            56 => 'ZCARD',
            57 => 'ZSCORE',
            58 => 'ZREMRANGEBYSCORE',
            59 => 'PING',
            60 => 'AUTH',
            61 => 'SELECT',
            62 => 'ECHO',
            63 => 'QUIT',
            64 => 'INFO',
            65 => 'SLAVEOF',
            66 => 'MONITOR',
            67 => 'DBSIZE',
            68 => 'FLUSHDB',
            69 => 'FLUSHALL',
            70 => 'SAVE',
            71 => 'BGSAVE',
            72 => 'LASTSAVE',
            73 => 'SHUTDOWN',
            74 => 'BGREWRITEAOF',
            75 => 'SETEX',
            76 => 'APPEND',
            77 => 'SUBSTR',
            78 => 'BLPOP',
            79 => 'BRPOP',
            80 => 'ZUNIONSTORE',
            81 => 'ZINTERSTORE',
            82 => 'ZCOUNT',
            83 => 'ZRANK',
            84 => 'ZREVRANK',
            85 => 'ZREMRANGEBYRANK',
            86 => 'HSET',
            87 => 'HSETNX',
            88 => 'HMSET',
            89 => 'HINCRBY',
            90 => 'HGET',
            91 => 'HMGET',
            92 => 'HDEL',
            93 => 'HEXISTS',
            94 => 'HLEN',
            95 => 'HKEYS',
            96 => 'HVALS',
            97 => 'HGETALL',
            98 => 'MULTI',
            99 => 'EXEC',
            100 => 'DISCARD',
            101 => 'SUBSCRIBE',
            102 => 'UNSUBSCRIBE',
            103 => 'PSUBSCRIBE',
            104 => 'PUNSUBSCRIBE',
            105 => 'PUBLISH',
            106 => 'CONFIG',
            107 => 'PERSIST',
            108 => 'STRLEN',
            109 => 'SETRANGE',
            110 => 'GETRANGE',
            111 => 'SETBIT',
            112 => 'GETBIT',
            113 => 'RPUSHX',
            114 => 'LPUSHX',
            115 => 'LINSERT',
            116 => 'BRPOPLPUSH',
            117 => 'ZREVRANGEBYSCORE',
            118 => 'WATCH',
            119 => 'UNWATCH',
            120 => 'OBJECT',
            121 => 'SLOWLOG',
            122 => 'CLIENT',
            123 => 'PTTL',
            124 => 'PEXPIRE',
            125 => 'PEXPIREAT',
            126 => 'MIGRATE',
            127 => 'PSETEX',
            128 => 'INCRBYFLOAT',
            129 => 'BITOP',
            130 => 'BITCOUNT',
            131 => 'HINCRBYFLOAT',
            132 => 'EVAL',
            133 => 'EVALSHA',
            134 => 'SCRIPT',
            135 => 'TIME',
            136 => 'SENTINEL',
            137 => 'SCAN',
            138 => 'BITPOS',
            139 => 'SSCAN',
            140 => 'ZSCAN',
            141 => 'ZLEXCOUNT',
            142 => 'ZRANGEBYLEX',
            143 => 'ZREMRANGEBYLEX',
            144 => 'ZREVRANGEBYLEX',
            145 => 'HSCAN',
            146 => 'PUBSUB',
            147 => 'PFADD',
            148 => 'PFCOUNT',
            149 => 'PFMERGE',
            150 => 'COMMAND',
            151 => 'HSTRLEN',
            152 => 'BITFIELD',
            153 => 'GEOADD',
            154 => 'GEOHASH',
            155 => 'GEOPOS',
            156 => 'GEODIST',
            157 => 'GEORADIUS',
            158 => 'GEORADIUSBYMEMBER',
            159 => 'JSONSET',
            160 => 'JSONGET',
            161 => 'JSONARRAPPEND',
            162 => 'JSONARRINDEX',
            163 => 'JSONARRINSERT',
            164 => 'JSONARRLEN',
            165 => 'JSONARRPOP',
            166 => 'JSONARRTRIM',
            167 => 'JSONCLEAR',
            168 => 'JSONDEBUG',
            169 => 'JSONDEL',
            170 => 'JSONFORGET',
            171 => 'JSONMGET',
            172 => 'JSONNUMINCRBY',
            173 => 'JSONOBJKEYS',
            174 => 'JSONOBJLEN',
            175 => 'JSONRESP',
            176 => 'JSONSTRAPPEND',
            177 => 'JSONSTRLEN',
            178 => 'JSONTOGGLE',
            179 => 'JSONTYPE',
            180 => 'BFADD',
            181 => 'BFEXISTS',
            182 => 'BFINFO',
            183 => 'BFINSERT',
            184 => 'BFLOADCHUNK',
            185 => 'BFMADD',
            186 => 'BFMEXISTS',
            187 => 'BFRESERVE',
            188 => 'BFSCANDUMP',
            189 => 'CMSINCRBY',
            190 => 'CMSINFO',
            191 => 'CMSINITBYDIM',
            192 => 'CMSINITBYPROB',
            193 => 'CMSMERGE',
            194 => 'CMSQUERY',
            195 => 'CFADD',
            196 => 'CFADDNX',
            197 => 'CFCOUNT',
            198 => 'CFDEL',
            199 => 'CFEXISTS',
            200 => 'CFINFO',
            201 => 'CFINSERT',
            202 => 'CFINSERTNX',
            203 => 'CFLOADCHUNK',
            204 => 'CFMEXISTS',
            205 => 'CFRESERVE',
            206 => 'CFSCANDUMP',
            207 => 'TDIGESTADD',
            208 => 'TDIGESTBYRANK',
            209 => 'TDIGESTBYREVRANK',
            210 => 'TDIGESTCDF',
            211 => 'TDIGESTCREATE',
            212 => 'TDIGESTINFO',
            213 => 'TDIGESTMAX',
            214 => 'TDIGESTMERGE',
            215 => 'TDIGESTMIN',
            216 => 'TDIGESTQUANTILE',
            217 => 'TDIGESTRANK',
            218 => 'TDIGESTRESET',
            219 => 'TDIGESTREVRANK',
            220 => 'TDIGESTTRIMMED_MEAN',
            221 => 'TOPKADD',
            222 => 'TOPKINCRBY',
            223 => 'TOPKINFO',
            224 => 'TOPKLIST',
            225 => 'TOPKQUERY',
            226 => 'TOPKRESERVE',
            227 => 'FTALIASADD',
            228 => 'FTALIASDEL',
            229 => 'FTALIASUPDATE',
            230 => 'FTALTER',
            231 => 'FTCONFIG',
            232 => 'FTCREATE',
            233 => 'FTDICTADD',
            234 => 'FTDICTDEL',
            235 => 'FTDICTDUMP',
            236 => 'FTDROPINDEX',
            237 => 'FTINFO',
            238 => 'FTPROFILE',
            239 => 'FTSEARCH',
            240 => 'FTSPELLCHECK',
            241 => 'FTSUGADD',
            242 => 'FTSUGDEL',
            243 => 'FTSUGGET',
            244 => 'FTSUGLEN',
            245 => 'FTSYNDUMP',
            246 => 'FTSYNUPDATE',
            247 => 'FTTAGVALS',
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\ScriptCommandTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command;

use PHPUnit\Framework\MockObject\MockObject;
use PredisTestCase;

/**
 * @group realm-scripting
 */
class ScriptCommandTest extends PredisTestCase
{
    public const LUA_SCRIPT = 'return { KEYS[1], KEYS[2], ARGV[1], ARGV[2] }';
    public const LUA_SCRIPT_SHA1 = '6e07f61f502e36d123fe28523076af588f5c315e';

    /**
     * @group disconnected
     */
    public function testGetId(): void
    {
        /** @var CommandInterface */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript'])
            ->getMock();

        $this->assertSame('EVALSHA', $command->getId());
    }

    /**
     * @group disconnected
     */
    public function testGetScriptHash(): void
    {
        /** @var ScriptCommand|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript', 'getKeysCount'])
            ->getMock();
        $command
            ->expects($this->exactly(2))
            ->method('getScript')
            ->willReturn(self::LUA_SCRIPT);
        $command
            ->expects($this->once())
            ->method('getKeysCount')
            ->willReturn(2);

        $command->setArguments($arguments = ['key1', 'key2', 'value1', 'value2']);

        $this->assertSame(self::LUA_SCRIPT_SHA1, $command->getScriptHash());
    }

    /**
     * @group disconnected
     */
    public function testGetKeys(): void
    {
        /** @var ScriptCommand|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript', 'getKeysCount'])
            ->getMock();
        $command
            ->expects($this->once())
            ->method('getScript')
            ->willReturn(self::LUA_SCRIPT);
        $command
            ->expects($this->exactly(2))
            ->method('getKeysCount')
            ->willReturn(2);

        $command->setArguments($arguments = ['key1', 'key2', 'value1', 'value2']);

        $this->assertSame(['key1', 'key2'], $command->getKeys());
    }

    /**
     * @group disconnected
     */
    public function testGetKeysWithZeroKeysCount(): void
    {
        /** @var ScriptCommand|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript'])
            ->getMock();
        $command
            ->expects($this->once())
            ->method('getScript')
            ->willReturn(self::LUA_SCRIPT);

        $command->setArguments($arguments = ['value1', 'value2', 'value3']);

        $this->assertSame([], $command->getKeys());
    }

    /**
     * @group disconnected
     */
    public function testGetKeysWithNegativeKeysCount(): void
    {
        /** @var ScriptCommand|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript', 'getKeysCount'])
            ->getMock();
        $command
            ->expects($this->once())
            ->method('getScript')
            ->willReturn(self::LUA_SCRIPT);
        $command
            ->expects($this->exactly(2))
            ->method('getKeysCount')
            ->willReturn(-2);

        $command->setArguments($arguments = ['key1', 'key2', 'value1', 'value2']);

        $this->assertSame(['key1', 'key2'], $command->getKeys());
    }

    /**
     * @group disconnected
     */
    public function testGetArguments(): void
    {
        /** @var ScriptCommand|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript', 'getKeysCount'])
            ->getMock();
        $command
            ->expects($this->once())
            ->method('getScript')
            ->willReturn(self::LUA_SCRIPT);
        $command
            ->expects($this->once())
            ->method('getKeysCount')
            ->willReturn(2);

        $command->setArguments($arguments = ['key1', 'key2', 'value1', 'value2']);

        $this->assertSame(array_merge([self::LUA_SCRIPT_SHA1, 2], $arguments), $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testGetArgumentsWithZeroKeysCount(): void
    {
        /** @var ScriptCommand|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript', 'getKeysCount'])
            ->getMock();
        $command
            ->expects($this->once())
            ->method('getScript')
            ->willReturn(self::LUA_SCRIPT);

        $command->setArguments($arguments = ['key1', 'key2', 'value1', 'value2']);

        $this->assertSame(array_merge([self::LUA_SCRIPT_SHA1, 0], $arguments), $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testGetArgumentsWithNegativeKeysCount(): void
    {
        /** @var ScriptCommand|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript', 'getKeysCount'])
            ->getMock();
        $command
            ->expects($this->once())
            ->method('getScript')
            ->willReturn(self::LUA_SCRIPT);
        $command
            ->expects($this->once())
            ->method('getKeysCount')
            ->willReturn(-2);

        $command->setArguments($arguments = ['key1', 'key2', 'value1', 'value2']);

        $this->assertSame(array_merge([self::LUA_SCRIPT_SHA1, 2], $arguments), $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testGetEvalArguments(): void
    {
        /** @var ScriptCommand|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript', 'getKeysCount'])
            ->getMock();
        $command
            ->expects($this->exactly(2))
            ->method('getScript')
            ->willReturn(self::LUA_SCRIPT);
        $command
            ->expects($this->once())
            ->method('getKeysCount')
            ->willReturn(2);

        $command->setArguments($arguments = ['key1', 'key2', 'value1', 'value2']);

        $this->assertSame(array_merge([self::LUA_SCRIPT, 2], $arguments), $command->getEvalArguments());
    }

    /**
     * @group disconnected
     */
    public function testGetEvalCommand(): void
    {
        /** @var ScriptCommand|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript', 'getKeysCount'])
            ->getMock();
        $command
            ->expects($this->exactly(2))
            ->method('getScript')
            ->willReturn(self::LUA_SCRIPT);
        $command
            ->expects($this->once())
            ->method('getKeysCount')
            ->willReturn(2);

        $command->setArguments($arguments = ['key1', 'key2', 'value1', 'value2']);

        $evalCMD = new RawCommand('EVAL', array_merge([self::LUA_SCRIPT, 2], $arguments));

        $this->assertRedisCommand($evalCMD, $command->getEvalCommand());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\AggregateArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use PHPUnit\Framework\TestCase;

class AggregateArgumentsTest extends TestCase
{
    /**
     * @var AggregateArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new AggregateArguments();
    }

    /**
     * @dataProvider loadProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testCreatesArgumentsWithLoadModifier(array $arguments, array $expectedResponse): void
    {
        $this->arguments->load(...$arguments);

        $this->assertSame($expectedResponse, $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithGroupByModifier(): void
    {
        $this->arguments->groupBy('property1', 'property2');

        $this->assertSame(['GROUPBY', 2, 'property1', 'property2'], $this->arguments->toArray());
    }

    /**
     * @dataProvider reduceProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testCreatesArgumentsWithReduceModifier(array $arguments, array $expectedResponse): void
    {
        $this->arguments->reduce(...$arguments);

        $this->assertSame($expectedResponse, $this->arguments->toArray());
    }

    /**
     * @dataProvider sortByProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testCreatesArgumentsWithSortByModifier(array $arguments, array $expectedResponse): void
    {
        $this->arguments->sortBy(...$arguments);

        $this->assertSame($expectedResponse, $this->arguments->toArray());
    }

    /**
     * @dataProvider applyProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testCreatesArgumentsWithApplyByModifier(array $arguments, array $expectedResponse): void
    {
        $this->arguments->apply(...$arguments);

        $this->assertSame($expectedResponse, $this->arguments->toArray());
    }

    /**
     * @dataProvider withCursorProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testCreatesArgumentsWithWithCursorByModifier(array $arguments, array $expectedResponse): void
    {
        $this->arguments->withCursor(...$arguments);

        $this->assertSame($expectedResponse, $this->arguments->toArray());
    }

    public function loadProvider(): array
    {
        return [
            'with given fields' => [
                ['field1', 'field2'],
                ['LOAD', 2, 'field1', 'field2'],
            ],
            'with all fields' => [
                ['*'],
                ['LOAD', '*'],
            ],
        ];
    }

    public function reduceProvider(): array
    {
        return [
            'without aliases' => [
                ['function', 'arg1', 'arg2'],
                ['REDUCE', 'function', 2, 'arg1', 'arg2'],
            ],
            'with aliases' => [
                ['function', 'arg1', true, 'alias1', 'arg2', true, 'alias2'],
                ['REDUCE', 'function', 2, 'arg1', 'AS', 'alias1', 'arg2', 'AS', 'alias2'],
            ],
        ];
    }

    public function sortByProvider(): array
    {
        return [
            'without sorting direction and max value' => [
                [0, 'property1', 'property2'],
                ['SORTBY', 2, 'property1', 'property2'],
            ],
            'with sorting direction' => [
                [0, 'property1', 'ASC', 'property2', 'DESC'],
                ['SORTBY', 4, 'property1', 'ASC', 'property2', 'DESC'],
            ],
            'with max value' => [
                [2, 'property1', 'property2'],
                ['SORTBY', 2, 'property1', 'property2', 'MAX', 2],
            ],
            'with sorting direction and max value' => [
                [2, 'property1', 'ASC', 'property2', 'DESC'],
                ['SORTBY', 4, 'property1', 'ASC', 'property2', 'DESC', 'MAX', 2],
            ],
        ];
    }

    public function applyProvider(): array
    {
        return [
            'with default arguments' => [
                ['expression'],
                ['APPLY', 'expression'],
            ],
            'with alias' => [
                ['expression', 'name'],
                ['APPLY', 'expression', 'AS', 'name'],
            ],
        ];
    }

    public function withCursorProvider(): array
    {
        return [
            'with default arguments' => [
                [],
                ['WITHCURSOR'],
            ],
            'with readSize argument' => [
                [2],
                ['WITHCURSOR', 'COUNT', 2],
            ],
            'with maxIdle argument' => [
                [0, 2],
                ['WITHCURSOR', 'MAXIDLE', 2],
            ],
            'with readSize and maxIdle arguments' => [
                [3, 2],
                ['WITHCURSOR', 'COUNT', 3, 'MAXIDLE', 2],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\CommonArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use PHPUnit\Framework\TestCase;

class CommonArgumentsTest extends TestCase
{
    /**
     * @var CommonArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new CommonArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithLanguageModifier(): void
    {
        $this->arguments->language('english');

        $this->assertSame(['LANGUAGE', 'english'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithDialectModifier(): void
    {
        $this->arguments->dialect('dialect');

        $this->assertSame(['DIALECT', 'dialect'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithPayloadModifier(): void
    {
        $this->arguments->payload('payload');

        $this->assertSame(['PAYLOAD', 'payload'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithStopInitialScanModifier(): void
    {
        $this->arguments->skipInitialScan();

        $this->assertSame(['SKIPINITIALSCAN'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithWithScoresModifier(): void
    {
        $this->arguments->withScores();

        $this->assertSame(['WITHSCORES'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithWithPayloadsModifier(): void
    {
        $this->arguments->withPayloads();

        $this->assertSame(['WITHPAYLOADS'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithVerbatimModifier(): void
    {
        $this->arguments->verbatim();

        $this->assertSame(['VERBATIM'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithTimeoutModifier(): void
    {
        $this->arguments->timeout(2);

        $this->assertSame(['TIMEOUT', 2], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithLimitModifier(): void
    {
        $this->arguments->limit(2, 2);

        $this->assertSame(['LIMIT', 2, 2], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithFilterModifier(): void
    {
        $this->arguments->filter('@age>16');

        $this->assertSame(['FILTER', '@age>16'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithParamsModifier(): void
    {
        $this->arguments->params(['name1', 'value1', 'name2', 'value2']);

        $this->assertSame(['PARAMS', 4, 'name1', 'value1', 'name2', 'value2'], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\CreateArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use InvalidArgumentException;
use PHPUnit\Framework\TestCase;

class CreateArgumentsTest extends TestCase
{
    /**
     * @var CreateArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new CreateArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithOnModifier(): void
    {
        $this->arguments->on('json');

        $this->assertSame(['ON', 'JSON'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnInvalidModifierValue(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Wrong modifier value given. Currently supports: HASH, JSON');

        $this->arguments->on('wrong');
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithPrefixModifier(): void
    {
        $this->arguments->prefix(['prefix:', 'prefix1:']);

        $this->assertSame(['PREFIX', 2, 'prefix:', 'prefix1:'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithLanguageFieldModifier(): void
    {
        $this->arguments->languageField('language_attribute');

        $this->assertSame(['LANGUAGE_FIELD', 'language_attribute'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithScoreModifier(): void
    {
        $this->arguments->score(10.0);

        $this->assertSame(['SCORE', 10.0], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithScoreFieldModifier(): void
    {
        $this->arguments->scoreField('score_field');

        $this->assertSame(['SCORE_FIELD', 'score_field'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithMaxTestFieldsModifier(): void
    {
        $this->arguments->maxTextFields();

        $this->assertSame(['MAXTEXTFIELDS'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithNoOffsetsModifier(): void
    {
        $this->arguments->noOffsets();

        $this->assertSame(['NOOFFSETS'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithTemporaryModifier(): void
    {
        $this->arguments->temporary(1);

        $this->assertSame(['TEMPORARY', 1], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithNoHlModifier(): void
    {
        $this->arguments->noHl();

        $this->assertSame(['NOHL'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithNoFieldsModifier(): void
    {
        $this->arguments->noFields();

        $this->assertSame(['NOFIELDS'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithNoFreqsModifier(): void
    {
        $this->arguments->noFreqs();

        $this->assertSame(['NOFREQS'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithStopWordsModifier(): void
    {
        $this->arguments->stopWords(['word1', 'word2']);

        $this->assertSame(['STOPWORDS', 2, 'word1', 'word2'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesCorrectFTCreateArgumentsSetOnMethodsChainCall(): void
    {
        $this->arguments->prefix(['prefix:', 'prefix1:']);
        $this->arguments->filter('@age>16');
        $this->arguments->stopWords(['hello', 'world']);

        $this->assertSame(
            ['PREFIX', 2, 'prefix:', 'prefix1:', 'FILTER', '@age>16', 'STOPWORDS', 2, 'hello', 'world'],
            $this->arguments->toArray()
        );
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\CursorArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use PHPUnit\Framework\TestCase;

class CursorArgumentsTest extends TestCase
{
    /**
     * @var CursorArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new CursorArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithCountModifier(): void
    {
        $this->arguments->count(2);

        $this->assertSame(['COUNT', 2], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\DropArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use PHPUnit\Framework\TestCase;

class DropArgumentsTest extends TestCase
{
    /**
     * @var DropArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new DropArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithLanguageModifier(): void
    {
        $this->arguments->dd();

        $this->assertSame(['DD'], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\ProfileArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use PHPUnit\Framework\TestCase;

class ProfileArgumentsTest extends TestCase
{
    /**
     * @var ProfileArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new ProfileArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithSearchModifier(): void
    {
        $this->arguments->search();

        $this->assertSame(['SEARCH'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithAggregateModifier(): void
    {
        $this->arguments->aggregate();

        $this->assertSame(['AGGREGATE'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithLimitedModifier(): void
    {
        $this->arguments->limited();

        $this->assertSame(['LIMITED'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithQueryModifier(): void
    {
        $this->arguments->query('query');

        $this->assertSame(['QUERY', 'query'], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\SearchArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use InvalidArgumentException;
use PHPUnit\Framework\TestCase;

class SearchArgumentsTest extends TestCase
{
    /**
     * @var SearchArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new SearchArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithNoContentModifier(): void
    {
        $this->arguments->noContent();

        $this->assertSame(['NOCONTENT'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithWithSortKeysModifier(): void
    {
        $this->arguments->withSortKeys();

        $this->assertSame(['WITHSORTKEYS'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithSearchFilterModifier(): void
    {
        $this->arguments->searchFilter(['numeric_field', 1, 10], ['numeric_field1', 2, 5]);

        $this->assertSame(
            ['FILTER', 'numeric_field', 1, 10, 'FILTER', 'numeric_field1', 2, 5],
            $this->arguments->toArray()
        );
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithGeoFilterModifier(): void
    {
        $this->arguments->geoFilter(
            ['geo_field', 13.2321, 14.2321, 300, 'km'],
            ['geo_field1', 15.231, 16.234, 210, 'km']
        );

        $this->assertSame(
            ['GEOFILTER', 'geo_field', 13.2321, 14.2321, 300, 'km', 'GEOFILTER', 'geo_field1', 15.231, 16.234, 210, 'km'],
            $this->arguments->toArray()
        );
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithInKeysModifier(): void
    {
        $this->arguments->inKeys(['key1', 'key2']);

        $this->assertSame(['INKEYS', 2, 'key1', 'key2'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithInFieldsModifier(): void
    {
        $this->arguments->inFields(['field1', 'field2']);

        $this->assertSame(['INFIELDS', 2, 'field1', 'field2'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithReturnModifier(): void
    {
        $this->arguments->addReturn(2, 'identifier', true, 'property', 'identifier2', 'identifier3');

        $this->assertSame(
            ['RETURN', 2, 'identifier', 'AS', 'property', 'identifier2', 'identifier3'],
            $this->arguments->toArray()
        );
    }

    /**
     * @dataProvider summarizeProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testCreatesArgumentsWithSummarizeModifier(array $arguments, array $expectedResponse): void
    {
        $this->arguments->summarize(...$arguments);

        $this->assertSame($expectedResponse, $this->arguments->toArray());
    }

    /**
     * @dataProvider highlightProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testCreatesArgumentsWithHighlightModifier(array $arguments, array $expectedResponse): void
    {
        $this->arguments->highlight(...$arguments);

        $this->assertSame($expectedResponse, $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithSlopModifier(): void
    {
        $this->arguments->slop(2);

        $this->assertSame(['SLOP', 2], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithInOrderModifier(): void
    {
        $this->arguments->inOrder();

        $this->assertSame(['INORDER'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithExpanderModifier(): void
    {
        $this->arguments->expander('expander');

        $this->assertSame(['EXPANDER', 'expander'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithScorerModifier(): void
    {
        $this->arguments->scorer('scorer');

        $this->assertSame(['SCORER', 'scorer'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsExplainScoreModifier(): void
    {
        $this->arguments->explainScore();

        $this->assertSame(['EXPLAINSCORE'], $this->arguments->toArray());
    }

    /**
     * @dataProvider sortByProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testCreatesArgumentsWithSortByModifier(array $arguments, array $expectedResponse): void
    {
        $this->arguments->sortBy(...$arguments);

        $this->assertSame($expectedResponse, $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnSortByWrongOrderByModifier(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Wrong order direction value given. Currently supports: ASC, DESC');

        $this->arguments->sortBy('sort_attribute', 'wrong');
    }

    /**
     * @return void
     */
    public function testCreatesCorrectFTSearchArgumentsSetOnMethodsChainCall(): void
    {
        $this->arguments->withScores();
        $this->arguments->withPayloads();
        $this->arguments->searchFilter(['numeric_field', 1, 10]);
        $this->arguments->addReturn(2, 'identifier', true, 'property');

        $this->assertSame(
            ['WITHSCORES', 'WITHPAYLOADS', 'FILTER', 'numeric_field', 1, 10, 'RETURN', 2, 'identifier', 'AS', 'property'],
            $this->arguments->toArray()
        );
    }

    public function sortByProvider(): array
    {
        return [
            'with default arguments' => [
                ['sort_attribute'],
                ['SORTBY', 'sort_attribute', 'ASC'],
            ],
            'with DESC modifier' => [
                ['sort_attribute', 'desc'],
                ['SORTBY', 'sort_attribute', 'DESC'],
            ],
        ];
    }

    public function summarizeProvider(): array
    {
        return [
            'with no arguments' => [
                [],
                ['SUMMARIZE'],
            ],
            'with fields only' => [
                [['field1', 'field2']],
                ['SUMMARIZE', 'FIELDS', 2, 'field1', 'field2'],
            ],
            'with non-default FRAGS' => [
                [['field1', 'field2'], 2],
                ['SUMMARIZE', 'FIELDS', 2, 'field1', 'field2', 'FRAGS', 2],
            ],
            'with non-default LEN' => [
                [['field1', 'field2'], 0, 2],
                ['SUMMARIZE', 'FIELDS', 2, 'field1', 'field2', 'LEN', 2],
            ],
            'with non-default SEPARATOR' => [
                [['field1', 'field2'], 0, 0, ','],
                ['SUMMARIZE', 'FIELDS', 2, 'field1', 'field2', 'SEPARATOR', ','],
            ],
            'with all arguments' => [
                [['field1', 'field2'], 2, 2, ','],
                ['SUMMARIZE', 'FIELDS', 2, 'field1', 'field2', 'FRAGS', 2, 'LEN', 2, 'SEPARATOR', ','],
            ],
        ];
    }

    public function highlightProvider(): array
    {
        return [
            'with no arguments' => [
                [],
                ['HIGHLIGHT'],
            ],
            'with fields only' => [
                [['field1', 'field2']],
                ['HIGHLIGHT', 'FIELDS', 2, 'field1', 'field2'],
            ],
            'with open tag only' => [
                [['field1', 'field2'], 'openTag'],
                ['HIGHLIGHT', 'FIELDS', 2, 'field1', 'field2'],
            ],
            'with close tag only' => [
                [['field1', 'field2'], '', 'closeTag'],
                ['HIGHLIGHT', 'FIELDS', 2, 'field1', 'field2'],
            ],
            'with both tags' => [
                [['field1', 'field2'], 'openTag', 'closeTag'],
                ['HIGHLIGHT', 'FIELDS', 2, 'field1', 'field2', 'TAGS', 'openTag', 'closeTag'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\SpellcheckArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use InvalidArgumentException;
use PHPUnit\Framework\TestCase;

class SpellcheckArgumentsTest extends TestCase
{
    /**
     * @var SpellcheckArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new SpellcheckArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithDistanceModifier(): void
    {
        $this->arguments->distance(2);

        $this->assertSame(['DISTANCE', 2], $this->arguments->toArray());
    }

    /**
     * @dataProvider termsProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testCreatesArgumentsWithTermsModifier(array $arguments, array $expectedResponse): void
    {
        $this->arguments->terms(...$arguments);

        $this->assertSame($expectedResponse, $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnInvalidTermsModifierValue(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Wrong modifier value given. Currently supports: INCLUDE, EXCLUDE');

        $this->arguments->terms('dict', 'wrong');
    }

    public function termsProvider(): array
    {
        return [
            'with INCLUDE modifier' => [
                ['dict', 'INCLUDE', 'term1', 'term2'],
                ['TERMS', 'INCLUDE', 'dict', 'term1', 'term2'],
            ],
            'with EXCLUDE modifier' => [
                ['dict', 'EXCLUDE', 'term1', 'term2'],
                ['TERMS', 'EXCLUDE', 'dict', 'term1', 'term2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\SugAddArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use PHPUnit\Framework\TestCase;

class SugAddArgumentsTest extends TestCase
{
    /**
     * @var SugAddArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new SugAddArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithIncrModifier(): void
    {
        $this->arguments->incr();

        $this->assertSame(['INCR'], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\SugGetArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search;

use PHPUnit\Framework\TestCase;

class SugGetArgumentsTest extends TestCase
{
    /**
     * @var SugGetArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new SugGetArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithFuzzyModifier(): void
    {
        $this->arguments->fuzzy();

        $this->assertSame(['FUZZY'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithMaxModifier(): void
    {
        $this->arguments->max(5);

        $this->assertSame(['MAX', 5], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\SchemaFields\GeoFieldTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

use PHPUnit\Framework\TestCase;

class GeoFieldTest extends TestCase
{
    /**
     * @dataProvider geoFieldsProvider
     * @param  array $arguments
     * @param  array $expectedSchema
     * @return void
     */
    public function testReturnsCorrectFieldArgumentsArray(
        array $arguments,
        array $expectedSchema
    ): void {
        $this->assertSame($expectedSchema, (new GeoField(...$arguments))->toArray());
    }

    public function geoFieldsProvider(): array
    {
        return [
            'with default arguments' => [
                ['field_name'],
                ['field_name', 'GEO'],
            ],
            'with alias' => [
                ['field_name', 'fn'],
                ['field_name', 'AS', 'fn', 'GEO'],
            ],
            'with sortable - no UNF' => [
                ['field_name', '', AbstractField::SORTABLE],
                ['field_name', 'GEO', 'SORTABLE'],
            ],
            'with sortable - with UNF' => [
                ['field_name', '', AbstractField::SORTABLE_UNF],
                ['field_name', 'GEO', 'SORTABLE', 'UNF'],
            ],
            'with NOINDEX modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, true],
                ['field_name', 'GEO', 'NOINDEX'],
            ],
            'with INDEXMISSING modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, false, true],
                ['field_name', 'GEO', 'INDEXMISSING'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\SchemaFields\GeoShapeFieldTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

use PHPUnit\Framework\TestCase;

class GeoShapeFieldTest extends TestCase
{
    /**
     * @dataProvider geoFieldsProvider
     * @param  array $arguments
     * @param  array $expectedSchema
     * @return void
     */
    public function testReturnsCorrectFieldArgumentsArray(
        array $arguments,
        array $expectedSchema
    ): void {
        $this->assertSame($expectedSchema, (new GeoShapeField(...$arguments))->toArray());
    }

    public function geoFieldsProvider(): array
    {
        return [
            'with default arguments' => [
                ['field_name'],
                ['field_name', 'GEOSHAPE'],
            ],
            'with alias' => [
                ['field_name', 'fn'],
                ['field_name', 'AS', 'fn', 'GEOSHAPE'],
            ],
            'with sortable - no UNF' => [
                ['field_name', '', AbstractField::SORTABLE],
                ['field_name', 'GEOSHAPE', 'SORTABLE'],
            ],
            'with sortable - with UNF' => [
                ['field_name', '', AbstractField::SORTABLE_UNF],
                ['field_name', 'GEOSHAPE', 'SORTABLE', 'UNF'],
            ],
            'with NOINDEX modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, true],
                ['field_name', 'GEOSHAPE', 'NOINDEX'],
            ],
            'with FLAT modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, false, GeoShapeField::COORD_FLAT],
                ['field_name', 'GEOSHAPE', 'FLAT'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\SchemaFields\NumericFieldTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

use PHPUnit\Framework\TestCase;

class NumericFieldTest extends TestCase
{
    /**
     * @dataProvider numericFieldsProvider
     * @param  array $arguments
     * @param  array $expectedSchema
     * @return void
     */
    public function testReturnsCorrectFieldArgumentsArray(
        array $arguments,
        array $expectedSchema
    ): void {
        $this->assertSame($expectedSchema, (new NumericField(...$arguments))->toArray());
    }

    public function numericFieldsProvider(): array
    {
        return [
            'with default arguments' => [
                ['field_name'],
                ['field_name', 'NUMERIC'],
            ],
            'with alias' => [
                ['field_name', 'fn'],
                ['field_name', 'AS', 'fn', 'NUMERIC'],
            ],
            'with sortable - no UNF' => [
                ['field_name', '', AbstractField::SORTABLE],
                ['field_name', 'NUMERIC', 'SORTABLE'],
            ],
            'with sortable - with UNF' => [
                ['field_name', '', AbstractField::SORTABLE_UNF],
                ['field_name', 'NUMERIC', 'SORTABLE', 'UNF'],
            ],
            'with NOINDEX modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, true],
                ['field_name', 'NUMERIC', 'NOINDEX'],
            ],
            'with INDEXMISSING modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, false, true],
                ['field_name', 'NUMERIC', 'INDEXMISSING'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\SchemaFields\TagFieldTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

use PHPUnit\Framework\TestCase;

class TagFieldTest extends TestCase
{
    /**
     * @dataProvider tagFieldsProvider
     * @param  array $arguments
     * @param  array $expectedSchema
     * @return void
     */
    public function testReturnsCorrectFieldArgumentsArray(
        array $arguments,
        array $expectedSchema
    ): void {
        $this->assertSame($expectedSchema, (new TagField(...$arguments))->toArray());
    }

    public function tagFieldsProvider(): array
    {
        return [
            'with default arguments' => [
                ['field_name'],
                ['field_name', 'TAG'],
            ],
            'with alias' => [
                ['field_name', 'fn'],
                ['field_name', 'AS', 'fn', 'TAG'],
            ],
            'with sortable - no UNF' => [
                ['field_name', '', AbstractField::SORTABLE],
                ['field_name', 'TAG', 'SORTABLE'],
            ],
            'with sortable - with UNF' => [
                ['field_name', '', AbstractField::SORTABLE_UNF],
                ['field_name', 'TAG', 'SORTABLE', 'UNF'],
            ],
            'with NOINDEX modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, true],
                ['field_name', 'TAG', 'NOINDEX'],
            ],
            'with INDEXEMPTY modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, false, ',', false, true],
                ['field_name', 'TAG', 'INDEXEMPTY'],
            ],
            'with INDEXMISSING modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, false, ',', false, false, true],
                ['field_name', 'TAG', 'INDEXMISSING'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\SchemaFields\TextFieldTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

use PHPUnit\Framework\TestCase;

class TextFieldTest extends TestCase
{
    /**
     * @dataProvider textFieldsProvider
     * @param  array $arguments
     * @param  array $expectedSchema
     * @return void
     */
    public function testReturnsCorrectFieldArgumentsArray(
        array $arguments,
        array $expectedSchema
    ): void {
        $this->assertSame($expectedSchema, (new TextField(...$arguments))->toArray());
    }

    public function textFieldsProvider(): array
    {
        return [
            'with default arguments' => [
                ['field_name'],
                ['field_name', 'TEXT'],
            ],
            'with alias' => [
                ['field_name', 'fn'],
                ['field_name', 'AS', 'fn', 'TEXT'],
            ],
            'with sortable - no UNF' => [
                ['field_name', '', AbstractField::SORTABLE],
                ['field_name', 'TEXT', 'SORTABLE'],
            ],
            'with sortable - with UNF' => [
                ['field_name', '', AbstractField::SORTABLE_UNF],
                ['field_name', 'TEXT', 'SORTABLE', 'UNF'],
            ],
            'with NOINDEX modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, true],
                ['field_name', 'TEXT', 'NOINDEX'],
            ],
            'with INDEXEMPTY modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, false, false, '', 1, false, true],
                ['field_name', 'TEXT', 'INDEXEMPTY'],
            ],
            'with INDEXMISSING modifier' => [
                ['field_name', '', AbstractField::NOT_SORTABLE, false, false, '', 1, false, false, true],
                ['field_name', 'TEXT', 'INDEXMISSING'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\Search\SchemaFields\VectorFieldTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\Search\SchemaFields;

use PHPUnit\Framework\TestCase;

class VectorFieldTest extends TestCase
{
    /**
     * @return void
     */
    public function testReturnsCorrectFieldArgumentsArray(): void
    {
        $this->assertSame(
            ['field_name', 'AS', 'field', 'VECTOR', 'FLAT', 2, 'attribute_name', 'attribute_value'],
            (new VectorField('field_name', 'FLAT', ['attribute_name', 'attribute_value'], 'field'))->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\TimeSeries\AddArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

use PHPUnit\Framework\TestCase;

class AddArgumentsTest extends TestCase
{
    /**
     * @var AddArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new AddArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithOnDuplicateModifier(): void
    {
        $this->arguments->onDuplicate(CommonArguments::POLICY_LAST);

        $this->assertSame(['ON_DUPLICATE', CommonArguments::POLICY_LAST], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\TimeSeries\CommonArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

use PHPUnit\Framework\TestCase;
use UnexpectedValueException;

class CommonArgumentsTest extends TestCase
{
    /**
     * @var CommonArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new CommonArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithRetentionModifier(): void
    {
        $this->arguments->retentionMsecs(10);

        $this->assertSame(['RETENTION', 10], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithChunkSizeModifier(): void
    {
        $this->arguments->chunkSize(100);

        $this->assertSame(['CHUNK_SIZE', 100], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithDuplicatePolicyModifier(): void
    {
        $this->arguments->duplicatePolicy(CommonArguments::POLICY_FIRST);

        $this->assertSame(['DUPLICATE_POLICY', CommonArguments::POLICY_FIRST], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithLabelsModifier(): void
    {
        $this->arguments->labels('label1', 1, 'label2', 2);

        $this->assertSame(['LABELS', 'label1', 1, 'label2', 2], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithEncodingModifier(): void
    {
        $this->arguments->encoding(CommonArguments::ENCODING_UNCOMPRESSED);

        $this->assertSame(['ENCODING', CommonArguments::ENCODING_UNCOMPRESSED], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithLatestModifier(): void
    {
        $this->arguments->latest();

        $this->assertSame(['LATEST'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithWithLabelsModifier(): void
    {
        $this->arguments->withLabels();

        $this->assertSame(['WITHLABELS'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithSelectedLabelsModifier(): void
    {
        $this->arguments->selectedLabels('label1', 'label2');

        $this->assertSame(['SELECTED_LABELS', 'label1', 'label2'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithIgnoreModifier(): void
    {
        $this->arguments->ignore(10, 10);

        $this->assertEquals(['IGNORE', 10, 10], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testIgnoreModifierThrowsExceptionOnNonPositiveValues(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Ignore does not accept negative values');

        $this->arguments->ignore(-1, -1);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\TimeSeries\CreateArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

use PHPUnit\Framework\TestCase;

class CreateArgumentsTest extends TestCase
{
    /**
     * @var CreateArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new CreateArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithEncodingModifier(): void
    {
        $this->arguments->encoding(CreateArguments::ENCODING_UNCOMPRESSED);

        $this->assertSame(['ENCODING', CreateArguments::ENCODING_UNCOMPRESSED], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\TimeSeries\IncrByArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

use PHPUnit\Framework\TestCase;

class IncrByArgumentsTest extends TestCase
{
    /**
     * @var IncrByArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new IncrByArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithTimestampModifier(): void
    {
        $this->arguments->timestamp('*');

        $this->assertSame(['TIMESTAMP', '*'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithUncompressedModifier(): void
    {
        $this->arguments->uncompressed();

        $this->assertSame(['UNCOMPRESSED'], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\TimeSeries\InfoArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

use PHPUnit\Framework\TestCase;

class InfoArgumentsTest extends TestCase
{
    /**
     * @var InfoArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new InfoArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithDebugModifier(): void
    {
        $this->arguments->debug();

        $this->assertSame(['DEBUG'], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\TimeSeries\MRangeArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

use PHPUnit\Framework\TestCase;

class MRangeArgumentsTest extends TestCase
{
    /**
     * @var MRangeArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new MRangeArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithFilterModifier(): void
    {
        $this->arguments->filter('exp1', 'exp2');

        $this->assertSame(['FILTER', 'exp1', 'exp2'], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithGroupByModifier(): void
    {
        $this->arguments->groupBy('label', 'reducer');

        $this->assertSame(['GROUPBY', 'label', 'REDUCE', 'reducer'], $this->arguments->toArray());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Argument\TimeSeries\RangeArgumentsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Argument\TimeSeries;

use PHPUnit\Framework\TestCase;

class RangeArgumentsTest extends TestCase
{
    /**
     * @var RangeArguments
     */
    private $arguments;

    protected function setUp(): void
    {
        $this->arguments = new RangeArguments();
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithFilterByTsModifier(): void
    {
        $this->arguments->filterByTs(1000, 1001);

        $this->assertSame(['FILTER_BY_TS', 1000, 1001], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithFilterByValueModifier(): void
    {
        $this->arguments->filterByValue(1000, 1001);

        $this->assertSame(['FILTER_BY_VALUE', 1000, 1001], $this->arguments->toArray());
    }

    /**
     * @return void
     */
    public function testCreatesArgumentsWithCountModifier(): void
    {
        $this->arguments->count(1000);

        $this->assertSame(['COUNT', 1000], $this->arguments->toArray());
    }

    /**
     * @dataProvider aggregatorProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testCreatesArgumentsWithAggregatorModifier(array $arguments, array $expectedResponse): void
    {
        $this->arguments->aggregation(...$arguments);

        $this->assertSame($expectedResponse, $this->arguments->toArray());
    }

    public function aggregatorProvider(): array
    {
        return [
            'with default arguments' => [
                ['sum', 1000],
                ['AGGREGATION', 'sum', 1000],
            ],
            'with ALIGN modifier' => [
                ['sum', 1000, 10],
                ['ALIGN', 10, 'AGGREGATION', 'sum', 1000],
            ],
            'with BUCKETTIMESTAMP modifier' => [
                ['sum', 1000, 0, 10000],
                ['AGGREGATION', 'sum', 1000, 'BUCKETTIMESTAMP', 10000],
            ],
            'with EMPTY modifier' => [
                ['sum', 1000, 0, 0, true],
                ['AGGREGATION', 'sum', 1000, 'EMPTY'],
            ],
            'with all arguments' => [
                ['sum', 1000, 10, 10000, true],
                ['ALIGN', 10, 'AGGREGATION', 'sum', 1000, 'BUCKETTIMESTAMP', 10000, 'EMPTY'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Processor\KeyPrefixProcessorTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Processor;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\CommandInterface;
use Predis\Command\RawCommand;
use PredisTestCase;
use stdClass;

class KeyPrefixProcessorTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testConstructorWithPrefix(): void
    {
        $prefix = 'prefix:';
        $processor = new KeyPrefixProcessor($prefix);

        $this->assertInstanceOf('Predis\Command\Processor\ProcessorInterface', $processor);
        $this->assertEquals($prefix, $processor->getPrefix());
    }

    /**
     * @group disconnected
     */
    public function testChangePrefix(): void
    {
        $prefix1 = 'prefix:';
        $prefix2 = 'prefix:new:';

        $processor = new KeyPrefixProcessor($prefix1);
        $this->assertEquals($prefix1, $processor->getPrefix());

        $processor->setPrefix($prefix2);
        $this->assertEquals($prefix2, $processor->getPrefix());
    }

    /**
     * @group disconnected
     */
    public function testProcessPrefixableCommandInterface(): void
    {
        $prefix = 'prefix:';

        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\PrefixableCommandInterface')->getMock();
        $command
            ->expects($this->never())
            ->method('getId');
        $command
            ->expects($this->once())
            ->method('prefixKeys')
            ->with($prefix);

        $processor = new KeyPrefixProcessor($prefix);

        $processor->process($command);
    }

    /**
     * @group disconnected
     */
    public function testSkipNotPrefixableCommands(): void
    {
        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\CommandInterface')->getMock();
        $command->expects($this->once())
            ->method('getId')
            ->willReturn('unknown');
        $command
            ->expects($this->never())
            ->method('getArguments');

        $processor = new KeyPrefixProcessor('prefix');

        $processor->process($command);
    }

    /**
     * @group disconnected
     */
    public function testInstanceCanBeCastedToString(): void
    {
        $prefix = 'prefix:';
        $processor = new KeyPrefixProcessor($prefix);

        $this->assertEquals($prefix, (string) $processor);
    }

    /**
     * @group disconnected
     */
    public function testPrefixFirst(): void
    {
        $arguments = ['1st', '2nd', '3rd', '4th'];
        $expected = ['prefix:1st', '2nd', '3rd', '4th'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        KeyPrefixProcessor::first($command, 'prefix:');
        $this->assertSame($expected, $command->getArguments());

        // Empty arguments
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        KeyPrefixProcessor::skipLast($command, 'prefix:');
        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testPrefixFirstTwo(): void
    {
        $arguments = ['1st', '2nd', '3rd', '4th'];
        $expected = ['prefix:1st', 'prefix:2nd', '3rd', '4th'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        KeyPrefixProcessor::firstTwo($command, 'prefix:');
        $this->assertSame($expected, $command->getArguments());

        // One argument
        $arguments = ['1st'];
        $expected = ['prefix:1st'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        KeyPrefixProcessor::firstTwo($command, 'prefix:');
        $this->assertSame($expected, $command->getArguments());

        // Empty arguments
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        KeyPrefixProcessor::firstTwo($command, 'prefix:');
        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testPrefixAll(): void
    {
        $arguments = ['1st', '2nd', '3rd', '4th'];
        $expected = ['prefix:1st', 'prefix:2nd', 'prefix:3rd', 'prefix:4th'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        KeyPrefixProcessor::all($command, 'prefix:');
        $this->assertSame($expected, $command->getArguments());

        // Empty arguments
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        KeyPrefixProcessor::skipLast($command, 'prefix:');
        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testPrefixInterleaved(): void
    {
        $arguments = ['1st', '2nd', '3rd', '4th'];
        $expected = ['prefix:1st', '2nd', 'prefix:3rd', '4th'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        KeyPrefixProcessor::interleaved($command, 'prefix:');
        $this->assertSame($expected, $command->getArguments());

        // Empty arguments
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        KeyPrefixProcessor::skipLast($command, 'prefix:');
        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testPrefixSkipLast(): void
    {
        $arguments = ['1st', '2nd', '3rd', '4th'];
        $expected = ['prefix:1st', 'prefix:2nd', 'prefix:3rd', '4th'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        KeyPrefixProcessor::skipLast($command, 'prefix:');
        $this->assertSame($expected, $command->getArguments());

        // Empty arguments
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        KeyPrefixProcessor::skipLast($command, 'prefix:');
        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testPrefixSort(): void
    {
        $arguments = ['key', 'BY', 'by_key_*', 'STORE', 'destination_key'];
        $expected = ['prefix:key', 'BY', 'prefix:by_key_*', 'STORE', 'prefix:destination_key'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        KeyPrefixProcessor::sort($command, 'prefix:');
        $this->assertSame($expected, $command->getArguments());

        // Empty arguments
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        KeyPrefixProcessor::sort($command, 'prefix:');
        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testPrefixZSetStore(): void
    {
        $arguments = ['key:destination', 2, 'key1', 'key2', 'WEIGHTS', 10, 100, 'AGGREGATE', 'sum'];
        $expected = [
            'prefix:key:destination', 2, 'prefix:key1', 'prefix:key2', 'WEIGHTS', 10, 100, 'AGGREGATE', 'sum',
        ];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        KeyPrefixProcessor::zsetStore($command, 'prefix:');
        $this->assertSame($expected, $command->getArguments());

        // Empty arguments
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        KeyPrefixProcessor::zsetStore($command, 'prefix:');
        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testPrefixEval(): void
    {
        $arguments = ['return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}', 2, 'foo', 'hoge', 'bar', 'piyo'];
        $expected = [
            'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}', 2, 'prefix:foo', 'prefix:hoge', 'bar', 'piyo',
        ];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        KeyPrefixProcessor::evalKeys($command, 'prefix:');
        $this->assertSame($expected, $command->getArguments());

        // Empty arguments
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        KeyPrefixProcessor::evalKeys($command, 'prefix:');
        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testPrefixMigrate(): void
    {
        $arguments = ['127.0.0.1', '6379', 'key', '0', '10', 'COPY', 'REPLACE'];
        $expected = ['127.0.0.1', '6379', 'prefix:key', '0', '10', 'COPY', 'REPLACE'];

        $command = $this->getMockForAbstractClass('Predis\Command\Command');
        $command->setRawArguments($arguments);

        KeyPrefixProcessor::migrate($command, 'prefix:');
        $this->assertSame($expected, $command->getArguments());

        // Empty arguments
        $command = $this->getMockForAbstractClass('Predis\Command\Command');

        KeyPrefixProcessor::sort($command, 'prefix:');
        $this->assertEmpty($command->getArguments());
    }

    /**
     * @group disconnected
     * @dataProvider commandArgumentsDataProvider
     *
     * @param string $commandID
     * @param array  $arguments
     * @param array  $expected
     */
    public function testApplyPrefixToCommand($commandID, array $arguments, array $expected): void
    {
        $processor = new KeyPrefixProcessor('prefix:');
        $command = $this->getCommandInstance($commandID, $arguments);

        $processor->process($command);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testCanDefineNewCommandHandlers(): void
    {
        $command = $this->getCommandInstance('NEWCMD', ['key', 'value']);

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($command, 'prefix:')
            ->willReturnCallback(function ($command, $prefix) {
                $command->setRawArguments(['prefix:key', 'value']);
            });

        $processor = new KeyPrefixProcessor('prefix:');
        $processor->setCommandHandler('NEWCMD', $callable);
        $processor->process($command);

        $this->assertSame(['prefix:key', 'value'], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testCanOverrideExistingCommandHandlers(): void
    {
        $command = $this->getCommandInstance('SET', ['key', 'value']);

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($command, 'prefix:')
            ->willReturnCallback(function ($command, $prefix) {
                $command->setRawArguments(['prefix:key', 'value']);
            });

        $processor = new KeyPrefixProcessor('prefix:');
        $processor->setCommandHandler('SET', $callable);
        $processor->process($command);

        $this->assertSame(['prefix:key', 'value'], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testCanUndefineCommandHandlers(): void
    {
        $command = $this->getCommandInstance('SET', ['key', 'value']);

        $processor = new KeyPrefixProcessor('prefix:');
        $processor->setCommandHandler('SET', null);
        $processor->process($command);

        $this->assertSame(['key', 'value'], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testCannotDefineCommandHandlerWithInvalidType(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Callback must be a valid callable object or NULL');

        $processor = new KeyPrefixProcessor('prefix:');
        $processor->setCommandHandler('NEWCMD', new stdClass());
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns a command instance by ID populated with the specified arguments.
     *
     * @param string $commandID ID of the Redis command
     * @param array  $arguments List of arguments for the command
     *
     * @return CommandInterface
     */
    public function getCommandInstance(string $commandID, array $arguments): CommandInterface
    {
        $command = new RawCommand($commandID);
        $command->setRawArguments($arguments);

        return $command;
    }

    /**
     * Data provider for key prefixing test.
     *
     * @return array
     */
    public function commandArgumentsDataProvider(): array
    {
        return [
            /* ---------------- Redis 1.2 ---------------- */
            ['EXISTS',
                ['key'],
                ['prefix:key'],
            ],
            ['DEL',
                ['key1', 'key2', 'key3'],
                ['prefix:key1', 'prefix:key2', 'prefix:key3'],
            ],
            ['TYPE',
                ['key'],
                ['prefix:key'],
            ],
            ['KEYS',
                ['pattern'],
                ['prefix:pattern'],
            ],
            ['RENAME',
                ['key', 'newkey'],
                ['prefix:key', 'prefix:newkey'],
            ],
            ['RENAMENX',
                ['key', 'newkey'],
                ['prefix:key', 'prefix:newkey'],
            ],
            ['EXPIRE',
                ['key', 'value'],
                ['prefix:key', 'value'],
            ],
            ['EXPIREAT',
                ['key', 'value'],
                ['prefix:key', 'value'],
            ],
            ['TTL',
                ['key', 10],
                ['prefix:key', 10],
            ],
            ['MOVE',
                ['key', 'db'],
                ['prefix:key', 'db'],
            ],
            ['SORT',
                ['key'],
                ['prefix:key'],
            ],
            ['SORT',
                ['key', 'BY', 'by_key_*'],
                ['prefix:key', 'BY', 'prefix:by_key_*'],
            ],
            ['SORT',
                ['key', 'BY', 'by_key_*', 'STORE', 'destination_key'],
                ['prefix:key', 'BY', 'prefix:by_key_*', 'STORE', 'prefix:destination_key'],
            ],
            ['SORT',
                ['key', 'BY', 'by_key_*', 'GET', 'object_*', 'GET', '#', 'LIMIT', 1, 4, 'ASC', 'ALPHA', 'STORE', 'destination_key'],
                ['prefix:key', 'BY', 'prefix:by_key_*', 'GET', 'prefix:object_*', 'GET', '#', 'LIMIT', 1, 4, 'ASC', 'ALPHA', 'STORE', 'prefix:destination_key'],
            ],
            ['DUMP',
                ['key'],
                ['prefix:key'],
            ],
            ['RESTORE',
                ['key', 0, "\x00\xC0\n\x06\x00\xF8r?\xC5\xFB\xFB_("],
                ['prefix:key', 0, "\x00\xC0\n\x06\x00\xF8r?\xC5\xFB\xFB_("],
            ],
            ['SET',
                ['key', 'value'],
                ['prefix:key', 'value'],
            ],
            ['SET',
                ['key', 'value', 'EX', 10, 'NX'],
                ['prefix:key', 'value', 'EX', 10, 'NX'],
            ],
            ['SETNX',
                ['key', 'value'],
                ['prefix:key', 'value'],
            ],
            ['MSET',
                ['foo', 'bar', 'hoge', 'piyo'],
                ['prefix:foo', 'bar', 'prefix:hoge', 'piyo'],
            ],
            ['MSETNX',
                ['foo', 'bar', 'hoge', 'piyo'],
                ['prefix:foo', 'bar', 'prefix:hoge', 'piyo'],
            ],
            ['GET',
                ['key'],
                ['prefix:key'],
            ],
            ['MGET',
                ['key1', 'key2', 'key3'],
                ['prefix:key1', 'prefix:key2', 'prefix:key3'],
            ],
            ['GETSET',
                ['key', 'value'],
                ['prefix:key', 'value'],
            ],
            ['INCR',
                ['key'],
                ['prefix:key'],
            ],
            ['INCRBY',
                ['key', 5],
                ['prefix:key', 5],
            ],
            ['DECR',
                ['key'],
                ['prefix:key'],
            ],
            ['DECRBY',
                ['key', 5],
                ['prefix:key', 5],
            ],
            ['RPUSH',
                ['key', 'value1', 'value2', 'value3'],
                ['prefix:key', 'value1', 'value2', 'value3'],
            ],
            ['LPUSH',
                ['key', 'value1', 'value2', 'value3'],
                ['prefix:key', 'value1', 'value2', 'value3'],
            ],
            ['LLEN',
                ['key'],
                ['prefix:key'],
            ],
            ['LRANGE',
                ['key', 0, -1],
                ['prefix:key', 0, -1],
            ],
            ['LTRIM',
                ['key', 0, 1],
                ['prefix:key', 0, 1],
            ],
            ['LINDEX',
                ['key', 1],
                ['prefix:key', 1],
            ],
            ['LSET',
                ['key', 0, 'value'],
                ['prefix:key', 0, 'value'],
            ],
            ['LREM',
                ['key', 0, 'value'],
                ['prefix:key', 0, 'value'],
            ],
            ['LPOP',
                ['key'],
                ['prefix:key'],
            ],
            ['RPOP',
                ['key'],
                ['prefix:key'],
            ],
            ['RPOPLPUSH',
                ['key:source', 'key:destination'],
                ['prefix:key:source', 'prefix:key:destination'],
            ],
            ['SADD',
                ['key', 'member1', 'member2', 'member3'],
                ['prefix:key', 'member1', 'member2', 'member3'],
            ],
            ['SREM',
                ['key', 'member1', 'member2', 'member3'],
                ['prefix:key', 'member1', 'member2', 'member3'],
            ],
            ['SPOP',
                ['key'],
                ['prefix:key'],
            ],
            ['SMOVE',
                ['key:source', 'key:destination', 'member'],
                ['prefix:key:source', 'prefix:key:destination', 'member'],
            ],
            ['SCARD',
                ['key'],
                ['prefix:key'],
            ],
            ['SISMEMBER',
                ['key', 'member'],
                ['prefix:key', 'member'],
            ],
            ['SINTER',
                ['key1', 'key2', 'key3'],
                ['prefix:key1', 'prefix:key2', 'prefix:key3'],
            ],
            ['SINTERSTORE',
                ['key:destination', 'key1', 'key2'],
                ['prefix:key:destination', 'prefix:key1', 'prefix:key2'],
            ],
            ['SUNION',
                ['key1', 'key2', 'key3'],
                ['prefix:key1', 'prefix:key2', 'prefix:key3'],
            ],
            ['SUNIONSTORE',
                ['key:destination', 'key1', 'key2'],
                ['prefix:key:destination', 'prefix:key1', 'prefix:key2'],
            ],
            ['SDIFF',
                ['key1', 'key2', 'key3'],
                ['prefix:key1', 'prefix:key2', 'prefix:key3'],
            ],
            ['SDIFFSTORE',
                ['key:destination', 'key1', 'key2'],
                ['prefix:key:destination', 'prefix:key1', 'prefix:key2'],
            ],
            ['SMEMBERS',
                ['key'],
                ['prefix:key'],
            ],
            ['SMISMEMBER',
                ['key', 'member1', 'member2', 'member3'],
                ['prefix:key', 'member1', 'member2', 'member3'],
            ],
            ['SRANDMEMBER',
                ['key', 1],
                ['prefix:key', 1],
            ],
            ['ZADD',
                ['key', 'score1', 'member1', 'score2', 'member2'],
                ['prefix:key', 'score1', 'member1', 'score2', 'member2'],
            ],
            ['ZINCRBY',
                ['key', 1.0, 'member'],
                ['prefix:key', 1.0, 'member'],
            ],
            ['ZREM',
                ['key', 'member1', 'member2', 'member3'],
                ['prefix:key', 'member1', 'member2', 'member3'],
            ],
            ['ZRANGE',
                ['key', 0, 100, 'WITHSCORES'],
                ['prefix:key', 0, 100, 'WITHSCORES'],
            ],
            ['ZREVRANGE',
                ['key', 0, 100, 'WITHSCORES'],
                ['prefix:key', 0, 100, 'WITHSCORES'],
            ],
            ['ZRANGEBYSCORE',
                ['key', 0, 100, 'LIMIT', 0, 100, 'WITHSCORES'],
                ['prefix:key', 0, 100, 'LIMIT', 0, 100, 'WITHSCORES'],
            ],
            ['ZCARD',
                ['key'],
                ['prefix:key'],
            ],
            ['ZSCORE',
                ['key', 'member'],
                ['prefix:key', 'member'],
            ],
            ['ZREMRANGEBYSCORE',
                ['key', 0, 10],
                ['prefix:key', 0, 10],
            ],
            /* ---------------- Redis 2.0 ---------------- */
            ['SETEX',
                ['key', 10, 'value'],
                ['prefix:key', 10, 'value'],
            ],
            ['APPEND',
                ['key', 'value'],
                ['prefix:key', 'value'],
            ],
            ['SUBSTR',
                ['key', 5, 10],
                ['prefix:key', 5, 10],
            ],
            ['BLPOP',
                ['key1', 'key2', 'key3', 10],
                ['prefix:key1', 'prefix:key2', 'prefix:key3', 10],
            ],
            ['BRPOP',
                ['key1', 'key2', 'key3', 10],
                ['prefix:key1', 'prefix:key2', 'prefix:key3', 10],
            ],
            ['ZUNIONSTORE',
                ['key:destination', 2, 'key1', 'key2', 'WEIGHTS', 10, 100, 'AGGREGATE', 'sum'],
                ['prefix:key:destination', 2, 'prefix:key1', 'prefix:key2', 'WEIGHTS', 10, 100, 'AGGREGATE', 'sum'],
            ],
            ['ZINTERSTORE',
                ['key:destination', 2, 'key1', 'key2', 'WEIGHTS', 10, 100, 'AGGREGATE', 'sum'],
                ['prefix:key:destination', 2, 'prefix:key1', 'prefix:key2', 'WEIGHTS', 10, 100, 'AGGREGATE', 'sum'],
            ],
            ['ZCOUNT',
                ['key', 0, 10],
                ['prefix:key', 0, 10],
            ],
            ['ZRANK',
                ['key', 'member'],
                ['prefix:key', 'member'],
            ],
            ['ZREVRANK',
                ['key', 'member'],
                ['prefix:key', 'member'],
            ],
            ['ZREMRANGEBYRANK',
                ['key', 0, 10],
                ['prefix:key', 0, 10],
            ],
            ['HSET',
                ['key', 'field', 'value'],
                ['prefix:key', 'field', 'value'],
            ],
            ['HSETNX',
                ['key', 'field', 'value'],
                ['prefix:key', 'field', 'value'],
            ],
            ['HMSET',
                ['key', 'field1', 'value1', 'field2', 'value2'],
                ['prefix:key', 'field1', 'value1', 'field2', 'value2'],
            ],
            ['HINCRBY',
                ['key', 'field', 10],
                ['prefix:key', 'field', 10],
            ],
            ['HGET',
                ['key', 'field'],
                ['prefix:key', 'field'],
            ],
            ['HMGET',
                ['key', 'field1', 'field2', 'field3'],
                ['prefix:key', 'field1', 'field2', 'field3'],
            ],
            ['HDEL',
                ['key', 'field1', 'field2', 'field3'],
                ['prefix:key', 'field1', 'field2', 'field3'],
            ],
            ['HEXISTS',
                ['key', 'field'],
                ['prefix:key', 'field'],
            ],
            ['HLEN',
                ['key'],
                ['prefix:key'],
            ],
            ['HKEYS',
                ['key'],
                ['prefix:key'],
            ],
            ['HVALS',
                ['key'],
                ['prefix:key'],
            ],
            ['HGETALL',
                ['key'],
                ['prefix:key'],
            ],
            ['SUBSCRIBE',
                ['channel:foo', 'channel:hoge'],
                ['prefix:channel:foo', 'prefix:channel:hoge'],
            ],
            ['UNSUBSCRIBE',
                ['channel:foo', 'channel:hoge'],
                ['prefix:channel:foo', 'prefix:channel:hoge'],
            ],
            ['PSUBSCRIBE',
                ['channel:foo:*', 'channel:hoge:*'],
                ['prefix:channel:foo:*', 'prefix:channel:hoge:*'],
            ],
            ['PUNSUBSCRIBE',
                ['channel:foo:*', 'channel:hoge:*'],
                ['prefix:channel:foo:*', 'prefix:channel:hoge:*'],
            ],
            ['PUBLISH',
                ['channel', 'message'],
                ['prefix:channel', 'message'],
            ],
            /* ---------------- Redis 2.2 ---------------- */
            ['PERSIST',
                ['key'],
                ['prefix:key'],
            ],
            ['STRLEN',
                ['key'],
                ['prefix:key'],
            ],
            ['SETRANGE',
                ['key', 5, 'string'],
                ['prefix:key', 5, 'string'],
            ],
            ['GETRANGE',
                ['key', 5, 10],
                ['prefix:key', 5, 10],
            ],
            ['SETBIT',
                ['key', 7, 1],
                ['prefix:key', 7, 1],
            ],
            ['GETBIT',
                ['key', 100],
                ['prefix:key', 100],
            ],
            ['RPUSHX',
                ['key', 'value'],
                ['prefix:key', 'value'],
            ],
            ['LPUSHX',
                ['key', 'value'],
                ['prefix:key', 'value'],
            ],
            ['LINSERT',
                ['key', 'before', 'value1', 'value2'],
                ['prefix:key', 'before', 'value1', 'value2'],
            ],
            ['BRPOPLPUSH',
                ['key:source', 'key:destination', 10],
                ['prefix:key:source', 'prefix:key:destination', 10],
            ],
            ['ZREVRANGEBYSCORE',
                ['key', 0, 100, 'LIMIT', 0, 100, 'WITHSCORES'],
                ['prefix:key', 0, 100, 'LIMIT', 0, 100, 'WITHSCORES'],
            ],
            ['WATCH',
                ['key1', 'key2', 'key3'],
                ['prefix:key1', 'prefix:key2', 'prefix:key3'],
            ],
            /* ---------------- Redis 2.6 ---------------- */
            ['PTTL',
                ['key', 10],
                ['prefix:key', 10],
            ],
            ['PEXPIRE',
                ['key', 1500],
                ['prefix:key', 1500],
            ],
            ['PEXPIREAT',
                ['key', 1555555555005],
                ['prefix:key', 1555555555005],
            ],
            ['PSETEX',
                ['key', 1500, 'value'],
                ['prefix:key', 1500, 'value'],
            ],
            ['INCRBYFLOAT',
                ['key', 10.5],
                ['prefix:key', 10.5],
            ],
            ['BITOP',
                ['AND', 'key:dst', 'key:01', 'key:02'],
                ['AND', 'prefix:key:dst', 'prefix:key:01', 'prefix:key:02'],
            ],
            ['BITCOUNT',
                ['key', 0, 10],
                ['prefix:key', 0, 10],
            ],
            ['HINCRBYFLOAT',
                ['key', 'field', 10.5],
                ['prefix:key', 'field', 10.5],
            ],
            ['EVAL',
                ['return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}', 2, 'foo', 'hoge', 'bar', 'piyo'],
                ['return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}', 2, 'prefix:foo', 'prefix:hoge', 'bar', 'piyo'],
            ],
            ['EVALSHA',
                ['a42059b356c875f0717db19a51f6aaca9ae659ea', 2, 'foo', 'hoge', 'bar', 'piyo'],
                ['a42059b356c875f0717db19a51f6aaca9ae659ea', 2, 'prefix:foo', 'prefix:hoge', 'bar', 'piyo'],
            ],
            ['BITPOS',
                ['key', 0],
                ['prefix:key', 0],
            ],
            ['MIGRATE',
                ['127.0.0.1', '6379', 'key', '0', '10'],
                ['127.0.0.1', '6379', 'prefix:key', '0', '10'],
            ],
            /* ---------------- Redis 2.8 ---------------- */
            ['SSCAN',
                ['key', '0', 'MATCH', 'member:*', 'COUNT', 10],
                ['prefix:key', '0', 'MATCH', 'member:*', 'COUNT', 10],
            ],
            ['ZSCAN',
                ['key', '0', 'MATCH', 'member:*', 'COUNT', 10],
                ['prefix:key', '0', 'MATCH', 'member:*', 'COUNT', 10],
            ],
            ['HSCAN',
                ['key', '0', 'MATCH', 'field:*', 'COUNT', 10],
                ['prefix:key', '0', 'MATCH', 'field:*', 'COUNT', 10],
            ],
            ['PFADD',
                ['key', 'a', 'b', 'c'],
                ['prefix:key', 'a', 'b', 'c'],
            ],
            ['PFCOUNT',
                ['key:1', 'key:2', 'key:3'],
                ['prefix:key:1', 'prefix:key:2', 'prefix:key:3'],
            ],
            ['PFMERGE',
                ['key:1', 'key:2', 'key:3'],
                ['prefix:key:1', 'prefix:key:2', 'prefix:key:3'],
            ],
            ['ZLEXCOUNT',
                ['key', '-', '+'],
                ['prefix:key', '-', '+'],
            ],
            ['ZRANGEBYLEX',
                ['key', '-', '+', 'LIMIT', '0', '10'],
                ['prefix:key', '-', '+', 'LIMIT', '0', '10'],
            ],
            ['ZREMRANGEBYLEX',
                ['key', '-', '+'],
                ['prefix:key', '-', '+'],
            ],
            ['ZREVRANGEBYLEX',
                ['key', '+', '-', 'LIMIT', '0', '10'],
                ['prefix:key', '+', '-', 'LIMIT', '0', '10'],
            ],
            /* ---------------- Redis 3.0 ---------------- */
            ['MIGRATE',
                ['127.0.0.1', '6379', 'key', '0', '10', 'COPY', 'REPLACE'],
                ['127.0.0.1', '6379', 'prefix:key', '0', '10', 'COPY', 'REPLACE'],
            ],
            ['EXISTS',
                ['key1', 'key2', 'key3'],
                ['prefix:key1', 'prefix:key2', 'prefix:key3'],
            ],
            /* ---------------- Redis 3.2 ---------------- */
            ['HSTRLEN',
                ['key', 'field'],
                ['prefix:key', 'field'],
            ],
            ['BITFIELD',
                ['key', 'GET', 'u8', '0', 'SET', 'u8', '0', '1'],
                ['prefix:key', 'GET', 'u8', '0', 'SET', 'u8', '0', '1'],
            ],
            ['GEOADD',
                ['key', '13.361389', '38.115556', 'member:1', '15.087269', '37.502669', 'member:2'],
                ['prefix:key', '13.361389', '38.115556', 'member:1', '15.087269', '37.502669', 'member:2'],
            ],
            ['GEOHASH',
                ['key', 'member:1', 'member:2'],
                ['prefix:key', 'member:1', 'member:2'],
            ],
            ['GEOPOS',
                ['key', 'member:1', 'member:2'],
                ['prefix:key', 'member:1', 'member:2'],
            ],
            ['GEODIST',
                ['key', 'member:1', 'member:2', 'km'],
                ['prefix:key', 'member:1', 'member:2', 'km'],
            ],
            ['GEORADIUS',
                ['key', '15', '37', '200', 'km'],
                ['prefix:key', '15', '37', '200', 'km'],
            ],
            ['GEORADIUS',
                ['key', '15', '37', '200', 'km', 'WITHDIST', 'STORE', 'key:store', 'STOREDIST', 'key:storedist'],
                ['prefix:key', '15', '37', '200', 'km', 'WITHDIST', 'STORE', 'prefix:key:store', 'STOREDIST', 'prefix:key:storedist'],
            ],
            ['GEORADIUSBYMEMBER',
                ['key', 'member', '100', 'km'],
                ['prefix:key', 'member', '100', 'km'],
            ],
            ['GEORADIUSBYMEMBER',
                ['key', 'member', '100', 'km', 'WITHDIST', 'STORE', 'key:store', 'STOREDIST', 'key:storedist'],
                ['prefix:key', 'member', '100', 'km', 'WITHDIST', 'STORE', 'prefix:key:store', 'STOREDIST', 'prefix:key:storedist'],
            ],
            /* ---------------- Redis 5.0 ---------------- */
            ['XADD',
                ['key', '*', ['field' => 'value']],
                ['prefix:key', '*', ['field' => 'value']],
            ],
            ['XRANGE',
                ['key', '-', '+'],
                ['prefix:key', '-', '+'],
            ],
            ['XREVRANGE',
                ['key', '+', '-'],
                ['prefix:key', '+', '-'],
            ],
            ['XDEL',
                ['key', 'id'],
                ['prefix:key', 'id'],
            ],
            ['XLEN',
                ['key'],
                ['prefix:key'],
            ],
            ['XACK',
                ['key', 'group', 'id'],
                ['prefix:key', 'group', 'id'],
            ],
            ['XTRIM',
                ['key', 'MAXLEN', 100],
                ['prefix:key', 'MAXLEN', 100],
            ],
            /* ---------------- Redis 6.2 ---------------- */
            ['GETDEL',
                ['key'],
                ['prefix:key'],
            ],
            ['LMOVE',
                ['key:source', 'key:destination', 'left', 'right'],
                ['prefix:key:source', 'prefix:key:destination', 'left', 'right'],
            ],
            ['BLMOVE',
                ['key:source', 'key:destination', 'left', 'right', 10],
                ['prefix:key:source', 'prefix:key:destination', 'left', 'right', 10],
            ],
            /* ---------------- Redis 7.0 ---------------- */
            ['EXPIRETIME',
                ['key'],
                ['prefix:key'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Processor\ProcessorChainTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Processor;

use Predis\Command\CommandInterface;
use PredisTestCase;
use stdClass;

class ProcessorChainTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testConstructor(): void
    {
        $chain = new ProcessorChain();

        $this->assertInstanceOf('Predis\Command\Processor\ProcessorInterface', $chain);
        $this->assertEmpty($chain->getProcessors());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithProcessorsArray(): void
    {
        $processors = [
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
        ];

        $chain = new ProcessorChain($processors);

        $this->assertSame($processors, $chain->getProcessors());
    }

    /**
     * @group disconnected
     */
    public function testCountProcessors(): void
    {
        $processors = [
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
        ];

        $chain = new ProcessorChain($processors);

        $this->assertEquals(2, $chain->count());
    }

    /**
     * @group disconnected
     */
    public function testAddProcessors(): void
    {
        /** @var ProcessorInterface[] */
        $processors = [
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
        ];

        $chain = new ProcessorChain();
        $chain->add($processors[0]);
        $chain->add($processors[1]);

        $this->assertSame($processors, $chain->getProcessors());
    }

    /**
     * @group disconnected
     */
    public function testAddMoreProcessors(): void
    {
        /** @var ProcessorInterface */
        $processors1 = [
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
        ];

        /** @var ProcessorInterface */
        $processors2 = [
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
        ];

        $chain = new ProcessorChain($processors1);
        $chain->add($processors2[0]);
        $chain->add($processors2[1]);

        $this->assertSame(array_merge($processors1, $processors2), $chain->getProcessors());
    }

    /**
     * @group disconnected
     */
    public function testRemoveProcessors(): void
    {
        /** @var ProcessorInterface */
        $processors = [
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
        ];

        $chain = new ProcessorChain($processors);

        $chain->remove($processors[0]);
        $this->assertSame([$processors[1]], $chain->getProcessors());

        $chain->remove($processors[1]);
        $this->assertEmpty($chain->getProcessors());
    }

    /**
     * @group disconnected
     */
    public function testRemoveProcessorNotInChain(): void
    {
        /** @var ProcessorInterface */
        $processor = $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock();

        $processors = [
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
        ];

        $chain = new ProcessorChain($processors);
        $chain->remove($processor);

        $this->assertSame($processors, $chain->getProcessors());
    }

    /**
     * @group disconnected
     */
    public function testRemoveProcessorFromEmptyChain(): void
    {
        /** @var ProcessorInterface */
        $processor = $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock();

        $chain = new ProcessorChain();
        $this->assertEmpty($chain->getProcessors());

        $chain->remove($processor);
        $this->assertEmpty($chain->getProcessors());
    }

    /**
     * @group disconnected
     */
    public function testOffsetGet(): void
    {
        $processors = [
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
        ];

        $chain = new ProcessorChain($processors);

        $this->assertSame($processors[0], $chain[0]);
        $this->assertSame($processors[1], $chain[1]);
    }

    /**
     * @group disconnected
     */
    public function testOffsetIsset(): void
    {
        $processors = [
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
        ];

        $chain = new ProcessorChain($processors);

        $this->assertTrue(isset($chain[0]));
        $this->assertTrue(isset($chain[1]));
        $this->assertFalse(isset($chain[2]));
    }

    /**
     * @group disconnected
     */
    public function testOffsetSet(): void
    {
        $processor = $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock();

        $chain = new ProcessorChain();
        $chain[0] = $processor;

        $this->assertSame($processor, $chain[0]);
    }

    /**
     * @group disconnected
     */
    public function testOffsetSetWithInvalidType(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Processor chain accepts only instances of `Predis\Command\Processor\ProcessorInterface`');

        $chain = new ProcessorChain();
        $chain[0] = new stdClass();
    }

    /**
     * @group disconnected
     */
    public function testGetIterator(): void
    {
        $processors = [
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
            $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock(),
        ];

        $chain = new ProcessorChain($processors);

        $this->assertSame($processors, iterator_to_array($chain->getIterator()));
    }

    /**
     * @group disconnected
     */
    public function testProcessChain(): void
    {
        /** @var CommandInterface */
        $command = $this->getMockBuilder('Predis\Command\CommandInterface')->getMock();

        $processor1 = $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock();
        $processor1
            ->expects($this->once())
            ->method('process')
            ->with($command);

        $processor2 = $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock();
        $processor2
            ->expects($this->once())
            ->method('process')
            ->with($command);

        $processors = [$processor1, $processor2];

        $chain = new ProcessorChain($processors);
        $chain->process($command);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ACL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

class ACL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return ACL::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'ACL';
    }

    /**
     * @group disconnected
     */
    public function testSetUserFilterArguments(): void
    {
        $arguments = ['SETUSER', 'username', 'rule1', 'rule2'];
        $expected = ['SETUSER', 'username', 'rule1', 'rule2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testDryRunFilterArguments(): void
    {
        $arguments = ['DRYRUN', 'username', 'command', 'arg1', 'arg2'];
        $expected = ['DRYRUN', 'username', 'command', 'arg1', 'arg2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testGetUserFilterArguments(): void
    {
        $arguments = ['GETUSER', 'username'];
        $expected = ['GETUSER', 'username'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.0.0
     */
    public function testSetUserCreatesACLUser(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->acl->setUser('Test'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testDryRunSimulateExecutionOfGivenCommandByUser(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->acl->setUser('Test', '+SET', '~*'));
        $this->assertEquals(
            'OK',
            $redis->acl->dryRun('Test', 'SET', 'foo', 'bar')
        );
        $this->assertEquals(
            "User Test has no permissions to run the 'get' command",
            $redis->acl->dryRun('Test', 'GET', 'foo')
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.0.0
     */
    public function testGetUserReturnsUserDefinedRules(): void
    {
        $redis = $this->getClient();

        $this->assertEquals(
            'OK',
            $redis->acl->setUser(
                'alan',
                'allkeys',
                '+@string',
                '+@set',
                '-SADD',
                '>alanpassword'
            )
        );

        foreach (['flags', 'passwords', 'commands', 'keys', 'channels'] as $key) {
            $this->assertContains($key, $redis->acl->getUser('alan'));
        }
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.0.0
     */
    public function testSetUserThrowsExceptionOnIncorrectRuleProvided(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage("ERR Error in ACL SETUSER modifier 'foobar'");

        $redis->acl->setUser('Test', 'foobar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\APPEND_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class APPEND_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\APPEND';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'APPEND';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'value'];
        $expected = ['key', 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(10, $this->getCommand()->parseResponse(10));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCreatesNewKeyOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertSame(3, $redis->append('foo', 'bar'));
        $this->assertSame('bar', $redis->get('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsTheLenghtOfTheStringAfterAppend(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $this->assertSame(5, $redis->append('foo', '__'));
        $this->assertSame(8, $redis->append('foo', 'bar'));
        $this->assertSame('bar__bar', $redis->get('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->append('metavars', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\AUTH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-connection
 */
class AUTH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\AUTH';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'AUTH';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['password'];
        $expected = ['password'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = null;
        $expected = null;

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BGREWRITEAOF_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class BGREWRITEAOF_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\BGREWRITEAOF';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'BGREWRITEAOF';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertTrue($this->getCommand()->parseResponse(true));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BGSAVE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class BGSAVE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\BGSAVE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'BGSAVE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertTrue($this->getCommand()->parseResponse(true));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BITCOUNT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class BITCOUNT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\BITCOUNT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'BITCOUNT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, 10, 'bit'];
        $expected = ['key', 0, 10, 'BIT'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = 10;
        $expected = 10;

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testReturnsNumberOfBitsSet(): void
    {
        $redis = $this->getClient();

        $redis->setbit('key', 1, 1);
        $redis->setbit('key', 10, 1);
        $redis->setbit('key', 16, 1);
        $redis->setbit('key', 22, 1);
        $redis->setbit('key', 32, 1);

        $this->assertSame(5, $redis->bitcount('key'), 'Count bits set (without range)');
        $this->assertSame(3, $redis->bitcount('key', 2, 4), 'Count bits set (with range)');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.0.0
     */
    public function testReturnsNumberOfBitsSetWithExplicitBitByteArgument(): void
    {
        $redis = $this->getClient();

        $redis->setbit('key', 1, 1);
        $redis->setbit('key', 10, 1);
        $redis->setbit('key', 16, 1);
        $redis->setbit('key', 22, 1);
        $redis->setbit('key', 32, 1);

        $this->assertSame(2, $redis->bitcount('key', 0, 10, 'bit'), 'Count bits set (without range)');
        $this->assertSame(1, $redis->bitcount('key', 0, 4, 'bit'), 'Count bits set (with range)');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('key', 'list');
        $redis->bitcount('key');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BITFIELD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class BITFIELD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\BITFIELD';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'BITFIELD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterMultipleArguments(): void
    {
        $arguments = ['key', 'incrby', 'u2', '100', '1', 'OVERFLOW', 'SAT', 'incrby', 'u2', '102', '1', 'GET', 'u2', '100'];
        $expected = ['key', 'incrby', 'u2', '100', '1', 'OVERFLOW', 'SAT', 'incrby', 'u2', '102', '1', 'GET', 'u2', '100'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = [1];
        $expected = [1];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testParseResponseComplex(): void
    {
        $raw = [1, 0, 3];
        $expected = [1, 0, 3];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testBitfieldWithGetModifier(): void
    {
        $redis = $this->getClient();

        $redis->setbit('string', 0, 1);
        $redis->setbit('string', 8, 1);

        $this->assertSame([128], $redis->bitfield('string', 'GET', 'u8', 0));
        $this->assertSame([128, 1, 128], $redis->bitfield('string', 'GET', 'u8', 0, 'GET', 'u8', 1, 'GET', 'u8', 8));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testBitfieldWithSetModifier(): void
    {
        $redis = $this->getClient();

        $redis->setbit('string', 0, 1);
        $redis->setbit('string', 8, 1);

        $this->assertSame([128], $redis->bitfield('string', 'SET', 'u8', 0, 1));
        $this->assertSame([1, 128], $redis->bitfield('string', 'SET', 'u8', 0, 128, 'SET', 'u8', 8, 1));
        $this->assertSame([1, 128], $redis->bitfield('string', 'SET', 'u8', 8, 128, 'GET', 'u8', 8));

        $this->assertSame("\x80\x80", $redis->get('string'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testBitfieldWithIncrbyModifier(): void
    {
        $redis = $this->getClient();

        $redis->setbit('string', 0, 1);
        $redis->setbit('string', 8, 1);

        $this->assertSame([138], $redis->bitfield('string', 'INCRBY', 'u8', 0, 10));
        $this->assertSame([143, 128], $redis->bitfield('string', 'INCRBY', 'u8', 0, 5, 'INCRBY', 'u8', 0, -15));

        $this->assertSame("\x80\x80", $redis->get('string'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->bitfield('metavars', 'SET', 'u4', '0', '1');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BITOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class BITOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\BITOP';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'BITOP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['AND', 'key:dst', 'key:01', 'key:02'];
        $expected = ['AND', 'key:dst', 'key:01', 'key:02'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsKeysAsSingleArray(): void
    {
        $arguments = ['AND', 'key:dst', ['key:01', 'key:02']];
        $expected = ['AND', 'key:dst', 'key:01', 'key:02'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = 10;
        $expected = 10;

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testCanPerformBitwiseAND(): void
    {
        $redis = $this->getClient();

        $redis->set('key:src:1', "h\x80");
        $redis->set('key:src:2', 'R');

        $this->assertSame(2, $redis->bitop('AND', 'key:dst', 'key:src:1', 'key:src:2'));
        $this->assertSame("@\x00", $redis->get('key:dst'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testCanPerformBitwiseOR(): void
    {
        $redis = $this->getClient();

        $redis->set('key:src:1', "h\x80");
        $redis->set('key:src:2', 'R');

        $this->assertSame(2, $redis->bitop('OR', 'key:dst', 'key:src:1', 'key:src:2'));
        $this->assertSame("z\x80", $redis->get('key:dst'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testCanPerformBitwiseXOR(): void
    {
        $redis = $this->getClient();

        $redis->set('key:src:1', "h\x80");
        $redis->set('key:src:2', 'R');

        $this->assertSame(2, $redis->bitop('XOR', 'key:dst', 'key:src:1', 'key:src:2'));
        $this->assertSame(":\x80", $redis->get('key:dst'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testCanPerformBitwiseNOT(): void
    {
        $redis = $this->getClient();

        $redis->set('key:src:1', "h\x80");

        $this->assertSame(2, $redis->bitop('NOT', 'key:dst', 'key:src:1'));
        $this->assertSame("\x97\x7f", $redis->get('key:dst'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testBitwiseNOTAcceptsOnlyOneSourceKey(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR BITOP NOT must be called with a single source key');

        $this->getClient()->bitop('NOT', 'key:dst', 'key:src:1', 'key:src:2');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnInvalidOperation(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR syntax error');

        $this->getClient()->bitop('NOOP', 'key:dst', 'key:src:1', 'key:src:2');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnInvalidSourceKey(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('key:src:1', 'list');
        $redis->bitop('AND', 'key:dst', 'key:src:1', 'key:src:2');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testDoesNotThrowExceptionOnInvalidDestinationKey(): void
    {
        $redis = $this->getClient();

        $redis->lpush('key:dst', 'list');
        $redis->bitop('AND', 'key:dst', 'key:src:1', 'key:src:2');

        $this->assertEquals('none', $redis->type('key:dst'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BITPOS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class BITPOS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\BITPOS';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'BITPOS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, 1, 10];
        $expected = ['key', 0, 1, 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = 10;
        $expected = 10;
        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.7
     */
    public function testReturnsBitPosition(): void
    {
        $redis = $this->getClient();

        $redis->setbit('key', 10, 0);
        $this->assertSame(0, $redis->bitpos('key', 0), 'Get position of first bit set to 0 - full range');
        $this->assertSame(-1, $redis->bitpos('key', 1), 'Get position of first bit set to 1 - full range');
        $this->assertSame(-1, $redis->bitpos('key', 1, 5, 10), 'Get position of first bit set to 1 - specific range');

        $redis->setbit('key', 5, 1);
        $this->assertSame(0, $redis->bitpos('key', 0), 'Get position of first bit set to 0 - full range');
        $this->assertSame(5, $redis->bitpos('key', 1), 'Get position of first bit set to 1 - full range');
        $this->assertSame(-1, $redis->bitpos('key', 1, 5, 10), 'Get position of first bit set to 1 - specific range');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.0.0
     */
    public function testReturnsBitPositionWithExplicitBitByteArgument(): void
    {
        $redis = $this->getClient();

        $redis->setbit('key', 10, 0);
        $this->assertSame(0, $redis->bitpos('key', 0, 0, 10, 'bit'), 'Get position of first bit set to 0 - full range');
        $this->assertSame(-1, $redis->bitpos('key', 1, 0, 10, 'bit'), 'Get position of first bit set to 1 - full range');
        $this->assertSame(-1, $redis->bitpos('key', 1, 5, 10, 'bit'), 'Get position of first bit set to 1 - specific range');

        $redis->setbit('key', 5, 1);
        $this->assertSame(0, $redis->bitpos('key', 0, 0, 5, 'bit'), 'Get position of first bit set to 0 - full range');
        $this->assertSame(5, $redis->bitpos('key', 1, 0, 5, 'bit'), 'Get position of first bit set to 1 - full range');
        $this->assertSame(5, $redis->bitpos('key', 1, 5, 10, 'bit'), 'Get position of first bit set to 1 - specific range');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.7
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();
        $redis->lpush('key', 'list');
        $redis->bitpos('key', 0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BLMOVE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

class BLMOVE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BLMOVE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BLMOVE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['list', 'argument1', 'argument2', 'argument3'];
        $expected = ['list', 'argument1', 'argument2', 'argument3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider listsProvider
     * @param  array  $firstList
     * @param  array  $secondList
     * @param  string $where
     * @param  string $to
     * @param  string $expectedResponse
     * @param  array  $expectedModifiedFirstList
     * @param  array  $expectedModifiedSecondList
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsCorrectListElement(
        array $firstList,
        array $secondList,
        string $where,
        string $to,
        string $expectedResponse,
        array $expectedModifiedFirstList,
        array $expectedModifiedSecondList
    ): void {
        $redis = $this->getClient();

        $redis->rpush('test-blmove1', $firstList);
        $redis->rpush('test-blmove2', $secondList);

        $actualResponse = $redis->blmove('test-blmove1', 'test-blmove2', $where, $to, 0);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedModifiedFirstList, $redis->lrange('test-blmove1', 0, -1));
        $this->assertSame($expectedModifiedSecondList, $redis->lrange('test-blmove2', 0, -1));
    }

    /**
     * @group connected
     * @dataProvider sameListProvider
     * @param  array  $list
     * @param  string $where
     * @param  string $to
     * @param  string $expectedResponse
     * @param  array  $expectedModifiedList
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsCorrectListElementAndListRotationPerformedOnTheSameListOperation(
        array $list,
        string $where,
        string $to,
        string $expectedResponse,
        array $expectedModifiedList
    ): void {
        $redis = $this->getClient();

        $redis->rpush('test-blmove1', $list);

        $actualResponse = $redis->blmove('test-blmove1', 'test-blmove1', $where, $to, 0);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedModifiedList, $redis->lrange('test-blmove1', 0, -1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->blmove('foo', 'test-lmove', 'LEFT', 'LEFT', 0);
    }

    public function listsProvider(): array
    {
        return [
            'move first element from list into head of another list' => [
                ['element1', 'element2', 'element3'],
                ['element4', 'element5', 'element6'],
                'LEFT',
                'LEFT',
                'element1',
                ['element2', 'element3'],
                ['element1', 'element4', 'element5', 'element6'],
            ],
            'move first element from list into tail of another list' => [
                ['element1', 'element2', 'element3'],
                ['element4', 'element5', 'element6'],
                'LEFT',
                'RIGHT',
                'element1',
                ['element2', 'element3'],
                ['element4', 'element5', 'element6', 'element1'],
            ],
            'move last element from list into head of another list' => [
                ['element1', 'element2', 'element3'],
                ['element4', 'element5', 'element6'],
                'RIGHT',
                'LEFT',
                'element3',
                ['element1', 'element2'],
                ['element3', 'element4', 'element5', 'element6'],
            ],
            'move last element from list into tail of another list' => [
                ['element1', 'element2', 'element3'],
                ['element4', 'element5', 'element6'],
                'RIGHT',
                'RIGHT',
                'element3',
                ['element1', 'element2'],
                ['element4', 'element5', 'element6', 'element3'],
            ],
        ];
    }

    public function sameListProvider(): array
    {
        return [
            'list rotation - head into tail' => [
                ['element1', 'element2', 'element3'],
                'LEFT',
                'RIGHT',
                'element1',
                ['element2', 'element3', 'element1'],
            ],
            'list rotation - tail into head' => [
                ['element1', 'element2', 'element3'],
                'RIGHT',
                'LEFT',
                'element3',
                ['element3', 'element1', 'element2'],
            ],
            'list rotation - head into head' => [
                ['element1', 'element2', 'element3'],
                'LEFT',
                'LEFT',
                'element1',
                ['element1', 'element2', 'element3'],
            ],
            'list rotation - tail into tail' => [
                ['element1', 'element2', 'element3'],
                'RIGHT',
                'RIGHT',
                'element3',
                ['element1', 'element2', 'element3'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BLMPOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class BLMPOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return BLMPOP::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'BLMPOP';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['key', ['elem1', 'elem2']];
        $expected = ['key' => ['elem1', 'elem2']];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @dataProvider listProvider
     * @param  int    $timeout
     * @param  array  $listArguments
     * @param  string $key
     * @param  string $modifier
     * @param  int    $count
     * @param  array  $expectedResponse
     * @param  array  $expectedModifiedList
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testPopElementsFromGivenList(
        int $timeout,
        array $listArguments,
        string $key,
        string $modifier,
        int $count,
        array $expectedResponse,
        array $expectedModifiedList
    ): void {
        $redis = $this->getClient();

        $redis->lpush(...$listArguments);
        $actualResponse = $redis->blmpop($timeout, ['key1', $key], $modifier, $count);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedModifiedList, $redis->lrange($key, 0, -1));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                [1, ['key']],
                [1, 1, 'key', 'LEFT'],
            ],
            'with LEFT/RIGHT argument' => [
                [1, ['key'], 'right'],
                [1, 1, 'key', 'RIGHT'],
            ],
            'with COUNT argument' => [
                [1, ['key'], 'left', 2],
                [1, 1, 'key', 'LEFT', 'COUNT', 2],
            ],
            'with all arguments' => [
                [1, ['key1', 'key2'], 'right', 2],
                [1, 2, 'key1', 'key2', 'RIGHT', 'COUNT', 2],
            ],
        ];
    }

    public function listProvider(): array
    {
        return [
            'pops single element - left' => [
                1,
                ['key', 'elem1', 'elem2', 'elem3'],
                'key',
                'left',
                1,
                ['key' => ['elem3']],
                ['elem2', 'elem1'],
            ],
            'pops single element - right' => [
                1,
                ['key', 'elem1', 'elem2', 'elem3'],
                'key',
                'right',
                1,
                ['key' => ['elem1']],
                ['elem3', 'elem2'],
            ],
            'pops multiple elements' => [
                1,
                ['key', 'elem1', 'elem2', 'elem3'],
                'key',
                'right',
                2,
                ['key' => ['elem1', 'elem2']],
                ['elem3'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BLPOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class BLPOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\BLPOP';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'BLPOP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key1', 'key2', 'key3', 10];
        $expected = ['key1', 'key2', 'key3', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsKeysAsSingleArray(): void
    {
        $arguments = [['key1', 'key2', 'key3'], 10];
        $expected = ['key1', 'key2', 'key3', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['key', 'value'];
        $expected = ['key', 'value'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BRPOPLPUSH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class BRPOPLPUSH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\BRPOPLPUSH';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'BRPOPLPUSH';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key:source', 'key:destination', 10];
        $expected = ['key:source', 'key:destination', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('element', $this->getCommand()->parseResponse('element'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BRPOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class BRPOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\BRPOP';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'BRPOP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key1', 'key2', 'key3', 10];
        $expected = ['key1', 'key2', 'key3', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsKeysAsSingleArray(): void
    {
        $arguments = [['key1', 'key2', 'key3'], 10];
        $expected = ['key1', 'key2', 'key3', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['key', 'value'];
        $expected = ['key', 'value'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BZMPOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;
use UnexpectedValueException;

class BZMPOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BZMPOP::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BZMPOP';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     * @dataProvider responsesProvider
     */
    public function testParseResponse(array $actualResponse, array $expectedResponse): void
    {
        $this->assertSame($expectedResponse, $this->getCommand()->parseResponse($actualResponse));
    }

    /**
     * @group connected
     * @dataProvider sortedSetsProvider
     * @param  int    $timeout
     * @param  array  $sortedSetDictionary
     * @param  string $key
     * @param  string $modifier
     * @param  int    $count
     * @param  array  $expectedResponse
     * @param  array  $expectedModifiedSortedSet
     * @return void
     * @requiresRedisVersion >= 7.0
     */
    public function testReturnsPoppedElementsFromGivenSortedSet(
        int $timeout,
        array $sortedSetDictionary,
        string $key,
        string $modifier,
        int $count,
        array $expectedResponse,
        array $expectedModifiedSortedSet
    ): void {
        $redis = $this->getClient();

        $redis->zadd($key, ...$sortedSetDictionary);
        $actualResponse = $redis->bzmpop($timeout, [$key], $modifier, $count);

        $this->assertEquals($expectedResponse, $actualResponse);
        $this->assertSame($expectedModifiedSortedSet, $redis->zrange($key, 0, -1));
    }

    /**
     * @group connected
     * @dataProvider unexpectedValuesProvider
     * @param  int    $timeout
     * @param  array  $keys
     * @param  string $modifier
     * @param  int    $count
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 7.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(
        int $timeout,
        array $keys,
        string $modifier,
        int $count,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->bzmpop($timeout, $keys, $modifier, $count);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('bzmpop_foo', 'bar');
        $redis->bzmpop(1, ['bzmpop_foo']);
    }

    public function argumentsProvider(): array
    {
        return [
            'with one key' => [
                [10, ['key1'], 'min', 1],
                [10, 1, 'key1', 'MIN', 'COUNT', 1],
            ],
            'with multiple keys' => [
                [10, ['key1', 'key2', 'key3'], 'max', 1],
                [10, 3, 'key1', 'key2', 'key3', 'MAX', 'COUNT', 1],
            ],
        ];
    }

    public function responsesProvider(): array
    {
        return [
            'null-element array' => [
                [null],
                [null],
            ],
            'two-element array' => [
                ['key', [['member1', 1, 'member2', 2, 'member3', 3]]],
                ['key' => ['member1' => 1, 'member2' => 2, 'member3' => 3]],
            ],
        ];
    }

    public function sortedSetsProvider(): array
    {
        return [
            'with MIN modifier' => [
                1,
                [1, 'member1', 2, 'member2', 3, 'member3'],
                'test-bzmpop',
                'min',
                1,
                ['test-bzmpop' => ['member1' => '1']],
                ['member2', 'member3'],
            ],
            'with MAX modifier' => [
                1,
                [1, 'member1', 2, 'member2', 3, 'member3'],
                'test-bzmpop',
                'max',
                1,
                ['test-bzmpop' => ['member3' => '3']],
                ['member1', 'member2'],
            ],
            'with non-default COUNT' => [
                1,
                [1, 'member1', 2, 'member2', 3, 'member3'],
                'test-bzmpop',
                'max',
                2,
                ['test-bzmpop' => ['member3' => '3', 'member2' => '2']],
                ['member1'],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'wrong modifier' => [
                1,
                ['key1', 'key2'],
                'wrong modifier',
                1,
                'Wrong type of modifier given',
            ],
            'wrong count' => [
                1,
                ['key1', 'key2'],
                'min',
                0,
                'Wrong count argument value or position offset',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BZPOPMAX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;
use UnexpectedValueException;

class BZPOPMAX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BZPOPMAX::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BZPOPMAX';
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 5.0.0
     */
    public function testReturnsPoppedMaxElementFromGivenNonEmptySortedSet(): void
    {
        $redis = $this->getClient();
        $sortedSetDictionary = [1, 'member1', 2, 'member2', 3, 'member3'];
        $expectedResponse = ['test-bzpopmax' => ['member3' => '3']];
        $expectedModifiedSortedSet = ['member1', 'member2'];

        $redis->zadd('test-bzpopmax', ...$sortedSetDictionary);

        $this->assertEquals($expectedResponse, $redis->bzpopmax(['empty sorted set', 'test-bzpopmax'], 0));
        $this->assertSame($expectedModifiedSortedSet, $redis->zrange('test-bzpopmax', 0, -1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 5.0.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong keys argument type or position offset');

        $redis->bzpopmax(1, 0);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('bzpopmax_foo', 'bar');
        $redis->bzpopmax(['bzpopmax_foo'], 0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BZPOPMIN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;
use UnexpectedValueException;

class BZPOPMIN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BZPOPMIN::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BZPOPMIN';
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 5.0.0
     */
    public function testReturnsPoppedMinElementFromGivenNonEmptySortedSet(): void
    {
        $redis = $this->getClient();
        $sortedSetDictionary = [1, 'member1', 2, 'member2', 3, 'member3'];
        $expectedResponse = ['test-bzpopmin' => ['member1' => '1']];
        $expectedModifiedSortedSet = ['member2', 'member3'];

        $redis->zadd('test-bzpopmin', ...$sortedSetDictionary);

        $this->assertEquals($expectedResponse, $redis->bzpopmin(['empty sorted set', 'test-bzpopmin'], 0));
        $this->assertSame($expectedModifiedSortedSet, $redis->zrange('test-bzpopmin', 0, -1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 5.0.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong keys argument type or position offset');

        $redis->bzpopmin(1, 0);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('bzpopmin_foo', 'bar');
        $redis->bzpopmin(['bzpopmin_foo'], 0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CLIENT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class CLIENT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\CLIENT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'CLIENT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsOfClientKill(): void
    {
        $arguments = ['kill', '127.0.0.1:45393'];
        $expected = ['kill', '127.0.0.1:45393'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsOfClientList(): void
    {
        $arguments = ['list'];
        $expected = ['list'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsOfClientGetname(): void
    {
        $arguments = $expected = ['getname'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsOfClientSetname(): void
    {
        $arguments = $expected = ['setname', 'connection-a'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponseOfClientKill(): void
    {
        $command = $this->getCommand();
        $command->setArguments(['kill']);

        $this->assertSame(true, $command->parseResponse(true));
    }

    /**
     * @group disconnected
     */
    public function testParseResponseOfClientList(): void
    {
        $command = $this->getCommand();
        $command->setArguments(['list']);

        $raw = <<<BUFFER
addr=127.0.0.1:45393 fd=6 idle=0 flags=N db=0 sub=0 psub=0
addr=127.0.0.1:45394 fd=7 idle=0 flags=N db=0 sub=0 psub=0
addr=127.0.0.1:45395 fd=8 idle=0 flags=N db=0 sub=0 psub=0

BUFFER;

        $parsed = [
            ['addr' => '127.0.0.1:45393', 'fd' => '6', 'idle' => '0', 'flags' => 'N', 'db' => '0', 'sub' => '0', 'psub' => '0'],
            ['addr' => '127.0.0.1:45394', 'fd' => '7', 'idle' => '0', 'flags' => 'N', 'db' => '0', 'sub' => '0', 'psub' => '0'],
            ['addr' => '127.0.0.1:45395', 'fd' => '8', 'idle' => '0', 'flags' => 'N', 'db' => '0', 'sub' => '0', 'psub' => '0'],
        ];

        $this->assertSame($parsed, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.4.0
     */
    public function testReturnsListOfConnectedClients(): void
    {
        $redis = $this->getClient();

        $this->assertIsArray($clients = $redis->client('LIST'));
        $this->assertGreaterThanOrEqual(1, count($clients));
        $this->assertIsArray($clients[0]);
        $this->assertArrayHasKey('addr', $clients[0]);
        $this->assertArrayHasKey('fd', $clients[0]);
        $this->assertArrayHasKey('idle', $clients[0]);
        $this->assertArrayHasKey('flags', $clients[0]);
        $this->assertArrayHasKey('db', $clients[0]);
        $this->assertArrayHasKey('sub', $clients[0]);
        $this->assertArrayHasKey('psub', $clients[0]);
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requiresRedisVersion >= 2.6.9
     */
    public function testGetsNameOfConnection(): void
    {
        $redis = $this->getClient();
        $clientName = $redis->client('GETNAME');
        $this->assertNull($clientName);

        $expectedConnectionName = 'foo-bar';
        $this->assertEquals('OK', $redis->client('SETNAME', $expectedConnectionName));
        $this->assertEquals($expectedConnectionName, $redis->client('GETNAME'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.9
     */
    public function testSetsNameOfConnection(): void
    {
        $redis = $this->getClient();

        $expectedConnectionName = 'foo-baz';
        $this->assertEquals('OK', $redis->client('SETNAME', $expectedConnectionName));
        $this->assertEquals($expectedConnectionName, $redis->client('GETNAME'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.0.0
     */
    public function testSetNoEvictModeForCurrentConnection(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->client('NO-EVICT', 'ON'));
        $this->assertEquals('OK', $redis->client('NO-EVICT', 'OFF'));
    }

    /**
     * @return array
     */
    public function invalidConnectionNameProvider()
    {
        return [
            ['foo space'],
            ['foo \n'],
            ['foo $'],
        ];
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.9
     * @dataProvider invalidConnectionNameProvider
     *
     * @param string $invalidConnectionName
     */
    public function testInvalidSetNameOfConnection($invalidConnectionName)
    {
        $this->expectException('Predis\Response\ServerException');

        $redis = $this->getClient();
        $redis->client('SETNAME', $invalidConnectionName);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.4.0
     */
    public function testThrowsExceptioOnWrongModifier(): void
    {
        $this->expectException('Predis\Response\ServerException');

        $redis = $this->getClient();

        $redis->client('FOO');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.4.0
     */
    public function testThrowsExceptionWhenKillingUnknownClient(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR No such client');

        $redis = $this->getClient();

        $redis->client('KILL', '127.0.0.1:65535');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.3.0
     */
    public function testKillWithMaxAgeOption(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->client('KILL', 'MAXAGE', 100));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CLUSTER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class CLUSTER_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CLUSTER::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CLUSTER';
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsOfAddSlotsRange(): void
    {
        $arguments = ['ADDSLOTSRANGE', 1, 1000];
        $expected = ['ADDSLOTSRANGE', 1, 1000];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsOfDelSlotsRange(): void
    {
        $arguments = ['DELSLOTSRANGE', 1, 1000];
        $expected = ['DELSLOTSRANGE', 1, 1000];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsOfLinks(): void
    {
        $arguments = ['LINKS'];
        $expected = ['LINKS'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsOfShards(): void
    {
        $arguments = ['SHARDS'];
        $expected = ['SHARDS'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group connected
     * @group cluster
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testAddSlotsRangeToGivenNode(): void
    {
        $redis = $this->getClient();

        // Sometimes the cluster can be in a state where slots are
        // missing on some shards (e.g. they are being rebalanced)
        $shards = $redis->cluster->shards();
        $slots = $shards[0][1] ?? $shards[0]['slots'];

        if (empty($slots)) {
            $slots = $shards[1][1] ?? $shards[1]['slots'];
        }

        if (empty($slots)) {
            $slots = $shards[2][1] ?? $shards[2]['slots'];
        }

        [$startSlot, $endSlot] = $slots;

        $this->assertEquals('OK', $redis->cluster->delSlotsRange($startSlot, $endSlot));
        $this->assertEquals('OK', $redis->cluster->addSlotsRange($startSlot, $endSlot));
    }

    /**
     * @group connected
     * @group cluster
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testLinksReturnsClusterPeerLinks(): void
    {
        $redis = $this->getClient();

        $this->assertNotEmpty($redis->cluster->links());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\COMMAND_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\Status;

/**
 * @group commands
 * @group realm-server
 */
class COMMAND_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\COMMAND';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'COMMAND';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['INFO', 'DEL'];
        $expected = ['INFO', 'DEL'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = [
            ['get', 2, [new Status('readonly'), new Status('fast')], 1, 1, 1],
            ['set', -3, [new Status('write'), new Status('denyoom')], 1, 1, 1],
            ['watch', -2, [new Status('readonly'), new Status('noscript'), new Status('fast')], 1, -1, 1],
            ['unwatch', 1, [new Status('readonly'), new Status('noscript'), new Status('fast')], 0, 0, 0],
            ['info', -1, [new Status('readonly'), new Status('loading'), new Status('stale')], 0, 0, 0],
        ];

        $expected = $raw;

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testParseEmptyResponse(): void
    {
        $raw = [null];
        $expected = [null];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.13
     */
    public function testReturnsEmptyCommandInfoOnNonExistingCommand(): void
    {
        $redis = $this->getClient();

        $this->assertCount(1, $response = $redis->command('INFO', 'FOOBAR'));
        $this->assertSame([null], $response);
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @group relay-fixme
     * @requiresRedisVersion >= 2.8.13
     *
     * Relay uses RESP3 maps, the `Predis\Command\Redis\COMMAND` needs a converter.
     */
    public function testReturnsCommandInfoOnExistingCommand(): void
    {
        $redis = $this->getClient();

        $expected = [['get', 2, ['readonly', 'fast'], 1, 1, 1]];

        // NOTE: starting with Redis 6.0 and the introduction of Access Control
        // Lists, COMMAND INFO returns an additional array for each specified
        // command in the request with a list of the ACL categories associated
        // to a command. We simply append this additional array in the expected
        // response if the test suite is executed against Redis >= 6.0.
        if ($this->isRedisServerVersion('>=', '6.0')) {
            $expected[0][] = ['@read', '@string', '@fast'];
        }

        // NOTE: starting with Redis 7.0 COMMAND INFO returns an additional arrays:
        // - Command tips: https://redis.io/topics/command-tips.
        // - Key specifications: https://redis.io/topics/key-specs.
        // - Subcommands: https://redis.io/commands/command/#subcommands.
        // We simply append this additional array in the expected response if the
        // test suite is executed against Redis >= 7.0.
        if ($this->isRedisServerVersion('>=', '7.0')) {
            $expected[0][] = [];
            $expected[0][] = [
                [
                    'flags',
                    ['RO', 'access'],
                    'begin_search',
                    ['type', 'index', 'spec', ['index', 1]],
                    'find_keys',
                    ['type', 'range', 'spec', ['lastkey', 0, 'keystep', 1, 'limit', 0]],
                ],
            ];
            $expected[0][] = [];
        }

        $this->assertCount(1, $response = $redis->command('INFO', 'GET'));

        // NOTE: we use assertEquals instead of assertSame because Redis returns
        // flags as +STATUS responses, represented by Predis with instances of
        // Predis\Response\Status instead of plain strings. This class responds
        // to __toString() so the string conversion is implicit, but assertSame
        // checks for strict equality while assertEquals is loose.
        $this->assertEquals($expected, $response);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.13
     */
    public function testReturnsListOfCommandInfoWithNoArguments(): void
    {
        $redis = $this->getClient();

        $this->assertGreaterThan(100, count($response = $redis->command()));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CONFIG_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class CONFIG_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\CONFIG';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'CONFIG';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['GET', 'slowlog'];
        $expected = ['GET', 'slowlog'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponseOfConfigGet(): void
    {
        $raw = ['slowlog-log-slower-than', '10000', 'slowlog-max-len', '64', 'loglevel', 'verbose'];
        $expected = [
            'slowlog-log-slower-than' => '10000',
            'slowlog-max-len' => '64',
            'loglevel' => 'verbose',
        ];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testParseResponseOfConfigSet(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group disconnected
     */
    public function testParseResponseOfConfigResetstat(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsListOfConfigurationValues(): void
    {
        $redis = $this->getClient();

        $this->assertIsArray($configs = $redis->config('GET', '*'));
        $this->assertGreaterThan(1, count($configs));
        $this->assertArrayHasKey('loglevel', $configs);
        $this->assertArrayHasKey('appendonly', $configs);
        $this->assertArrayHasKey('dbfilename', $configs);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsListOfOneConfigurationEntry(): void
    {
        $redis = $this->getClient();

        $this->assertIsArray($configs = $redis->config('GET', 'dbfilename'));
        $this->assertCount(1, $configs);
        $this->assertArrayHasKey('dbfilename', $configs);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsEmptyListOnUnknownConfigurationEntry(): void
    {
        $redis = $this->getClient();

        $this->assertSame([], $redis->config('GET', 'foobar'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsTrueOnSuccessfulConfiguration(): void
    {
        $redis = $this->getClient();

        $previous = $redis->config('GET', 'loglevel');

        $this->assertEquals('OK', $redis->config('SET', 'loglevel', 'notice'));
        $this->assertSame(['loglevel' => 'notice'], $redis->config('GET', 'loglevel'));

        // We set the loglevel configuration to the previous value.
        $redis->config('SET', 'loglevel', $previous['loglevel']);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionWhenSettingUnknownConfiguration(): void
    {
        $this->expectException('Predis\Response\ServerException');
        if ($this->isRedisServerVersion('<=', '6.0')) {
            $this->expectExceptionMessage('ERR Unsupported CONFIG parameter: foo');
        }

        if ($this->isRedisServerVersion('>=', '7.0')) {
            $this->expectExceptionMessage("ERR Unknown option or number of arguments for CONFIG SET - 'foo'");
        }

        $redis = $this->getClient();

        $redis->config('SET', 'foo', 'bar');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsTrueOnResetstat(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->config('RESETSTAT'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnUnknownSubcommand(): void
    {
        $this->expectException('Predis\Response\ServerException');

        $redis = $this->getClient();

        $redis->config('FOO');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\COPY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class COPY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return COPY::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'COPY';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testSuccessfullyCopyValueOnNonExistingDestinationKey(): void
    {
        $redis = $this->getClient();
        $redis->set('key', 'value');

        $actualResponse = $redis->copy('key', 'destination');

        $this->assertSame(1, $actualResponse);
        $this->assertSame($redis->get('key'), $redis->get('destination'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testSuccessfullyCopyValueFromSourceToAnotherDb(): void
    {
        $defaultDatabaseIndexClient = $this->getClient();
        $defaultDatabaseIndexClient->set('key', 'value');

        $copyResponse = $defaultDatabaseIndexClient->copy('key', 'new_key', 14);

        $anotherDatabaseIndexClient = $this->createClient(['database' => 14], null, false);
        $actualValue = $anotherDatabaseIndexClient->get('new_key');
        $anotherDatabaseIndexClient->flushdb();

        $this->assertNull($anotherDatabaseIndexClient->get('new_key'));
        $this->assertSame(1, $copyResponse);
        $this->assertSame('value', $actualValue);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testDoNotCopyValueOnAlreadyExistingDestinationKey(): void
    {
        $redis = $this->getClient();
        $redis->set('key', 'value');
        $redis->set('destination', 'destination_value');

        $actualResponse = $redis->copy('key', 'destination');

        $this->assertSame(0, $actualResponse);
        $this->assertSame('destination_value', $redis->get('destination'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testSuccessfullyCopyValueWithReplaceArgumentOnAlreadyExistingDestinationKey(): void
    {
        $redis = $this->getClient();
        $redis->set('key', 'value');
        $redis->set('destination', 'destination_value');

        $actualResponse = $redis->copy('key', 'destination', -1, true);

        $this->assertSame(1, $actualResponse);
        $this->assertSame('value', $redis->get('destination'));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['source', 'destination'],
                ['source', 'destination'],
            ],
            'with DB argument' => [
                ['source', 'destination', 1],
                ['source', 'destination', 'DB', 1],
            ],
            'with replace argument' => [
                ['source', 'destination', -1, true],
                ['source', 'destination', 'REPLACE'],
            ],
            'with all arguments' => [
                ['source', 'destination', 1, true],
                ['source', 'destination', 'DB', 1, 'REPLACE'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\DBSIZE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class DBSIZE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\DBSIZE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'DBSIZE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(100, $this->getCommand()->parseResponse(100));
    }

    /**
     * @group connected
     */
    public function testReturnsCurrentSizeOfDatabase(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $this->assertGreaterThan(0, $redis->dbsize());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\DECRBY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class DECRBY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\DECRBY';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'DECRBY';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 5];
        $expected = ['key', 5];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(5, $this->getCommand()->parseResponse(5));
    }

    /**
     * @group connected
     */
    public function testCreatesNewKeyOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertSame(-10, $redis->decrby('foo', 10));
        $this->assertEquals(-10, $redis->get('foo'));
    }

    /**
     * @group connected
     */
    public function testReturnsTheValueOfTheKeyAfterDecrement(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 10);

        $this->assertSame(6, $redis->decrby('foo', 4));
        $this->assertSame(0, $redis->decrby('foo', 6));
        $this->assertSame(-25, $redis->decrby('foo', 25));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnDecrementValueNotInteger(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR value is not an integer or out of range');

        $redis = $this->getClient();

        $redis->decrby('foo', 'bar');
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnKeyValueNotInteger(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR value is not an integer or out of range');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->decrby('foo', 5);
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->decrby('metavars', 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\DECR_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class DECR_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\DECR';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'DECR';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(5, $this->getCommand()->parseResponse(5));
    }

    /**
     * @group connected
     */
    public function testCreatesNewKeyOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertSame(-1, $redis->decr('foo'));
        $this->assertEquals(-1, $redis->get('foo'));
    }

    /**
     * @group connected
     */
    public function testReturnsTheValueOfTheKeyAfterDecrement(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 1);

        $this->assertSame(0, $redis->decr('foo'));
        $this->assertSame(-1, $redis->decr('foo'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnKeyValueNotInteger(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR value is not an integer or out of range');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->decr('foo');
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->decr('metavars');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\DEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class DEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\DEL';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'DEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key1', 'key2', 'key3'];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);
        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['key1', 'key2', 'key3']];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(10, $command->parseResponse(10));
    }

    /**
     * @group connected
     */
    public function testReturnsNumberOfDeletedKeys(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->del('foo'));

        $redis->set('foo', 'bar');
        $this->assertSame(1, $redis->del('foo'));

        $redis->set('foo', 'bar');
        $this->assertSame(1, $redis->del('foo', 'hoge'));

        $redis->set('foo', 'bar');
        $redis->set('hoge', 'piyo');
        $this->assertSame(2, $redis->del('foo', 'hoge'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\DISCARD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-transaction
 */
class DISCARD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\DISCARD';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'DISCARD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requiresRedisVersion >= 2.0.0
     */
    public function testAbortsTransactionAndRestoresNormalFlow(): void
    {
        $redis = $this->getClient();

        $redis->multi();

        $this->assertEquals('QUEUED', $redis->set('foo', 'bar'));
        $this->assertEquals('OK', $redis->discard());
        $this->assertSame(0, $redis->exists('foo'));
    }

    /**
     * @group connected
     * @group ext-relay
     */
    public function testAbortsTransactionAndRestoresNormalFlowUsingRelay(): void
    {
        $redis = $this->getClient();
        $relay = $redis->getConnection()->getClient();

        $redis->multi();

        $this->assertSame($relay, $redis->set('foo', 'bar'));
        $this->assertTrue($redis->discard());
        $this->assertSame(0, $redis->exists('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionWhenCallingOutsideTransaction(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('DISCARD without MULTI');

        $redis = $this->getClient();

        $redis->discard();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\DUMP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class DUMP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\DUMP';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'DUMP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = "\x00\xC0\n\x06\x00\xF8r?\xC5\xFB\xFB_(";
        $expected = "\x00\xC0\n\x06\x00\xF8r?\xC5\xFB\xFB_(";

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ECHO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-connection
 */
class ECHO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ECHO_';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ECHO';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['message'];
        $expected = ['message'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = 'message';
        $expected = 'message';

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testAlwaysReturnsThePassedMessage(): void
    {
        $redis = $this->getClient();

        $message = 'Can you hear me?';

        $this->assertSame($message, $redis->echo($message));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\EVALSHA_RO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-scripting
 */
class EVALSHA_RO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return EVALSHA_RO::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'EVALSHA_RO';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['return test', ['key1', 'key2'], 'arg1', 'arg2'];
        $expected = ['return test', 2, 'key1', 'key2', 'arg1', 'arg2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider scriptsProvider
     * @param  string $script
     * @param  array  $keys
     * @param  array  $arguments
     * @param         $expectedResponse
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testExecutesReadOnlyCachedScripts(
        string $script,
        array $keys,
        array $arguments,
        $expectedResponse
    ): void {
        $redis = $this->getClient();

        $sha1 = $redis->script('LOAD', $script);

        $this->assertSame($expectedResponse, $redis->evalsha_ro($sha1, $keys, ...$arguments));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testThrowsErrorOnWriteScriptExecution(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessageMatches('/^ERR Write commands are not allowed from read-only scripts./');

        $sha1 = $redis->script('LOAD', "return redis.call('SET', KEYS[1], ARGV[1])");

        $redis->evalsha_ro($sha1, ['key'], 'value');
    }

    public function scriptsProvider(): array
    {
        return [
            'with required arguments' => [
                "return 'test'",
                [],
                [],
                'test',
            ],
            'with keys argument' => [
                "return 'test ' .. KEYS[1] .. ' ' .. KEYS[2]",
                ['key1', 'key2'],
                [],
                'test key1 key2',
            ],
            'with arguments provided' => [
                "return 'test ' .. ARGV[1] .. ' ' .. ARGV[2]",
                ['key1', 'key2'],
                ['arg1', 'arg2'],
                'test arg1 arg2',
            ],
            'with both arguments provided' => [
                "return 'test ' .. KEYS[1] .. ' ' .. ARGV[1]",
                ['key1', 'key2'],
                ['arg1', 'arg2'],
                'test key1 arg1',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\EVALSHA_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-scripting
 */
class EVALSHA_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\EVALSHA';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'EVALSHA';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['9d0c0826bde023cc39eebaaf832c32a890f3b088', 1, 'foo', 'bar'];
        $expected = ['9d0c0826bde023cc39eebaaf832c32a890f3b088', 1, 'foo', 'bar'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('bar', $this->getCommand()->parseResponse('bar'));
    }

    /**
     * @group disconnected
     */
    public function testGetScriptHash(): void
    {
        $command = $this->getCommandWithArgumentsArray([$sha1 = sha1('return true')]);
        $this->assertSame($sha1, $command->getScriptHash());
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testExecutesSpecifiedLuaScript(): void
    {
        $redis = $this->getClient();

        $lua = 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}';
        $sha1 = sha1($lua);
        $result = ['foo', 'hoge', 'bar', 'piyo'];

        $this->assertSame($result, $redis->eval($lua, 2, 'foo', 'hoge', 'bar', 'piyo'));
        $this->assertSame($result, $redis->evalsha($sha1, 2, 'foo', 'hoge', 'bar', 'piyo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnWrongNumberOfKeys(): void
    {
        $this->expectException('Predis\Response\ServerException');

        $redis = $this->getClient();

        $lua = 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}';
        $sha1 = sha1($lua);

        $redis->eval($lua, 2, 'foo', 'hoge', 'bar', 'piyo');
        $redis->evalsha($sha1, 3, 'foo', 'hoge');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnInvalidScript(): void
    {
        $this->expectException('Predis\Response\ServerException');

        $redis = $this->getClient();

        $redis->evalsha('ffffffffffffffffffffffffffffffffffffffff', 0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\EVAL_RO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-scripting
 */
class EVAL_RO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return EVAL_RO::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'EVAL_RO';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ["return redis.call('GET', KEYS[1])", ['key1', 'key2'], 'arg1', 'arg2'];
        $expected = ["return redis.call('GET', KEYS[1])", 2, 'key1', 'key2', 'arg1', 'arg2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider scriptsProvider
     * @param  array  $dictionary
     * @param  string $script
     * @param  array  $keys
     * @param  array  $arguments
     * @param         $expectedResponse
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testExecutesReadOnlyCommandsFromGivenLuaScript(
        array $dictionary,
        string $script,
        array $keys,
        array $arguments,
        $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->mset(...$dictionary);

        $this->assertSame($expectedResponse, $redis->eval_ro($script, $keys, ...$arguments));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testThrowsErrorOnWriteCommandProvided(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessageMatches('/^ERR Write commands are not allowed from read-only scripts./');

        $redis->eval_ro("return redis.call('SET', KEYS[1], ARGV[1])", ['key'], 'value');
    }

    public function scriptsProvider(): array
    {
        return [
            'with single key' => [
                ['key', 'value'],
                "return redis.call('GET', KEYS[1])",
                ['key'],
                [],
                'value',
            ],
            'with multiple keys' => [
                ['key', 'value', 'key1', 2],
                "return redis.call('MGET', KEYS[1], KEYS[2])",
                ['key', 'key1'],
                [],
                ['value', '2'],
            ],
            'with arguments provided' => [
                ['key', 'mytest', 'key1', 'ourtest'],
                "return redis.call('LCS', KEYS[1], KEYS[2], ARGV[1])",
                ['key', 'key1'],
                ['LEN'],
                4,
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\EVAL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-scripting
 */
class EVAL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\EVAL_';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'EVAL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['return redis.call("SET", KEYS[1], ARGV[1])', 1, 'foo', 'bar'];
        $expected = ['return redis.call("SET", KEYS[1], ARGV[1])', 1, 'foo', 'bar'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('bar', $this->getCommand()->parseResponse('bar'));
    }

    /**
     * @group disconnected
     */
    public function testGetScriptHash(): void
    {
        $command = $this->getCommandWithArgumentsArray([$lua = 'return true', 0]);
        $this->assertSame(sha1($lua), $command->getScriptHash());
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testExecutesSpecifiedLuaScript(): void
    {
        $redis = $this->getClient();

        $lua = 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}';
        $result = ['foo', 'hoge', 'bar', 'piyo'];

        $this->assertSame($result, $redis->eval($lua, 2, 'foo', 'hoge', 'bar', 'piyo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnWrongNumberOfKeys(): void
    {
        $this->expectException('Predis\Response\ServerException');

        $redis = $this->getClient();
        $lua = 'return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}';

        $redis->eval($lua, 3, 'foo', 'hoge');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnInvalidScript(): void
    {
        $this->expectException('Predis\Response\ServerException');

        $redis = $this->getClient();

        $redis->eval('invalid', 0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\EXEC_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-transaction
 */
class EXEC_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\EXEC';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'EXEC';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['tx1', 'tx2'];
        $expected = ['tx1', 'tx2'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testExecutesTransactionAndReturnsArrayOfResponses(): void
    {
        $redis = $this->getClient();

        $redis->multi();
        $redis->echo('tx1');
        $redis->echo('tx2');

        $this->assertSame(['tx1', 'tx2'], $redis->exec());
    }

    /**
     * @group connected
     */
    public function testReturnsEmptyArrayOnEmptyTransactions(): void
    {
        $redis = $this->getClient();

        $redis->multi();

        $this->assertSame([], $redis->exec());
    }

    /**
     * @group connected
     */
    public function testResponsesOfTransactionsAreNotParsed(): void
    {
        $redis = $this->getClient();

        $redis->multi();
        $redis->ping();
        $redis->set('foo', 'bar');
        $redis->exists('foo');

        $this->assertEquals(['PONG', 'OK', 1], $redis->exec());
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionWhenCallingOutsideTransaction(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('EXEC without MULTI');

        $redis = $this->getClient();

        $redis->exec();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\EXISTS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class EXISTS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\EXISTS';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'EXISTS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsMultipleKeys(): void
    {
        $arguments = ['key:1', 'key:2', 'key:3'];
        $expected = ['key:1', 'key:2', 'key:3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
        $this->assertSame(2, $command->parseResponse(2));
    }

    /**
     * @group connected
     */
    public function testReturnValueWhenKeyExists(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $this->assertSame(1, $redis->exists('foo'));
    }

    /**
     * @group connected
     */
    public function testReturnValueWhenKeyDoesNotExist(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->exists('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.0.3
     */
    public function testReturnValueWhenKeysExist(): void
    {
        $redis = $this->getClient();

        $redis->mset('foo', 'bar', 'hoge', 'piyo');
        $this->assertSame(2, $redis->exists('foo', 'hoge'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.0.3
     */
    public function testReturnValueWhenKeyDoNotExist(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->exists('foo', 'bar'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\EXPIREAT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class EXPIREAT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\EXPIREAT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'EXPIREAT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'ttl'];
        $expected = ['key', 'ttl'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testReturnsZeroOnNonExistingKeys(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->expireat('foo', 2));
    }

    /**
     * @medium
     * @group connected
     * @group slow
     */
    public function testCanExpireKeys(): void
    {
        $redis = $this->getClient();

        $now = time();
        $this->assertEquals('OK', $redis->set('foo', 'bar'));

        $this->assertSame(1, $redis->expireat('foo', $now + 1));
        $this->assertThat($redis->ttl('foo'), $this->logicalAnd(
            $this->greaterThanOrEqual(0), $this->lessThanOrEqual(1)
        ));

        $this->sleep(2.0);
        $this->assertSame(0, $redis->exists('foo'));
    }

    /**
     * @medium
     * @group connected
     * @group slow
     * @dataProvider keysProvider
     * @param  array $firstKeyArguments
     * @param  array $secondKeyArguments
     * @param  array $positivePathArguments
     * @param  array $negativePathArguments
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testSetNewExpirationTimeWithExpireOptions(
        array $firstKeyArguments,
        array $secondKeyArguments,
        array $positivePathArguments,
        array $negativePathArguments
    ): void {
        $redis = $this->getClient();

        $redis->set(...$firstKeyArguments);
        $redis->set(...$secondKeyArguments);

        $this->assertSame(1, $redis->expireat(...$positivePathArguments));
        $this->assertSame(0, $redis->expireat(...$negativePathArguments));
    }

    /**
     * @group connected
     */
    public function testDeletesKeysOnPastUnixTime(): void
    {
        $redis = $this->getClient();

        $now = time();
        $this->assertEquals('OK', $redis->set('foo', 'bar'));

        $this->assertSame(1, $redis->expireat('foo', $now - 100));
        $this->assertSame(0, $redis->exists('foo'));
    }

    public function keysProvider(): array
    {
        return [
            'only if key has no expiry' => [
                ['noExpiry', 'value'],
                ['withExpiry', 'value', 'EX', 10],
                ['noExpiry', time() + 10, 'NX'],
                ['withExpiry', time() + 10, 'NX'],
            ],
            'only if key has expiry' => [
                ['noExpiry', 'value'],
                ['withExpiry', 'value', 'EX', 10],
                ['withExpiry', time() + 10, 'XX'],
                ['noExpiry', time() + 10, 'XX'],
            ],
            'only if new expiry is greater then current one' => [
                ['newExpiryLower', 'value', 'EX', 1000],
                ['newExpiryGreater', 'value', 'EX', 10],
                ['newExpiryGreater', time() + 20, 'GT'],
                ['newExpiryLower', time() + 20, 'GT'],
            ],
            'only if new expiry is lower then current one' => [
                ['newExpiryLower', 'value', 'EX', 1000],
                ['newExpiryGreater', 'value', 'EX', 10],
                ['newExpiryLower', time() + 20, 'LT'],
                ['newExpiryGreater', time() + 20, 'LT'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\EXPIRETIME_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-keys
 */
class EXPIRETIME_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return EXPIRETIME::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'EXPIRETIME';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testReturnsCorrectKeyExpirationTime(): void
    {
        $expirationTime = (int) microtime(true) + 100000;
        $redis = $this->getClient();

        $redis->set('key', 'value');
        $redis->set('key1', 'value');
        $redis->expireat('key', $expirationTime);

        $this->assertSame($expirationTime, $redis->expiretime('key'));
        $this->assertSame(-1, $redis->expiretime('key1'));
        $this->assertSame(-2, $redis->expiretime('non-existing key'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\EXPIRE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class EXPIRE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\EXPIRE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'EXPIRE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'ttl', 'xx'];
        $expected = ['key', 'ttl', 'XX'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testReturnsZeroOnNonExistingKeys(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->expire('foo', 2));
    }

    /**
     * @medium
     * @group connected
     * @group slow
     */
    public function testCanExpireKeys(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar'));

        $this->assertSame(1, $redis->expire('foo', 1));
        $this->assertSame(1, $redis->ttl('foo'));

        $this->sleep(2.0);
        $this->assertSame(0, $redis->exists('foo'));
    }

    /**
     * @medium
     * @group connected
     * @group slow
     * @dataProvider keysProvider
     * @param  array $firstKeyArguments
     * @param  array $secondKeyArguments
     * @param  array $positivePathArguments
     * @param  array $negativePathArguments
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testSetNewExpirationTimeWithExpireOptions(
        array $firstKeyArguments,
        array $secondKeyArguments,
        array $positivePathArguments,
        array $negativePathArguments
    ): void {
        $redis = $this->getClient();

        $redis->set(...$firstKeyArguments);
        $redis->set(...$secondKeyArguments);

        $this->assertSame(1, $redis->expire(...$positivePathArguments));
        $this->assertSame(0, $redis->expire(...$negativePathArguments));
    }

    /**
     * @group connected
     */
    public function testDeletesKeysOnNegativeTTL(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar'));

        $this->assertSame(1, $redis->expire('foo', -10));
        $this->assertSame(0, $redis->exists('foo'));
    }

    public function keysProvider(): array
    {
        return [
            'only if key has no expiry' => [
                ['noExpiry', 'value'],
                ['withExpiry', 'value', 'EX', 10],
                ['noExpiry', 2, 'NX'],
                ['withExpiry', 2, 'NX'],
            ],
            'only if key has expiry' => [
                ['noExpiry', 'value'],
                ['withExpiry', 'value', 'EX', 10],
                ['withExpiry', 2, 'XX'],
                ['noExpiry', 2, 'XX'],
            ],
            'only if new expiry is greater then current one' => [
                ['newExpiryLower', 'value', 'EX', 1000],
                ['newExpiryGreater', 'value', 'EX', 10],
                ['newExpiryGreater', 100, 'GT'],
                ['newExpiryLower', 20, 'GT'],
            ],
            'only if new expiry is lower then current one' => [
                ['newExpiryLower', 'value', 'EX', 1000],
                ['newExpiryGreater', 'value', 'EX', 10],
                ['newExpiryLower', 20, 'LT'],
                ['newExpiryGreater', 20, 'LT'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\FAILOVER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Argument\Server\To;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-server
 */
class FAILOVER_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return FAILOVER::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'FAILOVER';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testPerformFailoverOfConnectedReplica(): void
    {
        $this->markTestSkipped('Test requires configured replica node connected to master');
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $redis = $this->getClient();
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong timeout argument value or position offset');

        $redis->failover(null, false, 0);
    }

    public function argumentsProvider(): array
    {
        return [
            'without optional arguments - no arguments' => [
                [],
                [],
            ],
            'without optional arguments - default arguments' => [
                [null, false, -1],
                [],
            ],
            'with TO argument - no FORCE' => [
                [new To('test', 9999)],
                ['TO', 'test', 9999],
            ],
            'with TO argument - with FORCE' => [
                [new To('test', 9999, true)],
                ['TO', 'test', 9999, 'FORCE'],
            ],
            'with ABORT modifier' => [
                [null, true],
                ['ABORT'],
            ],
            'with TIMEOUT argument' => [
                [null, false, 10],
                ['TIMEOUT', 10],
            ],
            'with all arguments' => [
                [new To('test', 9999, true), true, 10],
                ['TO', 'test', 9999, 'FORCE', 'ABORT', 'TIMEOUT', 10],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\FCALL_RO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use PHPUnit\Util\Test as TestUtil;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-scripting
 */
class FCALL_RO_Test extends PredisCommandTestCase
{
    private const LIB_NAME = 'mylib';

    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return FCALL_RO::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'FCALL_RO';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testInvokeGivenReadOnlyFunction(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('key', 'value'));

        $this->assertSame(
            self::LIB_NAME,
            $redis->function->load(
                "#!lua name=mylib\n redis.register_function{function_name='myfunc',callback=function(keys, args) return redis.call('GET', keys[1]) end,flags={'no-writes'}}"
            )
        );

        $actualResponse = $redis->fcall_ro('myfunc', ['key']);
        $this->assertSame('value', $actualResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testThrowsExceptionOnWriteContextFunction(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('key', 'value'));

        $this->assertSame(
            self::LIB_NAME,
            $redis->function->load(
                "#!lua name=mylib \n redis.register_function('myfunc',function(keys, args) return redis.call('GET', keys[1]) end)"
            )
        );

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR Can not execute a script with write flag using *_ro command.');

        $redis->fcall_ro('myfunc', ['key']);
    }

    protected function tearDown(): void
    {
        $annotations = TestUtil::parseTestMethodAnnotations(
            get_class($this),
            $this->getName(false)
        );

        if (
            isset($annotations['method']['group'])
            && in_array('connected', $annotations['method']['group'], true)
        ) {
            $redis = $this->getClient();
            $redis->function->delete(self::LIB_NAME);
        }
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['function', []],
                ['function', 0],
            ],
            'with provided keys' => [
                ['function', ['key1', 'key2']],
                ['function', 2, 'key1', 'key2'],
            ],
            'with provided keys and arguments' => [
                ['function', ['key1', 'key2'], 'arg1', 'arg2'],
                ['function', 2, 'key1', 'key2', 'arg1', 'arg2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\FCALL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-scripting
 * @requiresRedisVersion >= 7.0.0
 */
class FCALL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return FCALL::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'FCALL';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider functionsProvider
     * @param  string $function
     * @param  array  $functionArguments
     * @param         $expectedResponse
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testInvokeGivenFunction(
        string $function,
        array $functionArguments,
        $expectedResponse
    ): void {
        $redis = $this->getClient();
        $redis->executeRaw(['FUNCTION', 'FLUSH']);

        $this->assertSame('mylib', $redis->function->load($function));

        $actualResponse = $redis->fcall(...$functionArguments);
        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertEquals('OK', $redis->function->delete('mylib'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testThrowsExceptionOnNonExistingFunctionGiven(): void
    {
        $redis = $this->getClient();
        $redis->executeRaw(['FUNCTION', 'FLUSH']);

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR Function not found');

        $redis->fcall('function', []);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['function', []],
                ['function', 0],
            ],
            'with provided keys' => [
                ['function', ['key1', 'key2']],
                ['function', 2, 'key1', 'key2'],
            ],
            'with provided keys and arguments' => [
                ['function', ['key1', 'key2'], 'arg1', 'arg2'],
                ['function', 2, 'key1', 'key2', 'arg1', 'arg2'],
            ],
        ];
    }

    public function functionsProvider(): array
    {
        return [
            'with default arguments' => [
                "#!lua name=mylib \n redis.register_function('myfunc', function(keys, args) return 'hello' end)",
                ['myfunc', []],
                'hello',
            ],
            'with provided keys' => [
                "#!lua name=mylib \n redis.register_function('myfunc', function(keys, args) return keys[1] end)",
                ['myfunc', ['key1']],
                'key1',
            ],
            'with provided keys and arguments' => [
                "#!lua name=mylib \n redis.register_function('myfunc', function(keys, args) return keys[1] .. ' ' .. args[1] end)",
                ['myfunc', ['key1'], 'arg1'],
                'key1 arg1',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\FLUSHALL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class FLUSHALL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\FLUSHALL';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'FLUSHALL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\FLUSHDB_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class FLUSHDB_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\FLUSHDB';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'FLUSHDB';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     */
    public function testFlushesTheEntireLogicalDatabase(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $this->assertEquals('OK', $redis->flushdb());
        $this->assertSame(0, $redis->exists('foo'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\FUNCTIONS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-scripting
 * @requiresRedisVersion >= 7.0.0
 */
class FUNCTIONS_Test extends PredisCommandTestCase
{
    /**
     * @var string
     */
    private $libName = 'mylib';

    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return FUNCTIONS::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'FUNCTION';
    }

    /**
     * @group disconnected
     */
    public function testLoadFilterArguments(): void
    {
        $arguments = ['LOAD', 'function-code', true];
        $expected = ['LOAD', 'function-code', 'REPLACE'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testDeleteFilterArguments(): void
    {
        $arguments = ['DELETE', 'libraryName'];
        $expected = ['DELETE', 'libraryName'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testDumpFilterArguments(): void
    {
        $arguments = ['DUMP'];
        $expected = ['DUMP'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testKillFilterArguments(): void
    {
        $arguments = ['KILL'];
        $expected = ['KILL'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testStatsFilterArguments(): void
    {
        $arguments = ['STATS'];
        $expected = ['STATS'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @dataProvider flushArgumentsProvider
     * @group disconnected
     */
    public function testFlushFilterArguments(array $actualArguments, array $expectedResponse): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedResponse, $command->getArguments());
    }

    /**
     * @dataProvider restoreArgumentsProvider
     * @group disconnected
     */
    public function testRestoreFilterArguments(array $actualArguments, array $expectedResponse): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedResponse, $command->getArguments());
    }

    /**
     * @dataProvider listArgumentsProvider
     * @group disconnected
     */
    public function testListFilterArguments(array $actualArguments, array $expectedResponse): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedResponse, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testLoadFunctionAddFunctionIntoGivenLibrary(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();

        $actualResponse = $redis->function->load(
            "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[1] end)"
        );

        $this->assertSame('mylib', $actualResponse);
        $this->assertSame('arg1', $redis->fcall('myfunc', [], 'arg1'));
        $this->assertEquals('OK', $redis->function->delete($this->libName));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testLoadFunctionOverridesExistingFunctionWithReplaceArgumentGiven(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();

        $actualResponse = $redis->function->load(
            "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[1] end)"
        );

        $this->assertSame($this->libName, $actualResponse);
        $this->assertSame('arg1', $redis->fcall('myfunc', [], 'arg1'));

        $overriddenResponse = $redis->function->load(
            "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[2] end)",
            true
        );

        $this->assertSame($this->libName, $overriddenResponse);
        $this->assertSame('arg2', $redis->fcall('myfunc', [], 'arg1', 'arg2'));
        $this->assertEquals('OK', $redis->function->delete($this->libName));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testLoadFunctionThrowsErrorOnAlreadyExistingLibraryGiven(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();

        $actualResponse = $redis->function->load(
            "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[1] end)"
        );

        $this->assertSame($this->libName, $actualResponse);

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage("ERR Library '{$this->libName}' already exists");

        try {
            $redis->function->load(
                "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[1] end)"
            );
        } finally {
            $this->assertEquals('OK', $redis->function->delete($this->libName));
        }
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testDeleteFunctionRemovesAlreadyExistingLibrary(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();

        $actualResponse = $redis->function->load(
            "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[1] end)"
        );

        $this->assertSame($this->libName, $actualResponse);
        $this->assertEquals('OK', $redis->function->delete($this->libName));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testDumpReturnsSerializedPayloadOfLibrary(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();

        $libName = $redis->function->load(
            "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[1] end)"
        );

        $this->assertSame($this->libName, $libName);
        $this->assertStringContainsString($libName, $redis->function->dump());
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testFlushRemovesAllLibraries(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();

        $libName = $redis->function->load(
            "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[1] end)"
        );

        $this->assertEquals($this->libName, $libName);
        $this->assertEquals('OK', $redis->function->flush());
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testRestoresLibraryFromSerializedPayload(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();

        $libName = $redis->function->load(
            "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[1] end)"
        );
        $this->assertEquals($this->libName, $libName);

        $serializedPayload = $redis->function->dump();
        $this->assertStringContainsString($libName, $serializedPayload);

        $redis->function->flush();

        $this->assertEquals('OK', $redis->function->restore($serializedPayload));
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testListReturnsListOfAvailableFunctions(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();
        $expectedResponse = [
            [
                'library_name', 'mylib', 'engine', 'LUA', 'functions',
                [
                    ['name', 'myfunc', 'description', null, 'flags', []],
                ],
            ],
        ];

        $libName = $redis->function->load(
            "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[1] end)"
        );

        $this->assertEquals($this->libName, $libName);
        $this->assertSame($expectedResponse, $redis->function->list());
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testStatsReturnsInformationAboutRunningScript(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();
        $expectedResponse = ['running_script', null, 'engines', ['LUA', ['libraries_count', 1, 'functions_count', 1]]];

        $libName = $redis->function->load(
            "#!lua name={$this->libName} \n redis.register_function('myfunc', function(keys, args) return args[1] end)"
        );

        $this->assertEquals($this->libName, $libName);
        $this->assertSame($expectedResponse, $redis->function->stats());
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testDeleteFunctionThrowsErrorOnNonExistingLibrary(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR Library not found');

        $redis->function->delete($this->libName);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testKillThrowsExceptionOnNonExistingRunningScript(): void
    {
        $redis = $this->getClient();
        $redis->function->flush();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('NOTBUSY No scripts in execution right now.');

        $redis->function->kill();
    }

    public function flushArgumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['FLUSH', null],
                ['FLUSH'],
            ],
            'with mode argument' => [
                ['FLUSH', 'sync'],
                ['FLUSH', 'SYNC'],
            ],
        ];
    }

    public function restoreArgumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['RESTORE', 'value', null],
                ['RESTORE', 'value'],
            ],
            'with mode argument' => [
                ['RESTORE', 'value', 'append'],
                ['RESTORE', 'value', 'APPEND'],
            ],
        ];
    }

    public function listArgumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['LIST', null, false],
                ['LIST'],
            ],
            'with LIBRARYNAME modifier' => [
                ['LIST', 'libraryname', false],
                ['LIST', 'LIBRARYNAME', 'libraryname'],
            ],
            'with WITHCODE modifier' => [
                ['LIST', null, true],
                ['LIST', 'WITHCODE'],
            ],
            'with all arguments' => [
                ['LIST', 'libraryname', true],
                ['LIST', 'LIBRARYNAME', 'libraryname', 'WITHCODE'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GEOADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-geospatial
 */
class GEOADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\GEOADD';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GEOADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania'];
        $expected = ['Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithMembersAsSingleArray(): void
    {
        $arguments = ['Sicily', [
            ['13.361389', '38.115556', 'Palermo'],
            ['15.087269', '37.502669', 'Catania'],
        ]];

        $expected = ['Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = 1;
        $expected = 1;

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testCommandFillsSortedSet(): void
    {
        $redis = $this->getClient();

        $redis->geoadd('Sicily', '13.361389', '38.115556', 'Palermo');
        $this->assertEquals(['Palermo' => '3479099956230698'], $redis->zrange('Sicily', 0, -1, 'WITHSCORES'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('Sicily', 'Palermo');
        $redis->geoadd('Sicily', '13.361389', '38.115556', 'Palermo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GEODIST_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-geospatial
 */
class GEODIST_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\GEODIST';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GEODIST';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'member:1', 'member:2', 'km'];
        $expected = ['key', 'member:1', 'member:2', 'km'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['103.31822459492736'];
        $expected = ['103.31822459492736'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testCommandReturnsGeoDistance(): void
    {
        $redis = $this->getClient();

        $redis->geoadd('Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania');
        $this->assertSame('166.2742', $redis->geodist('Sicily', 'Palermo', 'Catania', 'km'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('Sicily', 'Palermo');
        $redis->geodist('Sicily', 'Palermo', 'Catania');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GEOHASH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-geospatial
 */
class GEOHASH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\GEOHASH';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GEOHASH';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'member:1', 'member:2'];
        $expected = ['key', 'member:1', 'member:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithMembersAsSingleArray(): void
    {
        $arguments = ['key', ['member:1', 'member:2']];
        $expected = ['key', 'member:1', 'member:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['sqc8b49rny0', 'sqdtr74hyu0'];
        $expected = ['sqc8b49rny0', 'sqdtr74hyu0'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testCommandReturnsGeoHashes(): void
    {
        $redis = $this->getClient();

        $redis->geoadd('Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania');
        $this->assertSame(['sqc8b49rny0', 'sqdtr74hyu0'], $redis->geohash('Sicily', 'Palermo', 'Catania'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('Sicily', 'Palermo');
        $redis->geohash('Sicily', 'Palermo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GEOPOS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-geospatial
 */
class GEOPOS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\GEOPOS';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GEOPOS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'member:1', 'member:2'];
        $expected = ['key', 'member:1', 'member:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithMembersAsSingleArray(): void
    {
        $arguments = ['key', ['member:1', 'member:2']];
        $expected = ['key', 'member:1', 'member:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = [
            ['13.36138933897018433', '38.11555639549629859'],
            ['15.08726745843887329', '37.50266842333162032'],
        ];

        $expected = [
            ['13.36138933897018433', '38.11555639549629859'],
            ['15.08726745843887329', '37.50266842333162032'],
        ];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testCommandReturnsGeoPositions(): void
    {
        $redis = $this->getClient();

        $redis->geoadd('Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania');
        $this->assertEquals([
            ['13.36138933897018433', '38.11555639549629859'],
            ['15.08726745843887329', '37.50266842333162032'],
        ], $redis->geopos('Sicily', 'Palermo', 'Catania'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('Sicily', 'Palermo');
        $redis->geopos('Sicily', 'Palermo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GEORADIUSBYMEMBER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-geospatial
 */
class GEORADIUSBYMEMBER_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\GEORADIUSBYMEMBER';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GEORADIUSBYMEMBER';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = [
            'Sicily', 'Agrigento', 100, 'km',
            'WITHCOORD', 'WITHDIST', 'WITHHASH', 'COUNT', 1, 'ASC', 'STORE', 'key:store', 'STOREDIST', 'key:storedist',
        ];

        $expected = [
            'Sicily', 'Agrigento', 100, 'km',
            'WITHCOORD', 'WITHDIST', 'WITHHASH', 'COUNT', 1, 'ASC', 'STORE', 'key:store', 'STOREDIST', 'key:storedist',
        ];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithComplexOptions(): void
    {
        $arguments = [
            'Sicily', 'Agrigento', 100, 'km', [
                'store' => 'key:store',
                'storedist' => 'key:storedist',
                'withdist' => true,
                'withcoord' => true,
                'withhash' => true,
                'count' => 1,
                'sort' => 'asc',
            ],
        ];

        $expected = [
            'Sicily', 'Agrigento', 100, 'km',
            'WITHCOORD', 'WITHDIST', 'WITHHASH', 'COUNT', 1, 'ASC', 'STORE', 'key:store', 'STOREDIST', 'key:storedist',
        ];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithSpecificOptionsSetToFalse(): void
    {
        $arguments = [
            'Sicily', 'Agrigento', 100, 'km', [
                'store' => 'key:store',
                'storedist' => 'key:storedist',
                'withdist' => false,
                'withcoord' => false,
                'withhash' => false,
                'count' => 1,
                'sort' => 'asc',
            ],
        ];

        $expected = ['Sicily', 'Agrigento', 100, 'km', 'COUNT', 1, 'ASC', 'STORE', 'key:store', 'STOREDIST', 'key:storedist'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponseWithNoOptions(): void
    {
        $raw = [
            ['Agrigento', 'Palermo'],
        ];

        $expected = [
            ['Agrigento', 'Palermo'],
        ];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testCommandReturnsGeoRadiusInfoWithNoOptions(): void
    {
        $redis = $this->getClient();

        $redis->geoadd('Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania', '13.583333', '37.316667', 'Agrigento');
        $this->assertEquals(['Agrigento', 'Palermo'], $redis->georadiusbymember('Sicily', 'Agrigento', 100, 'km'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testCommandReturnsGeoRadiusInfoWithOptions(): void
    {
        $redis = $this->getClient();

        $redis->geoadd('Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania', '13.583333', '37.316667', 'Agrigento');
        $this->assertEquals([
            ['Agrigento', '0.0000', ['13.5833314061164856', '37.31666804993816555']],
            ['Palermo', '90.9778', ['13.36138933897018433', '38.11555639549629859']],
        ], $redis->georadiusbymember('Sicily', 'Agrigento', 100, 'km', 'WITHDIST', 'WITHCOORD'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('Sicily', 'Palermo');
        $redis->georadiusbymember('Sicily', 'Agrigento', 200, 'km');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GEORADIUS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-geospatial
 */
class GEORADIUS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\GEORADIUS';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GEORADIUS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = [
            'Sicily', 15, 37, 200, 'km',
            'WITHCOORD', 'WITHDIST', 'WITHHASH', 'COUNT', 1, 'ASC', 'STORE', 'key:store', 'STOREDIST', 'key:storedist',
        ];

        $expected = [
            'Sicily', 15, 37, 200, 'km',
            'WITHCOORD', 'WITHDIST', 'WITHHASH', 'COUNT', 1, 'ASC', 'STORE', 'key:store', 'STOREDIST', 'key:storedist',
        ];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithComplexOptions(): void
    {
        $arguments = [
            'Sicily', 15, 37, 200, 'km', [
                'store' => 'key:store',
                'storedist' => 'key:storedist',
                'withdist' => true,
                'withcoord' => true,
                'withhash' => true,
                'count' => 1,
                'sort' => 'asc',
            ],
        ];

        $expected = [
            'Sicily', 15, 37, 200, 'km',
            'WITHCOORD', 'WITHDIST', 'WITHHASH', 'COUNT', 1, 'ASC', 'STORE', 'key:store', 'STOREDIST', 'key:storedist',
        ];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithSpecificOptionsSetToFalse(): void
    {
        $arguments = [
            'Sicily', 15, 37, 200, 'km', [
                'store' => 'key:store',
                'storedist' => 'key:storedist',
                'withdist' => false,
                'withcoord' => false,
                'withhash' => false,
                'count' => 1,
                'sort' => 'asc',
            ],
        ];

        $expected = ['Sicily', 15, 37, 200, 'km', 'COUNT', 1, 'ASC', 'STORE', 'key:store', 'STOREDIST', 'key:storedist'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponseWithNoOptions(): void
    {
        $raw = [
            ['Palermo', '190.4424'],
            ['Catania', '56.4413'],
        ];

        $expected = [
            ['Palermo', '190.4424'],
            ['Catania', '56.4413'],
        ];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testCommandReturnsGeoRadiusInfoWithNoOptions(): void
    {
        $redis = $this->getClient();

        $redis->geoadd('Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania');
        $this->assertEquals(['Palermo', 'Catania'], $redis->georadius('Sicily', 15, 37, 200, 'km'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testCommandReturnsGeoRadiusInfoWithOptions(): void
    {
        $redis = $this->getClient();

        $redis->geoadd('Sicily', '13.361389', '38.115556', 'Palermo', '15.087269', '37.502669', 'Catania');
        $this->assertEquals([
            ['Palermo', '190.4424', ['13.36138933897018433', '38.11555639549629859']],
            ['Catania', '56.4413', ['15.08726745843887329', '37.50266842333162032']],
        ], $redis->georadius('Sicily', 15, 37, 200, 'km', 'WITHDIST', 'WITHCOORD'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('Sicily', 'Palermo');
        $redis->georadius('Sicily', 15, 37, 200, 'km');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GEOSEARCHSTORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use InvalidArgumentException;
use Predis\Command\Argument\Geospatial\ByBox;
use Predis\Command\Argument\Geospatial\ByInterface;
use Predis\Command\Argument\Geospatial\ByRadius;
use Predis\Command\Argument\Geospatial\FromInterface;
use Predis\Command\Argument\Geospatial\FromLonLat;
use Predis\Command\Argument\Geospatial\FromMember;
use UnexpectedValueException;

class GEOSEARCHSTORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return GEOSEARCHSTORE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'GEOSEARCHSTORE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider coordinatesProvider
     * @param  array         $firstCoordinates
     * @param  array         $secondCoordinates
     * @param  array         $thirdCoordinates
     * @param  string        $destination
     * @param  string        $source
     * @param  FromInterface $from
     * @param  ByInterface   $by
     * @param  string|null   $sorting
     * @param  int           $count
     * @param  bool          $any
     * @param  int           $expectedResultingElements
     * @param  array         $expectedResponse
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testStoresCorrectGivenGeospatialCoordinates(
        array $firstCoordinates,
        array $secondCoordinates,
        array $thirdCoordinates,
        string $destination,
        string $source,
        FromInterface $from,
        ByInterface $by,
        ?string $sorting,
        int $count,
        bool $any,
        int $expectedResultingElements,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->geoadd(...$firstCoordinates);
        $redis->geoadd(...$secondCoordinates);
        $redis->geoadd(...$thirdCoordinates);

        $actualResultingElements = $redis->geosearchstore(
            $destination,
            $source,
            $from,
            $by,
            $sorting,
            $count,
            $any
        );

        $this->assertSame($expectedResultingElements, $actualResultingElements);
        $this->assertSame($expectedResponse, $redis->geosearch($destination, $from, $by, $sorting, $count, $any));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testStoresInSortedSetWithStoreDistArgumentProvided(): void
    {
        $redis = $this->getClient();

        $redis->geoadd('key', 1.1, 2, 'member1');
        $redis->geoadd('key', 2.1, 3, 'member2');
        $redis->geoadd('key', 3.1, 4, 'member3');

        $actualResultingElements = $redis->geosearchstore(
            'destination',
            'key',
            new FromLonLat(1, 4),
            new ByRadius(9999, 'km'),
            null,
            2,
            false,
            true
        );

        $this->assertSame(2, $actualResultingElements);
        $this->assertSame(['member2', 'member1'], $redis->zrange('destination', 0, -1));
    }

    /**
     * @group connected
     * @dataProvider unexpectedValuesProvider
     * @param  array  $arguments
     * @param  string $expectedException
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnUnexpectedValueProvided(
        array $arguments,
        string $expectedException,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();

        $this->expectException($expectedException);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->geosearchstore(...$arguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments - FROMLONLAT, BYRADIUS' => [
                ['destination', 'source', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km')],
                ['destination', 'source', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km'],
            ],
            'with default arguments - FROMMEMBER, BYBOX' => [
                ['destination', 'source', new FromMember('member'), new ByBox(1, 1, 'km')],
                ['destination', 'source', 'FROMMEMBER', 'member', 'BYBOX', 1, 1, 'km'],
            ],
            'with ASC sorting' => [
                ['destination', 'source', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), 'asc'],
                ['destination', 'source', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'ASC'],
            ],
            'with DESC sorting' => [
                ['destination', 'source', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), 'desc'],
                ['destination', 'source', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'DESC'],
            ],
            'with COUNT argument - without ANY option' => [
                ['destination', 'source', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), null, 20],
                ['destination', 'source', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'COUNT', 20],
            ],
            'with COUNT argument - with ANY option' => [
                ['destination', 'source', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), null, 20, true],
                ['destination', 'source', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'COUNT', 20, 'ANY'],
            ],
            'with STOREDIST argument' => [
                ['destination', 'source', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), null, -1, false, true],
                ['destination', 'source', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'STOREDIST'],
            ],
            'with all arguments' => [
                ['destination', 'source', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), 'asc', 20, true, true],
                ['destination', 'source', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'ASC', 'COUNT', 20, 'ANY', 'STOREDIST'],
            ],
        ];
    }

    public function coordinatesProvider(): array
    {
        return [
            'with default arguments - FROMLONLAT, BYRADIUS - all members' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'destination',
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                null,
                -1,
                false,
                3,
                ['member1', 'member2', 'member3'],
            ],
            'with default arguments - FROMLONLAT, BYRADIUS - closest members' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'destination',
                'key',
                new FromLonLat(1, 3),
                new ByRadius(200, 'km'),
                null,
                -1,
                false,
                2,
                ['member2', 'member1'],
            ],
            'with default arguments - FROMMEMBER, BYBOX - all members' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'destination',
                'key',
                new FromMember('member2'),
                new ByBox(999, 999, 'km'),
                null,
                -1,
                false,
                3,
                ['member1', 'member2', 'member3'],
            ],
            'with default arguments - FROMMEMBER, BYBOX - closest members' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'destination',
                'key',
                new FromMember('member1'),
                new ByBox(300, 300, 'km'),
                null,
                -1,
                false,
                2,
                ['member1', 'member2'],
            ],
            'with ASC modifier' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'destination',
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                'asc',
                -1,
                false,
                3,
                ['member2', 'member1', 'member3'],
            ],
            'with DESC modifier' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'destination',
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                'desc',
                -1,
                false,
                3,
                ['member3', 'member1', 'member2'],
            ],
            'with COUNT modifier - without ANY option' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'destination',
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                null,
                1,
                false,
                1,
                ['member2'],
            ],
            'with COUNT modifier - with ANY option' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'destination',
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                null,
                2,
                true,
                2,
                ['member1', 'member2'],
            ],
            'with all arguments' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'destination',
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                'asc',
                2,
                true,
                2,
                ['member2', 'member1'],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'with wrong FROM argument' => [
                ['destination', 'source', false, new ByRadius(9999, 'km'), null, -1, false, false],
                InvalidArgumentException::class,
                'Invalid FROM argument value given',
            ],
            'with wrong BY argument' => [
                ['destination', 'source', new FromLonLat(1, 4), false, null, -1, false, false],
                InvalidArgumentException::class,
                'Invalid BY argument value given',
            ],
            'with wrong sorting argument' => [
                ['destination', 'source', new FromLonLat(1, 4), new ByRadius(9999, 'km'), 'wrong', -1, false, false],
                UnexpectedValueException::class,
                'Sorting argument accepts only: asc, desc values',
            ],
            'with wrong COUNT argument' => [
                ['destination', 'source', new FromLonLat(1, 4), new ByRadius(9999, 'km'), null, 0, false, false],
                UnexpectedValueException::class,
                'Wrong count argument value or position offset',
            ],
            'with wrong STOREDIST argument' => [
                ['destination', 'source', new FromLonLat(1, 4), new ByRadius(9999, 'km'), null, 0, false, 'wrong'],
                UnexpectedValueException::class,
                'Wrong STOREDIST argument type',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GEOSEARCH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use InvalidArgumentException;
use Predis\Command\Argument\Geospatial\ByBox;
use Predis\Command\Argument\Geospatial\ByInterface;
use Predis\Command\Argument\Geospatial\ByRadius;
use Predis\Command\Argument\Geospatial\FromInterface;
use Predis\Command\Argument\Geospatial\FromLonLat;
use Predis\Command\Argument\Geospatial\FromMember;
use UnexpectedValueException;

class GEOSEARCH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return GEOSEARCH::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'GEOSEARCH';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     * @dataProvider responsesProvider
     */
    public function testParseResponse(array $actualResponse, array $expectedResponse): void
    {
        $this->assertSame($expectedResponse, $this->getCommand()->parseResponse($actualResponse));
    }

    /**
     * @group connected
     * @dataProvider coordinatesProvider
     * @param  array         $firstCoordinates
     * @param  array         $secondCoordinates
     * @param  array         $thirdCoordinates
     * @param  string        $key
     * @param  FromInterface $from
     * @param  ByInterface   $by
     * @param  string|null   $sorting
     * @param  int           $count
     * @param  bool          $any
     * @param  bool          $withCoord
     * @param  bool          $withDist
     * @param  bool          $withHash
     * @param  array         $expectedResponse
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsSearchedGeospatialCoordinates(
        array $firstCoordinates,
        array $secondCoordinates,
        array $thirdCoordinates,
        string $key,
        FromInterface $from,
        ByInterface $by,
        ?string $sorting,
        int $count,
        bool $any,
        bool $withCoord,
        bool $withDist,
        bool $withHash,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->geoadd(...$firstCoordinates);
        $redis->geoadd(...$secondCoordinates);
        $redis->geoadd(...$thirdCoordinates);

        $this->assertSame(
            $expectedResponse,
            $redis->geosearch($key, $from, $by, $sorting, $count, $any, $withCoord, $withDist, $withHash)
        );
    }

    /**
     * @group connected
     * @dataProvider unexpectedValuesProvider
     * @param  array  $arguments
     * @param  string $expectedException
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnUnexpectedValueProvided(
        array $arguments,
        string $expectedException,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();

        $this->expectException($expectedException);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->geosearch(...$arguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments - FROMLONLAT, BYRADIUS' => [
                ['key', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km')],
                ['key', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km'],
            ],
            'with default arguments - FROMMEMBER, BYBOX' => [
                ['key', new FromMember('member'), new ByBox(1, 1, 'km')],
                ['key', 'FROMMEMBER', 'member', 'BYBOX', 1, 1, 'km'],
            ],
            'with ASC sorting' => [
                ['key', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), 'asc'],
                ['key', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'ASC'],
            ],
            'with DESC sorting' => [
                ['key', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), 'desc'],
                ['key', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'DESC'],
            ],
            'with COUNT argument - without ANY option' => [
                ['key', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), null, 20],
                ['key', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'COUNT', 20],
            ],
            'with COUNT argument - with ANY option' => [
                ['key', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), null, 20, true],
                ['key', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'COUNT', 20, 'ANY'],
            ],
            'with WITHCOORD argument' => [
                ['key', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), null, -1, false, true],
                ['key', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'WITHCOORD'],
            ],
            'with WITHDIST argument' => [
                ['key', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), null, -1, false, false, true],
                ['key', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'WITHDIST'],
            ],
            'with WITHHASH argument' => [
                ['key', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), null, -1, false, false, false, true],
                ['key', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'WITHHASH'],
            ],
            'with all arguments' => [
                ['key', new FromLonLat(1.1, 2.2), new ByRadius(1, 'km'), 'asc', 20, true, true, true, true],
                ['key', 'FROMLONLAT', 1.1, 2.2, 'BYRADIUS', 1, 'km', 'ASC', 'COUNT', 20, 'ANY', 'WITHCOORD', 'WITHDIST', 'WITHHASH'],
            ],
        ];
    }

    public function responsesProvider(): array
    {
        return [
            'without WITH modifiers' => [
                ['member1', 'member2', 'member3'],
                ['member1', 'member2', 'member3'],
            ],
            'with WITHCOORD modifier' => [
                [['member1', [1.1, 2.2]], ['member2', [2.2, 3.3]], ['member3', [3.3, 4.4]]],
                [
                    'member1' => ['lng' => 1.1, 'lat' => 2.2],
                    'member2' => ['lng' => 2.2, 'lat' => 3.3],
                    'member3' => ['lng' => 3.3, 'lat' => 4.4]],
            ],
            'with WITHDIST modifier' => [
                [['member1', '111.111'], ['member2', '222.222'], ['member3', '333.333']],
                [
                    'member1' => ['dist' => 111.111],
                    'member2' => ['dist' => 222.222],
                    'member3' => ['dist' => 333.333],
                ],
            ],
            'with WITHHASH modifier' => [
                [['member1', 1111], ['member2', 2222], ['member3', 3333]],
                [
                    'member1' => ['hash' => 1111],
                    'member2' => ['hash' => 2222],
                    'member3' => ['hash' => 3333],
                ],
            ],
            'with all WITH modifiers' => [
                [
                    ['member1', '111.111', 1111, [1.1, 2.2]],
                    ['member2', '222.222', 2222, [2.2, 3.3]],
                    ['member3', '333.333', 3333, [3.3, 4.4]],
                ],
                [
                    'member1' => [
                        'dist' => 111.111,
                        'hash' => 1111,
                        'lng' => 1.1,
                        'lat' => 2.2,
                    ],
                    'member2' => [
                        'dist' => 222.222,
                        'hash' => 2222,
                        'lng' => 2.2,
                        'lat' => 3.3,
                    ],
                    'member3' => [
                        'dist' => 333.333,
                        'hash' => 3333,
                        'lng' => 3.3,
                        'lat' => 4.4,
                    ],
                ],
            ],
        ];
    }

    public function coordinatesProvider(): array
    {
        return [
            'with default arguments - FROMLONLAT, BYRADIUS - all members' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                null,
                -1,
                false,
                false,
                false,
                false,
                ['member1', 'member2', 'member3'],
            ],
            'with default arguments - FROMLONLAT, BYRADIUS - closest members' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromLonLat(1, 3),
                new ByRadius(200, 'km'),
                null,
                -1,
                false,
                false,
                false,
                false,
                ['member2', 'member1'],
            ],
            'with default arguments - FROMMEMBER, BYBOX - all members' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromMember('member2'),
                new ByBox(999, 999, 'km'),
                null,
                -1,
                false,
                false,
                false,
                false,
                ['member1', 'member2', 'member3'],
            ],
            'with default arguments - FROMMEMBER, BYBOX - closest members' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromMember('member1'),
                new ByBox(300, 300, 'km'),
                null,
                -1,
                false,
                false,
                false,
                false,
                ['member1', 'member2'],
            ],
            'with ASC modifier' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                'asc',
                -1,
                false,
                false,
                false,
                false,
                ['member2', 'member1', 'member3'],
            ],
            'with DESC modifier' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                'desc',
                -1,
                false,
                false,
                false,
                false,
                ['member3', 'member1', 'member2'],
            ],
            'with COUNT modifier - without ANY option' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                null,
                1,
                false,
                false,
                false,
                false,
                ['member2'],
            ],
            'with COUNT modifier - with ANY option' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                null,
                2,
                true,
                false,
                false,
                false,
                ['member1', 'member2'],
            ],
            'with WITHCOORD modifier' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                null,
                -1,
                false,
                true,
                false,
                false,
                [
                    'member1' => ['lng' => 1.1, 'lat' => 2.0],
                    'member2' => ['lng' => 2.1, 'lat' => 3.0],
                    'member3' => ['lng' => 3.1, 'lat' => 4.0],
                ],
            ],
            'with WITHDIST modifier' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                null,
                -1,
                false,
                false,
                true,
                false,
                [
                    'member1' => ['dist' => 222.7297],
                    'member2' => ['dist' => 165.1798],
                    'member3' => ['dist' => 233.006],
                ],
            ],
            'with WITHHASH modifier' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                null,
                -1,
                false,
                false,
                false,
                true,
                [
                    'member1' => ['hash' => 3378086406303657],
                    'member2' => ['hash' => 3378965307136228],
                    'member3' => ['hash' => 3379626601756294],
                ],
            ],
            'with all arguments' => [
                ['key', 1.1, 2, 'member1'],
                ['key', 2.1, 3, 'member2'],
                ['key', 3.1, 4, 'member3'],
                'key',
                new FromLonLat(1, 4),
                new ByRadius(9999, 'km'),
                'asc',
                1,
                true,
                true,
                true,
                true,
                [
                    'member1' => [
                        'dist' => 222.7297,
                        'hash' => 3378086406303657,
                        'lng' => 1.1,
                        'lat' => 2.0,
                    ],
                ],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'with wrong FROM argument' => [
                ['key', false, new ByRadius(9999, 'km'), null, -1, false, false],
                InvalidArgumentException::class,
                'Invalid FROM argument value given',
            ],
            'with wrong BY argument' => [
                ['key', new FromLonLat(1, 4), false, null, -1, false, false],
                InvalidArgumentException::class,
                'Invalid BY argument value given',
            ],
            'with wrong sorting argument' => [
                ['key', new FromLonLat(1, 4), new ByRadius(9999, 'km'), 'wrong', -1, false, false],
                UnexpectedValueException::class,
                'Sorting argument accepts only: asc, desc values',
            ],
            'with wrong COUNT argument' => [
                ['key', new FromLonLat(1, 4), new ByRadius(9999, 'km'), null, 0, false, false],
                UnexpectedValueException::class,
                'Wrong count argument value or position offset',
            ],
            'with wrong WITHCOORD argument' => [
                ['key', new FromLonLat(1, 4), new ByRadius(9999, 'km'), null, 0, false, 'wrong'],
                UnexpectedValueException::class,
                'Wrong WITHCOORD argument type',
            ],
            'with wrong WITHDIST argument' => [
                ['key', new FromLonLat(1, 4), new ByRadius(9999, 'km'), null, 0, false, false, 'wrong'],
                UnexpectedValueException::class,
                'Wrong WITHDIST argument type',
            ],
            'with wrong WITHHASH argument' => [
                ['key', new FromLonLat(1, 4), new ByRadius(9999, 'km'), null, 0, false, false, false, 'wrong'],
                UnexpectedValueException::class,
                'Wrong WITHHASH argument type',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GETBIT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class GETBIT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\GETBIT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GETBIT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 100];
        $expected = ['key', 100];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();
        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testCanGetBitsFromString(): void
    {
        $redis = $this->getClient();

        $redis->set('key:binary', "\x80\x00\00\x01");

        $this->assertSame(1, $redis->getbit('key:binary', 0));
        $this->assertSame(0, $redis->getbit('key:binary', 15));
        $this->assertSame(1, $redis->getbit('key:binary', 31));
        $this->assertSame(0, $redis->getbit('key:binary', 63));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnNegativeOffset(): void
    {
        $this->expectExceptionMessage('bit offset is not an integer or out of range');

        $redis = $this->getClient();

        $redis->set('key:binary', "\x80\x00\00\x01");
        $redis->getbit('key:binary', -1);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnInvalidOffset(): void
    {
        $this->expectExceptionMessage('bit offset is not an integer or out of range');

        $redis = $this->getClient();

        $redis->set('key:binary', "\x80\x00\00\x01");
        $redis->getbit('key:binary', 'invalid');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->getbit('metavars', '1');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GETDEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class GETDEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return GETDEL::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'GETDEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsValueForGivenKeyAndDeleteIt(): void
    {
        $redis = $this->getClient();
        $expectedKey = 'key';
        $expectedValue = 'value';

        $redis->set($expectedKey, $expectedValue);

        $actualResponse = $redis->getdel($expectedKey);

        $this->assertSame($expectedValue, $actualResponse);
        $this->assertNull($redis->get($expectedKey));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GETEX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use UnexpectedValueException;

/**
 * @group commands
 * @group realm-string
 */
class GETEX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return GETEX::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GETEX';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider keysProvider
     * @param  array  $kvPair
     * @param  array  $arguments
     * @param  string $expectedResponse
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsValueAndSetExpirationTimeForGivenKey(
        array $kvPair,
        array $arguments,
        string $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->set(...$kvPair);

        $this->assertSame($expectedResponse, $redis->getex(...$arguments));
    }

    /**
     * @group connected
     * @dataProvider unexpectedValuesProvider
     * @param  array  $arguments
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(
        array $arguments,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->getex(...$arguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key'],
                ['key'],
            ],
            'with EX modifier' => [
                ['key', 'ex', 1],
                ['key', 'EX', 1],
            ],
            'with PX modifier' => [
                ['key', 'px', 1],
                ['key', 'PX', 1],
            ],
            'with EXAT modifier' => [
                ['key', 'exat', 1],
                ['key', 'EXAT', 1],
            ],
            'with PXAT modifier' => [
                ['key', 'pxat', 1],
                ['key', 'PXAT', 1],
            ],
            'with PERSIST modifier' => [
                ['key', 'persist'],
                ['key', 'PERSIST'],
            ],
        ];
    }

    public function keysProvider(): array
    {
        return [
            'without expiration time' => [
                ['key', 'value'],
                ['key', '', false],
                'value',
            ],
            'with expiration - EX modifier' => [
                ['key', 'value'],
                ['key', 'ex', 10],
                'value',
            ],
            'with expiration - PX modifier' => [
                ['key', 'value'],
                ['key', 'px', 10],
                'value',
            ],
            'with expiration - EXAT modifier' => [
                ['key', 'value'],
                ['key', 'exat', 10],
                'value',
            ],
            'with expiration - PXAT modifier' => [
                ['key', 'value'],
                ['key', 'pxat', 10],
                'value',
            ],
            'with expiration - PERSIST modifier' => [
                ['key', 'value'],
                ['key', 'persist'],
                'value',
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'with wrong modifier' => [
                ['key', 'wrong', 1],
                'Modifier argument accepts only: ex, px, exat, pxat, persist values',
            ],
            'without value provided' => [
                ['key', 'ex'],
                'You should provide value for current modifier',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GETRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class GETRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\GETRANGE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GETRANGE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 5, 10];
        $expected = ['key', 5, 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('substring', $this->getCommand()->parseResponse('substring'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.4.0
     */
    public function testReturnsSubstring(): void
    {
        $redis = $this->getClient();

        $redis->set('string', 'this is a string');

        $this->assertSame('this', $redis->getrange('string', 0, 3));
        $this->assertSame('ing', $redis->getrange('string', -3, -1));
        $this->assertSame('this is a string', $redis->getrange('string', 0, -1));
        $this->assertSame('string', $redis->getrange('string', 10, 100));

        $this->assertSame('t', $redis->getrange('string', 0, 0));
        $this->assertSame('', $redis->getrange('string', -1, 0));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.4.0
     */
    public function testReturnsEmptyStringOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertSame('', $redis->getrange('string', 0, 3));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.4.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->getrange('metavars', 0, 5);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GETSET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class GETSET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\GETSET';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GETSET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'value'];
        $expected = ['key', 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('value', $this->getCommand()->parseResponse('value'));
    }

    /**
     * @group connected
     */
    public function testReturnsPreviousValueOfKey(): void
    {
        $redis = $this->getClient();

        $this->assertNull($redis->getset('foo', 'bar'));
        $this->assertSame('bar', $redis->getset('foo', 'barbar'));

        $redis->set('hoge', 'piyo');
        $this->assertSame('piyo', $redis->getset('hoge', 'piyopiyo'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->getset('metavars', 'foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\GET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class GET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\GET';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'GET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['foo'];
        $expected = ['foo'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('bar', $this->getCommand()->parseResponse('bar'));
    }

    /**
     * @group connected
     */
    public function testReturnsStringValue(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar'));
        $this->assertEquals('bar', $redis->get('foo'));
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testReturnsStringValueUsingCluster(): void
    {
        $this->testReturnsStringValue();
    }

    /**
     * @group connected
     */
    public function testReturnsEmptyStringOnEmptyStrings(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', '');

        $this->assertSame(1, $redis->exists('foo'));
        $this->assertSame('', $redis->get('foo'));
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testReturnsEmptyStringOnEmptyStringsUsingCluster(): void
    {
        $this->testReturnsEmptyStringOnEmptyStrings();
    }

    /**
     * @group connected
     */
    public function testReturnsNullOnNonExistingKeys(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->exists('foo'));
        $this->assertNull($redis->get('foo'));
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testReturnsNullOnNonExistingKeysUsingCluster(): void
    {
        $this->testReturnsNullOnNonExistingKeys();
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->rpush('metavars', 'foo');
        $redis->get('metavars');
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testThrowsExceptionOnWrongTypeUsingCluster(): void
    {
        $this->testThrowsExceptionOnWrongType();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HDEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HDEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HDEL';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HDEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'field1', 'field2', 'field3'];
        $expected = ['key', 'field1', 'field2', 'field3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsFieldsAsSingleArray(): void
    {
        $arguments = ['key', ['field1', 'field2', 'field3']];
        $expected = ['key', 'field1', 'field2', 'field3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testDeletesSpecifiedFieldsFromHash(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo', 'lol', 'wut');

        $this->assertSame(2, $redis->hdel('metavars', 'foo', 'hoge'));
        $this->assertSame(0, $redis->hdel('metavars', 'foofoo'));
        $this->assertSame(0, $redis->hdel('unknown', 'foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hdel('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HEXISTS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HEXISTS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HEXISTS';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HEXISTS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'field'];
        $expected = ['key', 'field'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsExistenceOfSpecifiedField(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo');

        $this->assertSame(1, $redis->hexists('metavars', 'foo'));
        $this->assertSame(0, $redis->hexists('metavars', 'lol'));
        $this->assertSame(0, $redis->hexists('unknown', 'foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hexists('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HEXPIREAT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use UnexpectedValueException;

class HEXPIREAT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return HEXPIREAT::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'HEXPIREAT';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsThrowsExceptionOnIncorrectFlagValue(): void
    {
        $command = $this->getCommand();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Unsupported flag value');

        $command->setArguments(['key', 1000, null, 'wrong']);
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @dataProvider hashProvider
     * @group connected
     * @group slow
     * @requiresRedisVersion >= 7.3.0
     */
    public function testHashExpiresCorrectlyWithNoFlags(
        array $hashArgs,
        array $expireArgs,
        array $expectedResponse,
        array $expectedHash
    ): void {
        $redis = $this->getClient();

        $redis->hset(...$hashArgs);

        // Time should be calculated within a test, in data provider it will be pre-calculated before test execution.
        $expireArgs[1] = time() + $expireArgs[1];
        $this->assertSame($expectedResponse, $redis->hexpireat(...$expireArgs));
        $this->sleep(2);
        $this->assertSameValues($expectedHash, $redis->hgetall('hashkey'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.3.0
     */
    public function testHashExpiresCorrectlyWithFlags(): void
    {
        $redis = $this->getClient();

        $redis->hset('hashkey', 'field1', 'value1', 'field2', 'value2');

        $this->assertSame([1, 1], $redis->hexpireat('hashkey', time() + 2, ['field1', 'field2']));
        $this->assertSame([0, 0], $redis->hexpireat('hashkey', time() + 2, ['field1', 'field2'], 'NX'));
        $this->assertSame([1, 1], $redis->hexpireat('hashkey', time() + 2, ['field1', 'field2'], 'XX'));
        $this->assertSame([1, 1], $redis->hexpireat('hashkey', time() + 3, ['field1', 'field2'], 'GT'));
        $this->assertSame([0, 0], $redis->hexpireat('hashkey', time() + 1, ['field1', 'field2'], 'GT'));
        $this->assertSame([1, 1], $redis->hexpireat('hashkey', time() + 2, ['field1', 'field2'], 'LT'));
        $this->assertSame([0, 0], $redis->hexpireat('hashkey', time() + 3, ['field1', 'field2'], 'LT'));
        $this->assertSame([-2, -2], $redis->hexpireat('wrongkey', time() + 2, ['field1', 'field2']));
    }

    public function hashProvider(): array
    {
        return [
            'with all fields expired' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 1, ['field1', 'field2']],
                [1, 1],
                [],
            ],
            'with partial fields expired' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 1, ['field1']],
                [1],
                ['field2' => 'value2'],
            ],
            'with incorrect fields' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 1, ['field3', 'field4']],
                [-2, -2],
                ['field2' => 'value2', 'field1' => 'value1'],
            ],
        ];
    }

    public function argumentsProvider(): array
    {
        return [
            'with specified fields' => [
                ['key', 100, ['field1', 'field2']],
                ['key', 100, 'FIELDS', 2, 'field1', 'field2'],
            ],
            'with specified flag' => [
                ['key', 100, null, 'NX'],
                ['key', 100, 'NX'],
            ],
            'with all arguments' => [
                ['key', 100, ['field1', 'field2'], 'XX'],
                ['key', 100, 'XX', 'FIELDS', 2, 'field1', 'field2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HEXPIRETIME_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class HEXPIRETIME_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return HEXPIRETIME::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'HEXPIRETIME';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments(['key', ['field1', 'field2']]);

        $this->assertSame(['key', 'FIELDS', 2, 'field1', 'field2'], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.3.0
     */
    public function testReturnsExpirationTimestamp(): void
    {
        $redis = $this->getClient();

        $redis->hset('hashkey', 'field1', 'value1', 'field2', 'value2');

        $expireAt = time() + 10;
        $this->assertSame([1, 1], $redis->hexpireat('hashkey', $expireAt, ['field1', 'field2']));
        $this->assertSame([$expireAt, $expireAt], $redis->hexpiretime('hashkey', ['field1', 'field2']));
        $this->assertSame([-2], $redis->hexpiretime('wrongkey', ['field1']));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HEXPIRE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use UnexpectedValueException;

class HEXPIRE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return HEXPIRE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'HEXPIRE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsThrowsExceptionOnIncorrectFlagValue(): void
    {
        $command = $this->getCommand();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Unsupported flag value');

        $command->setArguments(['key', 1000, null, 'wrong']);
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @dataProvider hashProvider
     * @group connected
     * @group slow
     * @requiresRedisVersion >= 7.3.0
     */
    public function testHashExpiresCorrectlyWithNoFlags(
        array $hashArgs,
        array $expireArgs,
        array $expectedResponse,
        array $expectedHash
    ): void {
        $redis = $this->getClient();

        $redis->hset(...$hashArgs);

        $this->assertSame($expectedResponse, $redis->hexpire(...$expireArgs));
        $this->sleep(2);
        $this->assertSameValues($expectedHash, $redis->hgetall('hashkey'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.3.0
     */
    public function testHashExpiresCorrectlyWithFlags(): void
    {
        $redis = $this->getClient();

        $redis->hset('hashkey', 'field1', 'value1', 'field2', 'value2');

        $this->assertSame([1, 1], $redis->hexpire('hashkey', 2, ['field1', 'field2']));
        $this->assertSame([0, 0], $redis->hexpire('hashkey', 2, ['field1', 'field2'], 'NX'));
        $this->assertSame([1, 1], $redis->hexpire('hashkey', 2, ['field1', 'field2'], 'XX'));
        $this->assertSame([1, 1], $redis->hexpire('hashkey', 3, ['field1', 'field2'], 'GT'));
        $this->assertSame([0, 0], $redis->hexpire('hashkey', 1, ['field1', 'field2'], 'GT'));
        $this->assertSame([1, 1], $redis->hexpire('hashkey', 2, ['field1', 'field2'], 'LT'));
        $this->assertSame([0, 0], $redis->hexpire('hashkey', 3, ['field1', 'field2'], 'LT'));
        $this->assertSame([-2, -2], $redis->hexpire('wrongkey', 2, ['field1', 'field2']));
    }

    public function hashProvider(): array
    {
        return [
            'with all fields expired' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 1, ['field1', 'field2']],
                [1, 1],
                [],
            ],
            'with partial fields expired' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 1, ['field1']],
                [1],
                ['field2' => 'value2'],
            ],
            'with incorrect fields' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 1, ['field3', 'field4']],
                [-2, -2],
                ['field2' => 'value2', 'field1' => 'value1'],
            ],
        ];
    }

    public function argumentsProvider(): array
    {
        return [
            'with specified fields' => [
                ['key', 100, ['field1', 'field2']],
                ['key', 100, 'FIELDS', 2, 'field1', 'field2'],
            ],
            'with specified flag' => [
                ['key', 100, null, 'NX'],
                ['key', 100, 'NX'],
            ],
            'with all arguments' => [
                ['key', 100, ['field1', 'field2'], 'XX'],
                ['key', 100, 'XX', 'FIELDS', 2, 'field1', 'field2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HGETALL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HGETALL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HGETALL';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HGETALL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['foo', 'bar', 'hoge', 'piyo', 'lol', 'wut'];
        $expected = ['foo' => 'bar', 'hoge' => 'piyo', 'lol' => 'wut'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsAllTheFieldsAndTheirValues(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo', 'lol', 'wut');

        $this->assertSame(['foo' => 'bar', 'hoge' => 'piyo', 'lol' => 'wut'], $redis->hgetall('metavars'));
        $this->assertSame([], $redis->hgetall('unknown'));
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testReturnsAllTheFieldsAndTheirValuesUsingCluster(): void
    {
        $redis = $this->getClient();

        $redis->del('metavars');

        $this->testReturnsAllTheFieldsAndTheirValues();
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessageMatches('/.*Operation against a key holding the wrong kind of value.*/');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hgetall('foo');
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testThrowsExceptionOnWrongTypeUsingCluster(): void
    {
        $this->testThrowsExceptionOnWrongType();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HGET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HGET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HGET';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HGET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'field'];
        $expected = ['key', 'field'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('value', $this->getCommand()->parseResponse('value'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsValueOfSpecifiedField(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo');

        $this->assertSame('bar', $redis->hget('metavars', 'foo'));
        $this->assertNull($redis->hget('metavars', 'lol'));
        $this->assertNull($redis->hget('unknown', 'foo'));
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testReturnsValueOfSpecifiedFieldUsingCluster(): void
    {
        $redis = $this->getClient();

        $redis->del('metavars');

        $this->testReturnsValueOfSpecifiedField();
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessageMatches('/.*Operation against a key holding the wrong kind of value.*/');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hget('foo', 'bar');
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testThrowsExceptionOnWrongTypeUsingCluster(): void
    {
        $this->testThrowsExceptionOnWrongType();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HINCRBYFLOAT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HINCRBYFLOAT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HINCRBYFLOAT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HINCRBYFLOAT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'field', 10.5];
        $expected = ['key', 'field', 10.5];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(10.5, $this->getCommand()->parseResponse(10.5));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testIncrementsValueOfFieldByFloat(): void
    {
        $redis = $this->getClient();

        $this->assertSame('10.5', $redis->hincrbyfloat('metavars', 'foo', 10.5));

        $redis->hincrbyfloat('metavars', 'hoge', 10.001);
        $this->assertSame('11', $redis->hincrbyfloat('metavars', 'hoge', 0.999));

        $this->assertSame(['foo' => '10.5', 'hoge' => '11'], $redis->hgetall('metavars'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testDecrementsValueOfFieldByFloat(): void
    {
        $redis = $this->getClient();

        $this->assertSame('-10.5', $redis->hincrbyfloat('metavars', 'foo', -10.5));

        $redis->hincrbyfloat('metavars', 'hoge', -10.001);
        $this->assertSame('-11', $redis->hincrbyfloat('metavars', 'hoge', -0.999));

        $this->assertSame(['foo' => '-10.5', 'hoge' => '-11'], $redis->hgetall('metavars'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnStringField(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessageMatches('/ERR hash value is not a( valid)? float/');

        $redis = $this->getClient();

        $redis->hset('metavars', 'foo', 'bar');
        $redis->hincrbyfloat('metavars', 'foo', 10.0);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hincrbyfloat('foo', 'bar', 10.5);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HINCRBY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HINCRBY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HINCRBY';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HINCRBY';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'field', 10];
        $expected = ['key', 'field', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(10, $this->getCommand()->parseResponse(10));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testIncrementsValueOfFieldByInteger(): void
    {
        $redis = $this->getClient();

        $this->assertSame(10, $redis->hincrby('metavars', 'foo', 10));
        $this->assertSame(5, $redis->hincrby('metavars', 'hoge', 5));
        $this->assertSame(15, $redis->hincrby('metavars', 'hoge', 10));
        $this->assertSame(['foo' => '10', 'hoge' => '15'], $redis->hgetall('metavars'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testDecrementsValueOfFieldByInteger(): void
    {
        $redis = $this->getClient();

        $this->assertSame(-10, $redis->hincrby('metavars', 'foo', -10));
        $this->assertSame(-5, $redis->hincrby('metavars', 'hoge', -5));
        $this->assertSame(-15, $redis->hincrby('metavars', 'hoge', -10));
        $this->assertSame(['foo' => '-10', 'hoge' => '-15'], $redis->hgetall('metavars'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnStringField(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR hash value is not an integer');

        $redis = $this->getClient();

        $redis->hset('metavars', 'foo', 'bar');
        $redis->hincrby('metavars', 'foo', 10);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hincrby('foo', 'bar', 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HKEYS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HKEYS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HKEYS';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HKEYS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['foo', 'hoge', 'lol'];
        $expected = ['foo', 'hoge', 'lol'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsKeysOfHash(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo', 'lol', 'wut');

        $this->assertSame(['foo', 'hoge', 'lol'], $redis->hkeys('metavars'));
        $this->assertSame([], $redis->hkeys('unknown'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hkeys('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HLEN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HLEN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HLEN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HLEN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsLengthOfHash(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo', 'lol', 'wut');

        $this->assertSame(3, $redis->hlen('metavars'));
        $this->assertSame(0, $redis->hlen('unknown'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hlen('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HMGET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HMGET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HMGET';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HMGET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'field1', 'field2', 'field3'];
        $expected = ['key', 'field1', 'field2', 'field3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsFieldsAsSingleArray(): void
    {
        $arguments = ['key', ['field1', 'field2', 'field3']];
        $expected = ['key', 'field1', 'field2', 'field3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['bar', 'piyo', 'wut'];
        $expected = ['bar', 'piyo', 'wut'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsValuesOfSpecifiedFields(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo', 'lol', 'wut');

        $this->assertSame(['bar', 'piyo', null], $redis->hmget('metavars', 'foo', 'hoge', 'unknown'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsDuplicateValues(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo', 'lol', 'wut');

        $this->assertSame(['bar', 'bar'], $redis->hmget('metavars', 'foo', 'foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsNullValues(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo', 'lol', 'wut');

        $this->assertSame([null, null], $redis->hmget('metavars', 'unknown', 'unknown'));
        $this->assertSame([null, null], $redis->hmget('unknown', 'foo', 'hoge'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hmget('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HMSET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HMSET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HMSET';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HMSET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'field1', 'value1', 'field2', 'value2'];
        $expected = ['key', 'field1', 'value1', 'field2', 'value2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsFieldsValuesAsSingleArray(): void
    {
        $arguments = ['key', ['field1' => 'value1', 'field2' => 'value2']];
        $expected = ['key', 'field1', 'value1', 'field2', 'value2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testSetsSpecifiedFieldsOfHash(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo'));
        $this->assertSame(['foo' => 'bar', 'hoge' => 'piyo'], $redis->hgetall('metavars'));

        $this->assertEquals('OK', $redis->hmset('metavars', 'foo', 'barbar', 'lol', 'wut'));
        $this->assertSame(['foo' => 'barbar', 'hoge' => 'piyo', 'lol' => 'wut'], $redis->hgetall('metavars'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testSetsTheSpecifiedField(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo', 'lol', 'wut');

        $this->assertSame(['foo' => 'bar', 'hoge' => 'piyo', 'lol' => 'wut'], $redis->hgetall('metavars'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'bar');
        $redis->hmset('metavars', 'foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HPERSIST_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class HPERSIST_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return HPERSIST::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'HPERSIST';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments(['key', ['field1', 'field2']]);

        $this->assertSame(['key', 'FIELDS', 2, 'field1', 'field2'], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @group medium
     * @return void
     * @requiresRedisVersion >= 7.3.0
     */
    public function testRemovesExpirationFromGivenField(): void
    {
        $redis = $this->getClient();

        $redis->hset('hashkey', 'field1', 'value1', 'field2', 'value2');

        $this->assertSame([1, 1], $redis->hpexpire('hashkey', 100, ['field1', 'field2']));
        $this->assertSame([1], $redis->hpersist('hashkey', ['field1']));
        $this->sleep(0.2);
        $this->assertSame(['field1' => 'value1'], $redis->hgetall('hashkey'));
        $this->assertSame([-2], $redis->hpersist('wrongkey', ['field1']));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HPEXPIREAT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use UnexpectedValueException;

class HPEXPIREAT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return HPEXPIREAT::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'HPEXPIREAT';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsThrowsExceptionOnIncorrectFlagValue(): void
    {
        $command = $this->getCommand();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Unsupported flag value');

        $command->setArguments(['key', 1000, null, 'wrong']);
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @dataProvider hashProvider
     * @group connected
     * @group slow
     * @requiresRedisVersion >= 7.3.0
     */
    public function testHashExpiresCorrectlyWithNoFlags(
        array $hashArgs,
        array $expireArgs,
        array $expectedResponse,
        array $expectedHash
    ): void {
        $redis = $this->getClient();

        $redis->hset(...$hashArgs);

        // Time should be calculated within a test, in data provider it will be pre-calculated before test execution.
        $expireArgs[1] = (time() + $expireArgs[1]) * 1000;
        $this->assertSame($expectedResponse, $redis->hpexpireat(...$expireArgs));
        $this->sleep(2);
        $this->assertSameValues($expectedHash, $redis->hgetall('hashkey'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.3.0
     */
    public function testHashExpiresCorrectlyWithFlags(): void
    {
        $redis = $this->getClient();

        $redis->hset('hashkey', 'field1', 'value1', 'field2', 'value2');

        $this->assertSame([1, 1], $redis->hpexpireat('hashkey', (time() + 2) * 1000, ['field1', 'field2']));
        $this->assertSame([0, 0], $redis->hpexpireat('hashkey', (time() + 2) * 1000, ['field1', 'field2'], 'NX'));
        $this->assertSame([1, 1], $redis->hpexpireat('hashkey', (time() + 2) * 1000, ['field1', 'field2'], 'XX'));
        $this->assertSame([1, 1], $redis->hpexpireat('hashkey', (time() + 3) * 1000, ['field1', 'field2'], 'GT'));
        $this->assertSame([0, 0], $redis->hpexpireat('hashkey', (time() + 1) * 1000, ['field1', 'field2'], 'GT'));
        $this->assertSame([1, 1], $redis->hpexpireat('hashkey', (time() + 2) * 1000, ['field1', 'field2'], 'LT'));
        $this->assertSame([0, 0], $redis->hpexpireat('hashkey', (time() + 3) * 1000, ['field1', 'field2'], 'LT'));
        $this->assertSame([-2, -2], $redis->hpexpireat('wrongkey', (time() + 2) * 1000, ['field1', 'field2']));
    }

    public function hashProvider(): array
    {
        return [
            'with all fields expired' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 1, ['field1', 'field2']],
                [1, 1],
                [],
            ],
            'with partial fields expired' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 1, ['field1']],
                [1],
                ['field2' => 'value2'],
            ],
            'with incorrect fields' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 1, ['field3', 'field4']],
                [-2, -2],
                ['field2' => 'value2', 'field1' => 'value1'],
            ],
        ];
    }

    public function argumentsProvider(): array
    {
        return [
            'with specified fields' => [
                ['key', 100, ['field1', 'field2']],
                ['key', 100, 'FIELDS', 2, 'field1', 'field2'],
            ],
            'with specified flag' => [
                ['key', 100, null, 'NX'],
                ['key', 100, 'NX'],
            ],
            'with all arguments' => [
                ['key', 100, ['field1', 'field2'], 'XX'],
                ['key', 100, 'XX', 'FIELDS', 2, 'field1', 'field2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HPEXPIRETIME_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class HPEXPIRETIME_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return HPEXPIRETIME::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'HPEXPIRETIME';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments(['key', ['field1', 'field2']]);

        $this->assertSame(['key', 'FIELDS', 2, 'field1', 'field2'], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.3.0
     */
    public function testReturnsExpirationTimestamp(): void
    {
        $redis = $this->getClient();

        $redis->hset('hashkey', 'field1', 'value1', 'field2', 'value2');

        $expireAt = (time() + 10) * 1000;
        $this->assertSame([1, 1], $redis->hpexpireat('hashkey', $expireAt, ['field1', 'field2']));
        $this->assertSame([$expireAt, $expireAt], $redis->hpexpiretime('hashkey', ['field1', 'field2']));
        $this->assertSame([-2], $redis->hexpiretime('wrongkey', ['field1']));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HPEXPIRE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use UnexpectedValueException;

class HPEXPIRE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return HPEXPIRE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'HPEXPIRE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsThrowsExceptionOnIncorrectFlagValue(): void
    {
        $command = $this->getCommand();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Unsupported flag value');

        $command->setArguments(['key', 1000, null, 'wrong']);
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @dataProvider hashProvider
     * @group connected
     * @group medium
     * @requiresRedisVersion >= 7.3.0
     */
    public function testHashExpiresCorrectlyWithNoFlags(
        array $hashArgs,
        array $expireArgs,
        array $expectedResponse,
        array $expectedHash
    ): void {
        $redis = $this->getClient();

        $redis->hset(...$hashArgs);

        $this->assertSame($expectedResponse, $redis->hpexpire(...$expireArgs));
        $this->sleep(0.2);
        $this->assertSameValues($expectedHash, $redis->hgetall('hashkey'));
    }

    /**
     * @group connected
     * @group medium
     * @requiresRedisVersion >= 7.3.0
     */
    public function testHashExpiresCorrectlyWithFlags(): void
    {
        $redis = $this->getClient();

        $redis->hset('hashkey', 'field1', 'value1', 'field2', 'value2');

        $this->assertSame([1, 1], $redis->hpexpire('hashkey', 200, ['field1', 'field2']));
        $this->assertSame([0, 0], $redis->hpexpire('hashkey', 200, ['field1', 'field2'], 'NX'));
        $this->assertSame([1, 1], $redis->hpexpire('hashkey', 200, ['field1', 'field2'], 'XX'));
        $this->assertSame([1, 1], $redis->hpexpire('hashkey', 300, ['field1', 'field2'], 'GT'));
        $this->assertSame([0, 0], $redis->hpexpire('hashkey', 100, ['field1', 'field2'], 'GT'));
        $this->assertSame([1, 1], $redis->hpexpire('hashkey', 200, ['field1', 'field2'], 'LT'));
        $this->assertSame([0, 0], $redis->hpexpire('hashkey', 300, ['field1', 'field2'], 'LT'));
        $this->assertSame([-2, -2], $redis->hpexpire('wrongkey', 200, ['field1', 'field2']));
    }

    public function argumentsProvider(): array
    {
        return [
            'with specified fields' => [
                ['key', 100, ['field1', 'field2']],
                ['key', 100, 'FIELDS', 2, 'field1', 'field2'],
            ],
            'with specified flag' => [
                ['key', 100, null, 'NX'],
                ['key', 100, 'NX'],
            ],
            'with all arguments' => [
                ['key', 100, ['field1', 'field2'], 'XX'],
                ['key', 100, 'XX', 'FIELDS', 2, 'field1', 'field2'],
            ],
        ];
    }

    public function hashProvider(): array
    {
        return [
            'with all fields expired' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 100, ['field1', 'field2']],
                [1, 1],
                [],
            ],
            'with partial fields expired' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 100, ['field1']],
                [1],
                ['field2' => 'value2'],
            ],
            'with incorrect fields' => [
                ['hashkey', 'field1', 'value1', 'field2', 'value2'],
                ['hashkey', 100, ['field3', 'field4']],
                [-2, -2],
                ['field2' => 'value2', 'field1' => 'value1'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HPTTL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class HPTTL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return HPTTL::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'HPTTL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments(['key', ['field1', 'field2']]);

        $this->assertSame(['key', 'FIELDS', 2, 'field1', 'field2'], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.3.0
     */
    public function testReturnsRemainingTTL(): void
    {
        $redis = $this->getClient();

        $redis->hset('hashkey', 'field1', 'value1', 'field2', 'value2');

        $this->assertSame([1, 1], $redis->hexpire('hashkey', 10, ['field1', 'field2']));
        $this->assertEqualsWithDelta([10000, 10000], $redis->hpttl('hashkey', ['field1', 'field2']), 10);
        $this->assertSame([-2], $redis->hpttl('wrongkey', ['field1']));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HRANDFIELD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

class HRANDFIELD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return HRANDFIELD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'HRANDFIELD';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider hashesProvider
     * @param  array  $hash
     * @param  string $key
     * @param  int    $count
     * @param  bool   $withValues
     * @param  array  $expectedResponse
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsRandomFieldsFromHash(
        array $hash,
        string $key,
        int $count,
        bool $withValues,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->hset($key, ...$hash);
        $actualResponse = $redis->hrandfield($key, $count, $withValues);

        $this->assertOneOf($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hrandfield('foo');
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key'],
                ['key'],
            ],
            'with count argument' => [
                ['key', 1],
                ['key', 1],
            ],
            'with WITHVALUES argument' => [
                ['key', 1, true],
                ['key', 1, 'WITHVALUES'],
            ],
        ];
    }

    public function hashesProvider(): array
    {
        return [
            'one field - without values' => [
                ['key1', 'value1', 'key2', 'value2', 'key3', 'value3'],
                'key',
                1,
                false,
                ['key1', 'key2', 'key3'],
            ],
            'one field - with values' => [
                ['key1', 'value1', 'key2', 'value2', 'key3', 'value3'],
                'key',
                1,
                true,
                ['key1', 'value1', 'key2', 'value2', 'key3', 'value3'],
            ],
            'multiple fields - without values' => [
                ['key1', 'value1', 'key2', 'value2', 'key3', 'value3'],
                'key',
                2,
                false,
                ['key1', 'key2', 'key3'],
            ],
            'multiple fields - with values' => [
                ['key1', 'value1', 'key2', 'value2', 'key3', 'value3'],
                'key',
                2,
                true,
                ['key1', 'value1', 'key2', 'value2', 'key3', 'value3'],
            ],
            'multiple fields - allows same fields' => [
                ['key1', 'value1', 'key2', 'value2', 'key3', 'value3'],
                'key',
                -2,
                false,
                ['key1', 'key2', 'key3'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HSCAN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HSCAN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HSCAN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HSCAN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, 'MATCH', 'field:*', 'COUNT', 10];
        $expected = ['key', 0, 'MATCH', 'field:*', 'COUNT', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsBasicUsage(): void
    {
        $arguments = ['key', 0];
        $expected = ['key', 0];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithOptionsArray(): void
    {
        $arguments = ['key', 0, ['match' => 'field:*', 'count' => 10]];
        $expected = ['key', 0, 'MATCH', 'field:*', 'COUNT', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['3', ['field:1', '1', 'field:2', '2', 'field:3', '3']];
        $expected = ['3', ['field:1' => '1', 'field:2' => '2', 'field:3' => '3']];

        $command = $this->getCommand();
        $command->setArguments($raw);

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithoutMatch(): void
    {
        $expectedFields = ['field:one', 'field:two', 'field:three', 'field:four'];
        $expectedValues = ['one', 'two', 'three', 'four'];

        $redis = $this->getClient();
        $redis->hmset('key', array_combine($expectedFields, $expectedValues));

        $response = $redis->hscan('key', 0);

        $this->assertSame('0', $response[0]);
        $this->assertSame($expectedFields, array_keys($response[1]));
        $this->assertSame($expectedValues, array_values($response[1]));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithMatchingMembers(): void
    {
        $redis = $this->getClient();
        $redis->hmset('key', ['field:one' => 'one', 'field:two' => 'two', 'field:three' => 'three', 'field:four' => 'four']);

        $response = $redis->hscan('key', 0, 'MATCH', 'field:t*');

        $this->assertSame(['field:two', 'field:three'], array_keys($response[1]));
        $this->assertSame(['two', 'three'], array_values($response[1]));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.3.0
     */
    public function testScanWithNoValues(): void
    {
        $redis = $this->getClient();
        $redis->hmset('key', ['field:one' => 'one', 'field:two' => 'two', 'field:three' => 'three', 'field:four' => 'four']);

        $response = $redis->hscan('key', 0, ['MATCH' => 'field:t*', 'NOVALUES' => true]);

        $this->assertSame(['field:two', 'field:three'], $response[1]);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithNoMatchingMembers(): void
    {
        $redis = $this->getClient();
        $redis->hmset('key', ['field:one' => 'one', 'field:two' => 'two', 'field:three' => 'three', 'field:four' => 'four']);

        $response = $redis->hscan('key', 0, 'MATCH', 'nofield:*');

        $this->assertSame('0', $response[0]);
        $this->assertEmpty($response[1]);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HSETNX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HSETNX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HSETNX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HSETNX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'field', 'value'];
        $expected = ['key', 'field', 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testSetsNewFieldsAndPreserversExistingOnes(): void
    {
        $redis = $this->getClient();

        $this->assertSame(1, $redis->hsetnx('metavars', 'foo', 'bar'));
        $this->assertSame(1, $redis->hsetnx('metavars', 'hoge', 'piyo'));
        $this->assertSame(0, $redis->hsetnx('metavars', 'foo', 'barbar'));

        $this->assertSame(['bar', 'piyo'], $redis->hmget('metavars', 'foo', 'hoge'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->hsetnx('metavars', 'foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HSET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HSET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HSET';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HSET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'field', 'value'];
        $expected = ['key', 'field', 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testSetsValueOfSpecifiedField(): void
    {
        $redis = $this->getClient();

        $this->assertSame(1, $redis->hset('metavars', 'foo', 'bar'));
        $this->assertSame(1, $redis->hset('metavars', 'hoge', 'piyo'));

        $this->assertSame(['bar', 'piyo'], $redis->hmget('metavars', 'foo', 'hoge'));
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testSetsValueOfSpecifiedFieldUsingCluster(): void
    {
        $redis = $this->getClient();

        $redis->del('metavars');

        $this->testSetsValueOfSpecifiedField();
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessageMatches('/.*Operation against a key holding the wrong kind of value.*/');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->hset('metavars', 'foo', 'bar');
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testThrowsExceptionOnWrongTypeUsingCluster(): void
    {
        $this->testThrowsExceptionOnWrongType();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HSTRLEN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HSTRLEN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HSTRLEN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HSTRLEN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'field'];
        $expected = ['key', 'field'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
        $this->assertSame(10, $command->parseResponse(10));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testReturnsStringLengthOfSpecifiedField(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo');

        // Existing key and field
        $this->assertSame(3, $redis->hstrlen('metavars', 'foo'));
        $this->assertSame(4, $redis->hstrlen('metavars', 'hoge'));

        // Existing key but non existing field
        $this->assertSame(0, $redis->hstrlen('metavars', 'foofoo'));

        // Non existing key
        $this->assertSame(0, $redis->hstrlen('unknown', 'foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->hstrlen('metavars', 'foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HTTL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class HTTL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return HTTL::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'HTTL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments(['key', ['field1', 'field2']]);

        $this->assertSame(['key', 'FIELDS', 2, 'field1', 'field2'], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.3.0
     */
    public function testReturnsRemainingTTL(): void
    {
        $redis = $this->getClient();

        $redis->hset('hashkey', 'field1', 'value1', 'field2', 'value2');

        $this->assertSame([1, 1], $redis->hexpire('hashkey', 10, ['field1', 'field2']));
        $this->assertSame([10, 10], $redis->httl('hashkey', ['field1', 'field2']));
        $this->assertSame([-2], $redis->httl('wrongkey', ['field1']));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\HVALS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hash
 */
class HVALS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\HVALS';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'HVALS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['foo', 'hoge', 'lol'];
        $expected = ['foo', 'hoge', 'lol'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsValuesOfHash(): void
    {
        $redis = $this->getClient();

        $redis->hmset('metavars', 'foo', 'bar', 'hoge', 'piyo', 'lol', 'wut');

        $this->assertSame(['bar', 'piyo', 'wut'], $redis->hvals('metavars'));
        $this->assertSame([], $redis->hvals('unknown'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->hvals('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\INCRBYFLOAT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class INCRBYFLOAT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\INCRBYFLOAT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'INCRBYFLOAT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 5.0];
        $expected = ['key', 5.0];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(5.0, $this->getCommand()->parseResponse(5.0));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testCreatesNewKeyOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertEquals(10.5, $redis->incrbyfloat('foo', 10.5));
        $this->assertEquals(10.5, $redis->get('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testReturnsTheValueOfTheKeyAfterIncrement(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 2);

        // We use round() to avoid errors on some platforms, see the following
        // issue https://github.com/predis/predis/issues/220 for reference.
        $this->assertEquals(22.123, $redis->incrbyfloat('foo', 20.123));
        $this->assertEquals(10, round($redis->incrbyfloat('foo', -12.123), 5));
        $this->assertEquals(-100.01, round($redis->incrbyfloat('foo', -110.01), 5));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnDecrementValueNotFloat(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR value is not a valid float');

        $redis = $this->getClient();

        $redis->incrbyfloat('foo', 'bar');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnKeyValueNotFloat(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR value is not a valid float');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->incrbyfloat('foo', 10.0);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->incrbyfloat('metavars', 10.0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\INCRBY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class INCRBY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\INCRBY';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'INCRBY';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 5];
        $expected = ['key', 5];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(5, $this->getCommand()->parseResponse(5));
    }

    /**
     * @group connected
     */
    public function testCreatesNewKeyOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertSame(10, $redis->incrby('foo', 10));
        $this->assertEquals(10, $redis->get('foo'));
    }

    /**
     * @group connected
     */
    public function testReturnsTheValueOfTheKeyAfterIncrement(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 2);

        $this->assertSame(22, $redis->incrby('foo', 20));
        $this->assertSame(10, $redis->incrby('foo', -12));
        $this->assertSame(-100, $redis->incrby('foo', -110));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnDecrementValueNotInteger(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR value is not an integer or out of range');

        $redis = $this->getClient();

        $redis->incrby('foo', 'bar');
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnKeyValueNotInteger(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR value is not an integer or out of range');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->incrby('foo', 10);
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->incrby('metavars', 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\INCR_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class INCR_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\INCR';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'INCR';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(5, $this->getCommand()->parseResponse(5));
    }

    /**
     * @group connected
     */
    public function testCreatesNewKeyOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertSame(1, $redis->incr('foo'));
        $this->assertEquals(1, $redis->get('foo'));
    }

    /**
     * @group connected
     */
    public function testReturnsTheValueOfTheKeyAfterIncrement(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 2);

        $this->assertSame(3, $redis->incr('foo'));
        $this->assertSame(4, $redis->incr('foo'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->incr('metavars');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\INFO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class INFO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\INFO';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'INFO';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testCanParseNewResponseFormat(): void
    {
        $raw = <<<BUFFER
# Server
redis_version:2.9.0
redis_git_sha1:237194b7
redis_git_dirty:0
arch_bits:32
multiplexing_api:epoll
process_id:16620
tcp_port:6379
uptime_in_seconds:444
uptime_in_days:0
lru_clock:198040

# Clients
connected_clients:1
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0

# Memory
used_memory:628076
used_memory_human:613.36K
used_memory_rss:1568768
used_memory_peak:570056
used_memory_peak_human:556.70K
used_memory_lua:14336
mem_fragmentation_ratio:2.50
mem_allocator:jemalloc-2.2.1

# Persistence
loading:0
aof_enabled:0
changes_since_last_save:0
bgsave_in_progress:0
last_save_time:1323185719
bgrewriteaof_in_progress:0

# Stats
total_connections_received:4
total_commands_processed:3
rejected_connections:0
expired_keys:0
evicted_keys:0
keyspace_hits:0
keyspace_misses:0
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:0

# Replication
role:master
connected_slaves:0

# CPU
used_cpu_sys:0.06
used_cpu_user:0.06
used_cpu_sys_children:0.00
used_cpu_user_children:0.00

# Cluster
cluster_enabled:0

# Keyspace
db0:keys=2,expires=0
db5:keys=1,expires=0

BUFFER;

        $expected = [
            'Server' => [
                'redis_version' => '2.9.0',
                'redis_git_sha1' => '237194b7',
                'redis_git_dirty' => '0',
                'arch_bits' => '32',
                'multiplexing_api' => 'epoll',
                'process_id' => '16620',
                'tcp_port' => '6379',
                'uptime_in_seconds' => '444',
                'uptime_in_days' => '0',
                'lru_clock' => '198040',
            ],
            'Clients' => [
                'connected_clients' => '1',
                'client_longest_output_list' => '0',
                'client_biggest_input_buf' => '0',
                'blocked_clients' => '0',
            ],
            'Memory' => [
                'used_memory' => '628076',
                'used_memory_human' => '613.36K',
                'used_memory_rss' => '1568768',
                'used_memory_peak' => '570056',
                'used_memory_peak_human' => '556.70K',
                'used_memory_lua' => '14336',
                'mem_fragmentation_ratio' => '2.50',
                'mem_allocator' => 'jemalloc-2.2.1',
            ],
            'Persistence' => [
                'loading' => '0',
                'aof_enabled' => '0',
                'changes_since_last_save' => '0',
                'bgsave_in_progress' => '0',
                'last_save_time' => '1323185719',
                'bgrewriteaof_in_progress' => '0',
            ],
            'Stats' => [
                'total_connections_received' => '4',
                'total_commands_processed' => '3',
                'rejected_connections' => '0',
                'expired_keys' => '0',
                'evicted_keys' => '0',
                'keyspace_hits' => '0',
                'keyspace_misses' => '0',
                'pubsub_channels' => '0',
                'pubsub_patterns' => '0',
                'latest_fork_usec' => '0',
            ],
            'Replication' => [
                'role' => 'master',
                'connected_slaves' => '0',
            ],
            'CPU' => [
                'used_cpu_sys' => '0.06',
                'used_cpu_user' => '0.06',
                'used_cpu_sys_children' => '0.00',
                'used_cpu_user_children' => '0.00',
            ],
            'Cluster' => [
                'cluster_enabled' => '0',
            ],
            'Keyspace' => [
                'db0' => ['keys' => '2', 'expires' => '0'],
                'db5' => ['keys' => '1', 'expires' => '0'],
            ],
        ];

        $this->assertSame($expected, $this->getCommand()->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testCanParseOldResponsesFormat(): void
    {
        $raw = <<<BUFFER
redis_version:2.4.4
redis_git_sha1:bc62bc5e
redis_git_dirty:0
arch_bits:32
multiplexing_api:epoll
process_id:15640
uptime_in_seconds:792
uptime_in_days:0
lru_clock:197890
used_cpu_sys:0.08
used_cpu_user:0.10
used_cpu_sys_children:0.00
used_cpu_user_children:0.00
connected_clients:1
connected_slaves:0
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0
used_memory:556156
used_memory_human:543.12K
used_memory_rss:1396736
used_memory_peak:547688
used_memory_peak_human:534.85K
mem_fragmentation_ratio:2.51
mem_allocator:jemalloc-2.2.1
loading:0
aof_enabled:0
changes_since_last_save:0
bgsave_in_progress:0
last_save_time:1323183872
bgrewriteaof_in_progress:0
total_connections_received:2
total_commands_processed:1
expired_keys:0
evicted_keys:0
keyspace_hits:0
keyspace_misses:0
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:0
vm_enabled:0
role:master
db0:keys=2,expires=0
db5:keys=1,expires=0

BUFFER;

        $expected = [
            'redis_version' => '2.4.4',
            'redis_git_sha1' => 'bc62bc5e',
            'redis_git_dirty' => '0',
            'arch_bits' => '32',
            'multiplexing_api' => 'epoll',
            'process_id' => '15640',
            'uptime_in_seconds' => '792',
            'uptime_in_days' => '0',
            'lru_clock' => '197890',
            'used_cpu_sys' => '0.08',
            'used_cpu_user' => '0.10',
            'used_cpu_sys_children' => '0.00',
            'used_cpu_user_children' => '0.00',
            'connected_clients' => '1',
            'connected_slaves' => '0',
            'client_longest_output_list' => '0',
            'client_biggest_input_buf' => '0',
            'blocked_clients' => '0',
            'used_memory' => '556156',
            'used_memory_human' => '543.12K',
            'used_memory_rss' => '1396736',
            'used_memory_peak' => '547688',
            'used_memory_peak_human' => '534.85K',
            'mem_fragmentation_ratio' => '2.51',
            'mem_allocator' => 'jemalloc-2.2.1',
            'loading' => '0',
            'aof_enabled' => '0',
            'changes_since_last_save' => '0',
            'bgsave_in_progress' => '0',
            'last_save_time' => '1323183872',
            'bgrewriteaof_in_progress' => '0',
            'total_connections_received' => '2',
            'total_commands_processed' => '1',
            'expired_keys' => '0',
            'evicted_keys' => '0',
            'keyspace_hits' => '0',
            'keyspace_misses' => '0',
            'pubsub_channels' => '0',
            'pubsub_patterns' => '0',
            'latest_fork_usec' => '0',
            'vm_enabled' => '0',
            'role' => 'master',
            'db0' => ['keys' => '2', 'expires' => '0'],
            'db5' => ['keys' => '1', 'expires' => '0'],
        ];

        $this->assertSame($expected, $this->getCommand()->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testDoesNotEmitPhpNoticeOnEmptyResponse(): void
    {
        $this->assertSame([], $this->getCommand()->parseResponse(''));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testReturnsAnArrayOfInfo(): void
    {
        $redis = $this->getClient();
        $command = $this->getCommand();

        $this->assertIsArray($info = $redis->executeCommand($command));
        $this->assertArrayHasKey('redis_version', $info['Server'] ?? $info);
    }

    /**
     * @group connected
     * @requiresRedisVersion < 2.6.0
     */
    public function testReturnsAnArrayOfInfoOnOlderRedisVersions(): void
    {
        $redis = $this->getClient();
        $command = $this->getCommand();

        $this->assertIsArray($info = $redis->executeCommand($command));
        $this->assertArrayHasKey('redis_version', $info);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\KEYS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class KEYS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\KEYS';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'KEYS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['pattern:*'];
        $expected = ['pattern:*'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['key1', 'key2', 'key3'];
        $parsed = ['key1', 'key2', 'key3'];

        $this->assertSame($parsed, $this->getCommand()->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testReturnsArrayOfMatchingKeys(): void
    {
        $keys = ['aaa' => 1, 'aba' => 2, 'aca' => 3];
        $keysNS = ['metavar:foo' => 'bar', 'metavar:hoge' => 'piyo'];
        $keysAll = array_merge($keys, $keysNS);

        $redis = $this->getClient();
        $redis->mset($keysAll);

        $this->assertSame([], $redis->keys('nomatch:*'));
        $this->assertSameValues(array_keys($keysNS), $redis->keys('metavar:*'));
        $this->assertSameValues(array_keys($keysAll), $redis->keys('*'));
        $this->assertSameValues(array_keys($keys), $redis->keys('a?a'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LASTSAVE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class LASTSAVE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LASTSAVE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LASTSAVE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(100, $this->getCommand()->parseResponse(100));
    }

    /**
     * @group connected
     */
    public function testReturnsIntegerValue(): void
    {
        $redis = $this->getClient();

        $this->assertIsInt($redis->lastsave());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LCS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class LCS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return LCS::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LCS';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     * @dataProvider responsesProvider
     */
    public function testParseResponse($actualResponse, $expectedResponse): void
    {
        $this->assertSame($expectedResponse, $this->getCommand()->parseResponse($actualResponse));
    }

    /**
     * @group connected
     * @dataProvider stringsProvider
     * @param  array $stringsArguments
     * @param  array $functionArguments
     * @param        $expectedResponse
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testReturnsLongestCommonSubsequenceFromGivenStrings(
        array $stringsArguments,
        array $functionArguments,
        $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->mset(...$stringsArguments);

        $this->assertSame($expectedResponse, $redis->lcs(...$functionArguments));
    }

    public function argumentsProvider(): array
    {
        return [
            'with required arguments' => [
                ['key1', 'key2'],
                ['key1', 'key2'],
            ],
            'with LEN argument' => [
                ['key1', 'key2', true],
                ['key1', 'key2', 'LEN'],
            ],
            'with IDX argument' => [
                ['key1', 'key2', false, true],
                ['key1', 'key2', 'IDX'],
            ],
            'with MINMATCHLEN argument' => [
                ['key1', 'key2', false, false, 2],
                ['key1', 'key2', 'MINMATCHLEN', 2],
            ],
            'with WITHMATCHLEN argument' => [
                ['key1', 'key2', false, false, 0, true],
                ['key1', 'key2', 'WITHMATCHLEN'],
            ],
            'with all arguments' => [
                ['key1', 'key2', true, true, 2, true],
                ['key1', 'key2', 'LEN', 'IDX', 'MINMATCHLEN', 2, 'WITHMATCHLEN'],
            ],
        ];
    }

    public function responsesProvider(): array
    {
        return [
            'non-array response' => [
                1,
                1,
            ],
            'array response' => [
                ['matches', [[[0, 1], [1, 2]]], 'len', 2],
                ['matches' => [[[0, 1], [1, 2]]], 'len' => 2],
            ],
        ];
    }

    public function stringsProvider(): array
    {
        return [
            'with required arguments' => [
                ['key1', 'value1', 'key2', '2value'],
                ['key1', 'key2'],
                'value',
            ],
            'only length' => [
                ['key1', 'value1', 'key2', '2value'],
                ['key1', 'key2', true],
                5,
            ],
            'with matching indexes - single match' => [
                ['key1', 'value1', 'key2', '2value'],
                ['key1', 'key2', false, true],
                [
                    'matches' => [
                        [
                            [0, 4],
                            [1, 5],
                        ],
                    ],
                    'len' => 5,
                ],
            ],
            'with matching indexes - multiple match' => [
                ['key1', 'value1test', 'key2', '2valuetest'],
                ['key1', 'key2', false, true],
                [
                    'matches' => [
                        [
                            [6, 9],
                            [6, 9],
                        ],
                        [
                            [0, 4],
                            [1, 5],
                        ],
                    ],
                    'len' => 9,
                ],
            ],
            'with matching indexes - MINMATCHLEN modifier' => [
                ['key1', 'value1test', 'key2', '2valuetest'],
                ['key1', 'key2', false, true, 5],
                [
                    'matches' => [
                        [
                            [0, 4],
                            [1, 5],
                        ],
                    ],
                    'len' => 9,
                ],
            ],
            'with matching indexes - WITHMATCHLEN modifier' => [
                ['key1', 'value1test', 'key2', '2valuetest'],
                ['key1', 'key2', false, true, 5, true],
                [
                    'matches' => [
                        [
                            [0, 4],
                            [1, 5],
                            5,
                        ],
                    ],
                    'len' => 9,
                ],
            ],
            'with wrong/empty keys arguments' => [
                ['key1', 'value1', 'key2', '2value'],
                ['key3', 'key4'],
                '',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LINDEX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LINDEX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LINDEX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LINDEX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 1];
        $expected = ['key', 1];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(0, $this->getCommand()->parseResponse(0));
    }

    /**
     * @group connected
     */
    public function testReturnsElementAtIndex(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e');

        $this->assertSame('a', $redis->lindex('letters', 0));
        $this->assertSame('c', $redis->lindex('letters', 2));
        $this->assertNull($redis->lindex('letters', 100));
    }

    /**
     * @group connected
     */
    public function testReturnsElementAtNegativeIndex(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e');

        $this->assertSame('a', $redis->lindex('letters', -0));
        $this->assertSame('c', $redis->lindex('letters', -3));
        $this->assertSame('e', $redis->lindex('letters', -1));
        $this->assertNull($redis->lindex('letters', -100));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->lindex('foo', 0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LINSERT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LINSERT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LINSERT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LINSERT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'before', 'value1', 'value2'];
        $expected = ['key', 'before', 'value1', 'value2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testReturnsLengthOfListAfterInser(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'c', 'e');

        $this->assertSame(4, $redis->linsert('letters', 'before', 'c', 'b'));
        $this->assertSame(5, $redis->linsert('letters', 'after', 'c', 'd'));
        $this->assertSame(['a', 'b', 'c', 'd', 'e'], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testReturnsNegativeLengthOnFailedInsert(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'c', 'e');

        $this->assertSame(-1, $redis->linsert('letters', 'before', 'n', 'm'));
        $this->assertSame(-1, $redis->linsert('letters', 'after', 'o', 'p'));
    }

    /**
     * @group connected
     */
    public function testReturnsZeroLengthOnNonExistingList(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->linsert('letters', 'after', 'a', 'b'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->linsert('foo', 'BEFORE', 'bar', 'baz');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LLEN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LLEN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LLEN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LLEN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testReturnsLengthOfList(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c');
        $this->assertSame(3, $redis->llen('letters'));

        $redis->rpush('letters', 'd', 'e', 'f');
        $this->assertSame(6, $redis->llen('letters'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testReturnsZeroLengthOnNonExistingList(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->llen('letters'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->llen('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LMOVE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-list
 */
class LMOVE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return LMOVE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'LMOVE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['list', 'argument1', 'argument2', 'argument3'];
        $expected = ['list', 'argument1', 'argument2', 'argument3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider listsProvider
     * @param  array  $firstList
     * @param  array  $secondList
     * @param  string $where
     * @param  string $to
     * @param  string $expectedResponse
     * @param  array  $expectedModifiedFirstList
     * @param  array  $expectedModifiedSecondList
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsCorrectListElement(
        array $firstList,
        array $secondList,
        string $where,
        string $to,
        string $expectedResponse,
        array $expectedModifiedFirstList,
        array $expectedModifiedSecondList
    ): void {
        $redis = $this->getClient();

        $redis->rpush('test-lmove1', $firstList);
        $redis->rpush('test-lmove2', $secondList);

        $actualResponse = $redis->lmove('test-lmove1', 'test-lmove2', $where, $to);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedModifiedFirstList, $redis->lrange('test-lmove1', 0, -1));
        $this->assertSame($expectedModifiedSecondList, $redis->lrange('test-lmove2', 0, -1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsNullAndNoOperationPerformedOnNonExistingSource(): void
    {
        $redis = $this->getClient();
        $expectedList = ['element1', 'element2', 'element3'];

        $redis->rpush('test-lmove1', $expectedList);

        $actualResponse = $redis->lmove('test-lmove2', 'test-lmove1', 'LEFT', 'LEFT');

        $this->assertNull($actualResponse);
        $this->assertSame($expectedList, $redis->lrange('test-lmove1', 0, -1));
    }

    /**
     * @group connected
     * @dataProvider sameListProvider
     * @param  array  $list
     * @param  string $where
     * @param  string $to
     * @param  string $expectedResponse
     * @param  array  $expectedModifiedList
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsCorrectListElementAndListRotationPerformedOnTheSameListOperation(
        array $list,
        string $where,
        string $to,
        string $expectedResponse,
        array $expectedModifiedList
    ): void {
        $redis = $this->getClient();

        $redis->rpush('test-lmove1', $list);

        $actualResponse = $redis->lmove('test-lmove1', 'test-lmove1', $where, $to);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedModifiedList, $redis->lrange('test-lmove1', 0, -1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->lmove('foo', 'test-lmove', 'LEFT', 'LEFT');
    }

    public function listsProvider(): array
    {
        return [
            'move first element from list into head of another list' => [
                ['element1', 'element2', 'element3'],
                ['element4', 'element5', 'element6'],
                'LEFT',
                'LEFT',
                'element1',
                ['element2', 'element3'],
                ['element1', 'element4', 'element5', 'element6'],
            ],
            'move first element from list into tail of another list' => [
                ['element1', 'element2', 'element3'],
                ['element4', 'element5', 'element6'],
                'LEFT',
                'RIGHT',
                'element1',
                ['element2', 'element3'],
                ['element4', 'element5', 'element6', 'element1'],
            ],
            'move last element from list into head of another list' => [
                ['element1', 'element2', 'element3'],
                ['element4', 'element5', 'element6'],
                'RIGHT',
                'LEFT',
                'element3',
                ['element1', 'element2'],
                ['element3', 'element4', 'element5', 'element6'],
            ],
            'move last element from list into tail of another list' => [
                ['element1', 'element2', 'element3'],
                ['element4', 'element5', 'element6'],
                'RIGHT',
                'RIGHT',
                'element3',
                ['element1', 'element2'],
                ['element4', 'element5', 'element6', 'element3'],
            ],
        ];
    }

    public function sameListProvider(): array
    {
        return [
            'list rotation - head into tail' => [
                ['element1', 'element2', 'element3'],
                'LEFT',
                'RIGHT',
                'element1',
                ['element2', 'element3', 'element1'],
            ],
            'list rotation - tail into head' => [
                ['element1', 'element2', 'element3'],
                'RIGHT',
                'LEFT',
                'element3',
                ['element3', 'element1', 'element2'],
            ],
            'list rotation - head into head' => [
                ['element1', 'element2', 'element3'],
                'LEFT',
                'LEFT',
                'element1',
                ['element1', 'element2', 'element3'],
            ],
            'list rotation - tail into tail' => [
                ['element1', 'element2', 'element3'],
                'RIGHT',
                'RIGHT',
                'element3',
                ['element1', 'element2', 'element3'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LMPOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LMPOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return LMPOP::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LMPOP';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['key', ['elem1', 'elem2']];
        $expected = ['key' => ['elem1', 'elem2']];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @dataProvider listProvider
     * @param  array      $listArguments
     * @param  string     $key
     * @param  string     $modifier
     * @param  int        $count
     * @param  array|null $expectedResponse
     * @param  array      $expectedModifiedList
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testPopElementsFromGivenList(
        array $listArguments,
        string $key,
        string $modifier,
        int $count,
        ?array $expectedResponse,
        array $expectedModifiedList
    ): void {
        $redis = $this->getClient();

        $redis->lpush(...$listArguments);
        $actualResponse = $redis->lmpop(['key1', $key], $modifier, $count);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedModifiedList, $redis->lrange($key, 0, -1));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                [['key']],
                [1, 'key', 'LEFT'],
            ],
            'with LEFT/RIGHT argument' => [
                [['key'], 'right'],
                [1, 'key', 'RIGHT'],
            ],
            'with COUNT argument' => [
                [['key'], 'left', 2],
                [1, 'key', 'LEFT', 'COUNT', 2],
            ],
            'with all arguments' => [
                [['key1', 'key2'], 'right', 2],
                [2, 'key1', 'key2', 'RIGHT', 'COUNT', 2],
            ],
        ];
    }

    public function listProvider(): array
    {
        return [
            'pops single element - left' => [
                ['key', 'elem1', 'elem2', 'elem3'],
                'key',
                'left',
                1,
                ['key' => ['elem3']],
                ['elem2', 'elem1'],
            ],
            'pops single element - right' => [
                ['key', 'elem1', 'elem2', 'elem3'],
                'key',
                'right',
                1,
                ['key' => ['elem1']],
                ['elem3', 'elem2'],
            ],
            'pops multiple elements' => [
                ['key', 'elem1', 'elem2', 'elem3'],
                'key',
                'right',
                2,
                ['key' => ['elem1', 'elem2']],
                ['elem3'],
            ],
            'with empty list' => [
                ['key', 'elem1', 'elem2', 'elem3'],
                'key2',
                'right',
                2,
                null,
                [],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LPOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LPOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LPOP';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LPOP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('element', $this->getCommand()->parseResponse('element'));
    }

    /**
     * @group connected
     */
    public function testPopsTheFirstElementFromList(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd');

        $this->assertSame('a', $redis->lpop('letters'));
        $this->assertSame('b', $redis->lpop('letters'));
        $this->assertSame(['c', 'd'], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testReturnsNullOnEmptyList(): void
    {
        $redis = $this->getClient();

        $this->assertNull($redis->lpop('letters'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->lpop('foo');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2
     */
    public function testPopsSpecifiedNumberOfElements(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e', 'f');

        $this->assertSame(['a', 'b'], $redis->lpop('letters', 2));
        $this->assertSame(['c', 'd'], $redis->lpop('letters', 2));
        $this->assertSame(['e', 'f'], $redis->lrange('letters', 0, -1));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LPUSHX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LPUSHX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LPUSHX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LPUSHX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'value'];
        $expected = ['key', 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testPushesElementsToHeadOfExistingList(): void
    {
        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');

        $this->assertSame(2, $redis->lpushx('metavars', 'hoge'));
        $this->assertSame(['hoge', 'foo'], $redis->lrange('metavars', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testDoesNotPushElementOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->lpushx('metavars', 'foo'));
        $this->assertSame(0, $redis->lpushx('metavars', 'hoge'));
        $this->assertSame(0, $redis->exists('metavars'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->lpushx('metavars', 'hoge');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LPUSH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LPUSH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LPUSH';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LPUSH';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'value1', 'value2', 'value3'];
        $expected = ['key', 'value1', 'value2', 'value3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsValuesAsSingleArray(): void
    {
        $arguments = ['key', ['value1', 'value2', 'value3']];
        $expected = ['key', 'value1', 'value2', 'value3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testPushesElementsToHeadOfList(): void
    {
        $redis = $this->getClient();

        // NOTE: List push operations return the list length since Redis commit 520b5a3
        $this->assertSame(1, $redis->lpush('metavars', 'foo'));
        $this->assertSame(2, $redis->lpush('metavars', 'hoge'));
        $this->assertSame(['hoge', 'foo'], $redis->lrange('metavars', 0, -1));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->lpush('metavars', 'hoge');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LRANGE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LRANGE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, -1];
        $expected = ['key', 0, -1];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['value1', 'value2', 'value3'];
        $expected = ['value1', 'value2', 'value3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testReturnsListSliceWithPositiveStartAndStop(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l');

        $this->assertSame(['a', 'b', 'c', 'd'], $redis->lrange('letters', 0, 3));
        $this->assertSame(['e', 'f', 'g', 'h'], $redis->lrange('letters', 4, 7));
        $this->assertSame(['a', 'b'], $redis->lrange('letters', 0, 1));
        $this->assertSame(['a'], $redis->lrange('letters', 0, 0));
    }

    /**
     * @group connected
     */
    public function testReturnsListSliceWithPositiveStartAndNegativeStop(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l');

        $this->assertSame(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l'], $redis->lrange('letters', 0, -1));
        $this->assertSame(['f'], $redis->lrange('letters', 5, -5));
        $this->assertSame([], $redis->lrange('letters', 7, -5));
    }

    /**
     * @group connected
     */
    public function testReturnsListSliceWithNegativeStartAndStop(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l');

        $this->assertSame(['f'], $redis->lrange('letters', -5, -5));
    }

    /**
     * @group connected
     */
    public function testHandlesStartAndStopOverflow(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l');

        $this->assertSame(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l'], $redis->lrange('letters', -100, 100));
    }

    /**
     * @group connected
     */
    public function testReturnsEmptyArrayOnNonExistingList(): void
    {
        $redis = $this->getClient();

        $this->assertSame([], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->lrange('metavars', 0, -1);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LREM_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LREM_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LREM';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LREM';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 1, 'value'];
        $expected = ['key', 1, 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testRemovesMatchingElementsFromHeadToTail(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', '_', 'b', '_', 'c', '_', 'd', '_');

        $this->assertSame(2, $redis->lrem('letters', 2, '_'));
        $this->assertSame(['a', 'b', 'c', '_', 'd', '_'], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testRemovesMatchingElementsFromTailToHead(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', '_', 'b', '_', 'c', '_', 'd', '_');

        $this->assertSame(2, $redis->lrem('letters', -2, '_'));
        $this->assertSame(['a', '_', 'b', '_', 'c', 'd'], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testRemovesAllMatchingElements(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', '_', 'b', '_', 'c', '_', 'd', '_');

        $this->assertSame(4, $redis->lrem('letters', 0, '_'));
        $this->assertSame(['a', 'b', 'c', 'd'], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testReturnsZeroOnNonMatchingElementsOrEmptyList(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd');

        $this->assertSame(0, $redis->lrem('letters', 0, 'z'));
        $this->assertSame(0, $redis->lrem('digits', 0, 100));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->lrem('metavars', 0, 0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LSET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LSET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LSET';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LSET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, 'value'];
        $expected = ['key', 0, 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     */
    public function testSetsElementAtSpecifiedIndex(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c');

        $this->assertEquals('OK', $redis->lset('letters', 1, 'B'));
        $this->assertSame(['a', 'B', 'c'], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnIndexOutOfRange(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR index out of range');

        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c');
        $redis->lset('letters', 21, 'z');
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->lset('metavars', 0, 'hoge');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\LTRIM_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class LTRIM_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\LTRIM';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'LTRIM';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, 1];
        $expected = ['key', 0, 1];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     */
    public function testTrimsListWithPositiveStartAndStop(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l');

        $this->assertEquals('OK', $redis->ltrim('letters', 0, 2));
        $this->assertSame(['a', 'b', 'c'], $redis->lrange('letters', 0, -1));

        $redis->flushdb();
        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l');

        $this->assertEquals('OK', $redis->ltrim('letters', 5, 9));
        $this->assertSame(['f', 'g', 'h', 'i', 'l'], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testTrimsListWithPositiveStartAndNegativeStop(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l');

        $this->assertEquals('OK', $redis->ltrim('letters', 0, -6));
        $this->assertSame(['a', 'b', 'c', 'd', 'e'], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testTrimsListWithNegativeStartAndStop(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l');

        $this->assertEquals('OK', $redis->ltrim('letters', -5, -5));
        $this->assertSame(['f'], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testHandlesStartAndStopOverflow(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l');

        $this->assertEquals('OK', $redis->ltrim('letters', -100, 100));
        $this->assertSame(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'l'], $redis->lrange('letters', -100, 100));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->ltrim('metavars', 0, 1);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\MGET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class MGET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\MGET';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'MGET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key1', 'key2', 'key3'];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['key1', 'key2', 'key3']];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['value1', 'value2', 'value3'];
        $expected = ['value1', 'value2', 'value3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testReturnsArrayOfValues(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->set('hoge', 'piyo');

        $this->assertSame(['bar', 'piyo'], $redis->mget('foo', 'hoge'));
    }

    /**
     * @group connected
     */
    public function testReturnsArrayWithNullValuesOnNonExistingKeys(): void
    {
        $redis = $this->getClient();

        $this->assertSame([null, null], $redis->mget('foo', 'hoge'));
    }

    /**
     * @group connected
     */
    public function testDoesNotThrowExceptionOnWrongType(): void
    {
        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $this->assertSame([null], $redis->mget('metavars'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\MIGRATE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class MIGRATE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\MIGRATE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'MIGRATE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['127.0.0.1', '6379', 'key', '0', '10'];
        $expected = ['127.0.0.1', '6379', 'key', '0', '10'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsRedis300(): void
    {
        $arguments = ['127.0.0.1', '6379', 'key', '0', '10', 'COPY', 'REPLACE'];
        $expected = ['127.0.0.1', '6379', 'key', '0', '10', 'COPY', 'REPLACE'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithOptionsArray(): void
    {
        $arguments = ['127.0.0.1', '6379', 'key', '0', '10', ['COPY' => true, 'REPLACE' => true]];
        $expected = ['127.0.0.1', '6379', 'key', '0', '10', 'COPY', 'REPLACE'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame('OK', $command->parseResponse('OK'));
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requiresRedisVersion >= 2.6.0
     */
    public function testReturnsStatusNOKEYOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('NOKEY', $response = $redis->migrate('169.254.10.10', 16379, 'foo', 15, 1));
        $this->assertInstanceOf('Predis\Response\Status', $response);
    }

    /**
     * @group connected
     * @group ext-relay
     * @requiresRedisVersion >= 2.6.0
     */
    public function testReturnsStatusNOKEYOnNonExistingKeyUsingRelay(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('NOKEY', $redis->migrate('169.254.10.10', 16379, 'foo', 15, 1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     * @group slow
     */
    public function testReturnsErrorOnUnreacheableDestination(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('IOERR');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->migrate('169.254.10.10', 16379, 'foo', 15, 1);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\MONITOR_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 * @group realm-monitor
 */
class MONITOR_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\MONITOR';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'MONITOR';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testReturnsStatusResponseAndReadsEventsFromTheConnection(): void
    {
        $connection = $this->getClient()->getConnection();
        $command = $this->getCommand();

        $this->assertEquals('OK', $connection->executeCommand($command));

        // NOTE: Starting with 2.6 Redis does not return the "MONITOR" message after
        // +OK to the client that issued the MONITOR command.
        if ($this->isRedisServerVersion('<=', '2.4.0')) {
            $this->assertMatchesRegularExpression('/\d+.\d+(\s?\(db \d+\))? "MONITOR"/', $connection->read());
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\MOVE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class MOVE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\MOVE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'MOVE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 10];
        $expected = ['key', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @todo Should be improved, this test fails when REDIS_SERVER_DBNUM is 0.
     */
    public function testMovesKeysToDifferentDatabases(): void
    {
        $db = REDIS_SERVER_DBNUM + 1;
        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $this->assertSame(1, $redis->move('foo', $db));
        $this->assertSame(0, $redis->exists('foo'));

        $redis->select($db);
        $this->assertSame(1, $redis->exists('foo'));

        $redis->del('foo');
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnInvalidDatabases(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessageMatches('/ERR.*out of range/');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $redis->move('foo', 100000000);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\MSETNX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class MSETNX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\MSETNX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'MSETNX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['foo', 'bar', 'hoge', 'piyo'];
        $expected = ['foo', 'bar', 'hoge', 'piyo'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleNamedArray(): void
    {
        $arguments = [['foo' => 'bar', 'hoge' => 'piyo']];
        $expected = ['foo', 'bar', 'hoge', 'piyo'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(0, $this->getCommand()->parseResponse(0));
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testCreatesMultipleKeys(): void
    {
        $redis = $this->getClient();

        $this->assertSame(1, $redis->msetnx('foo', 'bar', 'hoge', 'piyo'));
        $this->assertSame('bar', $redis->get('foo'));
        $this->assertSame('piyo', $redis->get('hoge'));
    }

    /**
     * @group connected
     */
    public function testCreatesMultipleKeysAndPreservesExistingOnes(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $this->assertSame(0, $redis->msetnx('foo', 'barbar', 'hoge', 'piyo'));
        $this->assertSame('bar', $redis->get('foo'));
        $this->assertSame(0, $redis->exists('hoge'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\MSET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class MSET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\MSET';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'MSET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['foo', 'bar', 'hoge', 'piyo'];
        $expected = ['foo', 'bar', 'hoge', 'piyo'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleNamedArray(): void
    {
        $arguments = [['foo' => 'bar', 'hoge' => 'piyo']];
        $expected = ['foo', 'bar', 'hoge', 'piyo'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     */
    public function testCreatesMultipleKeys(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->mset('foo', 'bar', 'hoge', 'piyo'));
        $this->assertSame('bar', $redis->get('foo'));
        $this->assertSame('piyo', $redis->get('hoge'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\MULTI_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-transaction
 */
class MULTI_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\MULTI';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'MULTI';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testInitializesNewTransaction(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->multi());
        $this->assertEquals('QUEUED', $redis->echo('tx1'));
        $this->assertEquals('QUEUED', $redis->echo('tx2'));
    }

    /**
     * @group connected
     * @group ext-relay
     */
    public function testInitializesNewTransactionUsingRelay(): void
    {
        $redis = $this->getClient();
        $relay = $redis->getConnection()->getClient();

        $this->assertSame($relay, $redis->multi());
        $this->assertSame($relay, $redis->echo('tx1'));
        $this->assertSame($relay, $redis->echo('tx2'));

        $relay->discard();
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @group relay-fixme
     */
    public function testActuallyReturnsResponseObjectAbstraction(): void
    {
        $redis = $this->getClient();

        $this->assertInstanceOf('Predis\Response\Status', $redis->multi());
        $this->assertInstanceOf('Predis\Response\Status', $redis->echo('tx1'));
        $this->assertInstanceOf('Predis\Response\Status', $redis->echo('tx2'));
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @group relay-fixme
     */
    public function testThrowsExceptionWhenCallingMultiInsideTransaction(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR MULTI calls can not be nested');

        $redis = $this->getClient();

        $redis->multi();
        $redis->multi();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\OBJECT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class OBJECT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\OBJECT_';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'OBJECT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['REFCOUNT', 'key'];
        $expected = ['REFCOUNT', 'key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('ziplist', $this->getCommand()->parseResponse('ziplist'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.3
     */
    public function testObjectRefcount(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $this->assertIsInt($redis->object('REFCOUNT', 'foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.3
     */
    public function testObjectIdletime(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $this->assertIsInt($redis->object('IDLETIME', 'foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion < 7.2.0
     */
    public function testObjectEncoding(): void
    {
        $redis = $this->getClient();

        $redis->lpush('list:metavars', 'foo', 'bar');
        $this->assertMatchesRegularExpression('/[zip|quick]list/', $redis->object('ENCODING', 'list:metavars'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.2.0
     */
    public function testObjectEncodingReturnsUpdatedResponse(): void
    {
        $redis = $this->getClient();

        $redis->lpush('list:metavars', 'foo', 'bar');

        $this->assertSame('listpack', $redis->object('ENCODING', 'list:metavars'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.3
     */
    public function testReturnsNullOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertNull($redis->object('REFCOUNT', 'foo'));
        $this->assertNull($redis->object('IDLETIME', 'foo'));
        $this->assertNull($redis->object('ENCODING', 'foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.3
     */
    public function testThrowsExceptionOnInvalidSubcommand(): void
    {
        $this->expectException('Predis\Response\ServerException');

        $redis = $this->getClient();

        $redis->object('INVALID', 'foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PERSIST_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class PERSIST_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PERSIST';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PERSIST';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testRemovesExpireFromKey(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->expire('foo', 10);

        $this->assertSame(1, $redis->persist('foo'));
        $this->assertSame(-1, $redis->ttl('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testReturnsZeroOnNonExpiringKeys(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $this->assertSame(0, $redis->persist('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testReturnsZeroOnNonExistentKeys(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->persist('foo'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PEXPIREAT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class PEXPIREAT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PEXPIREAT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PEXPIREAT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 100];
        $expected = ['key', 100];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @medium
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     * @group slow
     */
    public function testCanExpireKeys(): void
    {
        $ttl = 1.5;
        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $this->assertSame(1, $redis->pexpireat('foo', time() + $ttl * 1000));
        $this->assertLessThan($ttl * 1000, $redis->pttl('foo'));

        $this->sleep($ttl + 0.5);

        $this->assertSame(0, $redis->exists('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testDeletesKeysOnPastUnixTime(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $this->assertSame(1, $redis->expireat('foo', time() - 100000));
        $this->assertSame(0, $redis->exists('foo'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PEXPIRETIME_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-keys
 */
class PEXPIRETIME_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return PEXPIRETIME::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PEXPIRETIME';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testReturnsCorrectExpirationTimeForGivenKey(): void
    {
        $redis = $this->getClient();
        $expirationTime = time() * 1000 + 1000;

        $redis->set('key', 'value');
        $redis->set('key1', 'value');
        $redis->pexpireat('key', $expirationTime);

        $this->assertSame($expirationTime, $redis->pexpiretime('key'));
        $this->assertSame(-1, $redis->pexpiretime('key1'));
        $this->assertSame(-2, $redis->pexpiretime('non-existing key'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PEXPIRE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class PEXPIRE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PEXPIRE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PEXPIRE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 100];
        $expected = ['key', 100];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testReturnsZeroOnNonExistingKeys(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->pexpire('foo', 20000));
    }

    /**
     * @medium
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     * @group slow
     */
    public function testCanExpireKeys(): void
    {
        $ttl = 1000;
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar'));
        $this->assertSame(1, $redis->pexpire('foo', $ttl));

        $this->sleep(1.2);
        $this->assertSame(0, $redis->exists('foo'));
    }

    /**
     * @medium
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     * @group slow
     */
    public function testConsistencyWithTTL(): void
    {
        $ttl = 1000;
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar'));
        $this->assertSame(1, $redis->pexpire('foo', $ttl));

        $this->sleep(0.5);
        $this->assertThat($redis->pttl('foo'), $this->logicalAnd(
            $this->lessThanOrEqual($ttl), $this->greaterThan($ttl - 800)
        ));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testDeletesKeysOnNegativeTTL(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar'));

        $this->assertSame(1, $redis->pexpire('foo', -10000));
        $this->assertSame(0, $redis->exists('foo'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PFADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hyperloglog
 *
 * @todo Add integration tests depending on the minor redis version.
 */
class PFADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PFADD';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PFADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'a', 'b', 'c'];
        $expected = ['key', 'a', 'b', 'c'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsFieldsAsSingleArray(): void
    {
        $arguments = ['key', ['a', 'b', 'c']];
        $expected = ['key', 'a', 'b', 'c'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo', 'hoge');
        $redis->pfadd('metavars', 'foofoo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PFCOUNT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hyperloglog
 *
 * @todo Add integration tests depending on the minor redis version.
 */
class PFCOUNT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PFCOUNT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PFCOUNT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key:1', 'key:2'];
        $expected = ['key:1', 'key:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsFieldsAsSingleArray(): void
    {
        $arguments = [['key:1', 'key:2']];
        $expected = ['key:1', 'key:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
        $this->assertSame(10, $command->parseResponse(10));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo', 'hoge');
        $redis->pfcount('metavars');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnWrongTypeOfAtLeastOneKey(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->pfadd('metavars:1', 'foo', 'hoge');
        $redis->lpush('metavars:2', 'foofoo');
        $redis->pfcount('metavars:1', 'metavars:2');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PFMERGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-hyperloglog
 *
 * @todo Add integration tests depending on the minor redis version.
 */
class PFMERGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PFMERGE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PFMERGE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key:1', 'key:2', 'key:3'];
        $expected = ['key:1', 'key:2', 'key:3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsFieldsAsSingleArray(): void
    {
        $arguments = [['key:1', 'key:2', 'key:3']];
        $expected = ['key:1', 'key:2', 'key:3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->pfadd('metavars:1', 'foo', 'hoge');
        $redis->lpush('metavars:2', 'foofoo');
        $redis->pfmerge('metavars:1', 'metavars:2');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PING_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-connection
 */
class PING_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PING';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PING';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = [];
        $expected = [];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('PONG', $this->getCommand()->parseResponse('PONG'));
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testAlwaysReturnsStatusResponse(): void
    {
        $redis = $this->getClient();
        $response = $redis->ping();

        $this->assertInstanceOf('Predis\Response\Status', $response);
        $this->assertEquals('PONG', $response);
    }

    /**
     * @group connected
     * @group ext-relay
     */
    public function testAlwaysReturnsResponseUsingRelay(): void
    {
        $redis = $this->getClient();

        $response = $redis->ping();
        $this->assertEquals('PONG', $response);

        $response = $redis->ping('HELLO');
        $this->assertSame('HELLO', $response);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PSETEX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class PSETEX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PSETEX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PSETEX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 10, 'hello'];
        $expected = ['key', 10, 'hello'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testCreatesNewKeyAndSetsTTL(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->psetex('foo', 10000, 'bar'));
        $this->assertSame(1, $redis->exists('foo'));
        $this->assertSame(10, $redis->ttl('foo'));
    }

    /**
     * @group connected
     * @group slow
     * @requiresRedisVersion >= 2.6.0
     */
    public function testKeyExpiresAfterTTL(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->psetex('foo', 50, 'bar'));

        $this->sleep(0.5);
        $this->assertSame(0, $redis->exists('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnNonIntegerTTL(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR value is not an integer or out of range');

        $this->getClient()->psetex('foo', 2.5, 'bar');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnZeroTTL(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR invalid expire time');

        $this->getClient()->psetex('foo', 0, 'bar');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnNegativeTTL(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR invalid expire time');

        $this->getClient()->psetex('foo', -10000, 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PSUBSCRIBE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-pubsub
 * @group relay-incompatible
 */
class PSUBSCRIBE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PSUBSCRIBE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PSUBSCRIBE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['channel:foo:*', 'channel:hoge:*'];
        $expected = ['channel:foo:*', 'channel:hoge:*'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['channel:foo:*', 'channel:hoge:*']];
        $expected = ['channel:foo:*', 'channel:hoge:*'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['psubscribe', 'channel:*', 1];
        $expected = ['psubscribe', 'channel:*', 1];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsTheFirstPsubscribedChannelDetails(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['psubscribe', 'channel:*', 1], $redis->psubscribe('channel:*'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCanSendPsubscribeAfterPsubscribe(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['psubscribe', 'channel:foo:*', 1], $redis->psubscribe('channel:foo:*'));
        $this->assertSame(['psubscribe', 'channel:hoge:*', 2], $redis->psubscribe('channel:hoge:*'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCanSendSubscribeAfterPsubscribe(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['psubscribe', 'channel:foo:*', 1], $redis->psubscribe('channel:foo:*'));
        $this->assertSame(['subscribe', 'channel:foo:bar', 2], $redis->subscribe('channel:foo:bar'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCanSendUnsubscribeAfterPsubscribe(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['psubscribe', 'channel:foo:*', 1], $redis->psubscribe('channel:foo:*'));
        $this->assertSame(['psubscribe', 'channel:hoge:*', 2], $redis->psubscribe('channel:hoge:*'));
        $this->assertSame(['unsubscribe', 'channel:foo:bar', 2], $redis->unsubscribe('channel:foo:bar'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCanSendPunsubscribeAfterPsubscribe(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['psubscribe', 'channel:foo:*', 1], $redis->psubscribe('channel:foo:*'));
        $this->assertSame(['psubscribe', 'channel:hoge:*', 2], $redis->psubscribe('channel:hoge:*'));
        $this->assertSame(['punsubscribe', 'channel:*:*', 2], $redis->punsubscribe('channel:*:*'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCanSendQuitAfterPsubscribe(): void
    {
        $redis = $this->getClient();
        $quit = $this->getCommandFactory()->create('quit');

        $this->assertSame(['subscribe', 'channel1', 1], $redis->subscribe('channel1'));
        $this->assertEquals('OK', $redis->executeCommand($quit));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCannotSendOtherCommandsAfterPsubscribe(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessageMatches('/ERR.*only .* allowed in this context/');

        $redis = $this->getClient();

        $redis->psubscribe('channel:*');
        $redis->set('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PTTL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class PTTL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PTTL';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PTTL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 10];
        $expected = ['key', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(100, $command->parseResponse(100));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testReturnsTTL(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->expire('foo', 10);

        $this->assertLessThanOrEqual(10000, $redis->pttl('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testReturnsLessThanZeroOnNonExpiringKeys(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $this->assertSame(-1, $redis->pttl('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testReturnsLessThanZeroOnNonExistingKeys(): void
    {
        if ($this->isRedisServerVersion('<', '2.8.0')) {
            $this->assertSame(-1, $this->getClient()->pttl('foo'));
        } else {
            $this->assertSame(-2, $this->getClient()->pttl('foo'));
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PUBLISH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-pubsub
 */
class PUBLISH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PUBLISH';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PUBLISH';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['channel', 'message'];
        $expected = ['channel', 'message'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requiresRedisVersion >= 2.0.0
     */
    public function testPublishesMessagesToChannel(): void
    {
        $redis1 = $this->getClient();
        $redis2 = $this->getClient();

        $redis1->subscribe('channel:foo');

        $this->assertSame(1, $redis2->publish('channel:foo', 'bar'));
        $this->assertSame(0, $redis2->publish('channel:hoge', 'piyo'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PUBSUB_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-pubsub
 */
class PUBSUB_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PUBSUB';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PUBSUB';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['channels', 'predis:*'];
        $expected = ['channels', 'predis:*'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $response = ['predis:incoming', 'predis:outgoing'];
        $expected = ['predis:incoming', 'predis:outgoing'];

        $command = $this->getCommandWithArguments('channels', 'predis:*');

        $this->assertSame($expected, $command->parseResponse($response));
    }

    /**
     * @group disconnected
     */
    public function testPubsubNumsub(): void
    {
        $response = ['predis:incoming', '10', 'predis:outgoing', '8'];
        $expected = ['predis:incoming' => '10', 'predis:outgoing' => '8'];

        $command = $this->getCommandWithArguments('numsub', 'predis:incoming', 'predis:outgoing');

        $this->assertSame($expected, $command->parseResponse($response));
    }

    /**
     * @group disconnected
     */
    public function testPubsubNumpat(): void
    {
        $response = 6;
        $expected = 6;

        $command = $this->getCommandWithArguments('numpat');

        $this->assertSame($expected, $command->parseResponse($response));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\PUNSUBSCRIBE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-pubsub
 * @group relay-incompatible
 */
class PUNSUBSCRIBE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\PUNSUBSCRIBE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'PUNSUBSCRIBE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['channel:foo:*', 'channel:bar:*'];
        $expected = ['channel:foo:*', 'channel:bar:*'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['channel:foo:*', 'channel:bar:*']];
        $expected = ['channel:foo:*', 'channel:bar:*'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['punsubscribe', 'channel:*', 1];
        $expected = ['punsubscribe', 'channel:*', 1];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testDoesNotSwitchToSubscribeMode(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['punsubscribe', 'channel:*', 0], $redis->punsubscribe('channel:*'));
        $this->assertSame('echoed', $redis->echo('echoed'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testUnsubscribesFromNotSubscribedChannels(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['punsubscribe', 'channel:*', 0], $redis->punsubscribe('channel:*'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testUnsubscribesFromSubscribedChannels(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['subscribe', 'channel:foo', 1], $redis->subscribe('channel:foo'));
        $this->assertSame(['subscribe', 'channel:bar', 2], $redis->subscribe('channel:bar'));
        $this->assertSame(['punsubscribe', 'channel:*', 2], $redis->punsubscribe('channel:*'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testUnsubscribesFromAllSubscribedChannels(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['subscribe', 'channel:foo', 1], $redis->subscribe('channel:foo'));
        $this->assertSame(['subscribe', 'channel:bar', 2], $redis->subscribe('channel:bar'));
        $this->assertSame(['punsubscribe', null, 2], $redis->punsubscribe());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\QUIT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-connection
 */
class QUIT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\QUIT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'QUIT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = [];
        $expected = [];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testReturnsStatusResponseWhenClosingConnection(): void
    {
        $redis = $this->getClient();
        $command = $this->getCommand();
        $response = $redis->executeCommand($command);

        $this->assertInstanceOf('Predis\Response\Status', $response);
        $this->assertEquals('OK', $response);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\RANDOMKEY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class RANDOMKEY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\RANDOMKEY';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'RANDOMKEY';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = [];
        $expected = [];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = 'key';
        $expected = 'key';

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testReturnsZeroOnNonExpiringKeys(): void
    {
        $keys = ['key:1' => 1, 'key:2' => 2, 'key:3' => 3];

        $redis = $this->getClient();
        $redis->mset($keys);

        $this->assertContains($redis->randomkey(), array_keys($keys));
    }

    /**
     * @group connected
     */
    public function testReturnsNullOnEmptyDatabase(): void
    {
        $redis = $this->getClient();

        $this->assertNull($redis->randomkey());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\RENAMENX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class RENAMENX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\RENAMENX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'RENAMENX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'newkey'];
        $expected = ['key', 'newkey'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(0, $this->getCommand()->parseResponse(0));
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testRenamesKeys(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $this->assertSame(1, $redis->renamenx('foo', 'foofoo'));
        $this->assertSame(0, $redis->exists('foo'));
        $this->assertSame(1, $redis->exists('foofoo'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionWhenRenamingNonExistingKeys(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR no such key');

        $redis = $this->getClient();

        $this->assertSame(0, $redis->renamenx('foo', 'foobar'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\RENAME_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class RENAME_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\RENAME';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'RENAME';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'newkey'];
        $expected = ['key', 'newkey'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     */
    public function testRenamesKeys(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $this->assertEquals('OK', $redis->rename('foo', 'foofoo'));
        $this->assertSame(0, $redis->exists('foo'));
        $this->assertSame(1, $redis->exists('foofoo'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnNonExistingKeys(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR no such key');

        $redis = $this->getClient();

        $redis->rename('foo', 'foobar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\RESTORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class RESTORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\RESTORE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'RESTORE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, "\x00\xC0\n\x06\x00\xF8r?\xC5\xFB\xFB_("];
        $expected = ['key', 0, "\x00\xC0\n\x06\x00\xF8r?\xC5\xFB\xFB_("];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertTrue($this->getCommand()->parseResponse(true));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\RPOPLPUSH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class RPOPLPUSH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\RPOPLPUSH';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'RPOPLPUSH';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key:source', 'key:destination'];
        $expected = ['key:source', 'key:destination'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('element', $this->getCommand()->parseResponse('element'));
    }

    /**
     * @group connected
     */
    public function testReturnsElementPoppedFromSourceAndPushesToDestination(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters:source', 'a', 'b', 'c');

        $this->assertSame('c', $redis->rpoplpush('letters:source', 'letters:destination'));
        $this->assertSame('b', $redis->rpoplpush('letters:source', 'letters:destination'));
        $this->assertSame('a', $redis->rpoplpush('letters:source', 'letters:destination'));

        $this->assertSame([], $redis->lrange('letters:source', 0, -1));
        $this->assertSame(['a', 'b', 'c'], $redis->lrange('letters:destination', 0, -1));
    }

    /**
     * @group connected
     */
    public function testReturnsElementPoppedFromSourceAndPushesToSelf(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters:source', 'a', 'b', 'c');

        $this->assertSame('c', $redis->rpoplpush('letters:source', 'letters:source'));
        $this->assertSame('b', $redis->rpoplpush('letters:source', 'letters:source'));
        $this->assertSame('a', $redis->rpoplpush('letters:source', 'letters:source'));

        $this->assertSame(['a', 'b', 'c'], $redis->lrange('letters:source', 0, -1));
    }

    /**
     * @group connected
     */
    public function testReturnsNullOnEmptySource(): void
    {
        $redis = $this->getClient();

        $this->assertNull($redis->rpoplpush('key:source', 'key:destination'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongTypeOfSourceKey(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('key:source', 'foo');
        $redis->rpoplpush('key:source', 'key:destination');
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongTypeOfDestinationKey(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->rpush('key:source', 'foo');
        $redis->set('key:destination', 'bar');

        $redis->rpoplpush('key:source', 'key:destination');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\RPOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class RPOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\RPOP';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'RPOP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('element', $this->getCommand()->parseResponse('element'));
    }

    /**
     * @group connected
     */
    public function testPopsTheLastElementFromList(): void
    {
        $redis = $this->getClient();

        $redis->rpush('letters', 'a', 'b', 'c', 'd');

        $this->assertSame('d', $redis->rpop('letters'));
        $this->assertSame('c', $redis->rpop('letters'));
        $this->assertSame(['a', 'b'], $redis->lrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testReturnsNullOnEmptyList(): void
    {
        $redis = $this->getClient();

        $this->assertNull($redis->rpop('letters'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->rpop('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\RPUSHX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class RPUSHX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\RPUSHX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'RPUSHX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'value'];
        $expected = ['key', 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testPushesElementsToHeadOfExistingList(): void
    {
        $redis = $this->getClient();

        $redis->rpush('metavars', 'foo');

        $this->assertSame(2, $redis->rpushx('metavars', 'hoge'));
        $this->assertSame(['foo', 'hoge'], $redis->lrange('metavars', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testDoesNotPushElementOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->rpushx('metavars', 'foo'));
        $this->assertSame(0, $redis->rpushx('metavars', 'hoge'));
        $this->assertSame(0, $redis->exists('metavars'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->rpushx('metavars', 'hoge');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\RPUSH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-list
 */
class RPUSH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\RPUSH';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'RPUSH';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'value1', 'value2', 'value3'];
        $expected = ['key', 'value1', 'value2', 'value3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsValuesAsSingleArray(): void
    {
        $arguments = ['key', ['value1', 'value2', 'value3']];
        $expected = ['key', 'value1', 'value2', 'value3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testPushesElementsToHeadOfList(): void
    {
        $redis = $this->getClient();

        // NOTE: List push operations return the list length since Redis commit 520b5a3
        $this->assertSame(1, $redis->rpush('metavars', 'foo'));
        $this->assertSame(2, $redis->rpush('metavars', 'hoge'));
        $this->assertSame(['foo', 'hoge'], $redis->lrange('metavars', 0, -1));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->rpush('metavars', 'hoge');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SADD';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'member1', 'member2', 'member3'];
        $expected = ['key', 'member1', 'member2', 'member3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsValuesAsSingleArray(): void
    {
        $arguments = ['key', ['member1', 'member2', 'member3']];
        $expected = ['key', 'member1', 'member2', 'member3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testAddsMembersToSet(): void
    {
        $redis = $this->getClient();

        $this->assertSame(1, $redis->sadd('letters', 'a'));
        $this->assertSame(2, $redis->sadd('letters', 'b', 'c'));
        $this->assertSame(0, $redis->sadd('letters', 'b'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.4.0
     */
    public function c()
    {
        $redis = $this->getClient();

        $this->assertSame(3, $redis->sadd('letters', 'a', 'b', 'c', 'b'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->sadd('metavars', 'hoge');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SAVE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class SAVE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SAVE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SAVE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertTrue($this->getCommand()->parseResponse(true));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SCAN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class SCAN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SCAN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SCAN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = [0, 'MATCH', 'key:*', 'COUNT', 5];
        $expected = [0, 'MATCH', 'key:*', 'COUNT', 5];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsBasicUsage(): void
    {
        $arguments = [0];
        $expected = [0];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithOptionsArray(): void
    {
        $arguments = [0, ['match' => 'key:*', 'count' => 5]];
        $expected = [0, 'MATCH', 'key:*', 'COUNT', 5];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['3', ['key:1', 'key:2', 'key:3']];
        $expected = ['3', ['key:1', 'key:2', 'key:3']];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithoutMatch(): void
    {
        $kvs = ['key:one' => 'one', 'key:two' => 'two', 'key:three' => 'three', 'key:four' => 'four'];

        $redis = $this->getClient();
        $redis->mset($kvs);

        $response = $redis->scan(0);

        $this->assertSameValues(array_keys($kvs), $response[1]);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithMatchingKeys(): void
    {
        $kvs = ['key:one' => 'one', 'key:two' => 'two', 'key:three' => 'three', 'key:four' => 'four'];

        $redis = $this->getClient();
        $redis->mset($kvs);

        $response = $redis->scan('0', 'MATCH', 'key:t*');

        $this->assertSameValues(['key:two', 'key:three'], $response[1]);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithNoMatchingKeys(): void
    {
        $kvs = ['key:one' => 'one', 'key:two' => 'two', 'key:three' => 'three', 'key:four' => 'four'];

        $redis = $this->getClient();
        $redis->mset($kvs);

        $response = $redis->scan(0, 'MATCH', 'nokey:*');

        $this->assertSame('0', $response[0]);
        $this->assertEmpty($response[1]);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SCARD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SCARD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SCARD';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SCARD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testReturnsNumberOfMembers(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters', 'a', 'b', 'c', 'd');

        $this->assertSame(4, $redis->scard('letters'));
    }

    /**
     * @group connected
     */
    public function testReturnsZeroOnEmptySet(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->scard('letters'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('metavars', 'foo');
        $redis->scard('metavars');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SCRIPT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-scripting
 */
class SCRIPT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SCRIPT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SCRIPT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['EXISTS', '9d0c0826bde023cc39eebaaf832c32a890f3b088', 'ffffffffffffffffffffffffffffffffffffffff'];
        $expected = ['EXISTS', '9d0c0826bde023cc39eebaaf832c32a890f3b088', 'ffffffffffffffffffffffffffffffffffffffff'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testExistsReturnsAnArrayOfValues(): void
    {
        $redis = $this->getClient();

        $redis->eval($lua = 'return true', 0);
        $sha1 = sha1($lua);

        $this->assertSame([1, 0], $redis->script('EXISTS', $sha1, 'ffffffffffffffffffffffffffffffffffffffff'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testLoadReturnsHashOfScripts(): void
    {
        $redis = $this->getClient();

        $lua = 'return true';
        $sha1 = sha1($lua);

        $this->assertSame($sha1, $redis->script('LOAD', $lua));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testFlushesExistingScripts(): void
    {
        $redis = $this->getClient();

        $sha1 = $redis->script('LOAD', 'return true');

        $this->assertEquals('OK', $redis->script('FLUSH'));
        $this->assertSame([0], $redis->script('EXISTS', $sha1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testThrowsExceptionOnInvalidSubcommand(): void
    {
        $this->expectException('Predis\Response\ServerException');

        $redis = $this->getClient();

        $redis->script('INVALID');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SDIFFSTORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SDIFFSTORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SDIFFSTORE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SDIFFSTORE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key:destination', 'key:source1', 'key:source:2'];
        $expected = ['key:destination', 'key:source1', 'key:source:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsSourceKeysAsSingleArray(): void
    {
        $arguments = ['key:destination', ['key:source1', 'key:source:2']];
        $expected = ['key:destination', 'key:source1', 'key:source:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testStoresMembersOfSetOnSingleSet(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');

        $this->assertSame(7, $redis->sdiffstore('letters:destination', 'letters:1st'));
        $this->assertSameValues(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->smembers('letters:destination'));
    }

    /**
     * @group connected
     */
    public function testStoresDifferenceOfMultipleSets(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');
        $redis->sadd('letters:2nd', 'a', 'c', 'f', 'g');
        $redis->sadd('letters:3rd', 'a', 'b', 'e', 'f');

        $this->assertSame(3, $redis->sdiffstore('letters:destination', 'letters:1st', 'letters:2nd'));
        $this->assertSameValues(['b', 'd', 'e'], $redis->smembers('letters:destination'));

        $this->assertSame(1, $redis->sdiffstore('letters:destination', 'letters:1st', 'letters:2nd', 'letters:3rd'));
        $this->assertSameValues(['d'], $redis->smembers('letters:destination'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongTypeOfSourceKey(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('set:source', 'foo');
        $redis->sdiffstore('set:destination', 'set:source');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SDIFF_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SDIFF_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SDIFF';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SDIFF';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key1', 'key2', 'key3'];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['key1', 'key2', 'key3']];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['member1', 'member2', 'member3'];
        $expected = ['member1', 'member2', 'member3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testReturnsMembersOnSingleKeyOrNonExistingSetForDifference(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');

        $this->assertSameValues(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->sdiff('letters:1st'));
        $this->assertSameValues(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->sdiff('letters:1st', 'letters:2nd'));
    }

    /**
     * @group connected
     */
    public function testReturnsMembersFromDifferenceAmongSets(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');
        $redis->sadd('letters:2nd', 'a', 'c', 'f', 'g');
        $redis->sadd('letters:3rd', 'a', 'b', 'e', 'f');

        $this->assertSameValues(['b', 'd', 'e'], $redis->sdiff('letters:1st', 'letters:2nd'));
        $this->assertSameValues(['d'], $redis->sdiff('letters:1st', 'letters:2nd', 'letters:3rd'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('set:foo', 'a');
        $redis->sdiff('set:foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SELECT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-connection
 */
class SELECT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SELECT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SELECT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = [10];
        $expected = [10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     */
    public function testCanSelectDifferentDatabase(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');

        $this->assertEquals('OK', $redis->select(REDIS_SERVER_DBNUM + 1));
        $this->assertSame(0, $redis->exists('foo'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnUnexpectedDatabaseRange(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessageMatches('/ERR.*DB index/');

        $redis = $this->getClient();

        $redis->select(100000000);
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testThrowsExceptionOnUnexpectedDatabaseName(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessageMatches('/ERR.*(invalid DB index|value is not an integer or out of range)/');

        $redis = $this->getClient();

        $redis->select('x');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SENTINEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class SENTINEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SENTINEL';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SENTINEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['get-master-addr-by-name', 'predis:master'];
        $expected = ['get-master-addr-by-name', 'predis:master'];

        $command = $this->getCommandWithArgumentsArray($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $expected = ['127.0.0.1', '6379'];
        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($expected));
    }

    /**
     * @group disconnected
     */
    public function testSentinelMastersResponse(): void
    {
        $response = [
            [
                'name', 'predis:master',
                'ip', '127.0.0.1',
                'port', '6379',
                'runid', '89f6128a7e5780aa6ef7d4d7022cfafbf799b3ab',
                'flags', 'master',
                'pending-commands', '0',
                'last-ok-ping-reply', '386',
                'last-ping-reply', '386',
                'info-refresh', '9926',
                'num-slaves', '1',
                'num-other-sentinels', '0',
                'quorum', '2',
            ],
        ];

        $expected = [
            [
                'name' => 'predis:master',
                'ip' => '127.0.0.1',
                'port' => '6379',
                'runid' => '89f6128a7e5780aa6ef7d4d7022cfafbf799b3ab',
                'flags' => 'master',
                'pending-commands' => '0',
                'last-ok-ping-reply' => '386',
                'last-ping-reply' => '386',
                'info-refresh' => '9926',
                'num-slaves' => '1',
                'num-other-sentinels' => '0',
                'quorum' => '2',
            ],
        ];

        $command = $this->getCommandWithArguments('masters');

        $this->assertSame($expected, $command->parseResponse($response));
    }

    /**
     * @group disconnected
     */
    public function testSentinelSlavesResponse(): void
    {
        $response = [
            [
                'name', '127.0.0.1:6380',
                'ip', '127.0.0.1',
                'port', '6380',
                'runid', '92aea60e4fead2507cccd6574e4c7139d401d0ae',
                'flags', 'slave',
                'pending-commands', '0',
                'last-ok-ping-reply', '1011',
                'last-ping-reply', '1011',
                'info-refresh', '4366',
                'master-link-down-time', '0',
                'master-link-status', 'ok',
                'master-host', '127.0.0.1',
                'master-port', '6379',
                'slave-priority', '100',
            ],
        ];

        $expected = [
            [
                'name' => '127.0.0.1:6380',
                'ip' => '127.0.0.1',
                'port' => '6380',
                'runid' => '92aea60e4fead2507cccd6574e4c7139d401d0ae',
                'flags' => 'slave',
                'pending-commands' => '0',
                'last-ok-ping-reply' => '1011',
                'last-ping-reply' => '1011',
                'info-refresh' => '4366',
                'master-link-down-time' => '0',
                'master-link-status' => 'ok',
                'master-host' => '127.0.0.1',
                'master-port' => '6379',
                'slave-priority' => '100',
            ],
        ];

        $command = $this->getCommandWithArguments('slaves', 'predis:master');

        $this->assertSame($expected, $command->parseResponse($response));
    }

    /**
     * @group disconnected
     */
    public function testSentinelIsMasterDownByAddr(): void
    {
        $response = ['0', '7388832d5fdee6a2e301d6bbc5052bd1526d741c'];
        $expected = ['0', '7388832d5fdee6a2e301d6bbc5052bd1526d741c'];

        $command = $this->getCommandWithArguments('is-master-down-by-addr', '127.0.0.1', '6379');

        $this->assertSame($expected, $command->parseResponse($response));
    }

    /**
     * @group disconnected
     */
    public function testSentinelGetMasterAddrByName(): void
    {
        $response = ['127.0.0.1', '6379'];
        $expected = ['127.0.0.1', '6379'];

        $command = $this->getCommandWithArguments('get-master-addr-by-name', 'predis:master');

        $this->assertSame($expected, $command->parseResponse($response));
    }

    /**
     * @group disconnected
     */
    public function testSentinelReset(): void
    {
        $response = 1;
        $expected = 1;

        $command = $this->getCommandWithArguments('reset', 'predis:*');

        $this->assertSame($expected, $command->parseResponse($response));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SETBIT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class SETBIT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SETBIT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SETBIT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 7, 1];
        $expected = ['key', 7, 1];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();
        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testCanSetBitsOfStrings(): void
    {
        $redis = $this->getClient();

        $redis->set('key:binary', "\x80\x00\00\x01");

        $this->assertEquals(1, $redis->setbit('key:binary', 0, 0));
        $this->assertEquals(0, $redis->setbit('key:binary', 0, 0));
        $this->assertEquals("\x00\x00\00\x01", $redis->get('key:binary'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testCreatesNewKeyOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->setbit('key:binary', 31, 1));
        $this->assertSame(0, $redis->setbit('key:binary', 0, 1));
        $this->assertSame(4, $redis->strlen('key:binary'));
        $this->assertSame("\x80\x00\00\x01", $redis->get('key:binary'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnInvalidBitValue(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR bit is not an integer or out of range');

        $this->getClient()->setbit('key:binary', 10, 255);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnNegativeOffset(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR bit offset is not an integer or out of range');

        $this->getClient()->setbit('key:binary', -1, 1);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnInvalidOffset(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR bit offset is not an integer or out of range');

        $this->getClient()->setbit('key:binary', 'invalid', 1);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->setbit('metavars', 0, 1);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SETEX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class SETEX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SETEX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SETEX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 10, 'hello'];
        $expected = ['key', 10, 'hello'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCreatesNewKeyAndSetsTTL(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->setex('foo', 10, 'bar'));
        $this->assertSame(1, $redis->exists('foo'));
        $this->assertSame(10, $redis->ttl('foo'));
    }

    /**
     * @medium
     * @group connected
     * @group slow
     * @requiresRedisVersion >= 2.0.0
     */
    public function testKeyExpiresAfterTTL(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->setex('foo', 1, 'bar'));

        $this->sleep(2.0);
        $this->assertSame(0, $redis->exists('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonIntegerTTL(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR value is not an integer or out of range');

        $this->getClient()->setex('foo', 2.5, 'bar');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnZeroTTL(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR invalid expire time');

        $this->getClient()->setex('foo', 0, 'bar');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNegativeTTL(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR invalid expire time');

        $this->getClient()->setex('foo', -10, 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SETNX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class SETNX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SETNX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SETNX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['foo', 'bar'];
        $expected = ['foo', 'bar'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(0, $this->getCommand()->parseResponse(0));
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testSetStringValue(): void
    {
        $redis = $this->getClient();

        $this->assertSame(1, $redis->setnx('foo', 'bar'));
        $this->assertSame(0, $redis->setnx('foo', 'barbar'));
        $this->assertEquals('bar', $redis->get('foo'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SETRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class SETRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SETRANGE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SETRANGE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 5, 'range'];
        $expected = ['key', 5, 'range'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(10, $this->getCommand()->parseResponse(10));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testCreatesNewKeyOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertSame(3, $redis->setrange('foo', 0, 'bar'));
        $this->assertSame('bar', $redis->get('foo'));

        $this->assertSame(8, $redis->setrange('hoge', 4, 'piyo'));
        $this->assertSame("\x00\x00\x00\x00piyo", $redis->get('hoge'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testOverwritesOrAppendBytesInKeys(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'barbar');

        $this->assertSame(6, $redis->setrange('foo', 3, 'baz'));
        $this->assertSame('barbaz', $redis->get('foo'));

        $this->assertEquals(16, $redis->setrange('foo', 10, 'foofoo'));
        $this->assertEquals("barbaz\x00\x00\x00\x00foofoo", $redis->get('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testHandlesBinaryData(): void
    {
        $redis = $this->getClient();

        $this->assertSame(4, $redis->setrange('key:binary', 0, pack('i', -2147483648)));

        [$unpacked] = array_values(unpack('i', $redis->get('key:binary')));
        $this->assertEquals(-2147483648, $unpacked);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnInvalidOffset(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR offset is out of range');

        $this->getClient()->setrange('var', -1, 'bogus');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->setrange('metavars', 3, 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class SET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SET';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['foo', 'bar'];
        $expected = ['foo', 'bar'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsRedisWithModifiers(): void
    {
        $arguments = ['foo', 'bar', 'EX', '10', 'NX'];
        $expected = ['foo', 'bar', 'EX', '10', 'NX'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     */
    public function testSetStringValue(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar'));
        $this->assertSame(1, $redis->exists('foo'));
        $this->assertSame('bar', $redis->get('foo'));
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testSetStringValueUsingCluster(): void
    {
        $this->testSetStringValue();
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.12
     */
    public function testSetStringValueWithModifierEX(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar', 'ex', 1));
        $this->assertSame(1, $redis->ttl('foo'));
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testSetStringValueWithModifierEXUsingCluster(): void
    {
        $this->testSetStringValueWithModifierEX();
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.12
     */
    public function testSetStringValueWithModifierPX(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar', 'px', 1000));

        $pttl = $redis->pttl('foo');
        $this->assertGreaterThan(0, $pttl);
        $this->assertLessThanOrEqual(1000, $pttl);
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testSetStringValueWithModifierPXUsingCluster(): void
    {
        $this->testSetStringValueWithModifierPX();
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.12
     */
    public function testSetStringValueWithModifierNX(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar', 'NX'));
        $this->assertNull($redis->set('foo', 'bar', 'NX'));
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testSetStringValueWithModifierNXUsingCluster(): void
    {
        $this->testSetStringValueWithModifierNX();
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.12
     */
    public function testSetStringValueWithModifierXX(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar'));

        $this->assertEquals('OK', $redis->set('foo', 'barbar', 'XX'));
        $this->assertNull($redis->set('foofoo', 'barbar', 'XX'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.12
     */
    public function testSetStringDoesNotFailWithExplicitlySetNullArguments(): void
    {
        $redis = $this->getClient();

        $this->assertEquals(
            'OK', $redis->set('foo', 'barbar', null, null, null)
        );
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.12
     */
    public function testSetNull(): void
    {
        $redis = $this->getClient();

        $this->assertEquals(
            'OK', $redis->set('foo', null)
        );
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.12
     */
    public function testSetFalse(): void
    {
        $redis = $this->getClient();

        $this->assertEquals(
            'OK', $redis->set('foo', false)
        );
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 6.0.0
     */
    public function testSetStringValueWithModifierXXUsingCluster(): void
    {
        $this->testSetStringValueWithModifierXX();
    }

    /**
     * @group connected
     * @group cluster
     * @requiresRedisVersion >= 3.0.0
     */
    public function testSetStringValueInClusterMode(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SHUTDOWN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class SHUTDOWN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SHUTDOWN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SHUTDOWN';
    }

    /**
     * @dataProvider argumentsProvider
     * @group disconnected
     */
    public function testFilterArguments(array $actualArguments, array $expectedResponse): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedResponse, $command->getArguments());
    }

    public function argumentsProvider(): array
    {
        return [
            'with no arguments' => [
                [],
                [],
            ],
            'with SAVE argument' => [
                [true],
                ['SAVE'],
            ],
            'with NOSAVE argument' => [
                [false],
                ['NOSAVE'],
            ],
            'with NOW argument' => [
                [null, true],
                ['NOW'],
            ],
            'with FORCE argument' => [
                [null, false, true],
                ['FORCE'],
            ],
            'with ABORT argument' => [
                [null, false, false, true],
                ['ABORT'],
            ],
            'with all arguments' => [
                [true, true, true, true],
                ['SAVE', 'NOW', 'FORCE', 'ABORT'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SINTERCARD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-set
 */
class SINTERCARD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return SINTERCARD::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SINTERCARD';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider setsProvider
     * @param  array $firstSet
     * @param  array $secondSet
     * @param  array $keys
     * @param  int   $limit
     * @param  int   $expectedCardinality
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testReturnsCorrectCardinalityOfGivenSetIntersection(
        array $firstSet,
        array $secondSet,
        array $keys,
        int $limit,
        int $expectedCardinality
    ): void {
        $redis = $this->getClient();

        $redis->sadd(...$firstSet);
        $redis->sadd(...$secondSet);

        $this->assertSame($expectedCardinality, $redis->sintercard($keys, $limit));
    }

    /**
     * @group connected
     * @dataProvider unexpectedValuesProvider
     * @param  array  $arguments
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testThrowsExceptionOnUnexpectedValuesGiven(
        array $arguments,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->sintercard(...$arguments);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('sintercard', 'a');
        $redis->sintercard(['sintercard']);
    }

    public function argumentsProvider(): array
    {
        return [
            'with required arguments' => [
                [['key1', 'key2']],
                [2, 'key1', 'key2'],
            ],
            'with default arguments' => [
                [['key1', 'key2'], 0],
                [2, 'key1', 'key2', 'LIMIT', 0],
            ],
            'with non-default LIMIT' => [
                [['key1', 'key2'], 2],
                [2, 'key1', 'key2', 'LIMIT', 2],
            ],
        ];
    }

    public function setsProvider(): array
    {
        return [
            'with full intersection' => [
                ['key1', 'member1', 'member2', 'member3'],
                ['key2', 'member1', 'member2', 'member3'],
                ['key1', 'key2'],
                0,
                3,
            ],
            'with partial intersection' => [
                ['key1', 'member1', 'member2', 'member3'],
                ['key2', 'member1', 'member4', 'member5'],
                ['key1', 'key2'],
                0,
                1,
            ],
            'with no intersection' => [
                ['key1', 'member1', 'member2', 'member3'],
                ['key2', 'member4', 'member5', 'member6'],
                ['key1', 'key2'],
                0,
                0,
            ],
            'with no intersection on non-existing key' => [
                ['key1', 'member1', 'member2', 'member3'],
                ['key2', 'member1', 'member2', 'member3'],
                ['key1', 'key3'],
                0,
                0,
            ],
            'with non-default LIMIT' => [
                ['key1', 'member1', 'member2', 'member3'],
                ['key2', 'member1', 'member2', 'member3'],
                ['key1', 'key2'],
                1,
                1,
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'with wrong keys argument' => [
                ['key1', 0],
                'Wrong keys argument type or position offset',
            ],
            'with wrong limit argument' => [
                [['key1'], 'wrong'],
                'Wrong limit argument type',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SINTERSTORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SINTERSTORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SINTERSTORE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SINTERSTORE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key:destination', 'key:source1', 'key:source:2'];
        $expected = ['key:destination', 'key:source1', 'key:source:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsSourceKeysAsSingleArray(): void
    {
        $arguments = ['key:destination', ['key:source1', 'key:source:2']];
        $expected = ['key:destination', 'key:source1', 'key:source:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testStoresMembersOfSetOnSingleKey(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');

        $this->assertSame(7, $redis->sinterstore('letters:destination', 'letters:1st'));
        $this->assertSameValues(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->smembers('letters:destination'));
    }

    /**
     * @group connected
     */
    public function testDoesNotStoreOnNonExistingSetForIntersection(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');

        $this->assertSame(0, $redis->sinterstore('letters:destination', 'letters:1st', 'letters:2nd'));
        $this->assertSame(0, $redis->exists('letters:destination'));
    }

    /**
     * @group connected
     */
    public function testStoresIntersectionOfMultipleSets(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');
        $redis->sadd('letters:2nd', 'a', 'c', 'f', 'g');
        $redis->sadd('letters:3rd', 'a', 'b', 'e', 'f');

        $this->assertSame(4, $redis->sinterstore('letters:destination', 'letters:1st', 'letters:2nd'));
        $this->assertSameValues(['a', 'c', 'f', 'g'], $redis->smembers('letters:destination'));

        $this->assertSame(2, $redis->sinterstore('letters:destination', 'letters:1st', 'letters:2nd', 'letters:3rd'));
        $this->assertSameValues(['a', 'f'], $redis->smembers('letters:destination'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongTypeOfSourceKey(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('set:source', 'foo');
        $redis->sinterstore('set:destination', 'set:source');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SINTER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SINTER_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SINTER';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SINTER';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key1', 'key2', 'key3'];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['key1', 'key2', 'key3']];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['member1', 'member2', 'member3'];
        $expected = ['member1', 'member2', 'member3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testReturnsMembersOfSetOnSingleKey(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');

        $this->assertSameValues(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->sinter('letters:1st'));
    }

    /**
     * @group connected
     */
    public function testReturnsEmptyArrayOnNonExistingSetForIntersection(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');

        $this->assertSameValues([], $redis->sinter('letters:1st', 'letters:2nd'));
    }

    /**
     * @group connected
     */
    public function testReturnsMembersFromIntersectionAmongSets(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');
        $redis->sadd('letters:2nd', 'a', 'c', 'f', 'g');
        $redis->sadd('letters:3rd', 'a', 'b', 'e', 'f');

        $this->assertSameValues(['a', 'c', 'f', 'g'], $redis->sinter('letters:1st', 'letters:2nd'));
        $this->assertSameValues(['a', 'f'], $redis->sinter('letters:1st', 'letters:2nd', 'letters:3rd'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('set:foo', 'a');
        $redis->sinter('set:foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SISMEMBER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SISMEMBER_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SISMEMBER';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SISMEMBER';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'member'];
        $expected = ['key', 'member'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testReturnsMemberExistenceInSet(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters', 'a', 'b', 'c');

        $this->assertSame(1, $redis->sismember('letters', 'a'));
        $this->assertSame(0, $redis->sismember('letters', 'z'));
    }

    /**
     * @group connected
     */
    public function testReturnsZeroOnNonExistingSet(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->sismember('letters', 'a'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->sismember('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SLAVEOF_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class SLAVEOF_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SLAVEOF';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SLAVEOF';
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsHostPortArray(): void
    {
        $arguments = ['127.0.0.1', '80'];
        $expected = ['127.0.0.1', '80'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsNoOneArray(): void
    {
        $arguments = ['NO', 'ONE'];
        $expected = ['NO', 'ONE'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsNoOneString(): void
    {
        $arguments = ['NO ONE'];
        $expected = ['NO', 'ONE'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertTrue($this->getCommand()->parseResponse(true));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SLOWLOG_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * In order to support the output of SLOWLOG, the backend connection must be
 * able to parse nested multibulk responses deeper than 2 levels.
 *
 * @group commands
 * @group realm-server
 */
class SLOWLOG_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SLOWLOG';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SLOWLOG';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['GET', '2'];
        $expected = ['GET', '2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * This is the response type for SLOWLOG GET.
     *
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = [[0, 1323163469, 12451, ['SORT', 'list:unordered']]];
        $expected = [
            [
                'id' => 0,
                'timestamp' => 1323163469,
                'duration' => 12451,
                'command' => ['SORT', 'list:unordered'],
            ],
        ];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * This is the response type for SLOWLOG LEN.
     *
     * @group disconnected
     */
    public function testParseResponseInteger(): void
    {
        $command = $this->getCommand();

        $this->assertSame(10, $command->parseResponse(10));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.12
     */
    public function testReturnsAnArrayOfLoggedCommands(): void
    {
        $redis = $this->getClient();

        $config = $redis->config('get', 'slowlog-log-slower-than');
        $threshold = array_pop($config);

        $redis->config('set', 'slowlog-log-slower-than', 0);
        $redis->set('foo', 'bar');

        $this->assertIsArray($slowlog = $redis->slowlog('GET'));
        $this->assertGreaterThan(0, count($slowlog));

        $this->assertIsArray($slowlog[0]);
        $this->assertGreaterThan(0, $slowlog[0]['id']);
        $this->assertGreaterThan(0, $slowlog[0]['timestamp']);
        $this->assertGreaterThanOrEqual(0, $slowlog[0]['duration']);
        $this->assertIsArray($slowlog[0]['command']);

        $redis->config('set', 'slowlog-log-slower-than', $threshold);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.12
     */
    public function testCanResetTheLog(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->slowlog('RESET'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.12
     */
    public function testThrowsExceptionOnInvalidSubcommand(): void
    {
        $this->expectException('Predis\Response\ServerException');

        $redis = $this->getClient();

        $redis->slowlog('INVALID');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SMEMBERS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SMEMBERS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SMEMBERS';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SMEMBERS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['member1', 'member2', 'member3'];
        $expected = ['member1', 'member2', 'member3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testReturnsEmptyArrayOnNonExistingSet(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters', 'a', 'b', 'c', 'd', 'e');

        $this->assertSameValues(['a', 'b', 'c', 'd', 'e'], $redis->smembers('letters'));
        $this->assertSame([], $redis->smembers('digits'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->smembers('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SMISMEMBER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-hash
 */
class SMISMEMBER_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return SMISMEMBER::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SMISMEMBER';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'member1', 'member2'];
        $expected = ['key', 'member1', 'member2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider membersProvider
     * @param  array  $set
     * @param  string $key
     * @param  array  $members
     * @param  array  $expectedResponse
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsCorrectResponseIfMemberBelongsToSet(
        array $set,
        string $key,
        array $members,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->sadd(...$set);

        $this->assertSame($expectedResponse, $redis->smismember($key, ...$members));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->sismember('foo', 'member1');
    }

    public function membersProvider(): array
    {
        return [
            'with one member - belongs to set' => [
                ['key', 'member1'],
                'key',
                ['member1'],
                [1],
            ],
            'with one member - does not belongs to set' => [
                ['key', 'member1'],
                'key',
                ['member2'],
                [0],
            ],
            'with multiple members - belongs to set' => [
                ['key', 'member1', 'member2'],
                'key',
                ['member1', 'member2'],
                [1, 1],
            ],
            'with multiple members - partially belongs to set' => [
                ['key', 'member1', 'member2'],
                'key',
                ['member1', 'member3'],
                [1, 0],
            ],
            'with multiple members - does not belongs to set' => [
                ['key', 'member1', 'member2'],
                'key',
                ['member3', 'member4'],
                [0, 0],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SMOVE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SMOVE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SMOVE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SMOVE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key:source', 'key:destination', 'member'];
        $expected = ['key:source', 'key:destination', 'member'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(0, $command->parseResponse(0));
        $this->assertSame(1, $command->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testReturnsMemberExistenceInSet(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:source', 'a', 'b', 'c');

        $this->assertSame(1, $redis->smove('letters:source', 'letters:destination', 'b'));
        $this->assertSame(0, $redis->smove('letters:source', 'letters:destination', 'z'));

        $this->assertSameValues(['a', 'c'], $redis->smembers('letters:source'));
        $this->assertSameValues(['b'], $redis->smembers('letters:destination'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongTypeOfSourceKey(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('set:source', 'foo');
        $redis->sadd('set:destination', 'bar');
        $redis->smove('set:destination', 'set:source', 'foo');
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongTypeOfDestinationKey(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->sadd('set:source', 'foo');
        $redis->set('set:destination', 'bar');
        $redis->smove('set:destination', 'set:source', 'foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SORT_RO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Command\Argument\Server\LimitOffsetCount;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-set
 */
class SORT_RO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return SORT_RO::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SORT_RO';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider listProvider
     * @param  array $listArguments
     * @param  array $sortArguments
     * @param  array $expectedSortedResponse
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testSortItemsWithinGivenList(
        array $listArguments,
        array $sortArguments,
        array $expectedSortedResponse
    ): void {
        $redis = $this->getClient();

        $redis->lpush(...$listArguments);

        $this->assertSame($expectedSortedResponse, $redis->sort_ro(...$sortArguments));
    }

    /**
     * @group connected
     * @dataProvider listsProvider
     * @param  array $localKeys
     * @param  array $externalKeys
     * @param  array $sortArguments
     * @param  array $expectedSortedResponse
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testSortItemsWithExternalKeysWithinGivenList(
        array $localKeys,
        array $externalKeys,
        array $sortArguments,
        array $expectedSortedResponse
    ): void {
        $redis = $this->getClient();

        $redis->lpush(...$localKeys);
        $redis->mset(...$externalKeys);

        $this->assertSame($expectedSortedResponse, $redis->sort_ro(...$sortArguments));
    }

    /**
     * @group connected
     * @dataProvider unexpectedValuesProvider
     * @param  array  $arguments
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(
        array $arguments,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->sort_ro(...$arguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key'],
                ['key'],
            ],
            'with BY argument' => [
                ['key', 'pattern'],
                ['key', 'BY', 'pattern'],
            ],
            'with LIMIT argument' => [
                ['key', null, new LimitOffsetCount(0, 1)],
                ['key', 'LIMIT', 0, 1],
            ],
            'with GET patterns' => [
                ['key', null, null, ['pattern1', 'pattern2']],
                ['key', 'GET', 'pattern1', 'GET', 'pattern2'],
            ],
            'with sorting argument - ASC' => [
                ['key', null, null, [], 'asc'],
                ['key', 'ASC'],
            ],
            'with sorting argument - DESC' => [
                ['key', null, null, [], 'desc'],
                ['key', 'DESC'],
            ],
            'with ALPHA argument' => [
                ['key', null, null, [], null, true],
                ['key', 'ALPHA'],
            ],
            'with all arguments argument' => [
                ['key', 'pattern', new LimitOffsetCount(0, 1), ['pattern1', 'pattern2'], 'asc', true],
                ['key', 'BY', 'pattern', 'LIMIT', 0, 1, 'GET', 'pattern1', 'GET', 'pattern2', 'ASC', 'ALPHA'],
            ],
        ];
    }

    public function listProvider(): array
    {
        return [
            'without any modifiers' => [
                ['key', 2, 1],
                ['key', null, null, [], null, false],
                ['1', '2'],
            ],
            'with LIMIT modifier' => [
                ['key', 2, 1, 4, 15, 3, 36],
                ['key', null, new LimitOffsetCount(1, 2), [], null, false],
                ['2', '3'],
            ],
            'with sorting - ASC' => [
                ['key', 2, 1],
                ['key', null, null, [], 'asc', false],
                ['1', '2'],
            ],
            'with sorting - DESC' => [
                ['key', 2, 1],
                ['key', null, null, [], 'desc', false],
                ['2', '1'],
            ],
            'with sorting lexicographically' => [
                ['key', 'abc', 'aab', 'abb'],
                ['key', null, null, [], null, true],
                ['aab', 'abb', 'abc'],
            ],
            'with all arguments for single list' => [
                ['key', 'abc', 'aab', 'abb'],
                ['key', null, new LimitOffsetCount(0, 2), [], 'desc', true],
                ['abc', 'abb'],
            ],
        ];
    }

    public function listsProvider(): array
    {
        return [
            'sorted by external keys - returns local keys' => [
                ['uid', 1, 2, 3, 4, 5],
                ['points_1', 500, 'points_2', 200, 'points_3', 300, 'points_4', 400, 'points_5', 100],
                ['uid', 'points_*', null, [], null, false],
                ['5', '2', '3', '4', '1'],
            ],
            'sorted by external keys - returns external keys' => [
                ['uid', 1, 2, 3, 4, 5],
                [
                    'points_1', 500, 'points_2', 200, 'points_3', 300, 'points_4', 400, 'points_5', 100,
                    'user_1', 'User1', 'user_2', 'User2', 'user_3', 'User3', 'user_4', 'User4', 'user_5', 'User5',
                ],
                ['uid', 'points_*', null, ['user_*'], null, false],
                ['User5', 'User2', 'User3', 'User4', 'User1'],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'wrong GET argument type' => [
                ['key', null, null, 'wrong', null, false],
                'Wrong get argument type',
            ],
            'wrong sorting argument type' => [
                ['key', null, null, [], 'wrong', false],
                'Sorting argument accepts only: asc, desc values',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SORT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Client;

/**
 * @group commands
 * @group realm-key
 */
class SORT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SORT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SORT';
    }

    /**
     * Utility method to to an LPUSH of some unordered values on a key.
     *
     * @param Client $redis Redis client instance.
     * @param string $key   Target key
     *
     * @return array
     */
    protected function lpushUnorderedList(Client $redis, $key)
    {
        $list = [2, 100, 3, 1, 30, 10];
        $redis->lpush($key, $list);

        return $list;
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $modifiers = [
            'by' => 'by_key_*',
            'limit' => [1, 4],
            'get' => ['object_*', '#'],
            'sort' => 'asc',
            'alpha' => true,
            'store' => 'destination_key',
        ];
        $arguments = ['key', $modifiers];

        $expected = [
            'key', 'BY', 'by_key_*', 'GET', 'object_*', 'GET', '#',
            'LIMIT', 1, 4, 'ASC', 'ALPHA', 'STORE', 'destination_key',
        ];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertEquals($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testGetModifierCanBeString(): void
    {
        $arguments = ['key', ['get' => '#']];
        $expected = ['key', 'GET', '#'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['value1', 'value2', 'value3'];
        $expected = ['value1', 'value2', 'value3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testBasicSort(): void
    {
        $redis = $this->getClient();
        $redis->lpush('list:unordered', $unordered = [2, 100, 3, 1, 30, 10]);

        $this->assertEquals([1, 2, 3, 10, 30, 100], $redis->sort('list:unordered'));
    }

    /**
     * @group connected
     */
    public function testSortWithAscOrDescModifier(): void
    {
        $redis = $this->getClient();
        $redis->lpush('list:unordered', $unordered = [2, 100, 3, 1, 30, 10]);

        $this->assertEquals(
            [100, 30, 10, 3, 2, 1],
            $redis->sort('list:unordered', [
                'sort' => 'desc',
            ])
        );

        $this->assertEquals(
            [1, 2, 3, 10, 30, 100],
            $redis->sort('list:unordered', [
                'sort' => 'asc',
            ])
        );
    }

    /**
     * @group connected
     */
    public function testSortWithLimitModifier(): void
    {
        $redis = $this->getClient();
        $redis->lpush('list:unordered', $unordered = [2, 100, 3, 1, 30, 10]);

        $this->assertEquals(
            [1, 2, 3],
            $redis->sort('list:unordered', [
                'limit' => [0, 3],
            ])
        );

        $this->assertEquals(
            [10, 30],
            $redis->sort('list:unordered', [
                'limit' => [3, 2],
            ])
        );
    }

    /**
     * @group connected
     */
    public function testSortWithAlphaModifier(): void
    {
        $redis = $this->getClient();
        $redis->lpush('list:unordered', $unordered = [2, 100, 3, 1, 30, 10]);

        $this->assertEquals(
            [1, 10, 100, 2, 3, 30],
            $redis->sort('list:unordered', [
                'alpha' => true,
            ])
        );
    }

    /**
     * @group connected
     */
    public function testSortWithStoreModifier(): void
    {
        $redis = $this->getClient();
        $redis->lpush('list:unordered', $unordered = [2, 100, 3, 1, 30, 10]);

        $this->assertCount(
            $redis->sort('list:unordered', [
                'store' => 'list:ordered',
            ]),
            $unordered
        );

        $this->assertEquals([1, 2, 3, 10, 30, 100], $redis->lrange('list:ordered', 0, -1));
    }

    /**
     * @group connected
     */
    public function testSortWithCombinedModifiers(): void
    {
        $redis = $this->getClient();
        $redis->lpush('list:unordered', $unordered = [2, 100, 3, 1, 30, 10]);

        $this->assertEquals(
            [30, 10, 3, 2],
            $redis->sort('list:unordered', [
                'alpha' => false,
                'sort' => 'desc',
                'limit' => [1, 4],
            ])
        );
    }

    /**
     * @group connected
     */
    public function testSortWithGetModifiers(): void
    {
        $redis = $this->getClient();
        $redis->lpush('list:unordered', $unordered = [2, 100, 3, 1, 30, 10]);

        $redis->rpush('list:uids', $uids = [1003, 1001, 1002, 1000]);
        $redis->mset($sortget = [
            'uid:1000' => 'foo',  'uid:1001' => 'bar',
            'uid:1002' => 'hoge', 'uid:1003' => 'piyo',
        ]);

        $this->assertEquals(array_values($sortget), $redis->sort('list:uids', ['get' => 'uid:*']));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->sort('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SPOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SPOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SPOP';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SPOP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 2];
        $expected = ['key', 2];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('member', $this->getCommand()->parseResponse('member'));
    }

    /**
     * @group connected
     */
    public function testPopsRandomMemberFromSet(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters', 'a', 'b');

        $this->assertContains($redis->spop('letters'), ['a', 'b']);
        $this->assertContains($redis->spop('letters'), ['a', 'b']);

        $this->assertNull($redis->spop('letters'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.2.0
     */
    public function testPopsMoreRandomMembersFromSet(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters', 'a', 'b', 'c');

        $this->assertSameValues(['a', 'b', 'c'], $redis->spop('letters', 3));
        $this->assertEmpty($redis->spop('letters', 3));

        $this->assertNull($redis->spop('letters'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->spop('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SRANDMEMBER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SRANDMEMBER_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SRANDMEMBER';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SRANDMEMBER';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 1];
        $expected = ['key', 1];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('member', $this->getCommand()->parseResponse('member'));
    }

    /**
     * @group connected
     */
    public function testReturnsRandomMemberFromSet(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters', 'a', 'b');

        $this->assertContains($redis->srandmember('letters'), ['a', 'b']);
        $this->assertContains($redis->srandmember('letters'), ['a', 'b']);

        $this->assertSame(2, $redis->scard('letters'));
    }

    /**
     * @group connected
     */
    public function testReturnsNullOnNonExistingSet(): void
    {
        $this->assertNull($this->getClient()->srandmember('letters'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->srandmember('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SREM_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SREM_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SREM';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SREM';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'member1', 'member2', 'member3'];
        $expected = ['key', 'member1', 'member2', 'member3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsMembersAsSingleArray(): void
    {
        $arguments = ['key', ['member1', 'member2', 'member3']];
        $expected = ['key', 'member1', 'member2', 'member3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testRemovesMembersFromSet(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters', 'a', 'b', 'c', 'd');

        $this->assertSame(1, $redis->srem('letters', 'b'));
        $this->assertSame(1, $redis->srem('letters', 'd', 'z'));
        $this->assertSameValues(['a', 'c'], $redis->smembers('letters'));

        $this->assertSame(0, $redis->srem('digits', 1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.4.0
     */
    public function testRemovesMembersFromSetVariadic(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters', 'a', 'b', 'c', 'd');

        $this->assertSame(2, $redis->srem('letters', 'b', 'd', 'z'));
        $this->assertSameValues(['a', 'c'], $redis->smembers('letters'));

        $this->assertSame(0, $redis->srem('digits', 1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.4.0
     */
    public function testRemovesMembersInArrayTypeFromSetVariadic(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters', 'a', 'b', 'c', 'd');

        $this->assertSame(2, $redis->srem('letters', ['b', 'd', 'z']));
        $this->assertSameValues(['a', 'c'], $redis->smembers('letters'));

        $this->assertSame(0, $redis->srem('digits', [1]));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->srem('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SSCAN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SSCAN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SSCAN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SSCAN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, 'MATCH', 'member:*', 'COUNT', 10];
        $expected = ['key', 0, 'MATCH', 'member:*', 'COUNT', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsBasicUsage(): void
    {
        $arguments = ['key', 0];
        $expected = ['key', 0];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithOptionsArray(): void
    {
        $arguments = ['key', 0, ['match' => 'member:*', 'count' => 10]];
        $expected = ['key', 0, 'MATCH', 'member:*', 'COUNT', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['3', ['member:1', 'member:2', 'member:3']];
        $expected = ['3', ['member:1', 'member:2', 'member:3']];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithoutMatch(): void
    {
        $redis = $this->getClient();
        $redis->sadd('key', $members = ['member:one', 'member:two', 'member:three', 'member:four']);

        $response = $redis->sscan('key', 0);

        $this->assertSame('0', $response[0]);
        $this->assertSameValues($members, $response[1]);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithMatchingMembers(): void
    {
        $redis = $this->getClient();
        $redis->sadd('key', $members = ['member:one', 'member:two', 'member:three', 'member:four']);

        $response = $redis->sscan('key', 0, 'MATCH', 'member:t*');

        $this->assertSameValues(['member:two', 'member:three'], $response[1]);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithNoMatchingMembers(): void
    {
        $redis = $this->getClient();
        $redis->sadd('key', $members = ['member:one', 'member:two', 'member:three', 'member:four']);

        $response = $redis->sscan('key', 0, 'MATCH', 'nomember:*');

        $this->assertSame('0', $response[0]);
        $this->assertEmpty($response[1]);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\STRLEN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-string
 */
class STRLEN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\STRLEN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'STRLEN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(4, $this->getCommand()->parseResponse(4));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testReturnsTheLengthOfString(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $this->assertSame(3, $redis->strlen('foo'));

        $redis->append('foo', 'bar');
        $this->assertSame(6, $redis->strlen('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testReturnsZeroOnNonExistingKeys(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->strlen('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->lpush('metavars', 'foo');
        $redis->strlen('metavars');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SUBSCRIBE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-pubsub
 * @group relay-incompatible
 */
class SUBSCRIBE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SUBSCRIBE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SUBSCRIBE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['channel:foo', 'channel:bar'];
        $expected = ['channel:foo', 'channel:bar'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['channel:foo', 'channel:bar']];
        $expected = ['channel:foo', 'channel:bar'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['subscribe', 'channel', 1];
        $expected = ['subscribe', 'channel', 1];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsTheFirstSubscribedChannelDetails(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['subscribe', 'channel', 1], $redis->subscribe('channel'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCanSendSubscribeAfterSubscribe(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['subscribe', 'channel:foo', 1], $redis->subscribe('channel:foo'));
        $this->assertSame(['subscribe', 'channel:bar', 2], $redis->subscribe('channel:bar'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCanSendPsubscribeAfterSubscribe(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['subscribe', 'channel:foo', 1], $redis->subscribe('channel:foo'));
        $this->assertSame(['psubscribe', 'channel:*', 2], $redis->psubscribe('channel:*'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCanSendUnsubscribeAfterSubscribe(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['subscribe', 'channel:foo', 1], $redis->subscribe('channel:foo'));
        $this->assertSame(['subscribe', 'channel:bar', 2], $redis->subscribe('channel:bar'));
        $this->assertSame(['unsubscribe', 'channel:foo', 1], $redis->unsubscribe('channel:foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCanSendPunsubscribeAfterSubscribe(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['subscribe', 'channel:foo', 1], $redis->subscribe('channel:foo'));
        $this->assertSame(['subscribe', 'channel:bar', 2], $redis->subscribe('channel:bar'));
        $this->assertSame(['punsubscribe', 'channel:*', 2], $redis->punsubscribe('channel:*'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCanSendQuitAfterSubscribe(): void
    {
        $redis = $this->getClient();
        $quit = $this->getCommandFactory()->create('quit');

        $this->assertSame(['subscribe', 'channel:foo', 1], $redis->subscribe('channel:foo'));
        $this->assertEquals('OK', $redis->executeCommand($quit));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testCannotSendOtherCommandsAfterSubscribe(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessageMatches('/ERR.*only .* allowed in this context/');

        $redis = $this->getClient();

        $redis->subscribe('channel:foo');
        $redis->set('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SUBSTR_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * SUBSTR is actually the old name of GETRANGE in version of Redis <= 2.0.
 * This command should be considered obsolete and we will perform any kind
 * of tests against a Redis server for this one.
 *
 * @group commands
 * @group realm-string
 */
class SUBSTR_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SUBSTR';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SUBSTR';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 5, 10];
        $expected = ['key', 5, 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('substring', $this->getCommand()->parseResponse('substring'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SUNIONSTORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SUNIONSTORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SUNIONSTORE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SUNIONSTORE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key:destination', 'key:source1', 'key:source:2'];
        $expected = ['key:destination', 'key:source1', 'key:source:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsSourceKeysAsSingleArray(): void
    {
        $arguments = ['key:destination', ['key:source1', 'key:source:2']];
        $expected = ['key:destination', 'key:source1', 'key:source:2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testStoresMembersOfSetOnSingleSet(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');

        $this->assertSame(7, $redis->sunionstore('letters:destination', 'letters:1st'));
        $this->assertSameValues(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->smembers('letters:destination'));
    }

    /**
     * @group connected
     */
    public function testStoresUnionOfMultipleSets(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'b', 'd', 'f');
        $redis->sadd('letters:2nd', 'a', 'c', 'g');
        $redis->sadd('letters:3rd', 'a', 'e', 'f');

        $this->assertSame(5, $redis->sunionstore('letters:destination', 'letters:2nd', 'letters:3rd'));
        $this->assertSameValues(['a', 'c', 'e', 'f', 'g'], $redis->smembers('letters:destination'));

        $this->assertSame(7, $redis->sunionstore('letters:destination', 'letters:1st', 'letters:2nd', 'letters:3rd'));
        $this->assertSameValues(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->smembers('letters:destination'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongTypeOfSourceKey(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('set:source', 'foo');
        $redis->sunionstore('set:destination', 'set:source');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\SUNION_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-set
 */
class SUNION_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\SUNION';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'SUNION';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key1', 'key2', 'key3'];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['key1', 'key2', 'key3']];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['member1', 'member2', 'member3'];
        $expected = ['member1', 'member2', 'member3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     */
    public function testReturnsMembersOnSingleKeyOrNonExistingSetForUnion(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'a', 'b', 'c', 'd', 'e', 'f', 'g');

        $this->assertSameValues(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->sunion('letters:1st'));
        $this->assertSameValues(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->sunion('letters:1st', 'letters:2nd'));
    }

    /**
     * @group connected
     */
    public function testReturnsMembersFromDifferenceAmongSets(): void
    {
        $redis = $this->getClient();

        $redis->sadd('letters:1st', 'b', 'd', 'f');
        $redis->sadd('letters:2nd', 'a', 'c', 'g');
        $redis->sadd('letters:3rd', 'a', 'e', 'f');

        $this->assertSameValues(['a', 'c', 'e', 'f', 'g'], $redis->sunion('letters:2nd', 'letters:3rd'));
        $this->assertSameValues(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->sunion('letters:1st', 'letters:2nd', 'letters:3rd'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('set:foo', 'a');
        $redis->sunion('set:foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TIME_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class TIME_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\TIME';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'TIME';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = [];
        $expected = [];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $expected = [1331114908, 453990];
        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($expected));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.6.0
     */
    public function testReturnsServerTime(): void
    {
        $redis = $this->getClient();

        $this->assertIsArray($time = $redis->time());
        $this->assertIsString($time[0]);
        $this->assertIsString($time[1]);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TOUCH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-server
 */
class TOUCH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\TOUCH';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'TOUCH';
    }

    /**
     * @requiresRedisVersion >= 3.2.1
     *
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key1', 'key2', 'key3'];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);
        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @requiresRedisVersion >= 3.2.1
     *
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['key1', 'key2', 'key3']];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @requiresRedisVersion >= 3.2.1
     *
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(10, $command->parseResponse(10));
    }

    /**
     * @requiresRedisVersion >= 3.2.1
     *
     * @group connected
     */
    public function testReturnsNumberOfDeletedKeys(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->touch('foo'));

        $redis->set('foo', 'bar');
        $this->assertSame(1, $redis->touch('foo'));
        $this->assertSame(1, $redis->touch('foo', 'hoge'));

        $redis->set('hoge', 'piyo');
        $this->assertSame(1, $redis->touch('foo'));
        $this->assertSame(2, $redis->touch('foo', 'hoge'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TTL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class TTL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\TTL';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'TTL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 10];
        $expected = ['key', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $command = $this->getCommand();

        $this->assertSame(100, $command->parseResponse(100));
    }

    /**
     * @group connected
     */
    public function testReturnsTTL(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->expire('foo', 10);

        $this->assertSame(10, $redis->ttl('foo'));
    }

    /**
     * @group connected
     */
    public function testReturnsLessThanZeroOnNonExpiringKeys(): void
    {
        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $this->assertSame(-1, $redis->ttl('foo'));
    }

    /**
     * @group connected
     */
    public function testReturnsLessThanZeroOnNonExistingKeys(): void
    {
        if ($this->isRedisServerVersion('<', '2.8.0')) {
            $this->assertSame(-1, $this->getClient()->ttl('foo'));
        } else {
            $this->assertSame(-2, $this->getClient()->ttl('foo'));
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TYPE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-key
 */
class TYPE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\TYPE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'TYPE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('none', $this->getCommand()->parseResponse('none'));
    }

    /**
     * @group connected
     */
    public function testReturnsTypeOfKey(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('none', $redis->type('type:keydoesnotexist'));

        $redis->set('type:string', 'foobar');
        $this->assertEquals('string', $redis->type('type:string'));

        $redis->lpush('type:list', 'foobar');
        $this->assertEquals('list', $redis->type('type:list'));

        $redis->sadd('type:set', 'foobar');
        $this->assertEquals('set', $redis->type('type:set'));

        $redis->zadd('type:zset', 0, 'foobar');
        $this->assertEquals('zset', $redis->type('type:zset'));

        $redis->hset('type:hash', 'foo', 'bar');
        $this->assertEquals('hash', $redis->type('type:hash'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\UNSUBSCRIBE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-pubsub
 * @group relay-incompatible
 */
class UNSUBSCRIBE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\UNSUBSCRIBE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'UNSUBSCRIBE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['channel1', 'channel2', 'channel3'];
        $expected = ['channel1', 'channel2', 'channel3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['channel1', 'channel2', 'channel3']];
        $expected = ['channel1', 'channel2', 'channel3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['unsubscribe', 'channel', 1];
        $expected = ['unsubscribe', 'channel', 1];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testDoesNotSwitchToSubscribeMode(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['unsubscribe', 'channel', 0], $redis->unsubscribe('channel'));
        $this->assertSame('echoed', $redis->echo('echoed'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testUnsubscribesFromNotSubscribedChannels(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['unsubscribe', 'channel', 0], $redis->unsubscribe('channel'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testUnsubscribesFromSubscribedChannels(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['subscribe', 'channel', 1], $redis->subscribe('channel'));
        $this->assertSame(['unsubscribe', 'channel', 0], $redis->unsubscribe('channel'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testUnsubscribesFromAllSubscribedChannels(): void
    {
        $redis = $this->getClient();

        $this->assertSame(['subscribe', 'channel:foo', 1], $redis->subscribe('channel:foo'));
        $this->assertSame(['subscribe', 'channel:bar', 2], $redis->subscribe('channel:bar'));

        [$_, $unsubscribed1, $_] = $redis->unsubscribe();
        [$_, $unsubscribed2, $_] = $redis->getConnection()->read();
        $this->assertSameValues(['channel:foo', 'channel:bar'], [$unsubscribed1, $unsubscribed2]);

        $this->assertSame('echoed', $redis->echo('echoed'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\UNWATCH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-transaction
 */
class UNWATCH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\UNWATCH';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'UNWATCH';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $command = $this->getCommand();
        $command->setArguments([]);

        $this->assertSame([], $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testUnwatchWatchedKeys(): void
    {
        $redis1 = $this->getClient();
        $redis2 = $this->getClient();

        $redis1->set('foo', 'bar');
        $redis1->watch('foo');
        $this->assertEquals('OK', $redis1->unwatch());
        $redis1->multi();
        $redis1->get('foo');

        $redis2->set('foo', 'hijacked');

        $this->assertSame(['hijacked'], $redis1->exec());
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requiresRedisVersion >= 2.2.0
     */
    public function testCanBeCalledInsideTransaction(): void
    {
        $redis = $this->getClient();

        $redis->multi();
        $this->assertInstanceOf('Predis\Response\Status', $redis->unwatch());
    }

    /**
     * @group connected
     * @group ext-relay
     * @requiresRedisVersion >= 2.2.0
     */
    public function testCanBeCalledInsideTransactionUsingRelay(): void
    {
        $redis = $this->getClient();

        $redis->multi();
        $this->assertInstanceOf('Relay\Relay', $redis->unwatch());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\WAITAOF_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class WAITAOF_Test extends PredisCommandTestCase
{
    protected function setUp(): void
    {
        parent::setUp();

        $redis = $this->getClient();
        $this->assertEquals('OK', $redis->config('set', 'appendonly', 'yes'));
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return WAITAOF::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'WAITAOF';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = $expectedArguments = [1, 2, 3];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.2.0
     */
    public function testReturnQuantityOfSyncedAOFInstances(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->set('foo', 'bar'));
        $this->assertSame([1, 0], $redis->waitaof(1, 0, 0));
    }

    protected function tearDown(): void
    {
        $redis = $this->getClient();
        $this->assertEquals('OK', $redis->config('set', 'appendonly', 'no'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\WATCH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-transaction
 * @group relay-incompatible
 */
class WATCH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\WATCH';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'WATCH';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key1', 'key2', 'key3'];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsAsSingleArray(): void
    {
        $arguments = [['key1', 'key2', 'key3']];
        $expected = ['key1', 'key2', 'key3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('OK', $this->getCommand()->parseResponse('OK'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testAbortsTransactionOnExternalWriteOperations(): void
    {
        $redis1 = $this->getClient();
        $redis2 = $this->getClient();

        $redis1->mset('foo', 'bar', 'hoge', 'piyo');

        $this->assertEquals('OK', $redis1->watch('foo', 'hoge'));
        $this->assertEquals('OK', $redis1->multi());
        $this->assertEquals('QUEUED', $redis1->get('foo'));
        $this->assertEquals('OK', $redis2->set('foo', 'hijacked'));
        $this->assertNull($redis1->exec());
        $this->assertSame('hijacked', $redis1->get('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testCanWatchNotYetExistingKeys(): void
    {
        $redis1 = $this->getClient();
        $redis2 = $this->getClient();

        $this->assertEquals('OK', $redis1->watch('foo'));
        $this->assertEquals('OK', $redis1->multi());
        $this->assertEquals('QUEUED', $redis1->set('foo', 'bar'));
        $this->assertEquals('OK', $redis2->set('foo', 'hijacked'));
        $this->assertNull($redis1->exec());
        $this->assertSame('hijacked', $redis1->get('foo'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionWhenCallingInsideTransaction(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR WATCH inside MULTI is not allowed');

        $redis = $this->getClient();

        $redis->multi();
        $redis->watch('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\XADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-stream
 */
class XADD_Test extends PredisCommandTestCase
{
    /**
     * @group disconnected
     * @dataProvider dataFilterArguments
     */
    public function testFilterArguments(array $arguments, array $expected): void
    {
        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    public function dataFilterArguments(): array
    {
        $data = [];
        $data[] = [
            [
                'stream',
                ['key' => 'val'],
                '*',
                ['trim' => ['MINID', '~', '0-1'], 'limit' => 5, 'nomkstream' => true],
            ],
            ['stream', 'NOMKSTREAM', 'MINID', '~', '0-1', 'LIMIT', 5, '*', 'key', 'val'],
        ];

        $data[] = [
            [
                'stream',
                ['key1' => 'val1', 'key2' => 'val2'],
                '*',
                ['trim' => ['MINID', '~', '0-1'], 'limit' => 5, 'nomkstream' => true],
            ],
            ['stream', 'NOMKSTREAM', 'MINID', '~', '0-1', 'LIMIT', 5, '*', 'key1', 'val1', 'key2', 'val2'],
        ];

        $data[] = [
            [
                'stream',
                ['key' => 'val'],
                '*',
                ['trim' => ['MINID', '~', '0-1'], 'limit' => 5],
            ],
            ['stream', 'MINID', '~', '0-1', 'LIMIT', 5, '*', 'key', 'val'],
        ];

        $data[] = [
            [
                'stream',
                ['key' => 'val'],
                '*',
                ['trim' => ['MINID', '~', '0-1']],
            ],
            ['stream', 'MINID', '~', '0-1', '*', 'key', 'val'],
        ];

        $data[] = [
            [
                'stream',
                ['key' => 'val'],
                '*',
                ['trim' => ['MINID', '0-1']],
            ],
            ['stream', 'MINID', '0-1', '*', 'key', 'val'],
        ];

        $data[] = [
            ['stream', ['key' => 'val'], '2-3'],
            ['stream', '2-3', 'key', 'val'],
        ];

        $data[] = [
            ['stream', ['key' => 'val']],
            ['stream', '*', 'key', 'val'],
        ];

        return $data;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\XADD';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'XADD';
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testAddsToStreamWithDefaults(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream', ['key' => 'val']);

        $this->assertSame(1, $redis->xlen('stream'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testAddsToStreamWithSpecificId(): void
    {
        $redis = $this->getClient();
        $id = time() . '-123';

        $redis->xadd('stream', ['key' => 'val'], $id);

        $response = $redis->xrange('stream', $id, $id);
        $this->assertCount(1, $response);
        $this->assertNotNull($response[$id]);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testNomkstreamWhenStreamDoesNotExist(): void
    {
        $redis = $this->getClient();

        $redis->xadd('new-stream', ['key' => 'val'], '*', ['nomkstream' => true]);

        $this->assertSame(0, $redis->exists('new-stream'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testNomkstreamWhenStreamExists(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream', ['key' => 'val']);

        $redis->xadd('stream', ['key' => 'val'], '*', ['nomkstream' => true]);

        $this->assertSame(1, $redis->exists('stream'));
        $this->assertSame(2, $redis->xlen('stream'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testTrimOnMinidExact(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream', ['key' => 'val']);
        $id = $redis->xadd('stream', ['key' => 'val']);

        $redis->xadd('stream', ['key' => 'val'], '*', ['trim' => ['MINID', $id]]);

        $this->assertSame(2, $redis->xlen('stream'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testTrimOnMinidInexact(): void
    {
        $redis = $this->getClient();
        $config = $redis->config('get', 'stream-node-max-entries');
        $oldStreamNodeMaxEntries = (int) array_pop($config);
        $redis->config('set', 'stream-node-max-entries', 2);

        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $id = $redis->xadd('stream', ['key' => 'val']);

        $redis->xadd('stream', ['key' => 'val'], '*', ['trim' => ['MINID', '~', $id]]);

        $this->assertSame(3, $redis->xlen('stream'));
        $redis->config('set', 'stream-node-max-entries', $oldStreamNodeMaxEntries);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testTrimOnMaxlenExact(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);

        $redis->xadd('stream', ['key' => 'val'], '*', ['trim' => ['MAXLEN', 2]]);

        $this->assertSame(2, $redis->xlen('stream'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testTrimOnMaxlenInexact(): void
    {
        $redis = $this->getClient();
        $config = $redis->config('get', 'stream-node-max-entries');
        $oldStreamNodeMaxEntries = (int) array_pop($config);
        $redis->config('set', 'stream-node-max-entries', 2);

        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);

        $redis->xadd('stream', ['key' => 'val'], '*', ['trim' => ['MAXLEN', '~', 2]]);

        $this->assertSame(3, $redis->xlen('stream'));
        $redis->config('set', 'stream-node-max-entries', $oldStreamNodeMaxEntries);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testTrimOnMaxlenWithLimit(): void
    {
        $redis = $this->getClient();
        $config = $redis->config('get', 'stream-node-max-entries');
        $oldStreamNodeMaxEntries = (int) array_pop($config);
        $redis->config('set', 'stream-node-max-entries', 2);

        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);

        $redis->xadd(
            'stream',
            ['key' => 'val'],
            '*',
            ['trim' => ['MAXLEN', '~', 2], 'limit' => 2]
        );

        $this->assertSame(4, $redis->xlen('stream'));
        $redis->config('set', 'stream-node-max-entries', $oldStreamNodeMaxEntries);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->xadd('foo', ['key' => 'val']);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\XDEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-stream
 */
class XDEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\XDEL';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'XDEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['stream', 'id1', 'id2', 'id3'];
        $expected = ['stream', 'id1', 'id2', 'id3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testRemovesSpecifiedMembers(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream', ['key0' => 'val0'], '0-1');
        $redis->xadd('stream', ['key1' => 'val1'], '1-1');
        $redis->xadd('stream', ['key2' => 'val2'], '2-1');

        $this->assertSame(2, $redis->xdel('stream', '0-1', '2-1', '99-1'));
        $this->assertSame(['1-1' => ['key1' => 'val1']], $redis->xrange('stream', '-', '+'));

        $this->assertSame(0, $redis->xdel('stream', '0-1'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->xdel('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\XLEN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-stream
 */
class XLEN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\XLEN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'XLEN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testReturnsLengthOfList(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $this->assertSame(2, $redis->xlen('stream'));

        $redis->xadd('stream', ['key' => 'val']);
        $this->assertSame(3, $redis->xlen('stream'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testReturnsZeroLengthOnNonExistingList(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->llen('stream'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->xlen('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\XRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-stream
 */
class XRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\XRANGE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'XRANGE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['stream', '0-1', '1-2', 123];
        $expected = ['stream', '0-1', '1-2', 'COUNT', 123];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsNoCount(): void
    {
        $arguments = ['stream', '0-1', '1-2'];
        $expected = ['stream', '0-1', '1-2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = [['0-1', ['key', 'val']]];
        $expected = ['0-1' => ['key' => 'val']];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testParseResponseMultipleKeys(): void
    {
        $raw = [['0-1', ['key1', 'val1', 'key2', 'val2']]];
        $expected = ['0-1' => ['key1' => 'val1', 'key2' => 'val2']];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testReturnsElementsInRange(): void
    {
        $redis = $this->getClient();

        for ($i = 0; $i < 10; $i++) {
            $redis->xadd('stream', ['key' . $i => 'val' . $i], $i . '-1');
        }

        $this->assertSame([], $redis->xrange('stream', '1-1', '0-1'));
        $this->assertSame(
            ['0-1' => ['key0' => 'val0']],
            $redis->xrange('stream', '0-1', '0-1')
        );
        $this->assertSame(
            ['0-1' => ['key0' => 'val0'], '1-1' => ['key1' => 'val1']],
            $redis->xrange('stream', '0-1', '1-1')
        );
        $this->assertSame(
            ['0-1' => ['key0' => 'val0'], '1-1' => ['key1' => 'val1']],
            $redis->xrange('stream', '-', '1-1')
        );
        $this->assertSame(
            ['8-1' => ['key8' => 'val8'], '9-1' => ['key9' => 'val9']],
            $redis->xrange('stream', '8-1', '+')
        );
        $this->assertSame(
            ['5-1' => ['key5' => 'val5'], '6-1' => ['key6' => 'val6']],
            $redis->xrange('stream', '5-1', '6-1')
        );
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testMultipleKeys(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream', ['key1' => 'val1', 'key2' => 'val2'], '0-1');
        $redis->xadd('stream', ['key1' => 'val1', 'key2' => 'val2'], '1-1');

        $this->assertSame(
            [
                '0-1' => ['key1' => 'val1', 'key2' => 'val2'],
                '1-1' => ['key1' => 'val1', 'key2' => 'val2'],
            ],
            $redis->xrange('stream', '-', '+')
        );
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->xrange('foo', '0-1', '1-1');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\XREAD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class XREAD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return XREAD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'XREAD';
    }

    /**
     * @dataProvider argumentsProvider
     * @group disconnected
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(
            ['stream1' => [['id1', ['field', 'value']], ['id2', ['field', 'value']]]],
            $this->getCommand()->parseResponse(
                [['stream1', [['id1', ['field', 'value']], ['id2', ['field', 'value']]]]])
        );
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @return void
     * @requiresRedisVersion >= 5.0.0
     */
    public function testReadFromTheBeginningOfGivenStreams(): void
    {
        $redis = $this->getClient();

        $stream1Id = $redis->xadd('stream1', ['field' => 'value']);
        $stream2Id = $redis->xadd('stream2', ['field' => 'value']);

        $expectedResponse = [
            'stream1' => [
                [$stream1Id, ['field', 'value']],
            ],
            'stream2' => [
                [$stream2Id, ['field', 'value']],
            ],
        ];

        $response = $redis->xread(2, null, ['stream1', 'stream2'], '0-0', '0-0');

        $this->assertSame($expectedResponse, $response);
    }

    /**
     * @group medium
     * @group connected
     * @group relay-incompatible
     * @return void
     * @requiresRedisVersion >= 5.0.0
     */
    public function testReadFromTheBeginningOfGivenStreamsWithBlocking(): void
    {
        $redis = $this->getClient();

        $stream1Id = $redis->xadd('stream1', ['field' => 'value']);
        $stream2Id = $redis->xadd('stream2', ['field' => 'value']);

        $expectedResponse = [
            'stream1' => [
                [$stream1Id, ['field', 'value']],
            ],
            'stream2' => [
                [$stream2Id, ['field', 'value']],
            ],
        ];

        $response = $redis->xread(2, 20, ['stream1', 'stream2'], '0-0', '0-0');

        $this->assertSame($expectedResponse, $response);
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @return void
     * @requiresRedisVersion >= 7.3.0
     */
    public function testReadFromGivenStreamsStartingFromLastAvailableId(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream1', ['otherField' => 'otherValue']);
        $redis->xadd('stream2', ['otherField' => 'otherValue']);

        $stream1Id = $redis->xadd('stream1', ['field' => 'value']);
        $stream2Id = $redis->xadd('stream2', ['field' => 'value']);

        $expectedResponse = [
            'stream1' => [
                [$stream1Id, ['field', 'value']],
            ],
            'stream2' => [
                [$stream2Id, ['field', 'value']],
            ],
        ];

        $response = $redis->xread(2, null, ['stream1', 'stream2'], '+', '+');

        $this->assertSame($expectedResponse, $response);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                [null, null, null, '0-0', '0-1'],
                ['0-0', '0-1'],
            ],
            'with COUNT argument' => [
                [2, null, null, '0-0', '0-1'],
                ['COUNT', 2, '0-0', '0-1'],
            ],
            'with BLOCK argument' => [
                [null, 20, null, '0-0', '0-1'],
                ['BLOCK', 20, '0-0', '0-1'],
            ],
            'with STREAMS argument' => [
                [null, null, ['key1', 'key2'], '0-0', '0-1'],
                ['STREAMS', 'key1', 'key2', '0-0', '0-1'],
            ],
            'with all arguments' => [
                [2, 20, ['key1', 'key2'], '0-0', '0-1'],
                ['COUNT', 2, 'BLOCK', 20, 'STREAMS', 'key1', 'key2', '0-0', '0-1'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\XREVRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-stream
 */
class XREVRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\XREVRANGE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'XREVRANGE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['stream', '1-1', '0-1', 123];
        $expected = ['stream', '1-1', '0-1', 'COUNT', 123];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsNoCount(): void
    {
        $arguments = ['stream', '1-1', '0-1'];
        $expected = ['stream', '1-1', '0-1'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = [['0-1', ['key', 'val']]];
        $expected = ['0-1' => ['key' => 'val']];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testParseResponseMultipleKeys(): void
    {
        $raw = [['0-1', ['key1', 'val1', 'key2', 'val2']]];
        $expected = ['0-1' => ['key1' => 'val1', 'key2' => 'val2']];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testReturnsElementsInRange(): void
    {
        $redis = $this->getClient();

        for ($i = 0; $i < 10; $i++) {
            $redis->xadd('stream', ['key' . $i => 'val' . $i], $i . '-1');
        }

        $this->assertSame([], $redis->xrevrange('stream', '0-1', '1-1'));
        $this->assertSame(
            ['0-1' => ['key0' => 'val0']],
            $redis->xrevrange('stream', '0-1', '0-1')
        );
        $this->assertSame(
            ['1-1' => ['key1' => 'val1'], '0-1' => ['key0' => 'val0']],
            $redis->xrevrange('stream', '1-1', '0-1')
        );
        $this->assertSame(
            ['1-1' => ['key1' => 'val1'], '0-1' => ['key0' => 'val0']],
            $redis->xrevrange('stream', '1-1', '-')
        );
        $this->assertSame(
            ['9-1' => ['key9' => 'val9'], '8-1' => ['key8' => 'val8']],
            $redis->xrevrange('stream', '+', '8-1')
        );
        $this->assertSame(
            ['6-1' => ['key6' => 'val6'], '5-1' => ['key5' => 'val5']],
            $redis->xrevrange('stream', '6-1', '5-1')
        );
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testMultipleKeys(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream', ['key1' => 'val1', 'key2' => 'val2'], '0-1');
        $redis->xadd('stream', ['key1' => 'val1', 'key2' => 'val2'], '1-1');

        $this->assertSame(
            [
                '1-1' => ['key1' => 'val1', 'key2' => 'val2'],
                '0-1' => ['key1' => 'val1', 'key2' => 'val2'],
            ],
            $redis->xrevrange('stream', '+', '-')
        );
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->xrevrange('foo', '1-1', '0-1');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\XTRIM_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-stream
 */
class XTRIM_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\XTRIM';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'XTRIM';
    }

    /**
     * @group disconnected
     * @dataProvider dataFilterArguments
     */
    public function testFilterArguments(array $arguments, array $expected): void
    {
        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    public function dataFilterArguments(): array
    {
        return [
            [
                ['stream', ['MINID', '~'], '0-1', ['limit' => 10]],
                ['stream', 'MINID', '~', '0-1', 'LIMIT', 10],
            ],
            [
                ['stream', ['MINID'], '0-1', ['limit' => 10]],
                ['stream', 'MINID', '0-1', 'LIMIT', 10],
            ],
            [
                ['stream', 'MINID', '0-1', ['limit' => 10]],
                ['stream', 'MINID', '0-1', 'LIMIT', 10],
            ],
            [
                ['stream', 'MINID', '0-1'],
                ['stream', 'MINID', '0-1'],
            ],
        ];
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testTrimOnMaxlenExact(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);

        $res = $redis->xtrim('stream', 'MAXLEN', 2);

        $this->assertSame(1, $res);
        $this->assertSame(2, $redis->xlen('stream'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testTrimOnMaxlenInexact(): void
    {
        $redis = $this->getClient();
        $config = $redis->config('get', 'stream-node-max-entries');
        $oldStreamNodeMaxEntries = (int) array_pop($config);
        $redis->config('set', 'stream-node-max-entries', 2);

        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);

        $res = $redis->xtrim('stream', ['MAXLEN', '~'], 2);

        $this->assertSame(2, $res);
        $this->assertSame(3, $redis->xlen('stream'));
        $redis->config('set', 'stream-node-max-entries', $oldStreamNodeMaxEntries);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testTrimOnMinidExact(): void
    {
        $redis = $this->getClient();

        $redis->xadd('stream', ['key' => 'val']);
        $id = $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);

        $res = $redis->xtrim('stream', 'MINID', $id);

        $this->assertSame(1, $res);
        $this->assertSame(2, $redis->xlen('stream'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testTrimOnMinidInexact(): void
    {
        $redis = $this->getClient();
        $config = $redis->config('get', 'stream-node-max-entries');
        $oldStreamNodeMaxEntries = (int) array_pop($config);
        $redis->config('set', 'stream-node-max-entries', 2);

        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $id = $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);

        $res = $redis->xtrim('stream', ['MINID', '~'], $id);

        $this->assertSame(2, $res);
        $this->assertSame(3, $redis->xlen('stream'));
        $redis->config('set', 'stream-node-max-entries', $oldStreamNodeMaxEntries);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testTrimOnMaxlenWithLimit(): void
    {
        $redis = $this->getClient();
        $config = $redis->config('get', 'stream-node-max-entries');
        $oldStreamNodeMaxEntries = (int) array_pop($config);
        $redis->config('set', 'stream-node-max-entries', 2);

        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);
        $redis->xadd('stream', ['key' => 'val']);

        $res = $redis->xtrim('stream', ['MAXLEN', '~'], 2, ['limit' => 2]);

        $this->assertSame(2, $res);
        $this->assertSame(4, $redis->xlen('stream'));
        $redis->config('set', 'stream-node-max-entries', $oldStreamNodeMaxEntries);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('key', 'foo');
        $redis->xtrim('key', 'MAXLEN', 2);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZADD';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 1, 'member1', 2, 'member2'];
        $expected = ['key', 1, 'member1', 2, 'member2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsMembersScoresAsSingleArray(): void
    {
        $arguments = ['key', ['member1' => 1, 'member2' => 2]];
        $expected = ['key', 1, 'member1', 2, 'member2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsMembersScoresAsSingleArrayWithModifiers(): void
    {
        $arguments = ['key', 'NX', 'CH', ['member1' => 1, 'member2' => 2]];
        $expected = ['key', 'NX', 'CH', 1, 'member1', 2, 'member2'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testAddsOrUpdatesMembersOrderingByScore(): void
    {
        $redis = $this->getClient();

        $this->assertSame(5, $redis->zadd('letters', 1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e'));
        $this->assertSame(['a', 'b', 'c', 'd', 'e'], $redis->zrange('letters', 0, -1));

        $this->assertSame(1, $redis->zadd('letters', 1, 'e', 8, 'c', 6, 'f'));
        $this->assertSame(['a', 'e', 'b', 'd', 'f', 'c'], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.0.2
     */
    public function testOnlyAddsNonExistingMembersWithModifierNX(): void
    {
        $redis = $this->getClient();

        $this->assertSame(5, $redis->zadd('letters', 1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e'));
        $this->assertSame(['a', 'b', 'c', 'd', 'e'], $redis->zrange('letters', 0, -1));

        $this->assertSame(2, $redis->zadd('letters', 'NX', 8, 'a', 1, 'f', 8, 'g', 4, 'e'));
        $this->assertSame(['a', 'f', 'b', 'c', 'd', 'e', 'g'], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.0.2
     */
    public function testOnlyUpdatesExistingMembersWithModifierXX(): void
    {
        $redis = $this->getClient();

        $this->assertSame(5, $redis->zadd('letters', 1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e'));
        $this->assertSame(['a', 'b', 'c', 'd', 'e'], $redis->zrange('letters', 0, -1));

        $this->assertSame(0, $redis->zadd('letters', 'XX', 1, 'd', 2, 'c', 3, 'b', 1, 'x', 0, 'y'));
        $this->assertSame(['a', 'd', 'c', 'b', 'e'], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.0.2
     */
    public function testReturnsNumberOfAddedAndUpdatedElementsWithModifierCH(): void
    {
        $redis = $this->getClient();

        $this->assertSame(5, $redis->zadd('letters', 'CH', 1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e'));
        $this->assertSame(['a', 'b', 'c', 'd', 'e'], $redis->zrange('letters', 0, -1));

        $this->assertSame(2, $redis->zadd('letters', 'NX', 'CH', 8, 'a', 1, 'f', 8, 'g', 4, 'e'));
        $this->assertSame(['a', 'f', 'b', 'c', 'd', 'e', 'g'], $redis->zrange('letters', 0, -1));

        $this->assertSame(3, $redis->zadd('letters', 'XX', 'CH', 1, 'd', 2, 'c', 3, 'b', 1, 'x', 0, 'y'));
        $this->assertSame(['a', 'd', 'f', 'c', 'b', 'e', 'g'], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.0.2
     */
    public function testActsLikeZINCRBYWithModifierINCR(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('1', $redis->zadd('letters', 'INCR', 1, 'a'));
        $this->assertEquals('0', $redis->zadd('letters', 'INCR', -1, 'a'));
        $this->assertEquals('0.5', $redis->zadd('letters', 'INCR', 0.5, 'a'));
        $this->assertEquals('-10', $redis->zadd('letters', 'INCR', -10.5, 'a'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 3.0.2
     */
    public function testDoesNotAcceptMultipleScoreElementPairsWithModifierINCR(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('INCR option supports a single increment-element pair');

        $redis = $this->getClient();

        $redis->zadd('letters', 'INCR', 1, 'a', 2, 'b');
    }

    /**
     * @group connected
     */
    public function testAcceptsFloatValuesAsScore(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0.2, 'b', 0.3, 'a', 0.1, 'c');
        $this->assertSame(['c', 'b', 'a'], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zadd('foo', 10, 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZCARD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZCARD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZCARD';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZCARD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key'];
        $expected = ['key'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testReturnsSizeOfSortedSet(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 1, 'a', 2, 'b', 3, 'c');
        $this->assertSame(3, $redis->zcard('letters'));

        $this->assertSame(0, $redis->zcard('unknown'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zcard('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZCOUNT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZCOUNT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZCOUNT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZCOUNT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, 10];
        $expected = ['key', 0, 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsNumberOfElementsInGivenScoreRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 10, 'a', 20, 'b', 30, 'c', 40, 'd', 50, 'e');

        $this->assertSame(5, $redis->zcount('letters', 0, 100));
        $this->assertSame(5, $redis->zcount('letters', -100, 100));
        $this->assertSame(2, $redis->zcount('letters', 25, 45));
        $this->assertSame(1, $redis->zcount('letters', 20, 20));
        $this->assertSame(0, $redis->zcount('letters', 0, 0));

        $this->assertSame(0, $redis->zcount('unknown', 0, 100));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testInfinityScoreIntervals(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 10, 'a', 20, 'b', 30, 'c', 40, 'd', 50, 'e');

        $this->assertSame(3, $redis->zcount('letters', '-inf', 30));
        $this->assertSame(3, $redis->zcount('letters', 30, '+inf'));
        $this->assertSame(5, $redis->zcount('letters', '-inf', '+inf'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testExclusiveScoreIntervals(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 10, 'a', 20, 'b', 30, 'c', 40, 'd', 50, 'e');

        $this->assertSame(2, $redis->zcount('letters', 10, '(30'));
        $this->assertSame(2, $redis->zcount('letters', '(10', 30));
        $this->assertSame(1, $redis->zcount('letters', '(10', '(30'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zcount('foo', 0, 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZDIFFSTORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

class ZDIFFSTORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZDIFFSTORE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZDIFFSTORE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['zset_diff', ['key1', 'key2']];
        $expectedArguments = ['zset_diff', 2, 'key1', 'key2'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider sortedSetsProvider
     * @param  array $firstSetDictionary
     * @param  array $secondSetDictionary
     * @param  array $expectedResponse
     * @param  int   $expectedResultingElements
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testStoresDifferenceBetweenSortedSets(
        array $firstSetDictionary,
        array $secondSetDictionary,
        array $expectedResponse,
        int $expectedResultingElements
    ): void {
        $redis = $this->getClient();

        $redis->zadd('test-zset-1', ...$firstSetDictionary);
        $redis->zadd('test-zset-2', ...$secondSetDictionary);
        $actualResponse = $redis->zdiffstore('zdiffstore', ['test-zset-1', 'test-zset-2']);

        $this->assertSame($expectedResultingElements, $actualResponse);
        $this->assertSame($expectedResponse, $redis->zrange('zdiffstore', 0, -1));
    }

    public function sortedSetsProvider(): array
    {
        return [
            'no intersection' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member4', 2, 'member5', 3, 'member6'],
                ['member1', 'member2', 'member3'],
                3,
            ],
            'partial intersection' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2', 3, 'member4'],
                ['member3'],
                1,
            ],
            'full intersection' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [],
                0,
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZDIFF_test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

class ZDIFF_test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZDIFF::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZDIFF';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider sortedSetsProvider
     * @param  array $firstSetDictionary
     * @param  array $secondSetDictionary
     * @param  array $expectedResponse
     * @param  bool  $withScores
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsDifferenceBetweenSortedSets(
        array $firstSetDictionary,
        array $secondSetDictionary,
        array $expectedResponse,
        bool $withScores
    ): void {
        $redis = $this->getClient();

        $redis->zadd('test-zset-1', ...$firstSetDictionary);
        $redis->zadd('test-zset-2', ...$secondSetDictionary);

        $this->assertSame($expectedResponse, $redis->zdiff(['test-zset-1', 'test-zset-2'], $withScores));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsNoIntersectionOnNonExistingKey(): void
    {
        $redis = $this->getClient();
        $membersDictionary = [1, 'member1', 2, 'member2', 3, 'member3'];
        $expectedResponse = ['member1' => '1', 'member2' => '2', 'member3' => '3'];

        $redis->zadd('test-zset-1', ...$membersDictionary);
        $this->assertSame($expectedResponse, $redis->zdiff(['test-zset-1', 'test-zset-2'], true));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('zdiff_foo', 'bar');
        $redis->zdiff(['zdiff_foo'], true);
    }

    public function argumentsProvider(): array
    {
        return [
            'with scores' => [[['zset'], 5, 'withScores' => true], [1, 'zset', 5, 'WITHSCORES']],
            'without scores' => [[['zset'], 5], [1, 'zset', 5]],
            'without scores - false value' => [[['zset'], 5, 'withScores' => false], [1, 'zset', 5]],
        ];
    }

    public function sortedSetsProvider(): array
    {
        return [
            'no intersection - without score' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member4', 2, 'member5', 3, 'member6'],
                ['member1', 'member2', 'member3'],
                false,
            ],
            'partial intersection - without score' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2', 3, 'member4'],
                ['member3'],
                false,
            ],
            'full intersection' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [],
                false,
            ],
            'no intersection - with score' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member4', 2, 'member5', 3, 'member6'],
                ['member1' => '1', 'member2' => '2', 'member3' => '3'],
                true,
            ],
            'partial intersection - with score' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2', 3, 'member4'],
                ['member3' => '3'],
                true,
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZINCRBY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZINCRBY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZINCRBY';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZINCRBY';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 1.0, 'member'];
        $expected = ['key', 1.0, 'member'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame('1', $this->getCommand()->parseResponse('1'));
    }

    /**
     * @group connected
     */
    public function testIncrementsScoreOfMemberByFloat(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('1', $redis->zincrby('letters', 1, 'member'));
        $this->assertEquals('0', $redis->zincrby('letters', -1, 'member'));
        $this->assertEquals('0.5', $redis->zincrby('letters', 0.5, 'member'));
        $this->assertEquals('-10', $redis->zincrby('letters', -10.5, 'member'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zincrby('foo', 1, 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZINTERCARD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;
use UnexpectedValueException;

class ZINTERCARD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZINTERCARD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZINTERCARD';
    }

    /**
     * @dataProvider argumentsProvider
     * @group disconnected
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider sortedSetsProvider
     * @param  array $firstSortedSet
     * @param  array $secondSortedSet
     * @param  int   $limit
     * @param  int   $expectedResponse
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testReturnsIntersectionCardinalityOnSortedSets(
        array $firstSortedSet,
        array $secondSortedSet,
        int $limit,
        int $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->zadd('test-zintercard1', ...$firstSortedSet);
        $redis->zadd('test-zintercard2', ...$secondSortedSet);

        $this->assertSame($expectedResponse, $redis->zintercard(['test-zintercard1', 'test-zintercard2'], $limit));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testReturnsIntersectionCardinalityZeroOnEmptySortedSetGiven(): void
    {
        $redis = $this->getClient();
        $sortedSet = [1, 'member1', 2, 'member2', 3, 'member3'];

        $redis->zadd('test-zintercard', ...$sortedSet);

        $this->assertSame(0, $redis->zintercard(['test-zintercard', 'non-existing-key']));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zintercard(['foo']);
    }

    /**
     * @group connected
     * @dataProvider unexpectedValuesProvider
     * @param         $keys
     * @param         $limit
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 7.0.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(
        $keys,
        $limit,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->zintercard($keys, $limit);
    }

    public function argumentsProvider(): array
    {
        return [
            'with required arguments only' => [
                [['key1', 'key2']],
                [2, 'key1', 'key2'],
            ],
            'with all arguments' => [
                [['key1', 'key2'], 2],
                [2, 'key1', 'key2', 'LIMIT', 2],
            ],
        ];
    }

    public function sortedSetsProvider(): array
    {
        return [
            'with full intersection' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2', 3, 'member3'],
                0,
                3,
            ],
            'with partial intersection' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2', 4, 'member4'],
                0,
                2,
            ],
            'with no intersection' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [4, 'member4', 5, 'member5', 6, 'member6'],
                0,
                0,
            ],
            'with full intersection and limit' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2', 3, 'member3'],
                1,
                1,
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'with wrong type keys argument' => [
                'wrong',
                0,
                'Wrong keys argument type or position offset',
            ],
            'with wrong type limit argument' => [
                ['key1', 'key'],
                [1],
                'Wrong limit argument type',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZINTERSTORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-zset
 */
class ZINTERSTORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZINTERSTORE::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZINTERSTORE';
    }

    /**
     * @dataProvider argumentsProvider
     * @group disconnected
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider sortedSetsProvider
     * @param  array  $firstSortedSet
     * @param  array  $secondSortedSet
     * @param  string $destination
     * @param  array  $weights
     * @param  string $aggregate
     * @param  int    $expectedResponse
     * @param  array  $expectedResultSortedSet
     * @return void
     * @requiresRedisVersion >= 2.0.0
     */
    public function testStoresIntersectedValuesOnSortedSets(
        array $firstSortedSet,
        array $secondSortedSet,
        string $destination,
        array $weights,
        string $aggregate,
        int $expectedResponse,
        array $expectedResultSortedSet
    ): void {
        $redis = $this->getClient();

        $redis->zadd('test-zunionstore1', ...$firstSortedSet);
        $redis->zadd('test-zunionstore2', ...$secondSortedSet);

        $actualResponse = $redis->zinterstore(
            $destination,
            ['test-zunionstore1', 'test-zunionstore2'],
            $weights,
            $aggregate
        );

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertEquals(
            $expectedResultSortedSet,
            $redis->zrange($destination, 0, -1, ['withscores' => true])
        );
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zinterstore('zset_interstore:destination', ['foo']);
    }

    /**
     * @dataProvider unexpectedValueProvider
     * @param  string $destination
     * @param         $keys
     * @param         $weights
     * @param  string $aggregate
     * @param  string $expectedExceptionMessage
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(
        string $destination,
        $keys,
        $weights,
        string $aggregate,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->zinterstore($destination, $keys, $weights, $aggregate);
    }

    public function argumentsProvider(): array
    {
        return [
            'with required arguments only' => [
                ['destination', ['key1', 'key2']],
                ['destination', 2, 'key1', 'key2'],
            ],
            'with weights' => [
                ['destination', ['key1', 'key2'], [1, 2]],
                ['destination', 2, 'key1', 'key2', 'WEIGHTS', 1, 2],
            ],
            'with aggregate' => [
                ['destination', ['key1', 'key2'], [], 'min'],
                ['destination', 2, 'key1', 'key2', 'AGGREGATE', 'MIN'],
            ],
            'with all arguments' => [
                ['destination', ['key1', 'key2'], [1, 2], 'min'],
                ['destination', 2, 'key1', 'key2', 'WEIGHTS', 1, 2, 'AGGREGATE', 'MIN'],
            ],
            'with options array' => [
                ['destination', ['key1', 'key2'], [
                    'weights' => [1, 2],
                    'aggregate' => 'min',
                ]],
                ['destination', 2, 'key1', 'key2', 'WEIGHTS', 1, 2, 'AGGREGATE', 'MIN'],
            ],
        ];
    }

    public function sortedSetsProvider(): array
    {
        return [
            'with required arguments' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2'],
                'destination',
                [],
                'sum',
                2,
                ['member1' => '2', 'member2' => '4'],
            ],
            'with weights' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2'],
                'destination',
                [2, 3],
                'sum',
                2,
                ['member1' => '5', 'member2' => '10'],
            ],
            'with aggregate' => [
                [1, 'member1', 4, 'member2', 3, 'member3'],
                [2, 'member1', 2, 'member2'],
                'destination',
                [],
                'max',
                2,
                ['member1' => '2', 'member2' => '4'],
            ],
            'with all arguments' => [
                [1, 'member1', 5, 'member2', 4, 'member3'],
                [2, 'member1', 2, 'member2'],
                'destination',
                [2, 3],
                'max',
                2,
                ['member1' => '6', 'member2' => '10'],
            ],
        ];
    }

    public function unexpectedValueProvider(): array
    {
        return [
            'with unexpected keys argument' => [
                'destination',
                1,
                [],
                'sum',
                'Wrong keys argument type or position offset',
            ],
            'with unexpected weights argument' => [
                'destination',
                ['key1'],
                1,
                'sum',
                'Wrong weights argument type',
            ],
            'with unexpected aggregate argument' => [
                'destination',
                ['key1'],
                [],
                'wrong',
                'Aggregate argument accepts only: min, max, sum values',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZINTER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-zset
 */
class ZINTER_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZINTER::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZINTER';
    }

    /**
     * @dataProvider argumentsProvider
     * @group disconnected
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    public function argumentsProvider(): array
    {
        return [
            'with required arguments only' => [
                [['key1', 'key2']],
                [2, 'key1', 'key2'],
            ],
            'with weights' => [
                [['key1', 'key2'], [1, 2]],
                [2, 'key1', 'key2', 'WEIGHTS', 1, 2],
            ],
            'with aggregate' => [
                [['key1', 'key2'], [], 'min'],
                [2, 'key1', 'key2', 'AGGREGATE', 'MIN'],
            ],
            'with withscores' => [
                [['key1', 'key2'], [], 'min', true],
                [2, 'key1', 'key2', 'AGGREGATE', 'MIN', 'WITHSCORES'],
            ],
            'with all arguments' => [
                [['key1', 'key2'], [1, 2], 'min', true],
                [2, 'key1', 'key2', 'WEIGHTS', 1, 2, 'AGGREGATE', 'MIN', 'WITHSCORES'],
            ],
        ];
    }

    /**
     * @group connected
     * @dataProvider sortedSetsProvider
     * @param  array  $firstSortedSet
     * @param  array  $secondSortedSet
     * @param  array  $weights
     * @param  string $aggregate
     * @param  bool   $withScores
     * @param  array  $expectedResponse
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsIntersectedValuesOnSortedSets(
        array $firstSortedSet,
        array $secondSortedSet,
        array $weights,
        string $aggregate,
        bool $withScores,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->zadd('test-zinter1', ...$firstSortedSet);
        $redis->zadd('test-zinter2', ...$secondSortedSet);

        $actualResponse = $redis->zinter(
            ['test-zinter1', 'test-zinter2'],
            $weights,
            $aggregate,
            $withScores
        );

        $this->assertEquals($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zinter(['foo']);
    }

    /**
     * @dataProvider unexpectedValueProvider
     * @param         $keys
     * @param         $weights
     * @param  string $aggregate
     * @param  bool   $withScores
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(
        $keys,
        $weights,
        string $aggregate,
        bool $withScores,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->zinter($keys, $weights, $aggregate, $withScores);
    }

    public function sortedSetsProvider(): array
    {
        return [
            'with required arguments' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2'],
                [],
                'sum',
                false,
                ['member1', 'member2'],
            ],
            'with weights and withscores' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2'],
                [2, 3],
                'sum',
                true,
                ['member1' => '5', 'member2' => '10'],
            ],
            'with aggregate and withscores' => [
                [1, 'member1', 4, 'member2', 3, 'member3'],
                [2, 'member1', 2, 'member2'],
                [],
                'max',
                true,
                ['member1' => '2', 'member2' => '4'],
            ],
            'with all arguments' => [
                [1, 'member1', 5, 'member2', 4, 'member3'],
                [2, 'member1', 2, 'member2'],
                [2, 3],
                'max',
                true,
                ['member1' => '6', 'member2' => '10'],
            ],
        ];
    }

    public function unexpectedValueProvider(): array
    {
        return [
            'with unexpected keys argument' => [
                1,
                [],
                'sum',
                false,
                'Wrong keys argument type or position offset',
            ],
            'with unexpected weights argument' => [
                ['key1'],
                1,
                'sum',
                false,
                'Wrong weights argument type',
            ],
            'with unexpected aggregate argument' => [
                ['key1'],
                [],
                'wrong',
                false,
                'Aggregate argument accepts only: min, max, sum values',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZLEXCOUNT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZLEXCOUNT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZLEXCOUNT';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZLEXCOUNT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '+', '-'];
        $expected = ['key', '+', '-'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testExclusiveIntervalRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(3, $redis->zlexcount('letters', '(b', '(f'));
        $this->assertSame(5, $redis->zlexcount('letters', '(b', '(z'));
        $this->assertSame(4, $redis->zlexcount('letters', '(0', '(e'));
        $this->assertSame(0, $redis->zlexcount('letters', '(f', '(b'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testInclusiveIntervalRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(5, $redis->zlexcount('letters', '[b', '[f'));
        $this->assertSame(6, $redis->zlexcount('letters', '[b', '[z'));
        $this->assertSame(5, $redis->zlexcount('letters', '[0', '[e'));
        $this->assertSame(0, $redis->zlexcount('letters', '[f', '[b'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testWholeRangeInterval(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(7, $redis->zlexcount('letters', '-', '+'));
        $this->assertSame(0, $redis->zlexcount('letters', '+', '-'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnInvalidRangeFormat(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('min or max not valid string range item');

        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');
        $redis->zlexcount('letters', 'b', 'f');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zlexcount('foo', '+', '-');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZMPOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;
use UnexpectedValueException;

class ZMPOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZMPOP::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZMPOP';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     * @dataProvider responsesProvider
     */
    public function testParseResponse(array $actualResponse, array $expectedResponse): void
    {
        $this->assertSame($expectedResponse, $this->getCommand()->parseResponse($actualResponse));
    }

    /**
     * @group connected
     * @dataProvider sortedSetsProvider
     * @param  array  $sortedSetDictionary
     * @param  string $key
     * @param  string $modifier
     * @param  int    $count
     * @param  array  $expectedResponse
     * @param  array  $expectedModifiedSortedSet
     * @return void
     * @requiresRedisVersion >= 7.0
     */
    public function testReturnsPoppedElementsFromGivenSortedSet(
        array $sortedSetDictionary,
        string $key,
        string $modifier,
        int $count,
        array $expectedResponse,
        array $expectedModifiedSortedSet
    ): void {
        $redis = $this->getClient();

        $redis->zadd($key, ...$sortedSetDictionary);
        $actualResponse = $redis->zmpop([$key], $modifier, $count);

        $this->assertEquals($expectedResponse, $actualResponse);
        $this->assertSame($expectedModifiedSortedSet, $redis->zrange($key, 0, -1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisVersion >= 7.0
     */
    public function testReturnsPoppedElementsFromFirstNonEmptySortedSet(): void
    {
        $emptySortedSetKey = 'empty';
        $sortedSetKey = 'key';
        $sortedSet = [1, 'member1', 2, 'member2', 3, 'member3'];
        $redis = $this->getClient();

        $redis->zadd($sortedSetKey, ...$sortedSet);
        $actualResponse = $redis->zmpop([$emptySortedSetKey, $sortedSetKey]);

        $this->assertSame([$sortedSetKey], array_keys($actualResponse));
        $this->assertSame(['member2', 'member3'], $redis->zrange($sortedSetKey, 0, -1));
    }

    /**
     * @group connected
     * @dataProvider unexpectedValuesProvider
     * @param  array  $keys
     * @param  string $modifier
     * @param  int    $count
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 7.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(
        array $keys,
        string $modifier,
        int $count,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->zmpop($keys, $modifier, $count);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 7.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('zmpop_foo', 'bar');
        $redis->zmpop(['zmpop_foo']);
    }

    public function argumentsProvider(): array
    {
        return [
            'with one key' => [
                [['key1'], 'min', 1],
                [1, 'key1', 'MIN', 'COUNT', 1],
            ],
            'with multiple keys' => [
                [['key1', 'key2', 'key3'], 'max', 1],
                [3, 'key1', 'key2', 'key3', 'MAX', 'COUNT', 1],
            ],
        ];
    }

    public function responsesProvider(): array
    {
        return [
            'null-element array' => [
                [null],
                [null],
            ],
            'two-element array' => [
                ['key', [['member1', 1, 'member2', 2, 'member3', 3]]],
                ['key' => ['member1' => 1, 'member2' => 2, 'member3' => 3]],
            ],
        ];
    }

    public function sortedSetsProvider(): array
    {
        return [
            'with MIN modifier' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                'test-zmpop',
                'min',
                1,
                ['test-zmpop' => ['member1' => '1']],
                ['member2', 'member3'],
            ],
            'with MAX modifier' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                'test-zmpop',
                'max',
                1,
                ['test-zmpop' => ['member3' => '3']],
                ['member1', 'member2'],
            ],
            'with non-default COUNT' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                'test-zmpop',
                'max',
                2,
                ['test-zmpop' => ['member3' => '3', 'member2' => '2']],
                ['member1'],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'wrong modifier' => [
                ['key1', 'key2'],
                'wrong modifier',
                1,
                'Wrong type of modifier given',
            ],
            'wrong count' => [
                ['key1', 'key2'],
                'min',
                0,
                'Wrong count argument value or position offset',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZMSCORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-zset
 */
class ZMSCORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZMSCORE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZMSCORE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['zset', 'member1', 'member2', 'member3'];
        $expected = ['zset', 'member1', 'member2', 'member3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider membersProvider
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsScoresAssociatedWithMembers(
        string $key,
        array $membersDictionary,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();
        $notExpectedMember = 'not_expected';

        /** @var string[] $members */
        $members = array_filter($membersDictionary, static function ($item) {
            return is_string($item);
        });

        $redis->zadd($key, ...$membersDictionary);

        $this->assertEquals($expectedResponse, $redis->zmscore($key, ...$members));
        $this->assertNull($redis->zmscore($key, $notExpectedMember)[0]);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zmscore('foo', '');
    }

    public function membersProvider(): array
    {
        return [['test-zscore', [1, 'member1', 2, 'member2', 3, 'member3'], ['1', '2', '3']]];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZPOPMAX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZPOPMAX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZPOPMAX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZPOPMAX';
    }

    /**
     * @requiresRedisVersion >= 5.0.0
     *
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['zset', 2];
        $expected = ['zset', 2];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @requiresRedisVersion >= 5.0.0
     *
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['element1', '1', 'element2', '2', 'element3', '3'];
        $expected = ['element1' => '1', 'element2' => '2', 'element3' => '3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testReturnsElements(): void
    {
        $redis = $this->getClient();

        $this->assertSame([], $redis->zpopmax('letters'));
        $this->assertSame([], $redis->zpopmax('letters', 3));

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertEquals(['f' => '30'], $redis->zpopmax('letters'));
        $this->assertEquals(['e' => '20', 'd' => '20', 'c' => '10'], $redis->zpopmax('letters', 3));
        $this->assertEquals(['b' => '0', 'a' => '-10'], $redis->zpopmax('letters', 3));
    }

    /**
     * @requiresRedisVersion >= 5.0.0
     *
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zpopmax('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZPOPMIN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZPOPMIN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZPOPMIN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZPOPMIN';
    }

    /**
     * @requiresRedisVersion >= 5.0.0
     *
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['zset', 2];
        $expected = ['zset', 2];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @requiresRedisVersion >= 5.0.0
     *
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['element1', '1', 'element2', '2', 'element3', '3'];
        $expected = ['element1' => '1', 'element2' => '2', 'element3' => '3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 5.0.0
     */
    public function testReturnsElements(): void
    {
        $redis = $this->getClient();

        $this->assertSame([], $redis->zpopmin('letters'));
        $this->assertSame([], $redis->zpopmin('letters', 3));

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertEquals(['a' => '-10'], $redis->zpopmin('letters'));
        $this->assertEquals(['b' => '0', 'c' => '10', 'd' => '20'], $redis->zpopmin('letters', 3));
        $this->assertEquals(['e' => '20', 'f' => '30'], $redis->zpopmin('letters', 3));
    }

    /**
     * @requiresRedisVersion >= 5.0.0
     *
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zpopmin('foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZRANDMEMBER_test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;

class ZRANDMEMBER_test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZRANDMEMBER::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZRANDMEMBER';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @param  string $key
     * @param  int    $count
     * @param  array  $membersDictionary
     * @param  array  $expectedResponse
     * @param  bool   $withScores
     * @return void
     * @dataProvider membersProvider
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsRandomMembersFromSortedSet(
        string $key,
        int $count,
        array $membersDictionary,
        array $expectedResponse,
        bool $withScores
    ): void {
        $redis = $this->getClient();
        $notExpectedKey = 'not_expected';

        $redis->zadd($key, ...$membersDictionary);
        $this->assertSameValues($redis->zrandmember($key, $count, $withScores), $expectedResponse);
        $this->assertNull($redis->zrandmember($notExpectedKey));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('zrandmember_foo', 'bar');
        $redis->zrandmember('zrandmember_foo', 1, true);
    }

    public function argumentsProvider(): array
    {
        return [
            'with scores' => [['zset', 5, 'withScores' => true], ['zset', 5, 'WITHSCORES']],
            'without scores' => [['zset', 5], ['zset', 5]],
            'without scores - false value' => [['zset', 5, 'withScores' => false], ['zset', 5]],
        ];
    }

    public function membersProvider(): array
    {
        return [
            'one member - without score' => ['test-zset', 1, [1, 'member1'], ['member1'], false],
            'multiple members - positive count - without score' => [
                'test-zset',
                2,
                [1, 'member1', 2, 'member2'],
                ['member1', 'member2'],
                false,
            ],
            'multiple members - negative count - without score' => [
                'test-zset',
                -2,
                [1, 'member1'],
                ['member1', 'member1'],
                false,
            ],
            'one member - with score' => ['test-zset', 1, [1, 'member1'], ['member1' => '1'], true],
            'multiple members - positive count - with score' => [
                'test-zset',
                2,
                [1, 'member1', 2, 'member2'],
                ['member1' => '1', 'member2' => '2'],
                true,
            ],
            'multiple members - negative count - with score' => [
                'test-zset',
                -1,
                [1, 'member1'],
                ['member1' => '1'],
                true,
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZRANGEBYLEX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZRANGEBYLEX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZRANGEBYLEX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZRANGEBYLEX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $modifiers = [
            'limit' => [0, 100],
        ];

        $arguments = ['zset', '[a', '[z', $modifiers];
        $expected = ['zset', '[a', '[z', 'LIMIT', 0, 100];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithNamedLimit(): void
    {
        $arguments = ['zset', '[a', '[z', ['limit' => ['offset' => 1, 'count' => 2]]];
        $expected = ['zset', '[a', '[z', 'LIMIT', 1, 2];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['a', 'b', 'c'];
        $expected = ['a', 'b', 'c'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testReturnsElementsInWholeRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(['a', 'b', 'c', 'd', 'e', 'f', 'g'], $redis->zrangebylex('letters', '-', '+'));
        $this->assertSame([], $redis->zrangebylex('letters', '+', '-'));
        $this->assertSame([], $redis->zrangebylex('unknown', '-', '+'));
        $this->assertSame([], $redis->zrangebylex('unknown', '+', '-'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testReturnsElementsInInclusiveRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(['a'], $redis->zrangebylex('letters', '[a', '[a'));
        $this->assertSame(['c', 'd', 'e', 'f'], $redis->zrangebylex('letters', '[c', '[f'));
        $this->assertSame(['a', 'b', 'c'], $redis->zrangebylex('letters', '-', '[c'));
        $this->assertSame([], $redis->zrangebylex('letters', '+', '[c'));
        $this->assertSame([], $redis->zrangebylex('letters', '[x', '[z'));
        $this->assertSame([], $redis->zrangebylex('unknown', '[0', '[1'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testReturnsElementsInExclusiveRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame([], $redis->zrangebylex('letters', '(a', '(a'));
        $this->assertSame(['d', 'e'], $redis->zrangebylex('letters', '(c', '(f'));
        $this->assertSame(['a', 'b'], $redis->zrangebylex('letters', '-', '(c'));
        $this->assertSame([], $redis->zrangebylex('letters', '+', '(c'));
        $this->assertSame([], $redis->zrangebylex('letters', '(x', '(z'));
        $this->assertSame([], $redis->zrangebylex('unknown', '(0', '(1'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testReturnsElementsInMixedRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame([], $redis->zrangebylex('letters', '[a', '(a'));
        $this->assertSame([], $redis->zrangebylex('letters', '(a', '[a'));
        $this->assertSame(['c', 'd', 'e'], $redis->zrangebylex('letters', '[c', '(f'));
        $this->assertSame(['d', 'e', 'f'], $redis->zrangebylex('letters', '(c', '[f'));
        $this->assertSame([], $redis->zrangebylex('unknown', '[0', '(5'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testRangeWithLimitModifier(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(['c', 'd', 'e'], $redis->zrangebylex('letters', '-', '+', 'LIMIT', '2', '3'));
        $this->assertSame(['c', 'd', 'e'], $redis->zrangebylex('letters', '-', '+', ['limit' => [2, 3]]));
        $this->assertSame(['c', 'd', 'e'], $redis->zrangebylex('letters', '-', '+', ['limit' => ['offset' => 2, 'count' => 3]]));
        $this->assertSame([], $redis->zrangebylex('letters', '[a', '[f', 'LIMIT', '2', '0'));
        $this->assertSame([], $redis->zrangebylex('letters', '[a', '[f', 'LIMIT', '-4', '2'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnInvalidRangeFormat(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('min or max not valid string range item');

        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');
        $redis->zrangebylex('letters', 'b', 'f');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zrangebylex('foo', '-', '+');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZRANGEBYSCORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZRANGEBYSCORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZRANGEBYSCORE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZRANGEBYSCORE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $modifiers = [
            'withscores' => true,
            'limit' => [0, 100],
        ];

        $arguments = ['zset', 0, 100, $modifiers];
        $expected = ['zset', 0, 100, 'LIMIT', 0, 100, 'WITHSCORES'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithStringWithscores(): void
    {
        $arguments = ['zset', 0, 100, 'withscores'];
        $expected = ['zset', 0, 100, 'WITHSCORES'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithNamedLimit(): void
    {
        $arguments = ['zset', 0, 100, ['limit' => ['offset' => 1, 'count' => 2]]];
        $expected = ['zset', 0, 100, 'LIMIT', 1, 2];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['element1', 'element2', 'element3'];
        $expected = ['element1', 'element2', 'element3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testParseResponseWithScores(): void
    {
        $raw = ['element1', '1', 'element2', '2', 'element3', '3'];
        $expected = ['element1' => '1', 'element2' => '2', 'element3' => '3'];

        $command = $this->getCommandWithArgumentsArray(['zset', 0, 1, 'withscores']);

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testAddsWithscoresModifiersOnlyWhenOptionIsTrue(): void
    {
        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => true]);
        $this->assertSame(['zset', 0, 100, 'WITHSCORES'], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => 1]);
        $this->assertSame(['zset', 0, 100, 'WITHSCORES'], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => false]);
        $this->assertSame(['zset', 0, 100], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => 0]);
        $this->assertSame(['zset', 0, 100], $command->getArguments());
    }

    /**
     * @group connected
     */
    public function testReturnsElementsInScoreRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(['a'], $redis->zrangebyscore('letters', -10, -10));
        $this->assertSame(['c', 'd', 'e', 'f'], $redis->zrangebyscore('letters', 10, 30));
        $this->assertSame(['d', 'e'], $redis->zrangebyscore('letters', 20, 20));
        $this->assertSame([], $redis->zrangebyscore('letters', 30, 0));

        $this->assertSame([], $redis->zrangebyscore('unknown', 0, 30));
    }

    /**
     * @group connected
     */
    public function testInfinityScoreIntervals(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(['a', 'b', 'c'], $redis->zrangebyscore('letters', '-inf', 15));
        $this->assertSame(['d', 'e', 'f'], $redis->zrangebyscore('letters', 15, '+inf'));
        $this->assertSame(['a', 'b', 'c', 'd', 'e', 'f'], $redis->zrangebyscore('letters', '-inf', '+inf'));
    }

    /**
     * @group connected
     */
    public function testExclusiveScoreIntervals(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(['c', 'd', 'e'], $redis->zrangebyscore('letters', 10, '(30'));
        $this->assertSame(['d', 'e', 'f'], $redis->zrangebyscore('letters', '(10', 30));
        $this->assertSame(['d', 'e'], $redis->zrangebyscore('letters', '(10', '(30'));
    }

    /**
     * @group connected
     */
    public function testRangeWithWithscoresModifier(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');
        $expected = ['c' => '10', 'd' => '20', 'e' => '20'];

        $this->assertEquals($expected, $redis->zrangebyscore('letters', 10, 20, 'withscores'));
        $this->assertEquals($expected, $redis->zrangebyscore('letters', 10, 20, ['withscores' => true]));
    }

    /**
     * @group connected
     */
    public function testRangeWithLimitModifier(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');
        $expected = ['d', 'e'];

        $this->assertSame($expected, $redis->zrangebyscore('letters', 10, 20, ['limit' => [1, 2]]));
        $this->assertSame($expected, $redis->zrangebyscore('letters', 10, 20, ['limit' => ['offset' => 1, 'count' => 2]]));
    }

    /**
     * @group connected
     */
    public function testRangeWithCombinedModifiers(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $options = ['limit' => [1, 2], 'withscores' => true];
        $expected = ['d' => '20', 'e' => '20'];

        $this->assertEquals($expected, $redis->zrangebyscore('letters', 10, 20, $options));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zrangebyscore('foo', 0, 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZRANGESTORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use UnexpectedValueException;

class ZRANGESTORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZRANGESTORE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZRANGESTORE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider rangesProvider
     * @param array       $actualSortedSet
     * @param int|string  $min
     * @param int|string  $max
     * @param string|bool $by
     * @param bool        $rev
     * @param bool        $limit
     * @param int         $offset
     * @param int         $count
     * @param int         $expectedResultingElements
     * @param array       $expectedResponse
     * @requiresRedisVersion >= 6.2.0
     * @return void
     */
    public function testStoresSortedSetRanges(
        array $actualSortedSet,
        $min,
        $max,
        $by,
        bool $rev,
        bool $limit,
        int $offset,
        int $count,
        int $expectedResultingElements,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->zadd('source', ...$actualSortedSet);
        $actualResponse = $redis->zrangestore(
            'destination',
            'source',
            $min,
            $max,
            $by,
            $rev,
            $limit,
            $offset,
            $count
        );

        $this->assertSame($expectedResultingElements, $actualResponse);
        $this->assertSame($expectedResponse, $redis->zrange('destination', 0, -1));
    }

    /**
     * @group connected
     * @dataProvider unexpectedValuesProvider
     * @param  int|string  $min
     * @param  int|string  $max
     * @param  string|bool $by
     * @param              $rev
     * @param              $limit
     * @param  int         $offset
     * @param  int         $count
     * @param  string      $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnUnexpectedValuesGiven(
        $min,
        $max,
        $by,
        $rev,
        $limit,
        int $offset,
        int $count,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->zrangestore(
            'destination',
            'source',
            $min,
            $max,
            $by,
            $rev,
            $limit,
            $offset,
            $count
        );
    }

    public function argumentsProvider(): array
    {
        return [
            'without optional arguments' => [
                ['destination', 'source', 0, -1, false, false, false, 0, 0],
                ['destination', 'source', 0, -1],
            ],
            'with BYLEX argument' => [
                ['destination', 'source', 0, -1, 'bylex', false, false, 0, 0],
                ['destination', 'source', 0, -1, 'BYLEX'],
            ],
            'with BYSCORE argument' => [
                ['destination', 'source', 0, -1, 'byscore', false, false, 0, 0],
                ['destination', 'source', 0, -1, 'BYSCORE'],
            ],
            'with REV argument' => [
                ['destination', 'source', 0, -1, false, true, false, 0, 0],
                ['destination', 'source', 0, -1, 'REV'],
            ],
            'with BYSCORE/BYLEX and LIMIT argument' => [
                ['destination', 'source', 0, -1, 'byscore', false, true, 0, 1],
                ['destination', 'source', 0, -1, 'BYSCORE', 'LIMIT', 0, 1],
            ],
            'with BYSCORE/BYLEX argument and REV argument' => [
                ['destination', 'source', 0, -1, 'byscore', true, false, 0, 0],
                ['destination', 'source', 0, -1, 'BYSCORE', 'REV'],
            ],
            'with BYSCORE/BYLEX argument, REV argument and LIMIT' => [
                ['destination', 'source', 0, -1, 'bylex', true, true, 0, 1],
                ['destination', 'source', 0, -1, 'BYLEX', 'REV', 'LIMIT', 0, 1],
            ],
        ];
    }

    public function rangesProvider(): array
    {
        return [
            'without optional arguments' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                0,
                -1,
                false,
                false,
                false,
                0,
                0,
                3,
                ['member1', 'member2', 'member3'],
            ],
            'with BYLEX argument' => [
                [1, 'abc', 1, 'abb', 1, 'aaa'],
                '[aaa',
                '[abc',
                'bylex',
                false,
                false,
                0,
                0,
                3,
                ['aaa', 'abb', 'abc'],
            ],
            'with BYSCORE argument' => [
                [3, 'member1', 2, 'member2', 1, 'member3'],
                '1',
                '(4',
                'byscore',
                false,
                false,
                0,
                0,
                3,
                ['member3', 'member2', 'member1'],
            ],
            'with REV argument' => [
                [3, 'member1', 2, 'member2', 1, 'member3'],
                0,
                2,
                false,
                true,
                false,
                0,
                0,
                3,
                ['member3', 'member2', 'member1'],
            ],
            'with BYSCORE/BYLEX and LIMIT argument' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                '1',
                '(4',
                'byscore',
                false,
                true,
                0,
                1,
                1,
                ['member1'],
            ],
            'with BYSCORE/BYLEX argument and REV argument' => [
                [3, 'member1', 2, 'member2', 1, 'member3'],
                3,
                0,
                'byscore',
                true,
                false,
                0,
                0,
                3,
                ['member3', 'member2', 'member1'],
            ],
            'with BYSCORE/BYLEX argument, REV argument and LIMIT' => [
                [3, 'member1', 2, 'member2', 1, 'member3'],
                3,
                0,
                'byscore',
                true,
                true,
                0,
                2,
                2,
                ['member2', 'member1'],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'wrong BY argument value' => [
                0, -1, 'wrong value', false, false, 0, 0, 'By argument accepts only "bylex" and "byscore" values',
            ],
            'wrong REV argument type' => [
                0, -1, false, 'wrong value', false, 0, 0, 'Wrong rev argument type',
            ],
            'wrong LIMIT argument type' => [
                0, -1, false, false, 'wrong value', 0, 0, 'Wrong limit argument type',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZRANGE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZRANGE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['zset', 0, 100, ['withscores' => true]];
        $expected = ['zset', 0, 100, 'WITHSCORES'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithStringWithscores(): void
    {
        $arguments = ['zset', 0, 100, 'withscores'];
        $expected = ['zset', 0, 100, 'WITHSCORES'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['element1', 'element2', 'element3'];
        $expected = ['element1', 'element2', 'element3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testParseResponseWithScores(): void
    {
        $raw = ['element1', '1', 'element2', '2', 'element3', '3'];
        $expected = ['element1' => '1', 'element2' => '2', 'element3' => '3'];

        $command = $this->getCommandWithArgumentsArray(['zset', 0, 1, 'withscores']);

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testAddsWithscoresModifiersOnlyWhenOptionIsTrue(): void
    {
        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => true]);
        $this->assertSame(['zset', 0, 100, 'WITHSCORES'], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => 1]);
        $this->assertSame(['zset', 0, 100, 'WITHSCORES'], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => false]);
        $this->assertSame(['zset', 0, 100], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => 0]);
        $this->assertSame(['zset', 0, 100], $command->getArguments());
    }

    /**
     * @group connected
     */
    public function testReturnsElementsInRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame([], $redis->zrange('letters', 1, 0));
        $this->assertSame(['a'], $redis->zrange('letters', 0, 0));
        $this->assertSame(['a', 'b', 'c', 'd'], $redis->zrange('letters', 0, 3));

        $this->assertSame(['a', 'b', 'c', 'd', 'e', 'f'], $redis->zrange('letters', 0, -1));
        $this->assertSame(['a', 'b', 'c'], $redis->zrange('letters', 0, -4));
        $this->assertSame(['c'], $redis->zrange('letters', 2, -4));
        $this->assertSame(['a', 'b', 'c', 'd', 'e', 'f'], $redis->zrange('letters', -100, 100));

        $this->assertSame([], $redis->zrange('unknown', 0, 30));
    }

    /**
     * @group connected
     */
    public function testRangeWithWithscoresModifier(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');
        $expected = ['c' => '10', 'd' => '20', 'e' => '20'];

        $this->assertEquals($expected, $redis->zrange('letters', 2, 4, 'withscores'));
        $this->assertEquals($expected, $redis->zrange('letters', 2, 4, ['withscores' => true]));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zrange('foo', 0, 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZRANK_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZRANK_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZRANK';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZRANK';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'member'];
        $expected = ['key', 'member'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsRank(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(0, $redis->zrank('letters', 'a'));
        $this->assertSame(1, $redis->zrank('letters', 'b'));
        $this->assertSame(4, $redis->zrank('letters', 'e'));

        $this->assertNull($redis->zrank('unknown', 'a'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zrank('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZREMRANGEBYLEX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZREMRANGEBYLEX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZREMRANGEBYLEX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZREMRANGEBYLEX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '[a', '[b'];
        $expected = ['key', '[a', '[b'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testRemovesRangeByLexWithWholeRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(0, $redis->zremrangebylex('letters', '+', '-'));
        $this->assertSame(7, $redis->zremrangebylex('letters', '-', '+'));

        $this->assertSame([], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testRemovesRangeByLexWithInclusiveRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(3, $redis->zremrangebylex('letters', '[b', '[d'));
        $this->assertSame(['a', 'e', 'f', 'g'], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testRemovesRangeByLexWithExclusiveRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(3, $redis->zremrangebylex('letters', '(a', '(e'));
        $this->assertSame(['a', 'e', 'f', 'g'], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testRemovesRangeByLexWithMixedRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(3, $redis->zremrangebylex('letters', '[b', '(e'));
        $this->assertSame(['a', 'e', 'f', 'g'], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnInvalidRangeFormat(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('min or max not valid string range item');

        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');
        $redis->zremrangebylex('letters', 'b', 'f');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zremrangebylex('foo', '[a', '[b');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZREMRANGEBYRANK_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZREMRANGEBYRANK_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZREMRANGEBYRANK';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZREMRANGEBYRANK';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, 10];
        $expected = ['key', 0, 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testRemovesRangeByRank(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(3, $redis->zremrangebyrank('letters', 2, 4));
        $this->assertSame(['a', 'b', 'f'], $redis->zrange('letters', 0, -1));

        $this->assertSame(0, $redis->zremrangebyrank('unknown', 0, 30));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testRemovesRangeByRankWithNegativeIndex(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(3, $redis->zremrangebyrank('letters', -5, 3));
        $this->assertSame(['a', 'e', 'f'], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zremrangebyrank('foo', 0, 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZREMRANGEBYSCORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZREMRANGEBYSCORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZREMRANGEBYSCORE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZREMRANGEBYSCORE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, 10];
        $expected = ['key', 0, 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testRemovesRangeByScore(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(3, $redis->zremrangebyscore('letters', 5, 20));
        $this->assertSame(['a', 'b', 'f'], $redis->zrange('letters', 0, -1));

        $this->assertSame(0, $redis->zremrangebyscore('unknown', 0, 30));
    }

    /**
     * @group connected
     */
    public function testRemovesRangeByExclusiveScore(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(2, $redis->zremrangebyscore('letters', '(10', '(30'));
        $this->assertSame(['a', 'b', 'c', 'f'], $redis->zrange('letters', 0, -1));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zremrangebyscore('foo', 0, 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZREM_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZREM_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZREM';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZREM';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['zset', 'member1', 'member2', 'member3'];
        $expected = ['zset', 'member1', 'member2', 'member3'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testRemovesSpecifiedMembers(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(3, $redis->zrem('letters', 'b', 'd', 'f', 'z'));
        $this->assertSame(['a', 'c', 'e'], $redis->zrange('letters', 0, -1));

        $this->assertSame(0, $redis->zrem('unknown', 'a'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zrem('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZREVRANGEBYLEX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZREVRANGEBYLEX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZREVRANGEBYLEX';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZREVRANGEBYLEX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $modifiers = [
            'limit' => [0, 100],
        ];

        $arguments = ['zset', '[a', '[z', $modifiers];
        $expected = ['zset', '[a', '[z', 'LIMIT', 0, 100];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithNamedLimit(): void
    {
        $arguments = ['zset', '[a', '[z', ['limit' => ['offset' => 1, 'count' => 2]]];
        $expected = ['zset', '[a', '[z', 'LIMIT', 1, 2];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['a', 'b', 'c'];
        $expected = ['a', 'b', 'c'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testReturnsElementsInWholeRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(['g', 'f', 'e', 'd', 'c', 'b', 'a'], $redis->zrevrangebylex('letters', '+', '-'));
        $this->assertSame([], $redis->zrevrangebylex('letters', '-', '+'));
        $this->assertSame([], $redis->zrevrangebylex('unknown', '-', '+'));
        $this->assertSame([], $redis->zrevrangebylex('unknown', '+', '-'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testReturnsElementsInInclusiveRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(['a'], $redis->zrevrangebylex('letters', '[a', '[a'));
        $this->assertSame(['f', 'e', 'd', 'c'], $redis->zrevrangebylex('letters', '[f', '[c'));
        $this->assertSame(['g', 'f', 'e'], $redis->zrevrangebylex('letters', '+', '[e'));
        $this->assertSame([], $redis->zrevrangebylex('letters', '-', '[c'));
        $this->assertSame([], $redis->zrevrangebylex('letters', '[z', '[x'));
        $this->assertSame([], $redis->zrevrangebylex('unknown', '[1', '[0'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testReturnsElementsInExclusiveRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame([], $redis->zrevrangebylex('letters', '(a', '(a'));
        $this->assertSame(['e', 'd'], $redis->zrevrangebylex('letters', '(f', '(c'));
        $this->assertSame(['g', 'f'], $redis->zrevrangebylex('letters', '+', '(e'));
        $this->assertSame([], $redis->zrevrangebylex('letters', '-', '(c'));
        $this->assertSame([], $redis->zrevrangebylex('letters', '(z', '(x'));
        $this->assertSame([], $redis->zrevrangebylex('unknown', '(1', '(0'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testReturnsElementsInMixedRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame([], $redis->zrevrangebylex('letters', '[a', '(a'));
        $this->assertSame([], $redis->zrevrangebylex('letters', '(a', '[a'));
        $this->assertSame(['f', 'e', 'd'], $redis->zrevrangebylex('letters', '[f', '(c'));
        $this->assertSame(['e', 'd', 'c'], $redis->zrevrangebylex('letters', '(f', '[c'));
        $this->assertSame([], $redis->zrevrangebylex('unknown', '[5', '(0'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testRangeWithLimitModifier(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');

        $this->assertSame(['e', 'd', 'c'], $redis->zrevrangebylex('letters', '+', '-', 'LIMIT', '2', '3'));
        $this->assertSame(['e', 'd', 'c'], $redis->zrevrangebylex('letters', '+', '-', ['limit' => [2, 3]]));
        $this->assertSame(['e', 'd', 'c'], $redis->zrevrangebylex('letters', '+', '-', ['limit' => ['offset' => 2, 'count' => 3]]));
        $this->assertSame([], $redis->zrevrangebylex('letters', '[f', '[a', 'LIMIT', '2', '0'));
        $this->assertSame([], $redis->zrevrangebylex('letters', '[f', '[a', 'LIMIT', '-4', '2'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnInvalidRangeFormat(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('min or max not valid string range item');

        $redis = $this->getClient();

        $redis->zadd('letters', 0, 'a', 0, 'b', 0, 'c', 0, 'd', 0, 'e', 0, 'f', 0, 'g');
        $redis->zrevrangebylex('letters', 'f', 'b');
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.9
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zrevrangebylex('foo', '+', '-');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZREVRANGEBYSCORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZREVRANGEBYSCORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZREVRANGEBYSCORE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZREVRANGEBYSCORE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $modifiers = [
            'withscores' => true,
            'limit' => [0, 100],
        ];

        $arguments = ['zset', 0, 100, $modifiers];
        $expected = ['zset', 0, 100, 'LIMIT', 0, 100, 'WITHSCORES'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithStringWithscores(): void
    {
        $arguments = ['zset', 0, 100, 'withscores'];
        $expected = ['zset', 0, 100, 'WITHSCORES'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithNamedLimit(): void
    {
        $arguments = ['zset', 0, 100, ['limit' => ['offset' => 1, 'count' => 2]]];
        $expected = ['zset', 0, 100, 'LIMIT', 1, 2];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['element1', 'element2', 'element3'];
        $expected = ['element1', 'element2', 'element3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testParseResponseWithScores(): void
    {
        $raw = ['element1', '1', 'element2', '2', 'element3', '3'];
        $expected = ['element1' => '1', 'element2' => '2', 'element3' => '3'];

        $command = $this->getCommandWithArgumentsArray(['zset', 0, 1, 'withscores']);

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testAddsWithscoresModifiersOnlyWhenOptionIsTrue(): void
    {
        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => true]);
        $this->assertSame(['zset', 0, 100, 'WITHSCORES'], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => 1]);
        $this->assertSame(['zset', 0, 100, 'WITHSCORES'], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => false]);
        $this->assertSame(['zset', 0, 100], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => 0]);
        $this->assertSame(['zset', 0, 100], $command->getArguments());
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testReturnsElementsInScoreRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(['a'], $redis->zrevrangebyscore('letters', -10, -10));
        $this->assertSame([], $redis->zrevrangebyscore('letters', 10, 30));
        $this->assertSame(['e', 'd'], $redis->zrevrangebyscore('letters', 20, 20));
        $this->assertSame(['f', 'e', 'd', 'c', 'b'], $redis->zrevrangebyscore('letters', 30, 0));

        $this->assertSame([], $redis->zrevrangebyscore('unknown', 0, 30));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testInfinityScoreIntervals(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(['f', 'e', 'd'], $redis->zrevrangebyscore('letters', '+inf', 15));
        $this->assertSame(['c', 'b', 'a'], $redis->zrevrangebyscore('letters', 15, '-inf'));
        $this->assertSame(['f', 'e', 'd', 'c', 'b', 'a'], $redis->zrevrangebyscore('letters', '+inf', '-inf'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testExclusiveScoreIntervals(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(['e', 'd', 'c'], $redis->zrevrangebyscore('letters', '(30', 10));
        $this->assertSame(['f', 'e', 'd'], $redis->zrevrangebyscore('letters', 30, '(10'));
        $this->assertSame(['e', 'd'], $redis->zrevrangebyscore('letters', '(30', '(10'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testRangeWithWithscoresModifier(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');
        $expected = ['e' => '20', 'd' => '20', 'c' => '10'];

        $this->assertEquals($expected, $redis->zrevrangebyscore('letters', 20, 10, 'withscores'));
        $this->assertEquals($expected, $redis->zrevrangebyscore('letters', 20, 10, ['withscores' => true]));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testRangeWithLimitModifier(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');
        $expected = ['d', 'c'];

        $this->assertSame($expected, $redis->zrevrangebyscore('letters', 20, 10, ['limit' => [1, 2]]));
        $this->assertSame($expected, $redis->zrevrangebyscore('letters', 20, 10, ['limit' => ['offset' => 1, 'count' => 2]]));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testRangeWithCombinedModifiers(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $options = ['limit' => [1, 2], 'withscores' => true];
        $expected = ['d' => '20', 'c' => '10'];

        $this->assertEquals($expected, $redis->zrevrangebyscore('letters', 20, 10, $options));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zrevrangebyscore('foo', 0, 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZREVRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZREVRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZREVRANGE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZREVRANGE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['zset', 0, 100, ['withscores' => true]];
        $expected = ['zset', 0, 100, 'WITHSCORES'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithStringWithscores(): void
    {
        $arguments = ['zset', 0, 100, 'withscores'];
        $expected = ['zset', 0, 100, 'WITHSCORES'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['element1', 'element2', 'element3'];
        $expected = ['element1', 'element2', 'element3'];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testParseResponseWithScores(): void
    {
        $raw = ['element1', '1', 'element2', '2', 'element3', '3'];
        $expected = ['element1' => '1', 'element2' => '2', 'element3' => '3'];

        $command = $this->getCommandWithArgumentsArray(['zset', 0, 1, 'withscores']);

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group disconnected
     */
    public function testAddsWithscoresModifiersOnlyWhenOptionIsTrue(): void
    {
        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => true]);
        $this->assertSame(['zset', 0, 100, 'WITHSCORES'], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => 1]);
        $this->assertSame(['zset', 0, 100, 'WITHSCORES'], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => false]);
        $this->assertSame(['zset', 0, 100], $command->getArguments());

        $command = $this->getCommandWithArguments('zset', 0, 100, ['withscores' => 0]);
        $this->assertSame(['zset', 0, 100], $command->getArguments());
    }

    /**
     * @group connected
     */
    public function testReturnsElementsInRange(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame([], $redis->zrevrange('letters', 1, 0));
        $this->assertSame(['f'], $redis->zrevrange('letters', 0, 0));
        $this->assertSame(['f', 'e', 'd', 'c'], $redis->zrevrange('letters', 0, 3));

        $this->assertSame(['f', 'e', 'd', 'c', 'b', 'a'], $redis->zrevrange('letters', 0, -1));
        $this->assertSame(['f', 'e', 'd'], $redis->zrevrange('letters', 0, -4));
        $this->assertSame(['d'], $redis->zrevrange('letters', 2, -4));
        $this->assertSame(['f', 'e', 'd', 'c', 'b', 'a'], $redis->zrevrange('letters', -100, 100));

        $this->assertSame([], $redis->zrevrange('unknown', 0, 30));
    }

    /**
     * @group connected
     */
    public function testRangeWithWithscoresModifier(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');
        $expected = ['d' => '20', 'c' => '10', 'b' => '0'];

        $this->assertEquals($expected, $redis->zrevrange('letters', 2, 4, 'withscores'));
        $this->assertEquals($expected, $redis->zrevrange('letters', 2, 4, ['withscores' => true]));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zrevrange('foo', 0, 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZREVRANK_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZREVRANK_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZREVRANK';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZREVRANK';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'member'];
        $expected = ['key', 'member'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testReturnsRank(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertSame(5, $redis->zrevrank('letters', 'a'));
        $this->assertSame(4, $redis->zrevrank('letters', 'b'));
        $this->assertSame(1, $redis->zrevrank('letters', 'e'));

        $this->assertNull($redis->zrevrank('unknown', 'a'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zrevrank('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZSCAN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZSCAN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZSCAN';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZSCAN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 0, 'MATCH', 'member:*', 'COUNT', 10];
        $expected = ['key', 0, 'MATCH', 'member:*', 'COUNT', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsBasicUsage(): void
    {
        $arguments = ['key', 0];
        $expected = ['key', 0];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testFilterArgumentsWithOptionsArray(): void
    {
        $arguments = ['key', 0, ['match' => 'member:*', 'count' => 10]];
        $expected = ['key', 0, 'MATCH', 'member:*', 'COUNT', 10];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $raw = ['3', ['member:1', '1', 'member:2', '2', 'member:3', '3']];
        $expected = ['3', ['member:1' => 1.0, 'member:2' => 2.0, 'member:3' => 3.0]];

        $command = $this->getCommand();

        $this->assertSame($expected, $command->parseResponse($raw));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithoutMatch(): void
    {
        $expectedMembers = ['member:one', 'member:two', 'member:three', 'member:four'];
        $expectedScores = [1.0, 2.0, 3.0, 4.0];

        $redis = $this->getClient();
        $redis->zadd('key', array_combine($expectedMembers, $expectedScores));

        $response = $redis->zscan('key', 0);

        $this->assertSame('0', $response[0]);
        $this->assertSame($expectedMembers, array_keys($response[1]));
        $this->assertSame($expectedScores, array_values($response[1]));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithMatchingMembers(): void
    {
        $redis = $this->getClient();
        $redis->zadd('key', ['member:one' => 1.0, 'member:two' => 2.0, 'member:three' => 3.0, 'member:four' => 4.0]);

        $response = $redis->zscan('key', 0, 'MATCH', 'member:t*');

        $this->assertSame(['member:two', 'member:three'], array_keys($response[1]));
        $this->assertSame([2.0, 3.0], array_values($response[1]));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.8.0
     */
    public function testScanWithNoMatchingMembers(): void
    {
        $redis = $this->getClient();
        $redis->zadd('key', $members = ['member:one' => 1.0, 'member:two' => 2.0, 'member:three' => 3.0, 'member:four' => 4.0]);

        $response = $redis->zscan('key', 0, 'MATCH', 'nomember:*');

        $this->assertSame('0', $response[0]);
        $this->assertEmpty($response[1]);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZSCORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

/**
 * @group commands
 * @group realm-zset
 */
class ZSCORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return 'Predis\Command\Redis\ZSCORE';
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZSCORE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', 'member'];
        $expected = ['key', 'member'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     */
    public function testReturnsRank(): void
    {
        $redis = $this->getClient();

        $redis->zadd('letters', -10, 'a', 0, 'b', 10, 'c', 20, 'd', 20, 'e', 30, 'f');

        $this->assertEquals('-10', $redis->zscore('letters', 'a'));
        $this->assertEquals('0', $redis->zscore('letters', 'b'));
        $this->assertEquals('20', $redis->zscore('letters', 'e'));

        $this->assertNull($redis->zscore('unknown', 'a'));
    }

    /**
     * @group connected
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zscore('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZUNIONSTORE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-zset
 */
class ZUNIONSTORE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritdoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZUNIONSTORE::class;
    }

    /**
     * {@inheritdoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZUNIONSTORE';
    }

    /**
     * @dataProvider argumentsProvider
     * @group disconnected
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @dataProvider sortedSetsProvider
     * @param  array  $firstSortedSet
     * @param  array  $secondSortedSet
     * @param  string $destination
     * @param  array  $weights
     * @param  string $aggregate
     * @param  int    $expectedResponse
     * @param  array  $expectedResultSortedSet
     * @return void
     * @requiresRedisVersion >= 2.0.0
     */
    public function testStoresUnionValuesOnSortedSets(
        array $firstSortedSet,
        array $secondSortedSet,
        string $destination,
        array $weights,
        string $aggregate,
        int $expectedResponse,
        array $expectedResultSortedSet
    ): void {
        $redis = $this->getClient();

        $redis->zadd('test-zunionstore1', ...$firstSortedSet);
        $redis->zadd('test-zunionstore2', ...$secondSortedSet);

        $actualResponse = $redis->zunionstore(
            $destination,
            ['test-zunionstore1', 'test-zunionstore2'],
            $weights,
            $aggregate
        );

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertEquals(
            $expectedResultSortedSet,
            $redis->zrange($destination, 0, -1, ['withscores' => true])
        );
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zunionstore('zset_unionstore:destination', ['foo']);
    }

    /**
     * @dataProvider unexpectedValueProvider
     * @param  string $destination
     * @param         $keys
     * @param         $weights
     * @param  string $aggregate
     * @param  string $expectedExceptionMessage
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(
        string $destination,
        $keys,
        $weights,
        string $aggregate,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->zunionstore($destination, $keys, $weights, $aggregate);
    }

    public function argumentsProvider(): array
    {
        return [
            'with required arguments only' => [
                ['destination', ['key1', 'key2']],
                ['destination', 2, 'key1', 'key2'],
            ],
            'with weights' => [
                ['destination', ['key1', 'key2'], [1, 2]],
                ['destination', 2, 'key1', 'key2', 'WEIGHTS', 1, 2],
            ],
            'with aggregate' => [
                ['destination', ['key1', 'key2'], [], 'min'],
                ['destination', 2, 'key1', 'key2', 'AGGREGATE', 'MIN'],
            ],
            'with all arguments' => [
                ['destination', ['key1', 'key2'], [1, 2], 'min'],
                ['destination', 2, 'key1', 'key2', 'WEIGHTS', 1, 2, 'AGGREGATE', 'MIN'],
            ],
            'with options array' => [
                ['destination', ['key1', 'key2'], [
                    'weights' => [1, 2],
                    'aggregate' => 'min',
                ]],
                ['destination', 2, 'key1', 'key2', 'WEIGHTS', 1, 2, 'AGGREGATE', 'MIN'],
            ],
        ];
    }

    public function sortedSetsProvider(): array
    {
        return [
            'with required arguments' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2'],
                'destination',
                [],
                'sum',
                3,
                ['member1' => '2', 'member3' => '3', 'member2' => '4'],
            ],
            'with weights' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2'],
                'destination',
                [2, 3],
                'sum',
                3,
                ['member1' => '5', 'member3' => '6', 'member2' => '10'],
            ],
            'with aggregate' => [
                [1, 'member1', 4, 'member2', 3, 'member3'],
                [2, 'member1', 2, 'member2'],
                'destination',
                [],
                'max',
                3,
                ['member1' => '2', 'member3' => '3', 'member2' => '4'],
            ],
            'with all arguments' => [
                [1, 'member1', 5, 'member2', 4, 'member3'],
                [2, 'member1', 2, 'member2'],
                'destination',
                [2, 3],
                'max',
                3,
                ['member1' => '6', 'member3' => '8', 'member2' => '10'],
            ],
        ];
    }

    public function unexpectedValueProvider(): array
    {
        return [
            'with unexpected keys argument' => [
                'destination',
                1,
                [],
                'sum',
                'Wrong keys argument type or position offset',
            ],
            'with unexpected weights argument' => [
                'destination',
                ['key1'],
                1,
                'sum',
                'Wrong weights argument type',
            ],
            'with unexpected aggregate argument' => [
                'destination',
                ['key1'],
                [],
                'wrong',
                'Aggregate argument accepts only: min, max, sum values',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\ZUNION_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis;

use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-zset
 */
class ZUNION_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return ZUNION::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'ZUNION';
    }

    /**
     * @dataProvider argumentsProvider
     * @group disconnected
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group connected
     * @dataProvider sortedSetsProvider
     * @param  array  $firstSortedSet
     * @param  array  $secondSortedSet
     * @param  array  $weights
     * @param  string $aggregate
     * @param  bool   $withScores
     * @param  array  $expectedResponse
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testReturnsIntersectedValuesOnSortedSets(
        array $firstSortedSet,
        array $secondSortedSet,
        array $weights,
        string $aggregate,
        bool $withScores,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->zadd('test-zunion1', ...$firstSortedSet);
        $redis->zadd('test-zunion2', ...$secondSortedSet);

        $actualResponse = $redis->zunion(
            ['test-zunion1', 'test-zunion2'],
            $weights,
            $aggregate,
            $withScores
        );

        $this->assertEquals($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('foo', 'bar');
        $redis->zunion(['foo']);
    }

    /**
     * @dataProvider unexpectedValueProvider
     * @param         $keys
     * @param         $weights
     * @param  string $aggregate
     * @param  bool   $withScores
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisVersion >= 6.2.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(
        $keys,
        $weights,
        string $aggregate,
        bool $withScores,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->zunion($keys, $weights, $aggregate, $withScores);
    }

    public function argumentsProvider(): array
    {
        return [
            'with required arguments only' => [
                [['key1', 'key2']],
                [2, 'key1', 'key2'],
            ],
            'with weights' => [
                [['key1', 'key2'], [1, 2]],
                [2, 'key1', 'key2', 'WEIGHTS', 1, 2],
            ],
            'with aggregate' => [
                [['key1', 'key2'], [], 'min'],
                [2, 'key1', 'key2', 'AGGREGATE', 'MIN'],
            ],
            'with withscores' => [
                [['key1', 'key2'], [], 'min', true],
                [2, 'key1', 'key2', 'AGGREGATE', 'MIN', 'WITHSCORES'],
            ],
            'with all arguments' => [
                [['key1', 'key2'], [1, 2], 'min', true],
                [2, 'key1', 'key2', 'WEIGHTS', 1, 2, 'AGGREGATE', 'MIN', 'WITHSCORES'],
            ],
        ];
    }

    public function sortedSetsProvider(): array
    {
        return [
            'with required arguments' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2'],
                [],
                'sum',
                false,
                ['member1', 'member3', 'member2'],
            ],
            'with weights and withscores' => [
                [1, 'member1', 2, 'member2', 3, 'member3'],
                [1, 'member1', 2, 'member2'],
                [2, 3],
                'sum',
                true,
                ['member1' => '5', 'member3' => '6', 'member2' => '10'],
            ],
            'with aggregate and withscores' => [
                [1, 'member1', 4, 'member2', 3, 'member3'],
                [2, 'member1', 2, 'member2'],
                [],
                'max',
                true,
                ['member1' => '2', 'member3' => '3', 'member2' => '4'],
            ],
            'with all arguments' => [
                [1, 'member1', 5, 'member2', 4, 'member3'],
                [2, 'member1', 2, 'member2'],
                [2, 3],
                'max',
                true,
                ['member1' => '6', 'member3' => '8', 'member2' => '10'],
            ],
        ];
    }

    public function unexpectedValueProvider(): array
    {
        return [
            'with unexpected keys argument' => [
                1,
                [],
                'sum',
                false,
                'Wrong keys argument type or position offset',
            ],
            'with unexpected weights argument' => [
                ['key1'],
                1,
                'sum',
                false,
                'Wrong weights argument type',
            ],
            'with unexpected aggregate argument' => [
                ['key1'],
                [],
                'wrong',
                false,
                'Aggregate argument accepts only: min, max, sum values',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\AbstractCommand\BZPOPBaseTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\AbstractCommand;

use Predis\Command\CommandInterface;
use PredisTestCase;

class BZPOPBaseTest extends PredisTestCase
{
    /**
     * @var CommandInterface
     */
    private $testCommand;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testCommand = new class extends BZPOPBase {
            public function getId(): string
            {
                return 'test';
            }
        };
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $this->testCommand->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testCommand->getArguments());
    }

    /**
     * @group disconnected
     * @dataProvider responsesProvider
     */
    public function testParseResponse(array $actualResponse, array $expectedResponse): void
    {
        $this->assertSame($expectedResponse, $this->testCommand->parseResponse($actualResponse));
    }

    public function argumentsProvider(): array
    {
        return [
            'with one key' => [
                [['key1'], 1],
                ['key1', 1],
            ],
            'with multiple keys' => [
                [['key1', 'key2', 'key3'], 1],
                ['key1', 'key2', 'key3', 1],
            ],
        ];
    }

    public function responsesProvider(): array
    {
        return [
            'null-element array' => [
                [null],
                [null],
            ],
            'three-element array' => [
                ['key', 'member', 'score'],
                ['key' => ['member' => 'score']],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BloomFilter\BFADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class BFADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BFADD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BFADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item'];
        $expectedArguments = ['key', 'item'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testAddGivenItemIntoBloomFilter(): void
    {
        $redis = $this->getClient();

        $actualResponse = $redis->bfadd('key', 'item');
        $this->assertSame(1, $actualResponse);
        $this->assertSame(1, $redis->bfexists('key', 'item'));
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('bfadd_foo', 'bar');
        $redis->bfadd('bfadd_foo', 'foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BloomFilter\BFEXISTS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class BFEXISTS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BFEXISTS::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BFEXISTS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item'];
        $expectedArguments = ['key', 'item'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testExistsReturnsExistingItemWithinBloomFilter(): void
    {
        $redis = $this->getClient();

        $redis->bfadd('key', 'item');

        $this->assertSame(1, $redis->bfexists('key', 'item'));
        $this->assertSame(0, $redis->bfexists('key', 'non-existing'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BloomFilter\BFINFO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-stack
 */
class BFINFO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BFINFO::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BFINFO';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     * @dataProvider responsesProvider
     */
    public function testParseResponse(array $actualResponse, array $expectedResponse): void
    {
        $this->assertSame($expectedResponse, $this->getCommand()->parseResponse($actualResponse));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider filtersProvider
     * @param  array  $filter
     * @param  string $key
     * @param  string $modifier
     * @param  array  $expectedResponse
     * @return void
     * @requiresRedisBfVersion 1.0.0
     */
    public function testInfoReturnsCorrectInformationAboutBloomFilter(
        array $filter,
        string $key,
        string $modifier,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->bfadd(...$filter);
        $this->assertSame($expectedResponse, $redis->bfinfo($key, $modifier));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion 1.0.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Argument accepts only: capacity, size, filters, items, expansion values');

        $redis->bfinfo('key', 'wrong');
    }

    /**
     * @group connected
     * @group relay-resp3
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('binfo_foo', 'bar');
        $redis->bfinfo('binfo_foo');
    }

    public function argumentsProvider(): array
    {
        return [
            'without argument' => [
                [],
                [],
            ],
            'with default modifier value' => [
                ['key', ''],
                ['key'],
            ],
            'with CAPACITY modifier' => [
                ['key', 'capacity'],
                ['key', 'CAPACITY'],
            ],
            'with SIZE modifier' => [
                ['key', 'size'],
                ['key', 'SIZE'],
            ],
            'with FILTERS modifier' => [
                ['key', 'filters'],
                ['key', 'FILTERS'],
            ],
            'with ITEMS modifier' => [
                ['key', 'items'],
                ['key', 'ITEMS'],
            ],
            'with EXPANSION modifier' => [
                ['key', 'expansion'],
                ['key', 'EXPANSION'],
            ],
        ];
    }

    public function responsesProvider(): array
    {
        return [
            'with one modifier' => [
                [100],
                [100],
            ],
            'with all modifiers' => [
                [
                    'Capacity',
                    100,
                    'Size',
                    296,
                    'Number of filters',
                    1,
                    'Number of items inserted',
                    1,
                    'Expansion rate',
                    2,
                ],
                [
                    'Capacity' => 100,
                    'Size' => 296,
                    'Number of filters' => 1,
                    'Number of items inserted' => 1,
                    'Expansion rate' => 2,
                ],
            ],
        ];
    }

    public function filtersProvider(): array
    {
        return [
            'without modifier' => [
                ['key', 'item'],
                'key',
                '',
                [
                    'Capacity' => 100,
                    'Size' => 240,
                    'Number of filters' => 1,
                    'Number of items inserted' => 1,
                    'Expansion rate' => 2,
                ],
            ],
            'with CAPACITY modifier' => [
                ['key', 'item'],
                'key',
                'capacity',
                [100],
            ],
            'with SIZE modifier' => [
                ['key', 'item'],
                'key',
                'size',
                [240],
            ],
            'with FILTERS modifier' => [
                ['key', 'item'],
                'key',
                'filters',
                [1],
            ],
            'with ITEMS modifier' => [
                ['key', 'item'],
                'key',
                'items',
                [1],
            ],
            'with EXPANSION modifier' => [
                ['key', 'item'],
                'key',
                'expansion',
                [2],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BloomFilter\BFINSERT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-stack
 */
class BFINSERT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BFINSERT::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BFINSERT';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider filtersProvider
     * @param  array  $arguments
     * @param  string $key
     * @param  string $modifier
     * @param  array  $expectedInfo
     * @param  array  $expectedResponse
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInsertCreatesBloomFilterWithGivenItems(
        array $arguments,
        string $key,
        string $modifier,
        array $expectedInfo,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $actualResponse = $redis->bfinsert(...$arguments);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedInfo, $redis->bfinfo($key, $modifier));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInsertThrowsExceptionOnNonExistingBloomFilterWithNoCreateModifier(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR not found');

        $redis->bfinsert('key', -1, -1, -1, true, false, 'item1');
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInsertAddItemOnlyOnExistingFilterWithNoCreateModifier(): void
    {
        $redis = $this->getClient();

        $redis->bfadd('key', 'item1');
        $actualResponse = $redis->bfinsert(
            'key',
            -1,
            -1,
            -1,
            false,
            false,
            'item2'
        );

        $this->assertSame([1], $actualResponse);
        $this->assertSame(
            [
                'Capacity' => 100,
                'Size' => 240,
                'Number of filters' => 1,
                'Number of items inserted' => 2,
                'Expansion rate' => 2,
            ],
            $redis->bfinfo('key', '')
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider unexpectedValuesProvider
     * @param  array  $arguments
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(
        array $arguments,
        string $expectedExceptionMessage
    ): void {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->bfinsert(...$arguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', -1, -1, -1, false, false, 'item1'],
                ['key', 'ITEMS', 'item1'],
            ],
            'with CAPACITY modifier' => [
                ['key', 100, -1, -1, false, false, 'item1'],
                ['key', 'CAPACITY', 100, 'ITEMS', 'item1'],
            ],
            'with ERROR modifier' => [
                ['key', -1, 0.01, -1, false, false, 'item1'],
                ['key', 'ERROR', 0.01, 'ITEMS', 'item1'],
            ],
            'with EXPANSION modifier' => [
                ['key', -1, -1, 2, false, false, 'item1'],
                ['key', 'EXPANSION', 2, 'ITEMS', 'item1'],
            ],
            'with NOCREATE modifier' => [
                ['key', -1, -1, -1, true, false, 'item1'],
                ['key', 'NOCREATE', 'ITEMS', 'item1'],
            ],
            'with NONSCALING modifier' => [
                ['key', -1, -1, -1, false, true, 'item1'],
                ['key', 'NONSCALING', 'ITEMS', 'item1'],
            ],
            'with all arguments' => [
                ['key', 100, 0.01, 2, true, true, 'item1', 'item2'],
                ['key', 'CAPACITY', 100, 'ERROR', 0.01, 'EXPANSION', 2, 'NOCREATE', 'NONSCALING', 'ITEMS', 'item1', 'item2'],
            ],
        ];
    }

    public function filtersProvider(): array
    {
        return [
            'with default filter' => [
                ['key', -1, -1, -1, false, false, 'item1', 'item2'],
                'key',
                '',
                [
                    'Capacity' => 100,
                    'Size' => 240,
                    'Number of filters' => 1,
                    'Number of items inserted' => 2,
                    'Expansion rate' => 2,
                ],
                [1, 1],
            ],
            'with CAPACITY modifier' => [
                ['key', 120, -1, -1, false, false, 'item1', 'item2'],
                'key',
                'capacity',
                [120],
                [1, 1],
            ],
            'with ERROR modifier' => [
                ['key', -1, 0.01, -1, false, false, 'item1', 'item2'],
                'key',
                '',
                [
                    'Capacity' => 100,
                    'Size' => 240,
                    'Number of filters' => 1,
                    'Number of items inserted' => 2,
                    'Expansion rate' => 2,
                ],
                [1, 1],
            ],
            'with EXPANSION modifier' => [
                ['key', -1, -1, 3, false, false, 'item1', 'item2'],
                'key',
                'expansion',
                [3],
                [1, 1],
            ],
            'with NONSCALING modifier' => [
                ['key', -1, -1, -1, false, true, 'item1', 'item2'],
                'key',
                'expansion',
                [null],
                [1, 1],
            ],
            'with all arguments' => [
                ['key', 120, 0.01, 3, false, false, 'item1', 'item2'],
                'key',
                '',
                [
                    'Capacity' => 120,
                    'Size' => 264,
                    'Number of filters' => 1,
                    'Number of items inserted' => 2,
                    'Expansion rate' => 3,
                ],
                [1, 1],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'with wrong CAPACITY' => [
                ['key', -5, -1, -1, false, false, 'item1', 'item2'],
                'Wrong capacity argument value or position offset',
            ],
            'with wrong ERROR' => [
                ['key', -1, -5, -1, false, false, 'item1', 'item2'],
                'Wrong error argument value or position offset',
            ],
            'with wrong EXPANSION' => [
                ['key', -1, -1, -5, false, false, 'item1', 'item2'],
                'Wrong expansion argument value or position offset',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BloomFilter\BFLOADCHUNK_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class BFLOADCHUNK_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BFLOADCHUNK::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BFLOADCHUNK';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1, 'data'];
        $expectedArguments = ['key', 1, 'data'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testLoadChunkSuccessfullyRestoresBloomFilter(): void
    {
        $redis = $this->getClient();

        $redis->bfadd('key', 'item1');

        $chunks = [];
        $iter = 0;

        while (true) {
            [$iter, $data] = $redis->bfscandump('key', $iter);

            if ($iter === 0) {
                break;
            }

            $chunks[] = [$iter, $data];
        }

        $redis->flushall();

        foreach ($chunks as $chunk) {
            [$iter, $data] = $chunk;
            $actualResponse = $redis->bfloadchunk('key', $iter, $data);

            $this->assertEquals('OK', $actualResponse);
        }

        $this->assertSame(1, $redis->bfexists('key', 'item1'));
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('bfloadchunk_foo', 'bar');
        $redis->bfloadchunk('bfloadchunk_foo', 0, 'data');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BloomFilter\BFMADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class BFMADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BFMADD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BFMADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item1', 'item2'];
        $expectedArguments = ['key', 'item1', 'item2'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testAddGivenItemsIntoBloomFilter(): void
    {
        $redis = $this->getClient();

        $actualResponse = $redis->bfmadd('key', 'item1', 'item2');
        $this->assertSame([1, 1], $actualResponse);
        $this->assertSame([1, 1], $redis->bfmexists('key', 'item1', 'item2'));
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('bfmadd_foo', 'bar');
        $redis->bfmadd('bfmadd_foo', 'foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BloomFilter\BFMEXISTS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class BFMEXISTS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BFMEXISTS::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BFMEXISTS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item1', 'item2'];
        $expectedArguments = ['key', 'item1', 'item2'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testExistsReturnsExistingItemsWithinBloomFilter(): void
    {
        $redis = $this->getClient();

        $redis->bfmadd('key', 'item1', 'item2');
        $this->assertSame([1, 1], $redis->bfmexists('key', 'item1', 'item2'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BloomFilter\BFRESERVE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-stack
 */
class BFRESERVE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BFRESERVE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BFRESERVE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider filtersProvider
     * @param  array  $filter
     * @param  string $key
     * @param  string $modifier
     * @param  array  $expectedModification
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testReserveCreatesBloomFilterWithCorrectConfiguration(
        array $filter,
        string $key,
        string $modifier,
        array $expectedModification
    ): void {
        $redis = $this->getClient();

        $actualResponse = $redis->bfreserve(...$filter);
        $this->assertEquals('OK', $actualResponse);
        $this->assertSame($expectedModification, $redis->bfinfo($key, $modifier));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion 1.0.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong expansion argument value or position offset');

        $redis->bfreserve('key', 0.01, 2, 0);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('bfreserve_foo', 'bar');
        $redis->bfreserve('bfreserve_foo', 0.01, 2);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 0.01, 2],
                ['key', 0.01, 2],
            ],
            'with EXPANSION argument' => [
                ['key', 0.01, 2, 2],
                ['key', 0.01, 2, 'EXPANSION', 2],
            ],
            'with NONSCALING modifier' => [
                ['key', 0.01, 2, -1, true],
                ['key', 0.01, 2, 'NONSCALING'],
            ],
            'with all arguments' => [
                ['key', 0.01, 2, 2, true],
                ['key', 0.01, 2, 'EXPANSION', 2, 'NONSCALING'],
            ],
        ];
    }

    public function filtersProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 0.01, 100],
                'key',
                'capacity',
                [100],
            ],
            'with modified expansion' => [
                ['key', 0.01, 100, 2],
                'key',
                'expansion',
                [2],
            ],
            'with NONSCALING modifier' => [
                ['key', 0.01, 100, -1, true],
                'key',
                'expansion',
                [null],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\BloomFilter\BFSCANDUMP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\BloomFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class BFSCANDUMP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return BFSCANDUMP::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'BFSCANDUMP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1];
        $expectedArguments = ['key', 1];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testScanDumpReturnsCorrectDataChunk(): void
    {
        $expectedIterator = 1;
        $redis = $this->getClient();

        $redis->bfadd('key', 'item1');
        [$iterator, $dataChunk] = $redis->bfscandump('key', 0);

        $this->assertSame($expectedIterator, $iterator);
        $this->assertNotEmpty($dataChunk);
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('bfscandump_foo', 'bar');
        $redis->bfscandump('bfscandump_foo', 0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Container\AbstractContainerTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container;

use PHPUnit\Framework\TestCase;
use Predis\ClientInterface;
use Predis\Command\CommandInterface;

class AbstractContainerTest extends TestCase
{
    /**
     * @var AbstractContainer
     */
    private $testClass;

    /**
     * @var array
     */
    private $arguments;

    /**
     * @var array
     */
    private $expectedValue;

    /**
     * @var \PHPUnit\Framework\MockObject\MockObject|ClientInterface
     */
    private $mockClient;

    /**
     * @var \PHPUnit\Framework\MockObject\MockObject|CommandInterface
     */
    private $mockCommand;

    protected function setUp(): void
    {
        $this->arguments = ['arg1', 'arg2'];
        $this->expectedValue = ['value'];
        $this->mockCommand = $this->getMockBuilder(CommandInterface::class)->getMock();
        $this->mockClient = $this->getMockBuilder(ClientInterface::class)->getMock();

        $this->testClass = new class($this->mockClient) extends AbstractContainer {
            public function getContainerCommandId(): string
            {
                return 'test';
            }
        };
    }

    /**
     * @return void
     */
    public function testGetContainerId(): void
    {
        $this->assertSame('test', $this->testClass->getContainerCommandId());
    }

    /**
     * @return void
     */
    public function testCallReturnsValidCommandResponse(): void
    {
        $modifiedArguments = ['TEST', ['arg1', 'arg2']];

        $this->mockClient
            ->expects($this->once())
            ->method('createCommand')
            ->with($this->equalTo('test'), $modifiedArguments)
            ->willReturn($this->mockCommand);

        $this->mockClient
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->mockCommand)
            ->willReturn($this->expectedValue);

        $this->assertSame($this->expectedValue, $this->testClass->test($this->arguments));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Container\CLUSTER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container;

use Predis\ClientInterface;
use PredisTestCase;

class CLUSTER_Test extends PredisTestCase
{
    public function testGetContainerCommandId(): void
    {
        $mockClient = $this->getMockBuilder(ClientInterface::class)->getMock();
        $command = new CLUSTER($mockClient);

        $this->assertSame('CLUSTER', $command->getContainerCommandId());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Container\ContainerFactoryTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Container;

use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use Predis\ClientInterface;
use Predis\Command\Redis\Container\Search\FTCONFIG;
use UnexpectedValueException;

class ContainerFactoryTest extends TestCase
{
    /**
     * @var MockObject|ClientInterface
     */
    private $mockClient;

    /**
     * @var ContainerFactory
     */
    private $factory;

    protected function setUp(): void
    {
        $this->mockClient = $this->getMockBuilder(ClientInterface::class)->getMock();
        $this->factory = new ContainerFactory();
    }

    /**
     * @dataProvider containerProvider
     * @param  string $containerCommandId
     * @param  string $expectedContainerClass
     * @return void
     */
    public function testCreatesReturnsExistingCommandContainerClass(
        string $containerCommandId,
        string $expectedContainerClass
    ): void {
        $expectedContainer = new $expectedContainerClass($this->mockClient);

        $this->assertEquals(
            $expectedContainer,
            $this->factory::create($this->mockClient, $containerCommandId)
        );
    }

    /**
     * @dataProvider unexpectedValuesProvider
     * @param  string $containerCommandId
     * @param  string $expectedExceptionMessage
     * @return void
     */
    public function testThrowsExceptionOnNonExistingCommand(
        string $containerCommandId,
        string $expectedExceptionMessage
    ): void {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $this->factory::create($this->mockClient, $containerCommandId);
    }

    public function containerProvider(): array
    {
        return [
            'core command' => ['function', FunctionContainer::class],
            'module command' => ['ftconfig', FTCONFIG::class],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'not supported module container command' => ['ftfoobar', 'Given module container command is not supported.'],
            'not supported core container command' => ['foobar', 'Given container command is not supported.'],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CountMinSketch\CMSINCRBY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CMSINCRBY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CMSINCRBY::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CMSINCRBY';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item1', 1, 'item2', 1];
        $expectedArguments = ['key', 'item1', 1, 'item2', 1];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider sketchesProvider
     * @param  array $incrementArguments
     * @param  array $queryArguments
     * @param  array $expectedResponse
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testIncrementGivenItemsWithinCountMinSketch(
        array $incrementArguments,
        array $queryArguments,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->cmsinitbydim('key', 2000, 7);

        $actualResponse = $redis->cmsincrby(...$incrementArguments);
        $queryResponse = $redis->cmsquery(...$queryArguments);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedResponse, $queryResponse);
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('CMS: key does not exist');

        $redis = $this->getClient();

        $redis->cmsincrby('cmsincrby_foo', 'item1', 1);
    }

    public function sketchesProvider(): array
    {
        return [
            'with single item' => [
                ['key', 'item1', 1],
                ['key', 'item1'],
                [1],
            ],
            'with multiple items' => [
                ['key', 'item1', 1, 'item2', 1],
                ['key', 'item1', 'item2'],
                [1, 1],
            ],
            'with incrementing on X' => [
                ['key', 'item1', 2, 'item2', 5],
                ['key', 'item1', 'item2'],
                [2, 5],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CountMinSketch\CMSINFO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CMSINFO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CMSINFO::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CMSINFO';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key'];
        $expectedArguments = ['key'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $actualResponse = ['width', 2000, 'depth', 10, 'count', 0];
        $expectedResponse = ['width' => 2000, 'depth' => 10, 'count' => 0];

        $this->assertSame($expectedResponse, $this->getCommand()->parseResponse($actualResponse));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testReturnsInfoAboutGivenCountMinSketch(): void
    {
        $redis = $this->getClient();
        $expectedResponse = ['width' => 2000, 'depth' => 10, 'count' => 0];

        $redis->cmsinitbydim('key', 2000, 10);

        $actualResponse = $redis->cmsinfo('key');

        $this->assertSame($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('CMS: key does not exist');

        $redis = $this->getClient();

        $redis->cmsinfo('cmsinfo_foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CountMinSketch\CMSINITBYDIM_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CMSINITBYDIM_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CMSINITBYDIM::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CMSINITBYDIM';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 2000, 10];
        $expectedArguments = ['key', 2000, 10];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testInitializeCountMinSketchWithGivenConfiguration(): void
    {
        $redis = $this->getClient();

        $actualResponse = $redis->cmsinitbydim('key', 2000, 10);
        $info = $redis->cmsinfo('key');

        $this->assertEquals('OK', $actualResponse);
        $this->assertSame(2000, $info['width']);
        $this->assertSame(10, $info['depth']);
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnAlreadyExistingKey(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('CMS: key already exists');

        $redis = $this->getClient();

        $redis->set('cmsinitbydim_foo', 'bar');
        $redis->cmsinitbydim('cmsinitbydim_foo', 2000, 10);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CountMinSketch\CMSINITBYPROB_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CMSINITBYPROB_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CMSINITBYPROB::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CMSINITBYPROB';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 0.001, 0.01];
        $expectedArguments = ['key', 0.001, 0.01];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testInitializeCountMinSketchWithDesiredErrorRateAndProbability(): void
    {
        $redis = $this->getClient();

        $actualResponse = $redis->cmsinitbyprob('key', 0.001, 0.01);
        $info = $redis->cmsinfo('key');

        $this->assertEquals('OK', $actualResponse);
        $this->assertSame(2000, $info['width']);
        $this->assertSame(7, $info['depth']);
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnAlreadyExistingKey(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('CMS: key already exists');

        $redis = $this->getClient();

        $redis->set('cmsinitbydim_foo', 'bar');
        $redis->cmsinitbyprob('cmsinitbydim_foo', 0.001, 0.01);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CountMinSketch\CMSMERGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CMSMERGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CMSMERGE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CMSMERGE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider sketchesProvider
     * @param  array  $mergeArguments
     * @param  string $destinationKey
     * @param  array  $items
     * @param  array  $expectedCounts
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testMergeSketchesAndSaveWithinDestinationCountMinSketch(
        array $mergeArguments,
        string $destinationKey,
        array $items,
        array $expectedCounts
    ): void {
        $redis = $this->getClient();

        $redis->cmsinitbyprob('source1', 0.001, 0.01);
        $redis->cmsinitbyprob('source2', 0.001, 0.01);
        $redis->cmsinitbyprob('destination', 0.001, 0.01);
        $redis->cmsincrby('source1', 'item1', 1, 'item2', 1);
        $redis->cmsincrby('source2', 'item1', 1, 'item2', 1);

        $actualResponse = $redis->cmsmerge(...$mergeArguments);

        $this->assertEquals('OK', $actualResponse);
        $this->assertSame($expectedCounts, $redis->cmsquery('destination', ...$items));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingDestinationCountMinSketch(): void
    {
        $redis = $this->getClient();

        $redis->cmsinitbyprob('source1', 0.001, 0.01);
        $redis->cmsinitbyprob('source2', 0.001, 0.01);

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('CMS: key does not exist');

        $redis->cmsmerge('destination', ['source1', 'source2']);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingSourceCountMinSketch(): void
    {
        $redis = $this->getClient();

        $redis->cmsinitbyprob('source1', 0.001, 0.01);
        $redis->cmsinitbyprob('destination', 0.001, 0.01);

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('CMS: key does not exist');

        $redis->cmsmerge('destination', ['source1', 'source2']);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnDifferentCountMinSketchesConfigurations(): void
    {
        $redis = $this->getClient();

        $redis->cmsinitbyprob('source1', 0.001, 0.01);
        $redis->cmsinitbyprob('source2', 0.01, 0.01);
        $redis->cmsinitbyprob('destination', 0.001, 0.01);

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('CMS: width/depth is not equal');

        $redis->cmsmerge('destination', ['source1', 'source2']);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['destination', ['source']],
                ['destination', 1, 'source'],
            ],
            'with multiple sources' => [
                ['destination', ['source1', 'source2']],
                ['destination', 2, 'source1', 'source2'],
            ],
            'with WEIGHTS' => [
                ['destination', ['source1', 'source2'], [1, 3]],
                ['destination', 2, 'source1', 'source2', 'WEIGHTS', 1, 3],
            ],
        ];
    }

    public function sketchesProvider(): array
    {
        return [
            'with default arguments' => [
                ['destination', ['source1', 'source2']],
                'destination',
                ['item1', 'item2'],
                [2, 2],
            ],
            'with modified WEIGHTS' => [
                ['destination', ['source1', 'source2'], [2, 4]],
                'destination',
                ['item1', 'item2'],
                [6, 6],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CountMinSketch\CMSQUERY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CountMinSketch;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CMSQUERY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CMSQUERY::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CMSQUERY';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item1', 'item2'];
        $expectedArguments = ['key', 'item1', 'item2'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider sketchesProvider
     * @param  array $queryArguments
     * @param  array $expectedResponse
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testReturnCountValuesForGivenItemsWithinCountMinSketch(
        array $queryArguments,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->cmsinitbydim('key', 2000, 7);

        $actualResponse = $redis->cmsquery(...$queryArguments);
        $this->assertSame($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('CMS: key does not exist');

        $redis = $this->getClient();

        $redis->cmsquery('cmsquery_foo', 'item1');
    }

    public function sketchesProvider(): array
    {
        return [
            'with single item' => [
                ['key', 'item1'],
                [0],
            ],
            'with multiple items' => [
                ['key', 'item1', 'item2'],
                [0, 0],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFADDNX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CFADDNX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFADDNX::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFADDNX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item'];
        $expectedArguments = ['key', 'item'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testAddItemToCuckooFilterWhenExists(): void
    {
        $redis = $this->getClient();

        $actualResponse = $redis->cfaddnx('key', 'item');
        $this->assertSame(1, $actualResponse);
        $this->assertSame(1, $redis->cfexists('key', 'item'));

        $actualResponse = $redis->cfaddnx('key', 'item');
        $this->assertSame(0, $actualResponse);
        $this->assertSame(1, $redis->cfexists('key', 'item'));
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('cfaddnx_foo', 'bar');
        $redis->cfaddnx('cfaddnx_foo', 'foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CFADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFADD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item'];
        $expectedArguments = ['key', 'item'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testAddItemToCuckooFilter(): void
    {
        $redis = $this->getClient();

        $actualResponse = $redis->cfadd('key', 'item');
        $this->assertSame(1, $actualResponse);
        $this->assertSame(1, $redis->cfexists('key', 'item'));
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('cfadd_foo', 'bar');
        $redis->cfadd('cfadd_foo', 'foo');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFCOUNT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class CFCOUNT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFCOUNT::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFCOUNT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item'];
        $expectedArguments = ['key', 'item'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testReturnsCountOfItemsWithinCuckooFilter(): void
    {
        $redis = $this->getClient();

        $redis->cfadd('key', 'item');

        $singleItemResponse = $redis->cfcount('key', 'item');
        $this->assertSame(1, $singleItemResponse);

        $redis->cfadd('key', 'item');
        $redis->cfadd('key', 'item');

        $multipleItemsResponse = $redis->cfcount('key', 'item');
        $this->assertSame(3, $multipleItemsResponse);

        $nonExistingItemResponse = $redis->cfcount('non_existing_key', 'item');
        $this->assertSame(0, $nonExistingItemResponse);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFDEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CFDEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFDEL::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFDEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item'];
        $expectedArguments = ['key', 'item'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testDeletesItemFromGivenCuckooFilter(): void
    {
        $redis = $this->getClient();

        $redis->cfadd('key', 'item');
        $singleItemResponse = $redis->cfdel('key', 'item');

        $this->assertSame(1, $singleItemResponse);
        $this->assertSame(0, $redis->cfexists('key', 'item'));

        $redis->cfadd('key', 'item');
        $redis->cfadd('key', 'item');

        $multipleItemsResponse = $redis->cfdel('key', 'item');
        $this->assertSame(1, $multipleItemsResponse);
        $this->assertSame(1, $redis->cfexists('key', 'item'));

        $nonExistingItemResponse = $redis->cfdel('key', 'non_existing_item');
        $this->assertSame(0, $nonExistingItemResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testDeleteThrowsExceptionOnNonExistingFilterKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Not found');

        $redis->cfdel('non_existing_key', 'item');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFEXISTS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class CFEXISTS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFEXISTS::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFEXISTS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item'];
        $expectedArguments = ['key', 'item'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testExistsReturnsExistingItemWithinCuckooFilter(): void
    {
        $redis = $this->getClient();

        $redis->cfadd('key', 'item');

        $this->assertSame(1, $redis->cfexists('key', 'item'));
        $this->assertSame(0, $redis->cfexists('non-existing key', 'item'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFINFO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CFINFO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFINFO::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFINFO';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key'];
        $expectedArguments = ['key'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     * @dataProvider responsesProvider
     */
    public function testParseResponse(array $actualResponse, array $expectedResponse): void
    {
        $this->assertSame($expectedResponse, $this->getCommand()->parseResponse($actualResponse));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInfoReturnsInformationAboutGivenCuckooFilter(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [
            'Size' => 1080,
            'Number of buckets' => 512,
            'Number of filters' => 1,
            'Number of items inserted' => 1,
            'Number of items deleted' => 0,
            'Bucket size' => 2,
            'Expansion rate' => 1,
            'Max iterations' => 20,
        ];

        $redis->cfadd('key', 'item');

        $this->assertSame($expectedResponse, $redis->cfinfo('key'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInfoThrowsExceptionOnNonExistingFilterKeyGiven(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR not found');

        $redis->cfinfo('non_existing_key');
    }

    public function responsesProvider(): array
    {
        return [
            'with one modifier' => [
                [100],
                [100],
            ],
            'with all modifiers' => [
                [
                    'Size',
                    100,
                    'Number of buckets',
                    296,
                    'Number of filter',
                    1,
                    'Number of items inserted',
                    1,
                    'Number of items deleted',
                    1,
                    'Bucket size',
                    0,
                    'Expansion rate',
                    1,
                    'Max iteration',
                    20,
                ],
                [
                    'Size' => 100,
                    'Number of buckets' => 296,
                    'Number of filter' => 1,
                    'Number of items inserted' => 1,
                    'Number of items deleted' => 1,
                    'Bucket size' => 0,
                    'Expansion rate' => 1,
                    'Max iteration' => 20,
                ],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFINSERTNX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CFINSERTNX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFINSERTNX::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFINSERTNX';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider filtersProvider
     * @param  array  $filterArguments
     * @param  string $key
     * @param  int    $expectedCapacity
     * @param  array  $expectedResponse
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInsertItemsIntoNonExistingCuckooFilter(
        array $filterArguments,
        string $key,
        int $expectedCapacity,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $actualResponse = $redis->cfinsertnx(...$filterArguments);
        $info = $redis->cfinfo($key);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedCapacity, $info['Size']);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testDoNotInsertAlreadyExistingItems(): void
    {
        $redis = $this->getClient();

        $redis->cfadd('filter', 'item1');
        $redis->cfadd('filter', 'item2');

        $actualResponse = $redis->cfinsertnx('filter', -1, false, 'item1', 'item2');
        $this->assertSame([0, 0], $actualResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInsertThrowsErrorOnInsertingIntoNonExistingFilterWithNoCreateModifier(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR not found');

        $redis->cfinsertnx('key', -1, true, 'item');
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInsertIntoAlreadyExistingFilterWithNoCreateModifier(): void
    {
        $redis = $this->getClient();

        $redis->cfadd('filter', 'item');

        $actualResponse = $redis->cfinsertnx('filter', -1, true, 'item1');
        $this->assertSame([1], $actualResponse);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', -1, false, 'item1'],
                ['key', 'ITEMS', 'item1'],
            ],
            'with CAPACITY modifier' => [
                ['key', 500, false, 'item1'],
                ['key', 'CAPACITY', 500, 'ITEMS', 'item1'],
            ],
            'with NOCREATE modifier' => [
                ['key', -1, true, 'item1'],
                ['key', 'NOCREATE', 'ITEMS', 'item1'],
            ],
            'with all arguments' => [
                ['key', 500, true, 'item1', 'item2'],
                ['key', 'CAPACITY', 500, 'NOCREATE', 'ITEMS', 'item1', 'item2'],
            ],
        ];
    }

    public function filtersProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', -1, false, 'item1'],
                'key',
                1080,
                [1],
            ],
            'with modified CAPACITY' => [
                ['key', 500, false, 'item1'],
                'key',
                568,
                [1],
            ],
            'with multiple items' => [
                ['key', -1, false, 'item1', 'item2'],
                'key',
                1080,
                [1, 1],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFINSERT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-stack
 */
class CFINSERT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFINSERT::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFINSERT';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider filtersProvider
     * @param  array  $filterArguments
     * @param  string $key
     * @param  int    $expectedCapacity
     * @param  array  $expectedResponse
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInsertItemsIntoGivenCuckooFilter(
        array $filterArguments,
        string $key,
        int $expectedCapacity,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $actualResponse = $redis->cfinsert(...$filterArguments);
        $info = $redis->cfinfo($key);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedCapacity, $info['Size']);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInsertIgnoresCapacityModifierOnAlreadyExistingFilter(): void
    {
        $redis = $this->getClient();

        $redis->cfadd('filter', 'item');

        $actualResponse = $redis->cfinsert('filter', 500, false, 'item1');
        $info = $redis->cfinfo('filter');

        $this->assertSame([1], $actualResponse);
        $this->assertSame(1080, $info['Size']);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInsertThrowsErrorOnInsertingIntoNonExistingFilterWithNoCreateModifier(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR not found');

        $redis->cfinsert('key', -1, true, 'item');
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testInsertIntoAlreadyExistingFilterWithNoCreateModifier(): void
    {
        $redis = $this->getClient();

        $redis->cfadd('filter', 'item');

        $actualResponse = $redis->cfinsert('filter', -1, true, 'item1');
        $this->assertSame([1], $actualResponse);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong NOCREATE argument type');

        $redis->cfinsert('key', -1, 'wrong', 'item');
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', -1, false, 'item1'],
                ['key', 'ITEMS', 'item1'],
            ],
            'with CAPACITY modifier' => [
                ['key', 500, false, 'item1'],
                ['key', 'CAPACITY', 500, 'ITEMS', 'item1'],
            ],
            'with NOCREATE modifier' => [
                ['key', -1, true, 'item1'],
                ['key', 'NOCREATE', 'ITEMS', 'item1'],
            ],
            'with all arguments' => [
                ['key', 500, true, 'item1', 'item2'],
                ['key', 'CAPACITY', 500, 'NOCREATE', 'ITEMS', 'item1', 'item2'],
            ],
        ];
    }

    public function filtersProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', -1, false, 'item1'],
                'key',
                1080,
                [1],
            ],
            'with modified CAPACITY' => [
                ['key', 500, false, 'item1'],
                'key',
                568,
                [1],
            ],
            'with multiple items' => [
                ['key', -1, false, 'item1', 'item2'],
                'key',
                1080,
                [1, 1],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFLOADCHUNK_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CFLOADCHUNK_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFLOADCHUNK::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFLOADCHUNK';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1, 'data'];
        $expectedArguments = ['key', 1, 'data'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testLoadChunkSuccessfullyRestoresCuckooFilter(): void
    {
        $redis = $this->getClient();

        $redis->cfadd('key', 'item1');

        $chunks = [];
        $iter = 0;

        while (true) {
            [$iter, $data] = $redis->cfscandump('key', $iter);

            if ($iter === 0) {
                break;
            }

            $chunks[] = [$iter, $data];
        }

        $redis->flushall();

        foreach ($chunks as $chunk) {
            [$iter, $data] = $chunk;
            $actualResponse = $redis->cfloadchunk('key', $iter, $data);

            $this->assertEquals('OK', $actualResponse);
        }

        $this->assertSame(1, $redis->cfexists('key', 'item1'));
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Invalid position');

        $redis = $this->getClient();

        $redis->set('cfloadchunk_foo', 'bar');
        $redis->cfloadchunk('cfloadchunk_foo', 0, 'data');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFMEXISTS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class CFMEXISTS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFMEXISTS::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFMEXISTS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item1', 'item2'];
        $expectedArguments = ['key', 'item1', 'item2'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testExistsReturnsExistingItemsWithinCuckooFilter(): void
    {
        $redis = $this->getClient();

        $this->assertSame([0, 0, 0], $redis->cfmexists('key', 'item1', 'item2', 'item3'));
        $redis->cfadd('key', 'item1');
        $this->assertSame([1, 0, 0], $redis->cfmexists('key', 'item1', 'item2', 'item3'));
        $redis->cfadd('key', 'item2');
        $redis->cfadd('key', 'item3');
        $this->assertSame([1, 1, 1], $redis->cfmexists('key', 'item1', 'item2', 'item3'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFRESERVE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CFRESERVE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFRESERVE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFRESERVE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider filtersProvider
     * @param  array $filterArguments
     * @param  int   $expectedCapacity
     * @param  int   $expectedBucketSize
     * @param  int   $expectedMaxIterations
     * @param  int   $expectedExpansion
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testReserveCreatesCuckooFilterWithCorrectConfiguration(
        array $filterArguments,
        int $expectedCapacity,
        int $expectedBucketSize,
        int $expectedMaxIterations,
        int $expectedExpansion
    ): void {
        $redis = $this->getClient();

        $actualResponse = $redis->cfreserve(...$filterArguments);
        $this->assertEquals('OK', $actualResponse);

        $info = $redis->cfinfo('key');

        $this->assertSame($expectedCapacity, $info['Size']);
        $this->assertSame($expectedBucketSize, $info['Bucket size']);
        $this->assertSame($expectedMaxIterations, $info['Max iterations']);
        $this->assertSame($expectedExpansion, $info['Expansion rate']);
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('cfreserve_foo', 'bar');
        $redis->cfreserve('cfreserve_foo', 500);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 500],
                ['key', 500],
            ],
            'with BUCKETSIZE argument' => [
                ['key', 500, 2],
                ['key', 500, 'BUCKETSIZE', 2],
            ],
            'with MAXITERATIONS argument' => [
                ['key', 500, -1, 15],
                ['key', 500, 'MAXITERATIONS', 15],
            ],
            'with EXPANSION argument' => [
                ['key', 500, -1, -1, 3],
                ['key', 500, 'EXPANSION', 3],
            ],
            'with all arguments' => [
                ['key', 500, 2, 15, 3],
                ['key', 500, 'BUCKETSIZE', 2, 'MAXITERATIONS', 15, 'EXPANSION', 3],
            ],
        ];
    }

    public function filtersProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 500, -1, -1, -1],
                568,
                2,
                20,
                1,
            ],
            'with modified bucket size' => [
                ['key', 1000, 3, -1, -1],
                1592,
                3,
                20,
                1,
            ],
            'with modified max iterations' => [
                ['key', 1000, -1, 15, -1],
                1080,
                2,
                15,
                1,
            ],
            'with modified expansion' => [
                ['key', 1000, -1, -1, 3],
                1080,
                2,
                20,
                4,
            ],
            'with all arguments' => [
                ['key', 1000, 3, 15, 3],
                1592,
                3,
                15,
                4,
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\CuckooFilter\CFSCANDUMP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\CuckooFilter;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class CFSCANDUMP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return CFSCANDUMP::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'CFSCANDUMP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1];
        $expectedArguments = ['key', 1];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testScanDumpReturnsNotEmptyDataChunk(): void
    {
        $expectedIterator = 1;
        $redis = $this->getClient();

        $redis->cfadd('key', 'item1');
        [$iterator, $dataChunk] = $redis->cfscandump('key', 0);

        $this->assertSame($expectedIterator, $iterator);
        $this->assertNotEmpty($dataChunk);
    }

    /**
     * @group connected
     * @requiresRedisBfVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongType(): void
    {
        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Operation against a key holding the wrong kind of value');

        $redis = $this->getClient();

        $redis->set('cfscandump_foo', 'bar');
        $redis->cfscandump('cfscandump_foo', 0);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONARRAPPEND_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONARRAPPEND_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONARRAPPEND::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONARRAPPEND';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..', 5, 'value'];
        $expected = ['key', '$..', 5, 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  array  $values
     * @param  array  $expectedArrayLength
     * @param  string $expectedModifiedJson
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testAppendItemsToGivenJsonArray(
        array $jsonArguments,
        string $key,
        string $path,
        array $values,
        array $expectedArrayLength,
        string $expectedModifiedJson
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);

        $actualResponse = $redis->jsonarrappend($key, $path, ...$values);

        $this->assertSame($expectedArrayLength, $actualResponse);
        $this->assertSame($expectedModifiedJson, $redis->jsonget($key));
    }

    public function jsonProvider(): array
    {
        return [
            'append single item' => [
                ['key', '$', '{"key1":"value1","key2":["value1","value2"]}'],
                'key',
                '$.key2',
                ['"value3"'],
                [3],
                '{"key1":"value1","key2":["value1","value2","value3"]}',
            ],
            'append multiple items - same type' => [
                ['key', '$', '{"key1":"value1","key2":["value1","value2"]}'],
                'key',
                '$.key2',
                ['"value3"', '"value4"'],
                [4],
                '{"key1":"value1","key2":["value1","value2","value3","value4"]}',
            ],
            'append multiple items - different types' => [
                ['key', '$', '{"key1":"value1","key2":["value1","value2"]}'],
                'key',
                '$.key2',
                ['"value3"', '5'],
                [4],
                '{"key1":"value1","key2":["value1","value2","value3",5]}',
            ],
            'append on root and nested level' => [
                ['key', '$', '{"key1":{"key2":["value1","value2"]},"key2":["value1","value2"]}'],
                'key',
                '$..key2',
                ['"value3"', '5'],
                [4, 4],
                '{"key1":{"key2":["value1","value2","value3",5]},"key2":["value1","value2","value3",5]}',
            ],
            'append on root and nested level - not array key' => [
                ['key', '$', '{"key1":{"key2":"value2"},"key2":["value1","value2"]}'],
                'key',
                '$..key2',
                ['"value3"', '5'],
                [4, null],
                '{"key1":{"key2":"value2"},"key2":["value1","value2","value3",5]}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONARRINDEX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONARRINDEX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONARRINDEX::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONARRINDEX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..', 'value', 0, 0];
        $expected = ['key', '$..', 'value', 0, 0];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  string $value
     * @param  int    $start
     * @param  int    $stop
     * @param  array  $expectedIndices
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testReturnsCorrectJsonArrayIndex(
        array $jsonArguments,
        string $key,
        string $path,
        string $value,
        int $start,
        int $stop,
        array $expectedIndices
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);
        $this->assertSame($expectedIndices, $redis->jsonarrindex($key, $path, $value, $start, $stop));
    }

    public function jsonProvider(): array
    {
        return [
            'on root level' => [
                ['key', '$', '{"key1":"value1","key2":["value1","value2"]}'],
                'key',
                '$.key2',
                '"value2"',
                0,
                0,
                [1],
            ],
            'on nested level' => [
                ['key', '$', '{"key1":{"key2":["value1","value2"]}}'],
                'key',
                '$..key2',
                '"value2"',
                0,
                0,
                [1],
            ],
            'with both level matching keys' => [
                ['key', '$', '{"key1":{"key2":["value1","value2"]},"key2":["value2"]}'],
                'key',
                '$..key2',
                '"value2"',
                0,
                0,
                [0, 1],
            ],
            'with non-array path' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key2',
                '"value2"',
                0,
                0,
                [null],
            ],
            'not found - limit by start and stop' => [
                ['key', '$', '{"key1":{"key2":["value1","value2"]},"key2":["value2"]}'],
                'key',
                '$..key2',
                '"value2"',
                0,
                1,
                [0, -1],
            ],
            'not found - with wrong value' => [
                ['key', '$', '{"key1":{"key2":["value1","value2"]},"key2":["value2"]}'],
                'key',
                '$..key2',
                '"value3"',
                0,
                0,
                [-1, -1],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONARRINSERT_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONARRINSERT_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONARRINSERT::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONARRINSERT';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..', 2, 'value'];
        $expected = ['key', '$..', 2, 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  int    $index
     * @param  array  $values
     * @param  array  $expectedArrayLength
     * @param  string $expectedModifiedArray
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testInsertElementIntoJsonArrayBeforeGivenIndex(
        array $jsonArguments,
        string $key,
        string $path,
        int $index,
        array $values,
        array $expectedArrayLength,
        string $expectedModifiedArray
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);

        $actualResponse = $redis->jsonarrinsert($key, $path, $index, ...$values);

        $this->assertSame($expectedArrayLength, $actualResponse);
        $this->assertSame($expectedModifiedArray, $redis->jsonget($key));
    }

    public function jsonProvider(): array
    {
        return [
            'on root level' => [
                ['key', '$', '{"key1":"value1","key2":["value1","value3"]}'],
                'key',
                '$.key2',
                1,
                ['"value2"'],
                [3],
                '{"key1":"value1","key2":["value1","value2","value3"]}',
            ],
            'on nested level' => [
                ['key', '$', '{"key1":{"key2":["value1","value3"]}}'],
                'key',
                '$..key2',
                1,
                ['"value2"'],
                [3],
                '{"key1":{"key2":["value1","value2","value3"]}}',
            ],
            'with both levels matching keys' => [
                ['key', '$', '{"key1":{"key2":["value1","value3"]},"key2":["value1","value3"]}'],
                'key',
                '$..key2',
                1,
                ['"value2"'],
                [3, 3],
                '{"key1":{"key2":["value1","value2","value3"]},"key2":["value1","value2","value3"]}',
            ],
            'with multiple values inserted' => [
                ['key', '$', '{"key1":"value1","key2":["value1","value4"]}'],
                'key',
                '$.key2',
                1,
                ['"value2"', '"value3"'],
                [4],
                '{"key1":"value1","key2":["value1","value2","value3","value4"]}',
            ],
            'with non-array path' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key2',
                1,
                ['"value2"'],
                [null],
                '{"key1":"value1","key2":"value2"}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONARRLEN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONARRLEN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONARRLEN::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONARRLEN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..'];
        $expected = ['key', '$..'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  array  $expectedLength
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testReturnsCorrectJsonArrayLength(
        array $jsonArguments,
        string $key,
        string $path,
        array $expectedLength
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);

        $this->assertSame($expectedLength, $redis->jsonarrlen($key, $path));
    }

    public function jsonProvider(): array
    {
        return [
            'on root level' => [
                ['key', '$', '{"key1":"value1","key2":["value1","value2"]}'],
                'key',
                '$.key2',
                [2],
            ],
            'on nested level' => [
                ['key', '$', '{"key1":{"key2":["value1","value2"]}}'],
                'key',
                '$..key2',
                [2],
            ],
            'with same keys on both levels' => [
                ['key', '$', '{"key1":{"key2":["value1","value2"]},"key2":["value1","value2","value3"]}'],
                'key',
                '$..key2',
                [3, 2],
            ],
            'with non-array path' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key2',
                [null],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONARRPOP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONARRPOP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONARRPOP::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONARRPOP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..', 2];
        $expected = ['key', '$..', 2];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  int    $index
     * @param  array  $expectedPoppedElements
     * @param  string $expectedModifiedJson
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testRemovesElementFromIndexOfJsonArray(
        array $jsonArguments,
        string $key,
        string $path,
        int $index,
        array $expectedPoppedElements,
        string $expectedModifiedJson
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);
        $actualResponse = $redis->jsonarrpop($key, $path, $index);

        $this->assertSame($expectedPoppedElements, $actualResponse);
        $this->assertSame($expectedModifiedJson, $redis->jsonget($key));
    }

    public function jsonProvider(): array
    {
        return [
            'removes last element' => [
                ['key', '$', '{"key1":"value1","key2":["value1","value2"]}'],
                'key',
                '$.key2',
                -1,
                ['"value2"'],
                '{"key1":"value1","key2":["value1"]}',
            ],
            'removes i-element' => [
                ['key', '$', '{"key1":"value1","key2":["value1","value2"]}'],
                'key',
                '$.key2',
                0,
                ['"value1"'],
                '{"key1":"value1","key2":["value2"]}',
            ],
            'removes elements from root and nested levels' => [
                ['key', '$', '{"key1":{"key2":["value1","value2"]},"key2":["value1","value2"]}'],
                'key',
                '$..key2',
                -1,
                ['"value2"', '"value2"'],
                '{"key1":{"key2":["value1"]},"key2":["value1"]}',
            ],
            'removes element from non-array' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key2',
                -1,
                [null],
                '{"key1":"value1","key2":"value2"}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONARRTRIM_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONARRTRIM_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONARRTRIM::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONARRTRIM';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..', 0, 1];
        $expected = ['key', '$..', 0, 1];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  int    $start
     * @param  int    $stop
     * @param  array  $expectedArrayLength
     * @param  string $expectedModifiedJson
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testCorrectlyTrimGivenJsonArray(
        array $jsonArguments,
        string $key,
        string $path,
        int $start,
        int $stop,
        array $expectedArrayLength,
        string $expectedModifiedJson
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);
        $actualResponse = $redis->jsonarrtrim($key, $path, $start, $stop);

        $this->assertSame($expectedArrayLength, $actualResponse);
        $this->assertSame($expectedModifiedJson, $redis->jsonget($key));
    }

    public function jsonProvider(): array
    {
        return [
            'trim array from start to stop' => [
                ['key', '$', '{"key1":"value1","key2":[1,2,3,4,5,6]}'],
                'key',
                '$.key2',
                1,
                4,
                [4],
                '{"key1":"value1","key2":[2,3,4,5]}',
            ],
            'trim all values except first with 0 start and stop' => [
                ['key', '$', '{"key1":"value1","key2":[1,2,3,4,5,6]}'],
                'key',
                '$.key2',
                0,
                0,
                [1],
                '{"key1":"value1","key2":[1]}',
            ],
            'trim arrays with same keys on root and nested levels' => [
                ['key', '$', '{"key1":{"key2":[1,2,3,4,5,6]},"key2":[1,2,3,4,5,6]}'],
                'key',
                '$..key2',
                1,
                4,
                [4, 4],
                '{"key1":{"key2":[2,3,4,5]},"key2":[2,3,4,5]}',
            ],
            'do not trim on non-array key' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key2',
                1,
                4,
                [null],
                '{"key1":"value1","key2":"value2"}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONCLEAR_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONCLEAR_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONCLEAR::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONCLEAR';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..'];
        $expected = ['key', '$..'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  int    $expectedClearValues
     * @param  string $expectedModifiedJson
     * @return void
     * @requiresRedisJsonVersion >= 2.0.0
     */
    public function testClearValuesOnArraysAndObjects(
        array $jsonArguments,
        string $key,
        string $path,
        int $expectedClearValues,
        string $expectedModifiedJson
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);
        $actualResponse = $redis->jsonclear($key, $path);

        $this->assertSame($expectedClearValues, $actualResponse);
        $this->assertSame($expectedModifiedJson, $redis->jsonget($key));
    }

    public function jsonProvider(): array
    {
        return [
            'with array values' => [
                ['key', '$', '{"key1":"value1","key2":[1,2,3,4,5,6]}'],
                'key',
                '$.key2',
                1,
                '{"key1":"value1","key2":[]}',
            ],
            'with json object' => [
                ['key', '$', '{"key1":"value1","key2":{"key3":"value3"}}'],
                'key',
                '$.key2',
                1,
                '{"key1":"value1","key2":{}}',
            ],
            'with numeric values' => [
                ['key', '$', '{"key1":"value1","key2":1}'],
                'key',
                '$.key2',
                1,
                '{"key1":"value1","key2":0}',
            ],
            'with all accepted values' => [
                ['key', '$', '{"key1":1,"key2":{"key3":"value3"},"key3":[1,2,3]}'],
                'key',
                '$.*',
                3,
                '{"key1":0,"key2":{},"key3":[]}',
            ],
            'with string and boolean value' => [
                ['key', '$', '{"key1":"value1","key2":true}'],
                'key',
                '$.*',
                0,
                '{"key1":"value1","key2":true}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONDEBUG_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

class JSONDEBUG_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONDEBUG::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONDEBUG';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['MEMORY', 'key', '$'];
        $expected = ['MEMORY', 'key', '$'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testMemoryReturnsCorrectMemoryUsageAboutJson(
        array $jsonArguments,
        string $key,
        string $path
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);

        $this->assertGreaterThan(0, $redis->jsondebug->memory($key, $path));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testHelpReturnsInformationAboutContainerCommands(): void
    {
        $redis = $this->getClient();

        $actualResponse = $redis->jsondebug->help();

        $this->assertStringContainsString('MEMORY', $actualResponse[0]);
        $this->assertStringContainsString('HELP', $actualResponse[1]);
    }

    public function jsonProvider(): array
    {
        return [
            'on root level' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$',
            ],
            'on nested level' => [
                ['key', '$', '{"key1":{"key2":"value2"}}'],
                'key',
                '$..key2',
            ],
            'with same keys on both levels' => [
                ['key', '$', '{"key1":{"key2":"value2"},"key2":"value2"}'],
                'key',
                '$..key2',
            ],
            'with wrong key' => [
                ['key', '$', '{"key1":{"key2":"value2"}}'],
                'key1',
                '$',
            ],
            'with wrong path' => [
                ['key', '$', '{"key1":{"key2":"value2"}}'],
                'key',
                '$.key3',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONDEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONDEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONDEL::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONDEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..'];
        $expected = ['key', '$..'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  int    $expectedDeleteArgumentsCount
     * @param  string $expectedModifiedJson
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testDeletesPathsAtKeyFromGivenJsonString(
        array $jsonArguments,
        string $key,
        string $path,
        int $expectedDeleteArgumentsCount,
        string $expectedModifiedJson
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);
        $actualResponse = $redis->jsondel($key, $path);

        $this->assertSame($expectedDeleteArgumentsCount, $actualResponse);
        $this->assertSame($expectedModifiedJson, $redis->jsonget($key));
    }

    public function jsonProvider(): array
    {
        return [
            'without nested level' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key2',
                1,
                '{"key1":"value1"}',
            ],
            'with nested level' => [
                ['key', '$', '{"key1":{"key2":"value2"}}'],
                'key',
                '$..key2',
                1,
                '{"key1":{}}',
            ],
            'with nested level and same key on both levels' => [
                ['key', '$', '{"key1":{"key2":"value2"},"key2":"value2"}'],
                'key',
                '$..key2',
                2,
                '{"key1":{}}',
            ],
            'with wrong path' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key3',
                0,
                '{"key1":"value1","key2":"value2"}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONFORGET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONFORGET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONFORGET::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONFORGET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..'];
        $expected = ['key', '$..'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  int    $expectedDeleteArgumentsCount
     * @param  string $expectedModifiedJson
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testDeletesPathsAtKeyFromGivenJsonString(
        array $jsonArguments,
        string $key,
        string $path,
        int $expectedDeleteArgumentsCount,
        string $expectedModifiedJson
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);
        $actualResponse = $redis->jsonforget($key, $path);

        $this->assertSame($expectedDeleteArgumentsCount, $actualResponse);
        $this->assertSame($expectedModifiedJson, $redis->jsonget($key));
    }

    public function jsonProvider(): array
    {
        return [
            'without nested level' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key2',
                1,
                '{"key1":"value1"}',
            ],
            'with nested level' => [
                ['key', '$', '{"key1":{"key2":"value2"}}'],
                'key',
                '$..key2',
                1,
                '{"key1":{}}',
            ],
            'with nested level and same key on both levels' => [
                ['key', '$', '{"key1":{"key2":"value2"},"key2":"value2"}'],
                'key',
                '$..key2',
                2,
                '{"key1":{}}',
            ],
            'with wrong path' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key3',
                0,
                '{"key1":"value1","key2":"value2"}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONGET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-stack
 */
class JSONGET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONGET::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONGET';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonData
     * @param  string $key
     * @param  string $indent
     * @param  string $newline
     * @param  string $space
     * @param  string $expectedResponse
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testReturnsCorrectJsonResponse(
        array $jsonData,
        string $key,
        string $indent,
        string $newline,
        string $space,
        string $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonData);
        $this->assertSame($expectedResponse, $redis->jsonget($key, $indent, $newline, $space));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testReturnsJsonValuesArrayOnMultiplePathsProvided(): void
    {
        $redis = $this->getClient();

        $redis->jsonset('key', '$', '{"key1":"value1","key2":{"key3":"value3"}}');
        $actualResponse = $redis->jsonget('key', '', '', '', '$.key1', '$..key3');

        $this->assertStringContainsString('"$.key1":["value1"]', $actualResponse);
        $this->assertStringContainsString('"$..key3":["value3"]', $actualResponse);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider unexpectedValuesProvider
     * @param  array  $arguments
     * @param  string $expectedExceptionMessage
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(array $arguments, string $expectedExceptionMessage): void
    {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage($expectedExceptionMessage);

        $redis->jsonget(...$arguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key'],
                ['key'],
            ],
            'with INDENT modifier' => [
                ['key', '\t'],
                ['key', 'INDENT', '\t'],
            ],
            'with NEWLINE modifier' => [
                ['key', '', '\n'],
                ['key', 'NEWLINE', '\n'],
            ],
            'with SPACE modifier' => [
                ['key', '', '', ' '],
                ['key', 'SPACE', ' '],
            ],
            'with multiple paths' => [
                ['key', '', '', '', 'path1', 'path2'],
                ['key', 'path1', 'path2'],
            ],
            'with all arguments' => [
                ['key', '\t', '\n', ' '],
                ['key', 'INDENT', '\t', 'NEWLINE', '\n', 'SPACE', ' '],
            ],
        ];
    }

    public function jsonProvider(): array
    {
        return [
            'with key only' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '',
                '',
                '',
                '{"key1":"value1","key2":"value2"}',
            ],
            'with INDENT modifier only' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '\t',
                '',
                '',
                '{\t"key1":"value1",\t"key2":"value2"}',
            ],
            'with NEWLINE modifier only' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '',
                '\n',
                '',
                '{\n"key1":"value1",\n"key2":"value2"\n}',
            ],
            'with SPACE modifier only' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '',
                '',
                ' ',
                '{"key1": "value1","key2": "value2"}',
            ],
            'with all modifiers' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '\t',
                '\n',
                ' ',
                '{\n\t"key1": "value1",\n\t"key2": "value2"\n}',
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'with wrong INDENT modifier' => [
                ['key', 1, '', ''],
                'Indent argument value should be a string',
            ],
            'with wrong NEWLINE modifier' => [
                ['key', '', 1, ''],
                'Newline argument value should be a string',
            ],
            'with wrong SPACE modifier' => [
                ['key', '', '', 1],
                'Space argument value should be a string',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONMERGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

class JSONMERGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONMERGE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONMERGE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..', '{"a":2}'];
        $expected = ['key', '$..', '{"a":2}'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @dataProvider jsonProvider
     * @group connected
     * @group relay-resp3
     * @param  array  $setArguments
     * @param  array  $mergeArguments
     * @param  string $expectedResponse
     * @return void
     * @requiresRedisJsonVersion >= 2.6.0
     */
    public function testMergeCorrectlyMergeJsonValues(
        array $setArguments,
        array $mergeArguments,
        string $expectedResponse
    ): void {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->jsonset(...$setArguments));
        $this->assertEquals('OK', $redis->jsonmerge(...$mergeArguments));
        $this->assertEquals($expectedResponse, $redis->jsonget('key'));
    }

    public function jsonProvider(): array
    {
        return [
            'create non-existing value' => [
                ['key', '$', '{"a":2}'],
                ['key', '$.b', '8'],
                '{"a":2,"b":8}',
            ],
            'replace existing value' => [
                ['key', '$', '{"a":2}'],
                ['key', '$.a', '3'],
                '{"a":3}',
            ],
            'replace an array' => [
                ['key', '$', '{"a":[2,4,6,8]}'],
                ['key', '$.a', '[10,12]'],
                '{"a":[10,12]}',
            ],
            'merge in multiple-paths' => [
                ['key', '$', '{"f1": {"a":1}, "f2":{"a":2}}'],
                ['key', '$', '{"f2":{"a":3, "b":4}, "f3":[2,4,6]}'],
                '{"f1":{"a":1},"f2":{"a":3,"b":4},"f3":[2,4,6]}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONMGET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONMGET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONMGET::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONMGET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = [['key1', 'key2', 'key3'], 'path'];
        $expected = ['key1', 'key2', 'key3', 'path'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $firstJson
     * @param  array  $secondJson
     * @param  array  $keys
     * @param  string $path
     * @param  array  $expectedResponse
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testMGetReturnsMultipleKeysArguments(
        array $firstJson,
        array $secondJson,
        array $keys,
        string $path,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$firstJson);
        $redis->jsonset(...$secondJson);

        $this->assertSame($expectedResponse, $redis->jsonmget($keys, $path));
    }

    public function jsonProvider(): array
    {
        return [
            'with both existing paths' => [
                ['key1', '$', '{"key1":"value1","key2":"value2"}'],
                ['key2', '$', '{"key1":"value3","key2":"value2"}'],
                ['key1', 'key2'],
                '$.key1',
                ['["value1"]', '["value3"]'],
            ],
            'with non-existing path' => [
                ['key1', '$', '{"key1":"value1","key2":"value2"}'],
                ['key2', '$', '{"key1":"value3","key3":"value3"}'],
                ['key1', 'key2'],
                '$.key3',
                ['[]', '["value3"]'],
            ],
            'with nested paths - different keys' => [
                ['key1', '$', '{"key1":"value1","key2":{"key3":"value3"}}'],
                ['key2', '$', '{"key1":"value3","key2":{"key3":"value4"}}'],
                ['key1', 'key2'],
                '$..key3',
                ['["value3"]', '["value4"]'],
            ],
            'with nested paths - similar keys' => [
                ['key1', '$', '{"key1":"value1","key2":{"key1":"value3"}}'],
                ['key2', '$', '{"key1":"value3","key2":{"key1":"value4"}}'],
                ['key1', 'key2'],
                '$..key1',
                ['["value1","value3"]', '["value3","value4"]'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONMSET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

class JSONMSET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONMSET::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONMSET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..', 'value', 'key1', '$', 'value1'];
        $expected = ['key', '$..', 'value', 'key1', '$', 'value1'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisJsonVersion >= 2.6.0
     */
    public function testSetMultipleJsonDocuments(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->jsonmset('doc1', '$', '{"a":2}', 'doc2', '$', '{"b":3}'));
        $this->assertEquals(['[{"a":2}]', '[{"b":3}]'], $redis->jsonmget(['doc1', 'doc2'], '$'));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisJsonVersion >= 2.6.0
     */
    public function testThrowsExceptionOnNewValuesNotInTheRootPath(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR new objects must be created at the root');

        $redis->jsonmset('doc1', '$', '{"a":2}', 'doc2', '$.f', '{"b":3}');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONNUMINCRBY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONNUMINCRBY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONNUMINCRBY::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONNUMINCRBY';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..', 5];
        $expected = ['key', '$..', 5];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  int    $value
     * @param  string $expectedIncrementedResponse
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testIncrementJsonNumericOnGivenValue(
        array $jsonArguments,
        string $key,
        string $path,
        int $value,
        string $expectedIncrementedResponse
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);

        $this->assertSame($expectedIncrementedResponse, $redis->jsonnumincrby($key, $path, $value));
    }

    public function jsonProvider(): array
    {
        return [
            'on root level' => [
                ['key', '$', '{"key1":"value1","key2":1}'],
                'key',
                '$.key2',
                1,
                '[2]',
            ],
            'on nested level' => [
                ['key', '$', '{"key1":{"key2":5}}'],
                'key',
                '$..key2',
                3,
                '[8]',
            ],
            'on both levels' => [
                ['key', '$', '{"key1":{"key2":5},"key2":4}'],
                'key',
                '$..key2',
                2,
                '[6,7]',
            ],
            'with non-numeric' => [
                ['key', '$', '{"key1":{"key2":[1,2,3]}}'],
                'key',
                '$..key2',
                2,
                '[null]',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONOBJKEYS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONOBJKEYS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONOBJKEYS::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONOBJKEYS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..'];
        $expected = ['key', '$..'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  array  $expectedKeys
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testReturnsKeysForGivenJsonObject(
        array $jsonArguments,
        string $key,
        string $path,
        array $expectedKeys
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);

        $this->assertSame($expectedKeys, $redis->jsonobjkeys($key, $path));
    }

    public function jsonProvider(): array
    {
        return [
            'on root level' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$',
                [['key1', 'key2']],
            ],
            'on nested level' => [
                ['key', '$', '{"key1":"value1","key2":{"key1":"value1","key2":"value2"}}'],
                'key',
                '$.key2',
                [['key1', 'key2']],
            ],
            'with same key on both levels' => [
                ['key', '$', '{"key1":{"key3":"value3","key4":"value4"},"key2":{"key1":{"key2":"value2"}}}'],
                'key',
                '$..key1',
                [['key3', 'key4'], ['key2']],
            ],
            'with one of the keys not a JSON object' => [
                ['key', '$', '{"key1":"value1","key2":{"key1":{"key2":"value2"}}}'],
                'key',
                '$..key1',
                [null, ['key2']],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONOBJLEN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONOBJLEN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONOBJLEN::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONOBJLEN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..'];
        $expected = ['key', '$..'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  array  $expectedObjectLength
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testReturnsLengthOfGivenJsonObject(
        array $jsonArguments,
        string $key,
        string $path,
        array $expectedObjectLength
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);

        $this->assertSame($expectedObjectLength, $redis->jsonobjlen($key, $path));
    }

    public function jsonProvider(): array
    {
        return [
            'on root level' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$',
                [2],
            ],
            'on nested level' => [
                ['key', '$', '{"key1":"value1","key2":{"key1":"value1","key2":"value2"}}'],
                'key',
                '$.key2',
                [2],
            ],
            'with same key on both levels' => [
                ['key', '$', '{"key1":{"key3":"value3","key4":"value4"},"key2":{"key1":{"key2":"value2"}}}'],
                'key',
                '$..key1',
                [2, 1],
            ],
            'with one of the keys not a JSON object' => [
                ['key', '$', '{"key1":"value1","key2":{"key1":{"key2":"value2"}}}'],
                'key',
                '$..key1',
                [null, 1],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONRESP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\Status;

/**
 * @group commands
 * @group realm-stack
 */
class JSONRESP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONRESP::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONRESP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..'];
        $expected = ['key', '$..'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  array  $expectedResponse
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testReturnRespValueFromGivenJson(
        array $jsonArguments,
        string $key,
        string $path,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);

        $this->assertEquals($expectedResponse, $redis->jsonresp($key, $path));
    }

    public function jsonProvider(): array
    {
        return [
            'with string value' => [
                ['key', '$', '{"key1":"value1"}'],
                'key',
                '$.key1',
                ['value1'],
            ],
            'with numeric value' => [
                ['key', '$', '{"key1":1}'],
                'key',
                '$.key1',
                [1],
            ],
            'with array value' => [
                ['key', '$', '{"key1":[1,2,3]}'],
                'key',
                '$.key1',
                [[new Status('['), 1, 2, 3]],
            ],
            'with json object value' => [
                ['key', '$', '{"key1":{"key2":"value2"}}'],
                'key',
                '$.key1',
                [[new Status('{'), 'key2', 'value2']],
            ],
            'with boolean value' => [
                ['key', '$', '{"key1":true}'],
                'key',
                '$.key1',
                ['true'],
            ],
            'with null value' => [
                ['key', '$', '{"key1":null}'],
                'key',
                '$.key1',
                [null],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONSET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-stack
 */
class JSONSET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONSET::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONSET';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  string      $key
     * @param  string      $defaultJson
     * @param  string      $appendedJson
     * @param  string      $path
     * @param  string|null $nxXxArgument
     * @param  string|null $expectedResponse
     * @param  string      $expectedJson
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testSetCorrectJsonValueAndReturnsCorrespondingResponse(
        string $key,
        string $defaultJson,
        string $appendedJson,
        string $path,
        ?string $nxXxArgument,
        ?string $expectedResponse,
        string $expectedJson
    ): void {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->jsonset($key, '$', $defaultJson));
        $this->assertEquals($expectedResponse, $redis->jsonset($key, $path, $appendedJson, $nxXxArgument));
        $this->assertSame($expectedJson, $redis->jsonget($key));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $redis = $this->getClient();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Argument accepts only: nx, xx values');

        $redis->jsonset('key', '$', 'value', 'wrong');
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 'path', 'value'],
                ['key', 'path', 'value'],
            ],
            'with NX argument' => [
                ['key', 'path', 'value', 'nx'],
                ['key', 'path', 'value', 'NX'],
            ],
            'with XX argument' => [
                ['key', 'path', 'value', 'xx'],
                ['key', 'path', 'value', 'XX'],
            ],
        ];
    }

    public function jsonProvider(): array
    {
        return [
            'override json' => [
                'key',
                '{"key1":"value1","key2":"value2"}',
                '{"key3":"value3"}',
                '$',
                null,
                'OK',
                '{"key3":"value3"}',
            ],
            'override certain key - without nxXx argument' => [
                'key',
                '{"key1":"value1","key2":"value2"}',
                '"value3"',
                '$.key2',
                null,
                'OK',
                '{"key1":"value1","key2":"value3"}',
            ],
            'append to json - without nxXx argument' => [
                'key',
                '{"key1":"value1","key2":"value2"}',
                '"value3"',
                '$.key3',
                null,
                'OK',
                '{"key1":"value1","key2":"value2","key3":"value3"}',
            ],
            'override certain key - with XX argument' => [
                'key',
                '{"key1":"value1","key2":"value2"}',
                '"value3"',
                '$.key2',
                'xx',
                'OK',
                '{"key1":"value1","key2":"value3"}',
            ],
            'append to json - with NX argument' => [
                'key',
                '{"key1":"value1","key2":"value2"}',
                '"value3"',
                '$.key3',
                'nx',
                'OK',
                '{"key1":"value1","key2":"value2","key3":"value3"}',
            ],
            'override failed with XX argument' => [
                'key',
                '{"key1":"value1","key2":"value2"}',
                '"value3"',
                '$.key3',
                'xx',
                null,
                '{"key1":"value1","key2":"value2"}',
            ],
            'append failed with NX argument' => [
                'key',
                '{"key1":"value1","key2":"value2"}',
                '"value2"',
                '$.key2',
                'nx',
                null,
                '{"key1":"value1","key2":"value2"}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONSTRAPPEND_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONSTRAPPEND_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONSTRAPPEND::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONSTRAPPEND';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..', 'value'];
        $expected = ['key', '$..', 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  string $value
     * @param  array  $expectedStringLength
     * @param  string $expectedModifiedJson
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testAppendStringToExistingJsonString(
        array $jsonArguments,
        string $key,
        string $path,
        string $value,
        array $expectedStringLength,
        string $expectedModifiedJson
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);
        $actualResponse = $redis->jsonstrappend($key, $path, $value);

        $this->assertSame($expectedStringLength, $actualResponse);
        $this->assertSame($expectedModifiedJson, $redis->jsonget($key));
    }

    public function jsonProvider(): array
    {
        return [
            'appends to json string on root level' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key2',
                '"foo"',
                [9],
                '{"key1":"value1","key2":"value2foo"}',
            ],
            'appends to json string on nested level' => [
                ['key', '$', '{"key1":{"key2":"value2"}}'],
                'key',
                '$..key2',
                '"foo"',
                [9],
                '{"key1":{"key2":"value2foo"}}',
            ],
            'appends to json string on both levels' => [
                ['key', '$', '{"key1":{"key2":"value2"},"key2":"value2"}'],
                'key',
                '$..key2',
                '"foo"',
                [9, 9],
                '{"key1":{"key2":"value2foo"},"key2":"value2foo"}',
            ],
            'appends to non-json string' => [
                ['key', '$', '{"key1":{"key2":[1,2,3]}}'],
                'key',
                '$..key2',
                '"foo"',
                [null],
                '{"key1":{"key2":[1,2,3]}}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONSTRLEN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONSTRLEN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONSTRLEN::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONSTRLEN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..'];
        $expected = ['key', '$..'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  array  $expectedStringLength
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testReturnsLengthOfGivenJsonString(
        array $jsonArguments,
        string $key,
        string $path,
        array $expectedStringLength
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);

        $this->assertSame($expectedStringLength, $redis->jsonstrlen($key, $path));
    }

    public function jsonProvider(): array
    {
        return [
            'on root level' => [
                ['key', '$', '{"key1":"value1","key2":"value2"}'],
                'key',
                '$.key2',
                [6],
            ],
            'on nested level' => [
                ['key', '$', '{"key1":{"key2":"value2"}}'],
                'key',
                '$..key2',
                [6],
            ],
            'on both levels' => [
                ['key', '$', '{"key1":{"key2":"value2"},"key2":"value2"}'],
                'key',
                '$..key2',
                [6, 6],
            ],
            'with non-json string' => [
                ['key', '$', '{"key1":{"key2":[1,2,3]}}'],
                'key',
                '$..key2',
                [null],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONTOGGLE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONTOGGLE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONTOGGLE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONTOGGLE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..'];
        $expected = ['key', '$..'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  array  $expectedResponse
     * @param  string $expectedModifiedJson
     * @return void
     * @requiresRedisJsonVersion >= 2.0.0
     */
    public function testToggleChangesBooleanValueToOpposite(
        array $jsonArguments,
        string $key,
        string $path,
        array $expectedResponse,
        string $expectedModifiedJson
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);
        $actualResponse = $redis->jsontoggle($key, $path);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame($expectedModifiedJson, $redis->jsonget($key));
    }

    public function jsonProvider(): array
    {
        return [
            'on root level' => [
                ['key', '$', '{"key1":true}'],
                'key',
                '$.key1',
                [0],
                '{"key1":false}',
            ],
            'on nested level' => [
                ['key', '$', '{"key1":{"key2":false}}'],
                'key',
                '$..key2',
                [1],
                '{"key1":{"key2":true}}',
            ],
            'with same keys on both levels' => [
                ['key', '$', '{"key1":{"key2":false},"key2":true}'],
                'key',
                '$..key2',
                [0, 1],
                '{"key1":{"key2":true},"key2":false}',
            ],
            'on non-boolean value' => [
                ['key', '$', '{"key1":"value1"}'],
                'key',
                '$.key1',
                [null],
                '{"key1":"value1"}',
            ],
            'on wrong path' => [
                ['key', '$', '{"key1":"value1"}'],
                'key',
                '$.key2',
                [],
                '{"key1":"value1"}',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Json\JSONTYPE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Json;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class JSONTYPE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return JSONTYPE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'JSONTYPE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $arguments = ['key', '$..'];
        $expected = ['key', '$..'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider jsonProvider
     * @param  array  $jsonArguments
     * @param  string $key
     * @param  string $path
     * @param  array  $expectedType
     * @return void
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testReturnsJsonValueType(
        array $jsonArguments,
        string $key,
        string $path,
        array $expectedType
    ): void {
        $redis = $this->getClient();

        $redis->jsonset(...$jsonArguments);

        $this->assertSame($expectedType, $redis->jsontype($key, $path));
    }

    public function jsonProvider(): array
    {
        return [
            'with string value' => [
                ['key', '$', '{"key1":"value1"}'],
                'key',
                '$.key1',
                ['string'],
            ],
            'with numeric value' => [
                ['key', '$', '{"key1":1}'],
                'key',
                '$.key1',
                ['integer'],
            ],
            'with array value' => [
                ['key', '$', '{"key1":[1,2,3]}'],
                'key',
                '$.key1',
                ['array'],
            ],
            'with json object value' => [
                ['key', '$', '{"key1":{"key2":"value2"}}'],
                'key',
                '$.key1',
                ['object'],
            ],
            'with boolean value' => [
                ['key', '$', '{"key1":true}'],
                'key',
                '$.key1',
                ['boolean'],
            ],
            'with null value' => [
                ['key', '$', '{"key1":null}'],
                'key',
                '$.key1',
                ['null'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTAGGREGATE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\AggregateArguments;
use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\SchemaFields\AbstractField;
use Predis\Command\Argument\Search\SchemaFields\NumericField;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTAGGREGATE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTAGGREGATE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTAGGREGATE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.1.0
     */
    public function testReturnsAggregatedSearchResultWithGivenModifiers(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [
            2,
            [
                'country', 'Ukraine', 'birth', '1995', 'country_birth_Vlad_count', '2',
            ],
            [
                'country', 'Israel', 'birth', '1994', 'country_birth_Vlad_count', '1',
            ],
        ];

        $ftCreateArguments = (new CreateArguments())->prefix(['user:']);
        $schema = [
            new TextField('name'),
            new TextField('country'),
            new NumericField('dob', '', AbstractField::SORTABLE),
        ];

        $this->assertEquals('OK', $redis->ftcreate('idx', $schema, $ftCreateArguments));
        $this->assertSame(
            3,
            $redis->hset('user:0', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600)
        );
        $this->assertSame(
            3,
            $redis->hset('user:1', 'name', 'Vlad', 'country', 'Israel', 'dob', 782265600)
        );
        $this->assertSame(
            3,
            $redis->hset('user:2', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600)
        );

        $ftAggregateArguments = (new AggregateArguments())
            ->apply('year(@dob)', 'birth')
            ->groupBy('@country', '@birth')
            ->reduce('COUNT', true, 'country_birth_Vlad_count')
            ->sortBy(0, '@birth', 'DESC');

        $this->assertSame(
            $expectedResponse,
            $redis->ftaggregate('idx', '@name: "Vlad"', $ftAggregateArguments)
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.1.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('index: no such index');

        $redis->ftaggregate('index', 'query');
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['index', 'query'],
                ['index', 'query'],
            ],
            'with VERBATIM modifier' => [
                ['index', 'query', (new AggregateArguments())->verbatim()],
                ['index', 'query', 'VERBATIM'],
            ],
            'with LOAD modifier - specified fields' => [
                ['index', 'query', (new AggregateArguments())->load('field1', 'field2')],
                ['index', 'query', 'LOAD', 2, 'field1', 'field2'],
            ],
            'with LOAD modifier - all fields' => [
                ['index', 'query', (new AggregateArguments())->load('*')],
                ['index', 'query', 'LOAD', '*'],
            ],
            'with TIMEOUT modifier' => [
                ['index', 'query', (new AggregateArguments())->timeout(2)],
                ['index', 'query', 'TIMEOUT', 2],
            ],
            'with GROUPBY modifier' => [
                ['index', 'query', (new AggregateArguments())->groupBy('property1', 'property2')],
                ['index', 'query', 'GROUPBY', 2, 'property1', 'property2'],
            ],
            'with REDUCE modifier' => [
                ['index', 'query', (new AggregateArguments())->reduce('function', 'arg1', true, 'alias1', 'arg2')],
                ['index', 'query', 'REDUCE', 'function', 2, 'arg1', 'AS', 'alias1', 'arg2'],
            ],
            'with SORTBY modifier' => [
                ['index', 'query', (new AggregateArguments())->sortBy(2, 'property1', 'ASC', 'property2', 'DESC')],
                ['index', 'query', 'SORTBY', 2, 'property1', 'ASC', 'property2', 'DESC', 'MAX', 2],
            ],
            'with APPLY modifier' => [
                ['index', 'query', (new AggregateArguments())->apply('expression', 'name')],
                ['index', 'query', 'APPLY', 'expression', 'AS', 'name'],
            ],
            'with LIMIT modifier' => [
                ['index', 'query', (new AggregateArguments())->limit(2, 3)],
                ['index', 'query', 'LIMIT', 2, 3],
            ],
            'with FILTER modifier' => [
                ['index', 'query', (new AggregateArguments())->filter('filter')],
                ['index', 'query', 'FILTER', 'filter'],
            ],
            'with WITHCURSOR modifier' => [
                ['index', 'query', (new AggregateArguments())->withCursor(10, 20)],
                ['index', 'query', 'WITHCURSOR', 'COUNT', 10, 'MAXIDLE', 20],
            ],
            'with PARAMS modifier' => [
                ['index', 'query', (new AggregateArguments())->params(['name1', 'value1', 'name2', 'value2'])],
                ['index', 'query', 'PARAMS', 4, 'name1', 'value1', 'name2', 'value2'],
            ],
            'with DIALECT modifier' => [
                ['index', 'query', (new AggregateArguments())->dialect('dialect')],
                ['index', 'query', 'DIALECT', 'dialect'],
            ],
            'with chain of arguments' => [
                [
                    'index',
                    '@name: "test"',
                    (new AggregateArguments())
                        ->apply('year(@dob)', 'birth')
                        ->groupBy('@birth', '@country')
                        ->reduce('COUNT', true, 'num_visits')
                        ->sortBy(0, '@day'),
                ],
                [
                    'index', '@name: "test"', 'APPLY', 'year(@dob)', 'AS', 'birth', 'GROUPBY', 2, '@birth', '@country',
                    'REDUCE', 'COUNT', 0, 'AS', 'num_visits', 'SORTBY', 1, '@day',
                ],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTALIASADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTALIASADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTALIASADD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTALIASADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['alias', 'index'];
        $expectedArguments = ['alias', 'index'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testAddAliasToGivenIndex(): void
    {
        $redis = $this->getClient();

        $arguments = new CreateArguments();
        $arguments->prefix(['prefix:']);
        $arguments->language();

        $schema = [new TextField('text_field')];

        $createResponse = $redis->ftcreate('index', $schema, $arguments);
        $this->assertEquals('OK', $createResponse);

        $actualResponse = $redis->ftaliasadd('alias', 'index');
        $this->assertEquals('OK', $actualResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Unknown index name (or name is an alias itself)');

        $redis->ftaliasadd('alias', 'index');
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testThrowsExceptionOnAlreadyExistingAlias(): void
    {
        $redis = $this->getClient();

        $arguments = new CreateArguments();
        $arguments->prefix(['prefix:']);
        $arguments->language();

        $schema = [new TextField('text_field')];

        $createResponse = $redis->ftcreate('index', $schema, $arguments);
        $this->assertEquals('OK', $createResponse);

        $actualResponse = $redis->ftaliasadd('alias', 'index');
        $this->assertEquals('OK', $actualResponse);

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Alias already exists');

        $redis->ftaliasadd('alias', 'index');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTALIASDEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTALIASDEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTALIASDEL::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTALIASDEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['alias'];
        $expectedArguments = ['alias'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testRemovesAliasFromGivenIndex(): void
    {
        $redis = $this->getClient();

        $schema = [new TextField('text_field')];

        $this->assertEquals('OK', $redis->ftcreate('index', $schema));
        $this->assertEquals('OK', $redis->ftaliasadd('alias', 'index'));
        $this->assertEquals('OK', $redis->ftaliasdel('alias'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingAlias(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Alias does not exist');

        $redis->ftaliasdel('alias');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTALIASUPDATE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTALIASUPDATE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTALIASUPDATE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTALIASUPDATE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['alias', 'index'];
        $expectedArguments = ['alias', 'index'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testUpdateAliasAddAliasToGivenIndexIfAliasNotExists(): void
    {
        $redis = $this->getClient();

        $schema = [new TextField('text_field')];

        $createResponse = $redis->ftcreate('index', $schema);
        $this->assertEquals('OK', $createResponse);

        $actualResponse = $redis->ftaliasupdate('alias', 'index');
        $this->assertEquals('OK', $actualResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testUpdateRemovesAliasAssociationFromAlreadyExistingAlias(): void
    {
        $redis = $this->getClient();

        $schema = [new TextField('text_field')];

        $createResponse = $redis->ftcreate('index', $schema);
        $this->assertEquals('OK', $createResponse);

        $actualResponse = $redis->ftaliasadd('alias', 'index');
        $this->assertEquals('OK', $actualResponse);
        $this->assertEquals('OK', $redis->ftaliasupdate('new_alias', 'index'));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Unknown index name (or name is an alias itself)');

        $redis->ftaliasupdate('alias', 'index');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTALTER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\AlterArguments;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTALTER_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTALTER::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTALTER';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testAddsAttributeToExistingIndex(): void
    {
        $redis = $this->getClient();

        $schema = [new TextField('field_name')];

        $this->assertEquals('OK', $redis->ftcreate('index', $schema));

        $schema = [new TextField('new_field_name')];

        $this->assertEquals('OK', $redis->ftalter('index', $schema));
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Unknown index name');

        $redis->ftalter('alias', [new TextField('field_name')]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['index', [new TextField('text_field')]],
                ['index', 'SCHEMA', 'ADD', 'text_field', 'TEXT'],
            ],
            'with SKIPINITIALSCAN modifier' => [
                ['index', [new TextField('text_field')], (new AlterArguments())->skipInitialScan()],
                ['index', 'SKIPINITIALSCAN', 'SCHEMA', 'ADD', 'text_field', 'TEXT'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTCONFIG_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTCONFIG_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTCONFIG::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTCONFIG';
    }

    /**
     * @group disconnected
     */
    public function testGetFilterArguments(): void
    {
        $arguments = ['GET', 'option'];
        $expected = ['GET', 'option'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testHelpFilterArguments(): void
    {
        $arguments = ['HELP', 'option'];
        $expected = ['HELP', 'option'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testSetFilterArguments(): void
    {
        $arguments = ['SET', 'option', 'value'];
        $expected = ['SET', 'option', 'value'];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisVersion <= 7.3.0
     */
    public function testSetGivenRediSearchConfigurationParameter(): void
    {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->ftconfig->set('TIMEOUT', 42));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisVersion <= 7.3.0
     */
    public function testGetReturnsGivenRediSearchConfigurationParameter(): void
    {
        $redis = $this->getClient();

        $this->assertEquals([['MAXEXPANSIONS', '200']], $redis->ftconfig->get('MAXEXPANSIONS'));
        $this->assertEmpty($redis->ftconfig->get('foobar'));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisVersion <= 7.3.0
     */
    public function testHelpReturnsGivenRediSearchConfigurationDescription(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [
            [
                'MAXEXPANSIONS',
                'Description',
                'Maximum prefix expansions to be used in a query',
                'Value',
                '200',
            ],
        ];

        $this->assertEquals($expectedResponse, $redis->ftconfig->help('MAXEXPANSIONS'));
        $this->assertEmpty($redis->ftconfig->help('foobar'));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisVersion <= 7.3.0
     */
    public function testSetThrowsExceptionOnNonExistingOption(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Invalid option');

        $redis->ftconfig->set('foobar', 'value');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTCREATE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\SchemaFields\GeoField;
use Predis\Command\Argument\Search\SchemaFields\NumericField;
use Predis\Command\Argument\Search\SchemaFields\TagField;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Argument\Search\SchemaFields\VectorField;
use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class FTCREATE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTCREATE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTCREATE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testCreatesSearchIndexWithGivenArgumentsAndSchema(): void
    {
        $redis = $this->getClient();

        $schema = [
            new TextField('first', 'fst', true, true),
            new TextField('last'),
            new NumericField('age'),
        ];

        $arguments = new CreateArguments();
        $arguments->prefix(['prefix:', 'prefix1:']);
        $arguments->filter('@age>16');
        $arguments->stopWords(['hello', 'world']);

        $actualResponse = $redis->ftcreate('index', $schema, $arguments);

        $this->assertEquals('OK', $actualResponse);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 2.09.00
     */
    public function testCreatesSearchIndexWithFloat16Vector(): void
    {
        $redis = $this->getClient();

        $schema = [
            new VectorField('float16',
                'FLAT',
                ['TYPE', 'FLOAT16', 'DIM', 768, 'DISTANCE_METRIC', 'COSINE']
            ),
            new VectorField('bfloat16',
                'FLAT',
                ['TYPE', 'BFLOAT16', 'DIM', 768, 'DISTANCE_METRIC', 'COSINE']
            ),
        ];

        $actualResponse = $redis->ftcreate('index', $schema);

        $this->assertEquals('OK', $actualResponse);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 2.09.00
     */
    public function testCreatesSearchIndexWithMissingAndEmptyFields(): void
    {
        $redis = $this->getClient();

        $schema = [
            new TextField(
                'text_empty',
                '',
                false, false, false, '', 1, false, true
            ),
            new TagField('tag_empty',
                '', false, false, ',', false, true
            ),
            new NumericField('num_missing', '', false, false, true),
            new GeoField('geo_missing', '', false, false, true),
            new TextField(
                'text_empty_missing',
                '',
                false,
                false, false, '', 1, false, true, true
            ),
            new TagField('tag_empty_missing',
                '', false, false, ',', false, true, true
            ),
        ];

        $actualResponse = $redis->ftcreate('index', $schema);

        $this->assertEquals('OK', $actualResponse);
    }

    public function argumentsProvider(): array
    {
        return [
            'without arguments' => [
                ['index', [new TextField('field_name')]],
                ['index', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with ON modifier - HASH' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->on()],
                ['index', 'ON', 'HASH', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with ON modifier - JSON' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->on('JSON')],
                ['index', 'ON', 'JSON', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with prefixes' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->prefix(['prefix1:', 'prefix2:'])],
                ['index', 'PREFIX', 2, 'prefix1:', 'prefix2:', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with FILTER' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->filter('@age>16')],
                ['index', 'FILTER', '@age>16', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with LANGUAGE' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->language()],
                ['index', 'LANGUAGE', 'english', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with LANGUAGE_FIELD' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->languageField('language_attribute')],
                ['index', 'LANGUAGE_FIELD', 'language_attribute', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with SCORE' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->score()],
                ['index', 'SCORE', 1.0, 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with SCORE_FIELD' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->scoreField('score_attribute')],
                ['index', 'SCORE_FIELD', 'score_attribute', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with MAXTEXTFIELDS' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->maxTextFields()],
                ['index', 'MAXTEXTFIELDS', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with TEMPORARY' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->temporary(1)],
                ['index', 'TEMPORARY', 1, 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with NOOFFSETS' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->noOffsets()],
                ['index', 'NOOFFSETS', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with NOHL' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->noHl()],
                ['index', 'NOHL', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with NOFIELDS' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->noFields()],
                ['index', 'NOFIELDS', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with NOFREQS' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->noFreqs()],
                ['index', 'NOFREQS', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with STOPWORDS' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->stopWords(['word1', 'word2'])],
                ['index', 'STOPWORDS', 2, 'word1', 'word2', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with SKIPINITIALSCAN' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->skipInitialScan()],
                ['index', 'SKIPINITIALSCAN', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with chain of arguments' => [
                ['index', [new TextField('field_name')], (new CreateArguments())->on()->prefix(['prefix1:', 'prefix2:'])->filter('@age>16')],
                ['index', 'ON', 'HASH', 'PREFIX', 2, 'prefix1:', 'prefix2:', 'FILTER', '@age>16', 'SCHEMA', 'field_name', 'TEXT'],
            ],
            'with multiple fields schema' => [
                ['index', [new TextField('text_field'), new NumericField('numeric_field'), new TagField('tag_field', 'tf')], (new CreateArguments())->on()],
                ['index', 'ON', 'HASH', 'SCHEMA', 'text_field', 'TEXT', 'numeric_field', 'NUMERIC', 'tag_field', 'AS', 'tf', 'TAG'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTCURSOR_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\AggregateArguments;
use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\CursorArguments;
use Predis\Command\Argument\Search\SchemaFields\AbstractField;
use Predis\Command\Argument\Search\SchemaFields\NumericField;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTCURSOR_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTCURSOR::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTCURSOR';
    }

    /**
     * @group disconnected
     */
    public function testDelFilterArguments(): void
    {
        $arguments = ['DEL', 'index', 2];
        $expected = ['DEL', 'index', 2];

        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSameValues($expected, $command->getArguments());
    }

    /**
     * @group disconnected
     * @dataProvider readArgumentsProvider
     */
    public function testReadFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.1.0
     */
    public function testReadAggregatedResultsFromExistingCursor(): void
    {
        $redis = $this->getClient();

        $expectedResponse = [
            [
                'country', 'Ukraine', 'birth', '1995', 'country_birth_Vlad_count', '2',
            ],
            [
                'country', 'Israel', 'birth', '1994', 'country_birth_Vlad_count', '1',
            ],
        ];

        $ftCreateArguments = (new CreateArguments())->prefix(['user:']);
        $schema = [
            new TextField('name'),
            new TextField('country'),
            new NumericField('dob', '', AbstractField::SORTABLE),
        ];

        $this->assertEquals('OK', $redis->ftcreate('idx', $schema, $ftCreateArguments));
        $this->assertSame(
            3,
            $redis->hset('user:0', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600)
        );
        $this->assertSame(
            3,
            $redis->hset('user:1', 'name', 'Vlad', 'country', 'Israel', 'dob', 782265600)
        );
        $this->assertSame(
            3,
            $redis->hset('user:2', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600)
        );

        $ftAggregateArguments = (new AggregateArguments())
            ->apply('year(@dob)', 'birth')
            ->groupBy('@country', '@birth')
            ->reduce('COUNT', true, 'country_birth_Vlad_count')
            ->sortBy(0, '@birth', 'DESC')
            ->withCursor(1);

        [$response, $cursor] = $redis->ftaggregate('idx', '@name: "Vlad"', $ftAggregateArguments);
        $actualResponse = [];

        while ($cursor) {
            $actualResponse[] = $response[1];
            [$response, $cursor] = $redis->ftcursor->read('idx', $cursor);
        }

        $this->assertSame($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.1.0
     */
    public function testDelExplicitlyRemovesExistingCursor(): void
    {
        $redis = $this->getClient();

        $ftCreateArguments = (new CreateArguments())->prefix(['user:']);
        $schema = [
            new TextField('name'),
            new TextField('country'),
            new NumericField('dob', '', AbstractField::SORTABLE),
        ];

        $this->assertEquals('OK', $redis->ftcreate('idx', $schema, $ftCreateArguments));
        $this->assertSame(
            3,
            $redis->hset('user:0', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600)
        );
        $this->assertSame(
            3,
            $redis->hset('user:1', 'name', 'Vlad', 'country', 'Israel', 'dob', 782265600)
        );
        $this->assertSame(
            3,
            $redis->hset('user:2', 'name', 'Vlad', 'country', 'Ukraine', 'dob', 813801600)
        );

        $ftAggregateArguments = (new AggregateArguments())
            ->apply('year(@dob)', 'birth')
            ->groupBy('@country', '@birth')
            ->reduce('COUNT', true, 'country_birth_Vlad_count')
            ->sortBy(0, '@birth', 'DESC')
            ->withCursor(1);

        [$_, $cursor] = $redis->ftaggregate('idx', '@name: "Vlad"', $ftAggregateArguments);

        $this->assertEquals('OK', $redis->ftcursor->del('idx', $cursor));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.1.0
     */
    public function testReadThrowsExceptionOnWrongCursorId(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Cursor not found');

        $redis->ftcursor->read('idx', 21412412);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.1.0
     */
    public function testDelThrowsExceptionOnWrongCursorId(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Cursor does not exist');

        $redis->ftcursor->del('idx', 21412412);
    }

    public function readArgumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['READ', 'index', 2],
                ['READ', 'index', 2],
            ],
            'with COUNT modifier' => [
                ['READ', 'index', 2, (new CursorArguments())->count(2)],
                ['READ', 'index', 2, 'COUNT', 2],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTDICTADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class FTDICTADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTDICTADD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTDICTADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['dict', 'foo', 'bar'];
        $expectedArguments = ['dict', 'foo', 'bar'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.4.0
     */
    public function testAddTermsIntoGivenDictionary(): void
    {
        $redis = $this->getClient();

        $actualResponse = $redis->ftdictadd('dict', 'foo', 'bar');

        $this->assertSame(2, $actualResponse);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTDICTDEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class FTDICTDEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTDICTDEL::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTDICTDEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['dict', 'foo', 'bar'];
        $expectedArguments = ['dict', 'foo', 'bar'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider dictionariesProvider
     * @param  array $addArguments
     * @param  array $deleteArguments
     * @param  int   $expectedResponse
     * @return void
     * @requiresRediSearchVersion >= 1.4.0
     */
    public function testRemovesTermsFromGivenDictionary(
        array $addArguments,
        array $deleteArguments,
        int $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->ftdictadd(...$addArguments);

        $this->assertSame($expectedResponse, $redis->ftdictdel(...$deleteArguments));
    }

    public function dictionariesProvider(): array
    {
        return [
            'removes existing term' => [
                ['dict', 'foo', 'bar'],
                ['dict', 'foo'],
                1,
            ],
            'removes non-existing term' => [
                ['dict', 'foo', 'bar'],
                ['dict', 'baz'],
                0,
            ],
            'removes from non-existing dict' => [
                ['dict', 'foo', 'bar'],
                ['dict123', 'baz'],
                0,
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTDICTDUMP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTDICTDUMP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTDICTDUMP::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTDICTDUMP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['dict'];
        $expectedArguments = ['dict'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.4.0
     */
    public function testDumpTermsFromGivenDictionary(): void
    {
        $redis = $this->getClient();

        $redis->ftdictadd('dict', 'foo', 'bar');

        $this->assertSame(['bar', 'foo'], $redis->ftdictdump('dict'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.4.0
     */
    public function testThrowsExceptionOnNonExistingDictionary(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('could not open dict key');

        $redis->ftdictdump('dict');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTDROPINDEX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\DropArguments;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTDROPINDEX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTDROPINDEX::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTDROPINDEX';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 2.0.0
     */
    public function testDropRemovesGivenIndex(): void
    {
        $redis = $this->getClient();

        $schema = [new TextField('text_field')];

        $this->assertEquals('OK', $redis->ftcreate('index', $schema));
        $this->assertEquals('OK', $redis->ftdropindex('index'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Unknown Index name');

        $redis->ftdropindex('index');
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['index'],
                ['index'],
            ],
            'with DD modifier' => [
                ['index', (new DropArguments())->dd()],
                ['index', 'DD'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTEXPLAIN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\ExplainArguments;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTEXPLAIN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTEXPLAIN::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTEXPLAIN';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testExplainReturnsExecutionPlanForGivenQuery(): void
    {
        $redis = $this->getClient();
        $expectedResponse = <<<EOT
INTERSECT {
  UNION {
    INTERSECT {
      UNION {
        foo
        +foo(expanded)
      }
      UNION {
        bar
        +bar(expanded)
      }
    }
    INTERSECT {
      UNION {
        hello
        +hello(expanded)
      }
      UNION {
        world
        +world(expanded)
      }
    }
  }
  UNION {
    NUMERIC {100.000000 <= @date <= 200.000000}
    NUMERIC {500.000000 <= @date <= inf}
  }
}

EOT;

        $schema = [new TextField('text_field')];

        $this->assertEquals('OK', $redis->ftcreate('index', $schema));
        $this->assertEquals(
            $expectedResponse,
            $redis->ftexplain('index', '(foo bar)|(hello world) @date:[100 200]|@date:[500 +inf]')
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('index: no such index');

        $redis->ftexplain('index', 'query');
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['index', 'query', null],
                ['index', 'query'],
            ],
            'with DIALECT' => [
                ['index', 'query', (new ExplainArguments())->dialect('dialect')],
                ['index', 'query', 'DIALECT', 'dialect'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTINFO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTINFO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTINFO::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTINFO';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['index'];
        $expectedArguments = ['index'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     *
     * Prior to Redis 7.2 `-nan` is messing with Relay/hiredis.
     */
    public function testInfoReturnsInformationAboutGivenIndex(): void
    {
        $redis = $this->getClient();

        $arguments = new CreateArguments();
        $arguments->prefix(['prefix:']);
        $arguments->language();

        $schema = [new TextField('text_field')];

        $createResponse = $redis->ftcreate('index', $schema, $arguments);
        $this->assertEquals('OK', $createResponse);

        $actualResponse = $redis->ftinfo('index');
        $this->assertEquals('index', $actualResponse[1]);
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);

        $redis->ftinfo('index');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTPROFILE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\ProfileArguments;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTPROFILE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTPROFILE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTPROFILE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider queryProvider
     * @param  array $createArguments
     * @param  array $profileArguments
     * @return void
     * @requiresRediSearchVersion >= 2.2.0
     */
    public function testProfileReturnsPerformanceInformationAboutGivenQuery(
        array $createArguments,
        array $profileArguments
    ): void {
        $redis = $this->getClient();

        $this->assertEquals('OK', $redis->ftcreate(...$createArguments));
        $this->assertNotEmpty($redis->ftprofile(...$profileArguments));
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 2.2.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('index: no such index');

        $redis->ftprofile('index', (new ProfileArguments())->search()->query('query'));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments - SEARCH' => [
                ['index', (new ProfileArguments())->search()->query('query')],
                ['index', 'SEARCH', 'QUERY', 'query'],
            ],
            'with default arguments - AGGREGATE' => [
                ['index', (new ProfileArguments())->aggregate()->query('query')],
                ['index', 'AGGREGATE', 'QUERY', 'query'],
            ],
            'with LIMITED modifier' => [
                ['index', (new ProfileArguments())->aggregate()->limited()->query('query')],
                ['index', 'AGGREGATE', 'LIMITED', 'QUERY', 'query'],
            ],
        ];
    }

    public function queryProvider(): array
    {
        return [
            'with SEARCH context' => [
                ['index', [new TextField('text_field')]],
                ['index', (new ProfileArguments())->search()->query('hello world')],
            ],
            'with AGGREGATE context' => [
                ['index', [new TextField('text_field')]],
                ['index', (new ProfileArguments())->aggregate()->query('hello world')],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTSEARCH_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\SchemaFields\AbstractField;
use Predis\Command\Argument\Search\SchemaFields\GeoShapeField;
use Predis\Command\Argument\Search\SchemaFields\NumericField;
use Predis\Command\Argument\Search\SchemaFields\TagField;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Argument\Search\SearchArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTSEARCH_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTSEARCH::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTSEARCH';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testSearchValuesByJsonIndex(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [1, 'doc:1', ['arr', '[1,2,3]', 'val', 'hello']];

        $jsonResponse = $redis->jsonset(
            'doc:1',
            '$',
            '[{"arr": [1, 2, 3]}, {"val": "hello"}, {"val": "world"}]'
        );
        $this->assertEquals('OK', $jsonResponse);

        $createArguments = new CreateArguments();
        $createArguments->on('json');
        $createArguments->prefix(['doc:']);

        $schema = [new NumericField('$..arr', 'arr'), new TextField('$..val', 'val')];

        $ftCreateResponse = $redis->ftcreate('idx_json', $schema, $createArguments);
        $this->assertEquals('OK', $ftCreateResponse);

        // Timeout to make sure that index created before search performed.
        usleep(10000);

        $ftSearchArguments = new SearchArguments();
        $ftSearchArguments->addReturn(2, 'arr', 'val');

        $actualResponse = $redis->ftsearch('idx_json', '*', $ftSearchArguments);
        $this->assertSame($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testSearchValuesByHashIndex(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [1, 'doc:1', ['should_return', 'value1']];

        $hashResponse = $redis->hmset('doc:1', 'field1', 'value1', 'field2', 'value2');
        $this->assertEquals('OK', $hashResponse);

        $ftCreateArguments = new CreateArguments();
        $ftCreateArguments->prefix(['doc:']);

        $schema = [
            new TextField('field1', 'should_return'),
            new TextField('field2', 'should_not_return'),
        ];

        $ftCreateResponse = $redis->ftcreate('idx_hash', $schema, $ftCreateArguments);
        $this->assertEquals('OK', $ftCreateResponse);

        // Timeout to make sure that index created before search performed.
        usleep(10000);

        $ftSearchArguments = new SearchArguments();
        $ftSearchArguments->addReturn(1, 'should_return');

        $actualResponse = $redis->ftsearch('idx_hash', '*', $ftSearchArguments);
        $this->assertSame($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 2.09.00
     */
    public function testSearchHashEmptyValues(): void
    {
        $redis = $this->getClient();

        $hashResponse = $redis->hmset('test:1', ['text_empty' => '']);
        $this->assertEquals('OK', $hashResponse);

        $schema = [
            new TextField(
                'text_empty',
                '',
                false, false, false, '', 1, false, true
            ),
            new TextField(
                'text_not_empty',
                '',
                false, false, false, '', 1, false, false
            ),
        ];

        $createArgs = new CreateArguments();
        $createArgs->prefix(['test:']);

        $ftCreateResponse = $redis->ftcreate('idx', $schema, $createArgs);
        $this->assertEquals('OK', $ftCreateResponse);

        // Timeout to make sure that index created before search performed.
        usleep(10000);

        $searchArgs = new SearchArguments();
        $searchArgs->dialect(4);

        $this->assertSame(
            [1, 'test:1', ['text_empty', '']],
            $redis->ftsearch('idx', '@text_empty:("")', $searchArgs)
        );

        $this->expectException(ServerException::class);

        $redis->ftsearch('idx', '@text_not_empty:("")', $searchArgs);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 2.09.00
     * @requiresRedisJsonVersion >= 1.0.0
     */
    public function testSearchJsonEmptyValues(): void
    {
        $redis = $this->getClient();

        $hashResponse = $redis->jsonset('test:1', '$', '{"text_empty":""}');
        $this->assertEquals('OK', $hashResponse);

        $schema = [
            new TextField(
                '$.text_empty',
                'text_empty',
                false, false, false, '', 1, false, true
            ),
            new TextField(
                '$.text_not_empty',
                'text_not_empty',
                false, false, false, '', 1, false, false
            ),
        ];

        $createArgs = new CreateArguments();
        $createArgs->on('JSON');
        $createArgs->prefix(['test:']);

        $ftCreateResponse = $redis->ftcreate('idx', $schema, $createArgs);
        $this->assertEquals('OK', $ftCreateResponse);

        // Timeout to make sure that index created before search performed.
        usleep(10000);

        $searchArgs = new SearchArguments();
        $searchArgs->dialect(4);

        $this->assertSame(
            [1, 'test:1', ['$', '[{"text_empty":""}]']],
            $redis->ftsearch('idx', '@text_empty:("")', $searchArgs)
        );

        $this->expectException(ServerException::class);

        $redis->ftsearch('idx', '@text_not_empty:("")', $searchArgs);
    }

    public function testSearchWithEnhancedMatchingCapabilities(): void
    {
        $redis = $this->getClient();

        $hashResponse = $redis->hmset(
            'test:1', 'uuid', '3d3586fe-0416-4572-8ce', 'email', 'adriano@acme.com.ie', 'num', 5
        );
        $this->assertEquals('OK', $hashResponse);

        $ftCreateArguments = new CreateArguments();
        $ftCreateArguments->prefix(['test:']);

        $schema = [
            new TagField('uuid'),
            new TagField('email'),
            new NumericField('num'),
        ];

        $ftCreateResponse = $redis->ftcreate('idx_hash', $schema, $ftCreateArguments);
        $this->assertEquals('OK', $ftCreateResponse);

        $ftSearchArguments = new SearchArguments();
        $ftSearchArguments->params(['uuid', '3d3586fe-0416-4572-8ce', 'email', 'adriano@acme.com.ie']);
        $ftSearchArguments->dialect(4);

        $actualResponse = $redis->ftsearch(
            'idx_hash', '@uuid:{$uuid}', $ftSearchArguments
        );

        $this->assertSame([
            1, 'test:1',
            ['uuid', '3d3586fe-0416-4572-8ce', 'email', 'adriano@acme.com.ie', 'num', '5']], $actualResponse
        );

        $actualResponse = $redis->ftsearch(
            'idx_hash', '@email:{$email}', $ftSearchArguments
        );

        $this->assertSame([
            1, 'test:1',
            ['uuid', '3d3586fe-0416-4572-8ce', 'email', 'adriano@acme.com.ie', 'num', '5']], $actualResponse
        );

        $actualResponse = $redis->ftsearch(
            'idx_hash', '@num:[5]', $ftSearchArguments
        );

        $this->assertSame([
            1, 'test:1',
            ['uuid', '3d3586fe-0416-4572-8ce', 'email', 'adriano@acme.com.ie', 'num', '5']], $actualResponse
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 2.09.00
     */
    public function testGeoSearchQueriesIntersectsAndDisjoint(): void
    {
        $redis = $this->getClient();

        $redis->hset('geo:doc_point1', 'g', 'POINT (10 10)');
        $redis->hset('geo:doc_point2', 'g', 'POINT (50 50)');
        $redis->hset('geo:doc_polygon1', 'g', 'POLYGON ((20 20, 25 35, 35 25, 20 20))');
        $redis->hset('geo:doc_polygon2', 'g', 'POLYGON ((60 60, 65 75, 70 70, 65 55, 60 60))');

        $ftCreateArguments = new CreateArguments();
        $ftCreateArguments->prefix(['geo:']);

        $schema = [
            new GeoShapeField('g', '', AbstractField::NOT_SORTABLE, false, GeoShapeField::COORD_FLAT),
        ];

        $ftCreateResponse = $redis->ftcreate('idx_geo', $schema, $ftCreateArguments);
        $this->assertEquals('OK', $ftCreateResponse);

        // Timeout to make sure that index created before search performed.
        usleep(10000);

        $ftSearchArguments = new SearchArguments();
        $ftSearchArguments->params(['shape', 'POLYGON ((15 15, 75 15, 50 70, 20 40, 15 15))']);
        $ftSearchArguments->noContent();
        $ftSearchArguments->dialect(3);

        $actualResponse = $redis->ftsearch('idx_geo', '@g:[intersects $shape]', $ftSearchArguments);
        $this->assertSameValues(
            [
                2,
                'geo:doc_polygon1',
                'geo:doc_point2',
            ], $actualResponse
        );

        $actualResponse = $redis->ftsearch('idx_geo', '@g:[disjoint $shape]', $ftSearchArguments);
        $this->assertSameValues(
            [
                2,
                'geo:doc_polygon2',
                'geo:doc_point1',
            ], $actualResponse
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 2.09.00
     */
    public function testGeoSearchQueriesContainsAndWithin(): void
    {
        $redis = $this->getClient();

        $redis->hset('geo:doc_point1', 'g', 'POINT (10 10)');
        $redis->hset('geo:doc_point2', 'g', 'POINT (50 50)');
        $redis->hset('geo:doc_polygon1', 'g', 'POLYGON ((20 20, 25 35, 35 25, 20 20))');
        $redis->hset('geo:doc_polygon2', 'g', 'POLYGON ((60 60, 65 75, 70 70, 65 55, 60 60))');

        $ftCreateArguments = new CreateArguments();
        $ftCreateArguments->prefix(['geo:']);

        $schema = [
            new GeoShapeField('g', '',
                AbstractField::NOT_SORTABLE, false, GeoShapeField::COORD_FLAT
            ),
        ];

        $ftCreateResponse = $redis->ftcreate('idx_geo', $schema, $ftCreateArguments);
        $this->assertEquals('OK', $ftCreateResponse);

        // Timeout to make sure that index created before search performed.
        usleep(10000);

        $ftSearchArguments = new SearchArguments();
        $ftSearchArguments->params(['shape', 'POINT(25 25)']);
        $ftSearchArguments->noContent();
        $ftSearchArguments->dialect(3);

        $actualResponse = $redis->ftsearch('idx_geo', '@g:[contains $shape]', $ftSearchArguments);
        $this->assertSameValues(
            [
                1,
                'geo:doc_polygon1',
            ], $actualResponse
        );

        $ftSearchArguments = new SearchArguments();
        $ftSearchArguments->params(['shape', 'POLYGON((24 24, 24 26, 25 25, 24 24))']);
        $ftSearchArguments->noContent();
        $ftSearchArguments->dialect(3);

        $actualResponse = $redis->ftsearch('idx_geo', '@g:[contains $shape]', $ftSearchArguments);
        $this->assertSameValues(
            [
                1,
                'geo:doc_polygon1',
            ], $actualResponse
        );

        $ftSearchArguments = new SearchArguments();
        $ftSearchArguments->params(['shape', 'POLYGON((15 15, 75 15, 50 70, 20 40, 15 15))']);
        $ftSearchArguments->noContent();
        $ftSearchArguments->dialect(3);

        $actualResponse = $redis->ftsearch('idx_geo', '@g:[within $shape]', $ftSearchArguments);
        $this->assertSameValues(
            [
                2,
                'geo:doc_polygon1',
                'geo:doc_point2',
            ], $actualResponse
        );
    }

    public function argumentsProvider(): array
    {
        return [
            'with NOCONTENT modifier' => [
                ['index', '*', (new SearchArguments())->noContent()],
                ['index', '*', 'NOCONTENT'],
            ],
            'with VERBATIM modifier' => [
                ['index', '*', (new SearchArguments())->verbatim()],
                ['index', '*', 'VERBATIM'],
            ],
            'with WITHSCORES modifier' => [
                ['index', '*', (new SearchArguments())->withScores()],
                ['index', '*', 'WITHSCORES'],
            ],
            'with WITHPAYLOADS modifier' => [
                ['index', '*', (new SearchArguments())->withPayloads()],
                ['index', '*', 'WITHPAYLOADS'],
            ],
            'with WITHSORTKEYS modifier' => [
                ['index', '*', (new SearchArguments())->withSortKeys()],
                ['index', '*', 'WITHSORTKEYS'],
            ],
            'with FILTER modifier' => [
                ['index', '*', (new SearchArguments())->searchFilter(['numeric_field', 1, 10])],
                ['index', '*', 'FILTER', 'numeric_field', 1, 10],
            ],
            'with GEOFILTER modifier' => [
                ['index', '*', (new SearchArguments())->geoFilter(['geo_field', 12.213, 14.212, 300, 'km'])],
                ['index', '*', 'GEOFILTER', 'geo_field', 12.213, 14.212, 300, 'km'],
            ],
            'with INKEYS modifier' => [
                ['index', '*', (new SearchArguments())->inKeys(['key1', 'key2'])],
                ['index', '*', 'INKEYS', 2, 'key1', 'key2'],
            ],
            'with INFIELDS modifier' => [
                ['index', '*', (new SearchArguments())->inFields(['field1', 'field2'])],
                ['index', '*', 'INFIELDS', 2, 'field1', 'field2'],
            ],
            'with RETURN modifier' => [
                ['index', '*', (new SearchArguments())->addReturn(2, 'identifier', true, 'property')],
                ['index', '*', 'RETURN', 2, 'identifier', 'AS', 'property'],
            ],
            'with SUMMARIZE modifier' => [
                ['index', '*', (new SearchArguments())->summarize(['field1', 'field2'], 2, 2, ',')],
                ['index', '*', 'SUMMARIZE', 'FIELDS', 2, 'field1', 'field2', 'FRAGS', 2, 'LEN', 2, 'SEPARATOR', ','],
            ],
            'with HIGHLIGHT modifier' => [
                ['index', '*', (new SearchArguments())->highlight(['field1', 'field2'], 'openTag', 'closeTag')],
                ['index', '*', 'HIGHLIGHT', 'FIELDS', 2, 'field1', 'field2', 'TAGS', 'openTag', 'closeTag'],
            ],
            'with SLOP modifier' => [
                ['index', '*', (new SearchArguments())->slop(2)],
                ['index', '*', 'SLOP', 2],
            ],
            'with TIMEOUT modifier' => [
                ['index', '*', (new SearchArguments())->timeout(2)],
                ['index', '*', 'TIMEOUT', 2],
            ],
            'with INORDER modifier' => [
                ['index', '*', (new SearchArguments())->inOrder()],
                ['index', '*', 'INORDER'],
            ],
            'with EXPANDER modifier' => [
                ['index', '*', (new SearchArguments())->expander('expander')],
                ['index', '*', 'EXPANDER', 'expander'],
            ],
            'with SCORER modifier' => [
                ['index', '*', (new SearchArguments())->scorer('scorer')],
                ['index', '*', 'SCORER', 'scorer'],
            ],
            'with EXPLAINSCORE modifier' => [
                ['index', '*', (new SearchArguments())->explainScore()],
                ['index', '*', 'EXPLAINSCORE'],
            ],
            'with PAYLOAD modifier' => [
                ['index', '*', (new SearchArguments())->payload('payload')],
                ['index', '*', 'PAYLOAD', 'payload'],
            ],
            'with SORTBY modifier' => [
                ['index', '*', (new SearchArguments())->sortBy('sort_attribute', 'desc')],
                ['index', '*', 'SORTBY', 'sort_attribute', 'DESC'],
            ],
            'with LIMIT modifier' => [
                ['index', '*', (new SearchArguments())->limit(2, 2)],
                ['index', '*', 'LIMIT', 2, 2],
            ],
            'with PARAMS modifier' => [
                ['index', '*', (new SearchArguments())->params(['name1', 'value2', 'name2', 'value2'])],
                ['index', '*', 'PARAMS', 4, 'name1', 'value2', 'name2', 'value2'],
            ],
            'with DIALECT modifier' => [
                ['index', '*', (new SearchArguments())->dialect('dialect')],
                ['index', '*', 'DIALECT', 'dialect'],
            ],
            'with chain of arguments' => [
                ['index', '*', (new SearchArguments())->withScores()->withPayloads()->searchFilter(['numeric_field', 1, 10])->addReturn(2, 'identifier', true, 'property')],
                ['index', '*', 'WITHSCORES', 'WITHPAYLOADS', 'FILTER', 'numeric_field', 1, 10, 'RETURN', 2, 'identifier', 'AS', 'property'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTSPELLCHECK_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use InvalidArgumentException;
use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Argument\Search\SpellcheckArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTSPELLCHECK_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTSPELLCHECK::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTSPELLCHECK';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.4.0
     */
    public function testSpellcheckReturnsPossibleSuggestionsToGivenMisspelledTerm(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [['TERM', 'held', [['0', 'hello'], ['0', 'help']]]];

        $this->assertEquals('OK', $redis->ftcreate(
            'index',
            [new TextField('text_field')]
        ));

        $this->assertEquals(2, $redis->ftdictadd('dict', 'hello', 'help'));

        $actualResponse = $redis->ftspellcheck(
            'index',
            'held',
            (new SpellcheckArguments())->distance(2)->terms('dict')
        );

        $this->assertEquals($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.4.0
     */
    public function testThrowsExceptionOnIncorrectTermsModifierGiven(): void
    {
        $redis = $this->getClient();

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Wrong modifier value given. Currently supports: INCLUDE, EXCLUDE');

        $redis->ftspellcheck(
            'index',
            'held',
            (new SpellcheckArguments())->distance(2)->terms('dict', 'wrong')
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.4.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Unknown Index name');

        $redis->ftspellcheck(
            'index',
            'held',
            (new SpellcheckArguments())->distance(2)->terms('dict')
        );
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['index', 'query'],
                ['index', 'query'],
            ],
            'with DISTANCE modifier' => [
                ['index', 'query', (new SpellcheckArguments())->distance(2)],
                ['index', 'query', 'DISTANCE', 2],
            ],
            'with TERMS modifier - INCLUDE' => [
                ['index', 'query', (new SpellcheckArguments())->terms('dict', 'INCLUDE', 'term')],
                ['index', 'query', 'TERMS', 'INCLUDE', 'dict', 'term'],
            ],
            'with TERMS modifier - EXCLUDE' => [
                ['index', 'query', (new SpellcheckArguments())->terms('dict', 'EXCLUDE', 'term')],
                ['index', 'query', 'TERMS', 'EXCLUDE', 'dict', 'term'],
            ],
            'with DIALECT modifier' => [
                ['index', 'query', (new SpellcheckArguments())->dialect('dialect')],
                ['index', 'query', 'DIALECT', 'dialect'],
            ],
            'with all arguments' => [
                ['index', 'query', (new SpellcheckArguments())->distance(2)->terms('dict', 'INCLUDE', 'term')->dialect('dialect')],
                ['index', 'query', 'DISTANCE', 2, 'TERMS', 'INCLUDE', 'dict', 'term', 'DIALECT', 'dialect'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTSUGADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\SugAddArguments;
use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class FTSUGADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTSUGADD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTSUGADD';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testAddSuggestionStringIntoAutoCompleteDictionary(): void
    {
        $redis = $this->getClient();

        $this->assertSame(1, $redis->ftsugadd('key', 'string', 1));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 'string', 1],
                ['key', 'string', 1],
            ],
            'with INCR modifier' => [
                ['key', 'string', 1, (new SugAddArguments())->incr()],
                ['key', 'string', 1, 'INCR'],
            ],
            'with PAYLOAD' => [
                ['key', 'string', 1, (new SugAddArguments())->payload('payload')],
                ['key', 'string', 1, 'PAYLOAD', 'payload'],
            ],
            'with all arguments' => [
                ['key', 'string', 1, (new SugAddArguments())->incr()->payload('payload')],
                ['key', 'string', 1, 'INCR', 'PAYLOAD', 'payload'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTSUGDEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class FTSUGDEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTSUGDEL::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTSUGDEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'string'];
        $expectedArguments = ['key', 'string'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testRemovesSuggestionFromGivenSuggestionIndex(): void
    {
        $redis = $this->getClient();

        $this->assertSame(1, $redis->ftsugadd('key', 'string', 1));
        $this->assertSame(1, $redis->ftsugdel('key', 'string'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testReturnsZeroOnNonExistingSuggestionIndex(): void
    {
        $redis = $this->getClient();

        $this->assertSame(0, $redis->ftsugdel('key', 'string'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTSUGGET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\SugAddArguments;
use Predis\Command\Argument\Search\SugGetArguments;
use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class FTSUGGET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTSUGGET::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTSUGGET';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider suggestionProvider
     * @param  array $addArguments
     * @param  array $getArguments
     * @param  array $expectedResponse
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testGetSuggestionsForGivenPrefix(
        array $addArguments,
        array $getArguments,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->ftsugadd(...$addArguments);

        $actualResponse = $redis->ftsugget(...$getArguments);

        $this->assertEquals($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testGetReturnsLimitedResultsWithMaxModifier(): void
    {
        $redis = $this->getClient();

        $redis->ftsugadd('key', 'hello', 2);
        $redis->ftsugadd('key', 'hell', 2);

        $actualResponse = $redis->ftsugget('key', 'hel', (new SugGetArguments())->max(1));

        $this->assertSame(['hell'], $actualResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testGetReturnsNullOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->assertNull($redis->ftsugget('key', 'hel'));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 'prefix'],
                ['key', 'prefix'],
            ],
            'with FUZZY modifier' => [
                ['key', 'prefix', (new SugGetArguments())->fuzzy()],
                ['key', 'prefix', 'FUZZY'],
            ],
            'with WITHSCORES modifier' => [
                ['key', 'prefix', (new SugGetArguments())->withScores()],
                ['key', 'prefix', 'WITHSCORES'],
            ],
            'with WITHPAYLOADS modifier' => [
                ['key', 'prefix', (new SugGetArguments())->withPayloads()],
                ['key', 'prefix', 'WITHPAYLOADS'],
            ],
            'with MAX modifier' => [
                ['key', 'prefix', (new SugGetArguments())->max(5)],
                ['key', 'prefix', 'MAX', 5],
            ],
            'with all arguments' => [
                ['key', 'prefix', (new SugGetArguments())->fuzzy()->withScores()->withPayloads()->max(5)],
                ['key', 'prefix', 'FUZZY', 'WITHSCORES', 'WITHPAYLOADS', 'MAX', 5],
            ],
        ];
    }

    public function suggestionProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 'hello', 2],
                ['key', 'hell'],
                ['hello'],
            ],
            'with FUZZY search' => [
                ['key', 'hello', 2],
                ['key', 'help', (new SugGetArguments())->fuzzy()],
                ['hello'],
            ],
            'with WITHSCORES modifier' => [
                ['key', 'hello', 2],
                ['key', 'hell', (new SugGetArguments())->withScores()],
                ['hello', '1.4142135381698608'],
            ],
            'with WITHPAYLOADS modifier' => [
                ['key', 'hello', 2, (new SugAddArguments())->payload('payload')],
                ['key', 'hell', (new SugGetArguments())->withPayloads()],
                ['hello', 'payload'],
            ],
            'with all modifiers' => [
                ['key', 'hello', 2, (new SugAddArguments())->payload('payload')],
                ['key', 'hellp', (new SugGetArguments())->fuzzy()->withScores()->withPayloads()],
                ['hello', '290630304', 'payload'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTSUGLEN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class FTSUGLEN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTSUGLEN::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTSUGLEN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key'];
        $expectedArguments = ['key'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testReturnsLengthOfGivenSuggestionDictionary(): void
    {
        $redis = $this->getClient();

        $redis->ftsugadd('key', 'foo', 1);
        $redis->ftsugadd('key', 'bar', 1);

        $this->assertSame(2, $redis->ftsuglen('key'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTSYNDUMP_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTSYNDUMP_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTSYNDUMP::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTSYNDUMP';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['index'];
        $expectedArguments = ['index'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.2.0
     */
    public function testDumpReturnsContentOfSynonymGroupFromGivenIndex(): void
    {
        $redis = $this->getClient();
        $expectedResponse = ['term1', ['synonym1'], 'term2', ['synonym1']];

        $this->assertEquals(
            'OK',
            $redis->ftcreate('index', [new TextField('text_field')])
        );

        $this->assertEquals(
            'OK',
            $redis->ftsynupdate('index', 'synonym1', null, 'term1', 'term2')
        );

        $this->assertSame($expectedResponse, $redis->ftsyndump('index'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.2.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Unknown index name');

        $redis->ftsyndump('index');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTSYNUPDATE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\SchemaFields\TextField;
use Predis\Command\Argument\Search\SynUpdateArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTSYNUPDATE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTSYNUPDATE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTSYNUPDATE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.2.0
     */
    public function testCreatesSynonymGroupWithinGivenIndex(): void
    {
        $redis = $this->getClient();

        $this->assertEquals(
            'OK',
            $redis->ftcreate('index', [new TextField('text')])
        );

        $this->assertEquals(
            'OK',
            $redis->ftsynupdate('index', 'synonym1', null, 'term1', 'term2')
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.2.0
     */
    public function testUpdatesAlreadyExistingSynonymGroupWithinGivenIndex(): void
    {
        $redis = $this->getClient();

        $this->assertEquals(
            'OK',
            $redis->ftcreate('index', [new TextField('text')])
        );

        $this->assertEquals(
            'OK',
            $redis->ftsynupdate('index', 'synonym1', null, 'term1', 'term2')
        );

        $this->assertEquals(
            'OK',
            $redis->ftsynupdate('index', 'synonym1', null, 'term3', 'term4')
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.2.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Unknown index name');

        $redis->ftsynupdate(
            'index',
            'synonym1',
            null,
            'term1'
        );
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['index', 'synonymGroupId', null, 'term1', 'term2'],
                ['index', 'synonymGroupId', 'term1', 'term2'],
            ],
            'with SKIPINITIALSCAN modifier' => [
                ['index', 'synonymGroupId', (new SynUpdateArguments())->skipInitialScan(), 'term1', 'term2'],
                ['index', 'synonymGroupId', 'SKIPINITIALSCAN', 'term1', 'term2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\Search\FTTAGVALS_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\Search;

use Predis\Command\Argument\Search\CreateArguments;
use Predis\Command\Argument\Search\SchemaFields\TagField;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class FTTAGVALS_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return FTTAGVALS::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'FTTAGVALS';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['index', 'fieldName'];
        $expectedArguments = ['index', 'fieldName'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testReturnIndexedTagFieldDistinctValues(): void
    {
        $redis = $this->getClient();
        $expectedResponse = ['hello', 'hey', 'world'];

        $this->assertEquals(
            'OK',
            $redis->ftcreate(
                'index',
                [new TagField('tag_field')],
                (new CreateArguments())->prefix(['prefix:'])
            )
        );

        $this->assertSame(
            1,
            $redis->hset('prefix:1', 'tag_field', 'Hello, World')
        );

        $this->assertSame(
            1,
            $redis->hset('prefix:2', 'tag_field', 'Hey, World')
        );

        $this->assertSame($expectedResponse, $redis->fttagvals('index', 'tag_field'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRediSearchVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingIndex(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('Unknown Index name');

        $redis->fttagvals('index', 'fieldName');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTADD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1, 2, 3];
        $expectedArguments = ['key', 1, 2, 3];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testAddObservationsIntoGivenTDigestSketch(): void
    {
        $redis = $this->getClient();

        $redis->tdigestcreate('key');

        $actualResponse = $redis->tdigestadd('key', 1, 2, 3);
        $info = $redis->tdigestinfo('key');

        $this->assertEquals('OK', $actualResponse);
        $this->assertSame(3, $info['Observations']);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestadd('key', 1, 2, 3);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTBYRANK_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTBYRANK_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTBYRANK::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTBYRANK';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1, 2, 3];
        $expectedArguments = ['key', 1, 2, 3];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testReturnsValuesEstimatedForGivenRanks(): void
    {
        $redis = $this->getClient();
        $expectedResponse = ['1', '2', '2', '3', '3', '3', 'inf'];

        $redis->tdigestcreate('key');
        $redis->tdigestcreate('empty_key');

        $redis->tdigestadd('key', 1, 2, 2, 3, 3, 3);

        $actualResponse = $redis->tdigestbyrank('key', 0, 1, 2, 3, 4, 5, 6);

        $this->assertEquals($expectedResponse, $actualResponse);
        $this->assertEquals(['nan', 'nan'], $redis->tdigestbyrank('empty_key', 0, 1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestbyrank('key', 1, 2, 3);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTBYREVRANK_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTBYREVRANK_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTBYREVRANK::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTBYREVRANK';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1, 2, 3];
        $expectedArguments = ['key', 1, 2, 3];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testReturnsValuesEstimatedForGivenReverseRanks(): void
    {
        $redis = $this->getClient();
        $expectedResponse = ['3', '3', '3', '2', '2', '1', '-inf'];

        $redis->tdigestcreate('key');
        $redis->tdigestcreate('empty_key');

        $redis->tdigestadd('key', 1, 2, 2, 3, 3, 3);

        $actualResponse = $redis->tdigestbyrevrank('key', 0, 1, 2, 3, 4, 5, 6);

        $this->assertEquals($expectedResponse, $actualResponse);
        $this->assertEquals(['nan', 'nan'], $redis->tdigestbyrevrank('empty_key', 0, 1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestbyrevrank('key', 1, 2, 3);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTCDF_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTCDF_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTCDF::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTCDF';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1, 2, 3];
        $expectedArguments = ['key', 1, 2, 3];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testReturnsValuesEstimatedForGivenRanks(): void
    {
        $redis = $this->getClient();
        $expectedResponse = ['0', '0.083333333333333329', '0.33333333333333331', '0.75', '1'];

        $redis->tdigestcreate('key');
        $redis->tdigestcreate('empty_key');

        $redis->tdigestadd('key', 1, 2, 2, 3, 3, 3);

        $actualResponse = $redis->tdigestcdf('key', 0, 1, 2, 3, 4);

        $this->assertSameWithPrecision($expectedResponse, $actualResponse, 5);
        $this->assertSame(['nan', 'nan'], $redis->tdigestcdf('empty_key', 0, 1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestcdf('key', 1, 2, 3);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTCREATE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTCREATE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTCREATE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTCREATE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider sketchesProvider
     * @param  array  $createArguments
     * @param  string $key
     * @param  int    $expectedCompression
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testCreateTDigestSketchWithGivenConfiguration(
        array $createArguments,
        string $key,
        int $expectedCompression
    ): void {
        $redis = $this->getClient();

        $actualResponse = $redis->tdigestcreate(...$createArguments);
        $info = $redis->tdigestinfo($key);

        $this->assertEquals('OK', $actualResponse);
        $this->assertSame($expectedCompression, $info['Compression']);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnAlreadyCreatedKey(): void
    {
        $redis = $this->getClient();

        $actualResponse = $redis->tdigestcreate('key');
        $this->assertEquals('OK', $actualResponse);

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key already exists');

        $redis->tdigestcreate('key');
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key'],
                ['key'],
            ],
            'with 0 compression' => [
                ['key', 0],
                ['key'],
            ],
            'with COMPRESSION modifier' => [
                ['key', 100],
                ['key', 'COMPRESSION', 100],
            ],
        ];
    }

    public function sketchesProvider(): array
    {
        return [
            'with default arguments' => [
                ['key'],
                'key',
                100,
            ],
            'with modified COMPRESSION' => [
                ['key', 120],
                'key',
                120,
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTINFO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTINFO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTINFO::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTINFO';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key'];
        $expectedArguments = ['key'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $actualResponse = [
            'Compression', 100, 'Capacity', 610, 'Merged nodes', 0, 'Unmerged nodes', 5, 'Merged weight', 0,
            'Unmerged weight', 5, 'Observations', 5, 'Total compressions', 0, 'Memory usage', 9768,
        ];
        $expectedResponse = [
            'Compression' => 100,
            'Capacity' => 610,
            'Merged nodes' => 0,
            'Unmerged nodes' => 5,
            'Merged weight' => 0,
            'Unmerged weight' => 5,
            'Observations' => 5,
            'Total compressions' => 0,
            'Memory usage' => 9768,
        ];

        $this->assertSame($expectedResponse, $this->getCommand()->parseResponse($actualResponse));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testInfoReturnsInformationAboutGivenTDigestSketch(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [
            'Compression' => 100,
            'Capacity' => 610,
            'Merged nodes' => 0,
            'Unmerged nodes' => 0,
            'Merged weight' => 0,
            'Unmerged weight' => 0,
            'Observations' => 0,
            'Total compressions' => 0,
            'Memory usage' => 9768,
        ];

        $redis->tdigestcreate('key');

        $this->assertSame($expectedResponse, $redis->tdigestinfo('key'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestinfo('key');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTMAX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTMAX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTMAX::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTMAX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key'];
        $expectedArguments = ['key'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testReturnsMaxValueFromGivenSketch(): void
    {
        $redis = $this->getClient();

        $redis->tdigestcreate('key');
        $redis->tdigestcreate('empty_key');

        $redis->tdigestadd('key', 3, 2, 4, 5, 1);

        $actualResponse = $redis->tdigestmax('key');

        $this->assertEquals('5', $actualResponse);
        $this->assertEquals('nan', $redis->tdigestmax('empty_key'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestmax('key');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTMERGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTMERGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTMERGE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTMERGE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $command->getArguments());
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider sketchesProvider
     * @param  string $sourceKey1
     * @param  string $sourceKey2
     * @param  array  $sourceKey1AddValues
     * @param  array  $sourceKey2AddValues
     * @param  array  $mergeValues
     * @param  int    $expectedCompression
     * @param  array  $expectedMergedSketchValues
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testMergeTwoSketchesIntoOneWithinGivenDestinationKey(
        string $sourceKey1,
        string $sourceKey2,
        array $sourceKey1AddValues,
        array $sourceKey2AddValues,
        array $mergeValues,
        int $expectedCompression,
        array $expectedMergedSketchValues
    ): void {
        $redis = $this->getClient();

        $redis->tdigestcreate($sourceKey1);
        $redis->tdigestcreate($sourceKey2);

        $redis->tdigestadd(...$sourceKey1AddValues);
        $redis->tdigestadd(...$sourceKey2AddValues);

        $actualResponse = $redis->tdigestmerge(...$mergeValues);
        $info = $redis->tdigestinfo('destination-key');

        $this->assertEquals('OK', $actualResponse);
        $this->assertSame($expectedCompression, $info['Compression']);
        $this->assertEquals(
            $expectedMergedSketchValues,
            $redis->tdigestbyrank('destination-key', 0, 1, 2, 3, 4)
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testMergedSketchHaveCompressionEqualMaxValueAmongAllSourceSketches(): void
    {
        $redis = $this->getClient();

        $redis->tdigestcreate('source-key1');
        $redis->tdigestcreate('source-key2', 1000);

        $redis->tdigestadd('source-key1', 1, 2);
        $redis->tdigestadd('source-key2', 3, 4);

        $actualResponse = $redis->tdigestmerge('destination-key', ['source-key1', 'source-key2']);
        $info = $redis->tdigestinfo('destination-key');

        $this->assertEquals('OK', $actualResponse);
        $this->assertSame(1000, $info['Compression']);
        $this->assertEquals(
            ['1', '2', '3', '4', 'inf'],
            $redis->tdigestbyrank('destination-key', 0, 1, 2, 3, 4)
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testMergeOverrideAlreadyExistingSketchWithOverrideModifier(): void
    {
        $redis = $this->getClient();

        $redis->tdigestcreate('source-key1');
        $redis->tdigestcreate('source-key2');
        $redis->tdigestcreate('destination-key');

        $redis->tdigestadd('source-key1', 1, 2);
        $redis->tdigestadd('source-key2', 3, 4);
        $redis->tdigestadd('destination-key', 5, 6, 7, 8);

        $this->assertEquals(
            ['5', '6', '7', '8', 'inf'],
            $redis->tdigestbyrank('destination-key', 0, 1, 2, 3, 4)
        );

        $actualResponse = $redis->tdigestmerge(
            'destination-key',
            ['source-key1', 'source-key2'],
            0,
            true
        );
        $info = $redis->tdigestinfo('destination-key');

        $this->assertEquals('OK', $actualResponse);
        $this->assertSame(100, $info['Compression']);
        $this->assertEquals(
            ['1', '2', '3', '4', 'inf'],
            $redis->tdigestbyrank('destination-key', 0, 1, 2, 3, 4)
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testMergeWithAlreadyExistingSketchIfNoOverrideModifierGiven(): void
    {
        $redis = $this->getClient();

        $redis->tdigestcreate('source-key1');
        $redis->tdigestcreate('source-key2');
        $redis->tdigestcreate('destination-key');

        $redis->tdigestadd('source-key1', 1, 2);
        $redis->tdigestadd('source-key2', 3, 4);
        $redis->tdigestadd('destination-key', 5, 6, 7, 8);

        $actualResponse = $redis->tdigestmerge('destination-key', ['source-key1', 'source-key2']);
        $info = $redis->tdigestinfo('destination-key');

        $this->assertEquals('OK', $actualResponse);
        $this->assertSame(100, $info['Compression']);
        $this->assertEquals(
            ['1', '2', '3', '4', '5', '6', '7', '8', 'inf'],
            $redis->tdigestbyrank('destination-key', 0, 1, 2, 3, 4, 5, 6, 7, 8)
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingSourceKeyGiven(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestmerge('destination-key', ['source-key1', 'source-key2']);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', ['source-key1', 'source-key2']],
                ['key', 2, 'source-key1', 'source-key2'],
            ],
            'with COMPRESSION argument' => [
                ['key', ['source-key1', 'source-key2'], 10],
                ['key', 2, 'source-key1', 'source-key2', 'COMPRESSION', 10],
            ],
            'with OVERRIDE modifier' => [
                ['key', ['source-key1', 'source-key2'], 0, true],
                ['key', 2, 'source-key1', 'source-key2', 'OVERRIDE'],
            ],
            'with all arguments' => [
                ['key', ['source-key1', 'source-key2'], 10, true],
                ['key', 2, 'source-key1', 'source-key2', 'COMPRESSION', 10, 'OVERRIDE'],
            ],
        ];
    }

    public function sketchesProvider(): array
    {
        return [
            'with default arguments' => [
                'source-key1',
                'source-key2',
                ['source-key1', 1, 2],
                ['source-key2', 3, 4],
                ['destination-key', ['source-key1', 'source-key2']],
                100,
                ['1', '2', '3', '4', 'inf'],
            ],
            'with non-default COMPRESSION' => [
                'source-key1',
                'source-key2',
                ['source-key1', 1, 2],
                ['source-key2', 3, 4],
                ['destination-key', ['source-key1', 'source-key2'], 200],
                200,
                ['1', '2', '3', '4', 'inf'],
            ],
            'with OVERRIDE modifier' => [
                'source-key1',
                'source-key2',
                ['source-key1', 1, 2],
                ['source-key2', 3, 4],
                ['destination-key', ['source-key1', 'source-key2'], 0, true],
                100,
                ['1', '2', '3', '4', 'inf'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTMIN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTMIN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTMIN::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTMIN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key'];
        $expectedArguments = ['key'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testReturnsMinValueFromGivenSketch(): void
    {
        $redis = $this->getClient();

        $redis->tdigestcreate('key');
        $redis->tdigestcreate('empty_key');

        $redis->tdigestadd('key', 3, 2, 4, 5, 1);

        $actualResponse = $redis->tdigestmin('key');

        $this->assertEquals('1', $actualResponse);
        $this->assertEquals('nan', $redis->tdigestmin('empty_key'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestmin('key');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTQUANTILE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTQUANTILE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTQUANTILE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTQUANTILE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1, 2, 3];
        $expectedArguments = ['key', 1, 2, 3];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testReturnsValuesBelowGivenQuantile(): void
    {
        $redis = $this->getClient();

        $redis->tdigestcreate('key', 1000);

        $addResponse = $redis->tdigestadd('key', 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5);
        $quantileResponse = $redis->tdigestquantile('key', 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0);

        $this->assertEquals('OK', $addResponse);
        $this->assertEquals(['1', '2', '3', '3', '4', '4', '4', '5', '5', '5', '5'], $quantileResponse);

        $redis->tdigestcreate('empty_key');
        $this->assertEquals(['nan', 'nan'], $redis->tdigestquantile('empty_key', 0.0, 0.1));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestquantile('key', 1, 2, 3);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTRANK_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTRANK_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTRANK::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTRANK';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1, 2, 3];
        $expectedArguments = ['key', 1, 2, 3];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testReturnsRankOfGivenObservationValue(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [-1, 0, 1, 2, 3];

        $redis->tdigestcreate('key');
        $redis->tdigestcreate('empty_key');

        $redis->tdigestadd('key', 10, 20, 30);

        $actualResponse = $redis->tdigestrank('key', 0, 10, 20, 30, 40);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame([-2, -2, -2], $redis->tdigestrank('empty_key', 1, 2, 3));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestrank('key', 1, 2, 3);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTRESET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTRESET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTRESET::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTRESET';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key'];
        $expectedArguments = ['key'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testResetExistingSketch(): void
    {
        $redis = $this->getClient();

        $redis->tdigestcreate('key', 500);
        $redis->tdigestadd('key', 1, 2, 2, 3, 3, 3);

        $this->assertEquals(
            ['1', '2', '2', '3', '3', '3'],
            $redis->tdigestbyrank('key', 0, 1, 2, 3, 4, 5)
        );

        $actualResponse = $redis->tdigestreset('key');
        $info = $redis->tdigestinfo('key');

        $this->assertEquals('OK', $actualResponse);
        $this->assertSame(500, $info['Compression']);
        $this->assertEquals(
            ['nan', 'nan', 'nan', 'nan', 'nan', 'nan'],
            $redis->tdigestbyrank('key', 0, 1, 2, 3, 4, 5)
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestreset('key');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTREVRANK_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTREVRANK_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTREVRANK::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTREVRANK';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1, 2, 3];
        $expectedArguments = ['key', 1, 2, 3];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testReturnsReversedRanksOfGivenObservationsValue(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [3, 2, 1, 0, -1];

        $redis->tdigestcreate('key');
        $redis->tdigestcreate('empty_key');

        $redis->tdigestadd('key', 10, 20, 30);

        $actualResponse = $redis->tdigestrevrank('key', 0, 10, 20, 30, 40);

        $this->assertSame($expectedResponse, $actualResponse);
        $this->assertSame([-2, -2, -2], $redis->tdigestrank('empty_key', 1, 2, 3));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigestrevrank('key', 1, 2, 3);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TDigest\TDIGESTTRIMMED_MEAN_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TDigest;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TDIGESTTRIMMED_MEAN_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TDIGESTTRIMMED_MEAN::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TDIGESTTRIMMED_MEAN';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 0.1, 0.2];
        $expectedArguments = ['key', 0.1, 0.2];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider sketchesProvider
     * @param  array  $addArguments
     * @param  string $key
     * @param  array  $trimmedMeanArguments
     * @param  string $expectedResponse
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testReturnsMeanValueWithinGivenQuantilesRange(
        array $addArguments,
        string $key,
        array $trimmedMeanArguments,
        string $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->tdigestcreate($key);
        $redis->tdigestadd(...$addArguments);

        $actualResponse = $redis->tdigesttrimmed_mean(...$trimmedMeanArguments);

        $this->assertEquals($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testReturnsNanOnEmptySketchKey(): void
    {
        $redis = $this->getClient();

        $redis->tdigestcreate('key');

        $actualResponse = $redis->tdigesttrimmed_mean('key', 0, 1);
        $this->assertEquals('nan', $actualResponse);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.4.0
     */
    public function testThrowsExceptionOnNonExistingTDigestSketch(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR T-Digest: key does not exist');

        $redis->tdigesttrimmed_mean('key', 0, 1);
    }

    public function sketchesProvider(): array
    {
        return [
            'between low and high cut' => [
                ['key', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                'key',
                ['key', 0.1, 0.6],
                '4',
            ],
            'without low cut' => [
                ['key', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                'key',
                ['key', 0, 0.6],
                '3.5',
            ],
            'without high cut' => [
                ['key', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                'key',
                ['key', 0.6, 1],
                '8.5',
            ],
            'without low and high cut' => [
                ['key', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                'key',
                ['key', 0, 1],
                '5.5',
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\AddArguments;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-stack
 */
class TSADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSADD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSADD';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     * @return void
     */
    public function testFilterArgumentsThrowsExceptionOnNonPositiveValues(): void
    {
        $command = $this->getCommand();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Ignore does not accept negative values');

        $command->setArguments(['key', 123123121321, 1.0, (new AddArguments())->ignore(-2, -1)]);
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testAddSampleIntoTimeSeriesWithGivenConfiguration(): void
    {
        $redis = $this->getClient();

        $createArguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $createArguments)
        );

        $addArguments = (new AddArguments())
            ->retentionMsecs(31536000000);

        $this->assertEquals(
            123123123123,
            $redis->tsadd('temperature:2:32', 123123123123, 27, $addArguments)
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.12.01
     */
    public function testAddSampleIntoTimeSeriesWithIgnoreArgument(): void
    {
        $redis = $this->getClient();

        $createArguments = (new CreateArguments())
            ->retentionMsecs(31536000000)
            ->duplicatePolicy(CommonArguments::POLICY_LAST)
            ->ignore(10, 10);

        $this->assertEquals('OK', $redis->tscreate('temperature:2:32', $createArguments));

        $this->assertEquals(
            1000,
            $redis->tsadd('temperature:2:32', 1000, 27)
        );

        $this->assertEquals(
            1000,
            $redis->tsadd('temperature:2:32', 1005, 27)
        );

        $this->assertEquals(
            1005,
            $redis->tsadd('temperature:2:32', 1005, 38)
        );
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 123123121321, 1.0],
                ['key', 123123121321, 1.0],
            ],
            'with RETENTION modifier' => [
                ['key', 123123121321, 1.0, (new AddArguments())->retentionMsecs(100)],
                ['key', 123123121321, 1.0, 'RETENTION', 100],
            ],
            'with ENCODING modifier' => [
                ['key', 123123121321, 1.0, (new AddArguments())->encoding(CommonArguments::ENCODING_UNCOMPRESSED)],
                ['key', 123123121321, 1.0, 'ENCODING', CommonArguments::ENCODING_UNCOMPRESSED],
            ],
            'with CHUNK_SIZE modifier' => [
                ['key', 123123121321, 1.0, (new AddArguments())->chunkSize(100)],
                ['key', 123123121321, 1.0, 'CHUNK_SIZE', 100],
            ],
            'with ON_DUPLICATE modifier' => [
                ['key', 123123121321, 1.0, (new AddArguments())->onDuplicate(CommonArguments::POLICY_FIRST)],
                ['key', 123123121321, 1.0, 'ON_DUPLICATE', CommonArguments::POLICY_FIRST],
            ],
            'with IGNORE modifier' => [
                ['key', 123123121321, 1.0, (new AddArguments())->ignore(10, 1.1)],
                ['key', 123123121321, 1.0, 'IGNORE', 10, 1.1],
            ],
            'with all modifiers' => [
                ['key', 123123121321, 1.0, (new AddArguments())->retentionMsecs(100)->encoding(CommonArguments::ENCODING_UNCOMPRESSED)->chunkSize(100)->onDuplicate(CommonArguments::POLICY_FIRST)],
                ['key', 123123121321, 1.0, 'RETENTION', 100, 'ENCODING', CommonArguments::ENCODING_UNCOMPRESSED, 'CHUNK_SIZE', 100, 'ON_DUPLICATE', CommonArguments::POLICY_FIRST],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSALTER_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\AlterArguments;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-stack
 */
class TSALTER_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSALTER::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSALTER';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     * @return void
     */
    public function testFilterArgumentsThrowsExceptionOnNonPositiveValues(): void
    {
        $command = $this->getCommand();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Ignore does not accept negative values');

        $command->setArguments(['key', 123123121321, 1.0, (new AlterArguments())->ignore(-2, -1)]);
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testAlterUpdatesExistingTimeSeriesConfiguration(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );

        $alterArguments = (new AlterArguments())
            ->retentionMsecs(10000000);

        $this->assertEquals(
            'OK',
            $redis->tsalter('temperature:2:32', $alterArguments)
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.12.01
     */
    public function testAlterUpdatesExistingTimeSeriesWithIgnoreOption(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );

        $alterArguments = (new AlterArguments())
            ->retentionMsecs(10000000)
            ->duplicatePolicy(CommonArguments::POLICY_LAST)
            ->ignore(10, 10);

        $this->assertEquals(
            'OK',
            $redis->tsalter('temperature:2:32', $alterArguments)
        );

        $this->assertEquals(
            1000,
            $redis->tsadd('temperature:2:32', 1000, 27)
        );

        $this->assertEquals(
            1000,
            $redis->tsadd('temperature:2:32', 1005, 27)
        );

        $this->assertEquals(
            1005,
            $redis->tsadd('temperature:2:32', 1005, 38)
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR TSDB: the key does not exist');

        $redis->tsalter('non_existing_key');
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key'],
                ['key'],
            ],
            'with RETENTION modifier' => [
                ['key', (new AlterArguments())->retentionMsecs(100)],
                ['key', 'RETENTION', 100],
            ],
            'with CHUNK_SIZE modifier' => [
                ['key', (new AlterArguments())->chunkSize(100)],
                ['key', 'CHUNK_SIZE', 100],
            ],
            'with DUPLICATE_POLICY modifier' => [
                ['key', (new AlterArguments())->duplicatePolicy(CommonArguments::POLICY_FIRST)],
                ['key', 'DUPLICATE_POLICY', CommonArguments::POLICY_FIRST],
            ],
            'with IGNORE modifier' => [
                ['key', (new AlterArguments())->ignore(10, 1.1)],
                ['key', 'IGNORE', 10, 1.1],
            ],
            'with all modifiers' => [
                ['key', (new AlterArguments())->retentionMsecs(100)->chunkSize(100)->duplicatePolicy(CommonArguments::POLICY_FIRST)],
                ['key', 'RETENTION', 100, 'CHUNK_SIZE', 100, 'DUPLICATE_POLICY', CommonArguments::POLICY_FIRST],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSCREATERULE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TSCREATERULE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSCREATERULE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSCREATERULE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testCreateCompactionRuleWithinGivenTimeSeries(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->labels('type', 'temp', 'location', 'TLV');

        $this->assertEquals('OK', $redis->tscreate('temp:TLV', $arguments));
        $this->assertEquals('OK', $redis->tscreate('dailyAvgTemp:TLV', $arguments));
        $this->assertEquals(
            'OK',
            $redis->tscreaterule('temp:TLV', 'dailyAvgTemp:TLV', 'twa', 86400000)
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingDestinationKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR TSDB: the key does not exist');

        $redis->tscreaterule('temp:TLV', 'dailyAvgTemp:TLV', 'twa', 86400000);
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnWrongAggregationTypeGiven(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->labels('type', 'temp', 'location', 'TLV');

        $this->assertEquals('OK', $redis->tscreate('temp:TLV', $arguments));
        $this->assertEquals('OK', $redis->tscreate('dailyAvgTemp:TLV', $arguments));

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR TSDB: Unknown aggregation type');

        $redis->tscreaterule('temp:TLV', 'dailyAvgTemp:TLV', 'wrong', 86400000);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['sourceKey', 'destKey', 'sum', 100000],
                ['sourceKey', 'destKey', 'AGGREGATION', 'sum', 100000],
            ],
            'with alignTimestamp argument' => [
                ['sourceKey', 'destKey', 'sum', 100000, 10000000],
                ['sourceKey', 'destKey', 'AGGREGATION', 'sum', 100000, 10000000],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSCREATE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;
use UnexpectedValueException;

/**
 * @group commands
 * @group realm-stack
 */
class TSCREATE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSCREATE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSCREATE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     * @return void
     */
    public function testFilterArgumentsThrowsExceptionOnNonPositiveValues(): void
    {
        $command = $this->getCommand();

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Ignore does not accept negative values');

        $command->setArguments(['key', 123123121321, 1.0, (new CreateArguments())->ignore(-2, -1)]);
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testCreatesTimeSeriesWithGivenArguments(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.12.01
     */
    public function testCreatesTimeSeriesWithIgnoreOption(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_LAST)
            ->labels('sensor_id', 2, 'area_id', 32)
            ->ignore(10, 10);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );

        $this->assertEquals(
            1000,
            $redis->tsadd('temperature:2:32', 1000, 27)
        );

        $this->assertEquals(
            1000,
            $redis->tsadd('temperature:2:32', 1005, 27)
        );

        $this->assertEquals(
            1005,
            $redis->tsadd('temperature:2:32', 1005, 38)
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR TSDB: the key does not exist');

        $redis->tsinfo('non_existing_key');
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key'],
                ['key'],
            ],
            'with RETENTION modifier' => [
                ['key', (new CreateArguments())->retentionMsecs(100)],
                ['key', 'RETENTION', 100],
            ],
            'with ENCODING modifier' => [
                ['key', (new CreateArguments())->encoding(CreateArguments::ENCODING_UNCOMPRESSED)],
                ['key', 'ENCODING', CreateArguments::ENCODING_UNCOMPRESSED],
            ],
            'with CHUNK_SIZE modifier' => [
                ['key', (new CreateArguments())->chunkSize(100)],
                ['key', 'CHUNK_SIZE', 100],
            ],
            'with DUPLICATE_POLICY modifier' => [
                ['key', (new CreateArguments())->duplicatePolicy(CommonArguments::POLICY_FIRST)],
                ['key', 'DUPLICATE_POLICY', CommonArguments::POLICY_FIRST],
            ],
            'with IGNORE modifier' => [
                ['key', (new CreateArguments())->ignore(10, 1.1)],
                ['key', 'IGNORE', 10, 1.1],
            ],
            'with all modifiers' => [
                ['key', (new CreateArguments())->retentionMsecs(100)->encoding(CreateArguments::ENCODING_UNCOMPRESSED)->chunkSize(100)->duplicatePolicy(CommonArguments::POLICY_FIRST)],
                ['key', 'RETENTION', 100, 'ENCODING', CreateArguments::ENCODING_UNCOMPRESSED, 'CHUNK_SIZE', 100, 'DUPLICATE_POLICY', CommonArguments::POLICY_FIRST],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSDECRBY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\AddArguments;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\DecrByArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TSDECRBY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSDECRBY::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSDECRBY';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testDecrByDecreasesValueAndTimestampOfExistingSample(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );

        $addArguments = (new AddArguments())
            ->retentionMsecs(31536000000);

        $this->assertEquals(
            123123123123,
            $redis->tsadd('temperature:2:32', 123123123123, 27, $addArguments)
        );

        $this->assertEquals(
            123123123124,
            $redis->tsdecrby('temperature:2:32', 1, (new DecrByArguments())->timestamp(123123123124))
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testDecrByCreateNewSampleIfNotExists(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );

        $this->assertEquals(
            123123123123,
            $redis->tsdecrby('temperature:2:32', 27, (new DecrByArguments())->timestamp(123123123123))
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.12.01
     */
    public function testDecrByCreateNewSampleWithIgnoreArgument(): void
    {
        $redis = $this->getClient();

        $this->assertEquals(1000,
            $redis->tsdecrby('temperature:2:32', 27,
                (new DecrByArguments())
                    ->timestamp(1000)
                    ->duplicatePolicy(CommonArguments::POLICY_LAST)
                    ->ignore(10, 10)
            )
        );

        $this->assertEquals(
            1000,
            $redis->tsadd('temperature:2:32', 1000, 27)
        );

        $this->assertEquals(
            1000,
            $redis->tsadd('temperature:2:32', 1005, 27)
        );

        $this->assertEquals(
            1005,
            $redis->tsadd('temperature:2:32', 1005, 38)
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnOlderTimestampGiven(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );

        $addArguments = (new AddArguments())
            ->retentionMsecs(31536000000);

        $this->assertEquals(
            123123123123,
            $redis->tsadd('temperature:2:32', 123123123123, 27, $addArguments)
        );

        $this->expectException(ServerException::class);

        $redis->tsdecrby('temperature:2:32', 27, (new DecrByArguments())->timestamp(123123123122));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 1.0],
                ['key', 1.0],
            ],
            'with TIMESTAMP modifier' => [
                ['key', 1.0, (new DecrByArguments())->timestamp(10)],
                ['key', 1.0, 'TIMESTAMP', 10],
            ],
            'with RETENTION modifier' => [
                ['key', 1.0, (new DecrByArguments())->retentionMsecs(100)],
                ['key', 1.0, 'RETENTION', 100],
            ],
            'with UNCOMPRESSED modifier' => [
                ['key', 1.0, (new DecrByArguments())->uncompressed()],
                ['key', 1.0, 'UNCOMPRESSED'],
            ],
            'with CHUNK_SIZE modifier' => [
                ['key', 1.0, (new DecrByArguments())->chunkSize(100)],
                ['key', 1.0, 'CHUNK_SIZE', 100],
            ],
            'with LABELS modifier' => [
                ['key', 1.0, (new DecrByArguments())->labels('label1', 1, 'label2', 2)],
                ['key', 1.0, 'LABELS', 'label1', 1, 'label2', 2],
            ],
            'with all modifiers' => [
                ['key', 1.0, (new DecrByArguments())->timestamp(10)->retentionMsecs(100)->uncompressed()->chunkSize(100)->labels('label1', 1, 'label2', 2)],
                ['key', 1.0, 'TIMESTAMP', 10, 'RETENTION', 100, 'UNCOMPRESSED', 'CHUNK_SIZE', 100, 'LABELS', 'label1', 1, 'label2', 2],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSDELETERULE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TSDELETERULE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSDELETERULE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSDELETERULE';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['sourceKey', 'destKey'];
        $expectedArguments = ['sourceKey', 'destKey'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testDeleteCompactionRuleFromGivenTimeSeries(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->labels('type', 'temp', 'location', 'TLV');

        $this->assertEquals('OK', $redis->tscreate('temp:TLV', $arguments));
        $this->assertEquals('OK', $redis->tscreate('dailyAvgTemp:TLV', $arguments));
        $this->assertEquals(
            'OK',
            $redis->tscreaterule('temp:TLV', 'dailyAvgTemp:TLV', 'twa', 86400000)
        );
        $this->assertEquals(
            'OK',
            $redis->tsdeleterule('temp:TLV', 'dailyAvgTemp:TLV')
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingDestinationKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR TSDB: the key does not exist');

        $redis->tsdeleterule('temp:TLV', 'dailyAvgTemp:TLV');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSDEL_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TSDEL_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSDEL::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSDEL';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 1000, 1001];
        $expectedArguments = ['key', 1000, 1001];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.6.0
     */
    public function testDelRemovesSamplesWithinGivenTimestampsRange(): void
    {
        $redis = $this->getClient();

        $createArguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $createArguments)
        );

        $this->assertEquals(
            123123123123,
            $redis->tsadd('temperature:2:32', 123123123123, 27)
        );

        $this->assertEquals(
            123123123124,
            $redis->tsadd('temperature:2:32', 123123123124, 28)
        );

        $this->assertEquals(
            123123123125,
            $redis->tsadd('temperature:2:32', 123123123125, 29)
        );

        $this->assertSame(
            2,
            $redis->tsdel('temperature:2:32', 123123123124, 123123123125)
        );

        $this->assertEquals([123123123123, '27'], $redis->tsget('temperature:2:32'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.6.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR TSDB: the key does not exist');

        $redis->tsdel('non_existing_key', 100, 101);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSGET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\GetArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TSGET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSGET::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSGET';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testGetSampleWithHighestTimestampFromGivenTimeSeries(): void
    {
        $redis = $this->getClient();

        $createArguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $createArguments)
        );

        $this->assertEquals(
            123123123123,
            $redis->tsadd('temperature:2:32', 123123123123, 27)
        );

        $this->assertEquals(
            123123123124,
            $redis->tsadd('temperature:2:32', 123123123124, 28)
        );

        $this->assertEquals(
            123123123125,
            $redis->tsadd('temperature:2:32', 123123123125, 29)
        );

        $this->assertEquals([123123123125, '29'], $redis->tsget('temperature:2:32'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR TSDB: the key does not exist');

        $redis->tsget('non_existing_key');
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key'],
                ['key'],
            ],
            'with LATEST modifier' => [
                ['key', (new GetArguments())->latest()],
                ['key', 'LATEST'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSINCRBY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\AddArguments;
use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\IncrByArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TSINCRBY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSINCRBY::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSINCRBY';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testIncrByIncreasesValueAndTimestampOfExistingSample(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );

        $addArguments = (new AddArguments())
            ->retentionMsecs(31536000000);

        $this->assertEquals(
            123123123123,
            $redis->tsadd('temperature:2:32', 123123123123, 27, $addArguments)
        );

        $this->assertEquals(
            123123123124,
            $redis->tsincrby('temperature:2:32', 28, (new IncrByArguments())->timestamp(123123123124))
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testIncrByCreateNewSampleIfNotExists(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );

        $this->assertEquals(
            123123123123,
            $redis->tsincrby('temperature:2:32', 27, (new IncrByArguments())->timestamp(123123123123))
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.12.01
     */
    public function testIncrByCreateNewSampleWithIgnoreArgument(): void
    {
        $redis = $this->getClient();

        $this->assertEquals(
            1000,
            $redis->tsincrby(
                'temperature:2:32',
                27,
                (new IncrByArguments())
                    ->timestamp(1000)
                    ->duplicatePolicy(CommonArguments::POLICY_LAST)
                    ->ignore(10, 10)
            )
        );

        $this->assertEquals(
            1000,
            $redis->tsadd('temperature:2:32', 1000, 27)
        );

        $this->assertEquals(
            1000,
            $redis->tsadd('temperature:2:32', 1005, 27)
        );

        $this->assertEquals(
            1005,
            $redis->tsadd('temperature:2:32', 1005, 38)
        );
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnOlderTimestampGiven(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );

        $addArguments = (new AddArguments())
            ->retentionMsecs(31536000000);

        $this->assertEquals(
            123123123123,
            $redis->tsadd('temperature:2:32', 123123123123, 27, $addArguments)
        );

        $this->expectException(ServerException::class);

        $redis->tsincrby('temperature:2:32', 27, (new IncrByArguments())->timestamp(123123123122));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 1.0],
                ['key', 1.0],
            ],
            'with TIMESTAMP modifier' => [
                ['key', 1.0, (new IncrByArguments())->timestamp(10)],
                ['key', 1.0, 'TIMESTAMP', 10],
            ],
            'with RETENTION modifier' => [
                ['key', 1.0, (new IncrByArguments())->retentionMsecs(100)],
                ['key', 1.0, 'RETENTION', 100],
            ],
            'with UNCOMPRESSED modifier' => [
                ['key', 1.0, (new IncrByArguments())->uncompressed()],
                ['key', 1.0, 'UNCOMPRESSED'],
            ],
            'with CHUNK_SIZE modifier' => [
                ['key', 1.0, (new IncrByArguments())->chunkSize(100)],
                ['key', 1.0, 'CHUNK_SIZE', 100],
            ],
            'with LABELS modifier' => [
                ['key', 1.0, (new IncrByArguments())->labels('label1', 1, 'label2', 2)],
                ['key', 1.0, 'LABELS', 'label1', 1, 'label2', 2],
            ],
            'with all modifiers' => [
                ['key', 1.0, (new IncrByArguments())->timestamp(10)->retentionMsecs(100)->uncompressed()->chunkSize(100)->labels('label1', 1, 'label2', 2)],
                ['key', 1.0, 'TIMESTAMP', 10, 'RETENTION', 100, 'UNCOMPRESSED', 'CHUNK_SIZE', 100, 'LABELS', 'label1', 1, 'label2', 2],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSINFO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\InfoArguments;
use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class TSINFO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSINFO::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSINFO';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion <= 1.10.13
     */
    public function testReturnsInformationAboutGivenTimeSeries(): void
    {
        $redis = $this->getClient();
        $expectedResponse = ['totalSamples', 0, 'memoryUsage', 4239, 'firstTimestamp', 0, 'lastTimestamp', 0,
            'retentionTime', 60000, 'chunkCount', 1, 'chunkSize', 4096, 'chunkType', 'compressed', 'duplicatePolicy',
            'max', 'labels', [['sensor_id', '2'], ['area_id', '32']], 'sourceKey', null, 'rules', [],
            'ignoreMaxTimeDiff', 0, 'ignoreMaxValDiff', 0];

        $arguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $arguments)
        );

        $this->assertEquals($expectedResponse, $redis->tsinfo('temperature:2:32'));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key'],
                ['key'],
            ],
            'with DEBUG modifier' => [
                ['key', (new InfoArguments())->debug()],
                ['key', 'DEBUG'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSMADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TSMADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSMADD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSMADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key1', 1000, 1001, 'key2', 1000, 1001];
        $expectedArguments = ['key1', 1000, 1001, 'key2', 1000, 1001];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testAddSamplesIntoFewTimeSeries(): void
    {
        $redis = $this->getClient();

        $createArguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $createArguments)
        );

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:33', $createArguments)
        );

        $this->assertEquals(
            [123123123123, 123123123124],
            $redis->tsmadd('temperature:2:32', 123123123123, 27, 'temperature:2:33', 123123123124, 28)
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonWrongArgumentsNumber(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);

        $redis->tsmadd('temperature:2:32', 123123123123, 27, 'temperature:2:33', 123123123124);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSMGET_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CommonArguments;
use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\MGetArguments;
use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class TSMGET_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSMGET::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSMGET';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testGetSampleFromMultipleTimeSeriesMatchingGivenPattern(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [
            ['temperature:2:32', [['type', 'temp']], [123123123123, '27']],
            ['temperature:2:33', [['type', 'temp']], [123123123124, '27']],
        ];

        $createArguments = (new CreateArguments())
            ->retentionMsecs(60000)
            ->duplicatePolicy(CommonArguments::POLICY_MAX)
            ->labels('type', 'temp', 'sensor_id', 2, 'area_id', 32);

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:32', $createArguments)
        );

        $this->assertEquals(
            'OK',
            $redis->tscreate('temperature:2:33', $createArguments)
        );

        $redis->tsadd('temperature:2:32', 123123123123, 27);
        $redis->tsadd('temperature:2:33', 123123123124, 27);

        $this->assertEquals(
            $expectedResponse,
            $redis->tsmget((new MGetArguments())->selectedLabels('type'), 'type=temp')
        );
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                [(new MGetArguments())->withLabels(), 'filterExpression1', 'filterExpression2'],
                ['WITHLABELS', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with LATEST modifier' => [
                [(new MGetArguments())->latest(), 'filterExpression1', 'filterExpression2'],
                ['LATEST', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with WITHLABELS modifier' => [
                [(new MGetArguments())->withLabels(), 'filterExpression1', 'filterExpression2'],
                ['WITHLABELS', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with SELECTED_LABELS modifier' => [
                [(new MGetArguments())->selectedLabels('label1', 'label2'), 'filterExpression1', 'filterExpression2'],
                ['SELECTED_LABELS', 'label1', 'label2', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with all modifiers' => [
                [(new MGetArguments())->latest()->selectedLabels('label1', 'label2'), 'filterExpression1', 'filterExpression2'],
                ['LATEST', 'SELECTED_LABELS', 'label1', 'label2', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSMRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\MRangeArguments;
use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class TSMRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSMRANGE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSMRANGE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testQueryRangeAcrossMultipleTimeSeriesInForwardDirection(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [
            [
                'type=stock',
                [
                    ['type', 'stock'],
                    ['__reducer__', 'max'],
                    ['__source__', 'stock:A,stock:B'],
                ],
                [
                    [1000, '120'],
                    [1010, '110'],
                    [1020, '120'],
                ],
            ],
        ];

        $this->assertEquals(
            'OK',
            $redis->tscreate('stock:A', (new CreateArguments())->labels('type', 'stock', 'name', 'A'))
        );
        $this->assertEquals(
            'OK',
            $redis->tscreate('stock:B', (new CreateArguments())->labels('type', 'stock', 'name', 'B'))
        );
        $this->assertSame(
            [1000, 1010, 1020],
            $redis->tsmadd('stock:A', 1000, 100, 'stock:A', 1010, 110, 'stock:A', 1020, 120)
        );
        $this->assertSame(
            [1000, 1010, 1020],
            $redis->tsmadd('stock:B', 1000, 120, 'stock:B', 1010, 110, 'stock:B', 1020, 100)
        );

        $mrangeArguments = (new MRangeArguments())
            ->withLabels()
            ->filter('type=stock')
            ->groupBy('type', 'max');

        $this->assertEquals($expectedResponse, $redis->tsmrange('-', '+', $mrangeArguments));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                [1000, 1001, (new MRangeArguments())->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with LATEST modifier' => [
                [1000, 1001, (new MRangeArguments())->latest()->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'LATEST', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with FILTER_BY_TS modifier' => [
                [1000, 1001, (new MRangeArguments())->filterByTs(1000, 1001)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'FILTER_BY_TS', 1000, 1001, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with FILTER_BY_VALUE modifier' => [
                [1000, 1001, (new MRangeArguments())->filterByValue(1000, 1001)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'FILTER_BY_VALUE', 1000, 1001, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with WITHLABELS modifier' => [
                [1000, 1001, (new MRangeArguments())->withLabels()->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'WITHLABELS', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with SELECTED_LABELS modifier' => [
                [1000, 1001, (new MRangeArguments())->selectedLabels('label1', 'label2')->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'SELECTED_LABELS', 'label1', 'label2', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with COUNT modifier' => [
                [1000, 1001, (new MRangeArguments())->count(2)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'COUNT', 2, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with AGGREGATION modifier - default arguments' => [
                [1000, 1001, (new MRangeArguments())->aggregation('sum', 2)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'AGGREGATION', 'sum', 2, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with AGGREGATION modifier - with ALIGN' => [
                [1000, 1001, (new MRangeArguments())->aggregation('sum', 2, 2)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'ALIGN', 2, 'AGGREGATION', 'sum', 2, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with AGGREGATION modifier - with BUCKETTIMESTAMP' => [
                [1000, 1001, (new MRangeArguments())->aggregation('sum', 2, 0, 10000)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'AGGREGATION', 'sum', 2, 'BUCKETTIMESTAMP', 10000, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with AGGREGATION modifier - with EMPTY' => [
                [1000, 1001, (new MRangeArguments())->aggregation('sum', 2, 0, 0, true)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'AGGREGATION', 'sum', 2, 'EMPTY', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with GROUPBY modifier' => [
                [1000, 1001, (new MRangeArguments())->filter('filterExpression1', 'filterExpression2')->groupBy('label', 'reducer')],
                [1000, 1001, 'FILTER', 'filterExpression1', 'filterExpression2', 'GROUPBY', 'label', 'REDUCE', 'reducer'],
            ],
            'with all modifiers' => [
                [1000, 1001, (new MRangeArguments())->latest()->filterByTs(1000, 1001)->filterByValue(1000, 1001)->withLabels()->count(2)->aggregation('sum', 2)->filter('filterExpression1', 'filterExpression2')->groupBy('label', 'reducer'), 'filterExpression1', 'filterExpression2'],
                [1000, 1001, 'LATEST', 'FILTER_BY_TS', 1000, 1001, 'FILTER_BY_VALUE', 1000, 1001, 'WITHLABELS', 'COUNT', 2, 'AGGREGATION', 'sum', 2, 'FILTER', 'filterExpression1', 'filterExpression2', 'GROUPBY', 'label', 'REDUCE', 'reducer'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSMREVRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\MRangeArguments;
use Predis\Command\Redis\PredisCommandTestCase;

/**
 * @group commands
 * @group realm-stack
 */
class TSMREVRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSMREVRANGE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSMREVRANGE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.4.0
     */
    public function testQueryRangeAcrossMultipleTimeSeriesInReverseDirection(): void
    {
        $redis = $this->getClient();
        $expectedResponse = [
            [
                'type=stock',
                [
                    ['type', 'stock'],
                    ['__reducer__', 'max'],
                    ['__source__', 'stock:A,stock:B'],
                ],
                [
                    [1020, '120'],
                    [1010, '110'],
                    [1000, '120'],
                ],
            ],
        ];

        $this->assertEquals(
            'OK',
            $redis->tscreate('stock:A', (new CreateArguments())->labels('type', 'stock', 'name', 'A'))
        );
        $this->assertEquals(
            'OK',
            $redis->tscreate('stock:B', (new CreateArguments())->labels('type', 'stock', 'name', 'B'))
        );
        $this->assertSame(
            [1000, 1010, 1020],
            $redis->tsmadd('stock:A', 1000, 100, 'stock:A', 1010, 110, 'stock:A', 1020, 120)
        );
        $this->assertSame(
            [1000, 1010, 1020],
            $redis->tsmadd('stock:B', 1000, 120, 'stock:B', 1010, 110, 'stock:B', 1020, 100)
        );

        $mrangeArguments = (new MRangeArguments())
            ->withLabels()
            ->filter('type=stock')
            ->groupBy('type', 'max');

        $this->assertEquals($expectedResponse, $redis->tsmrevrange('-', '+', $mrangeArguments));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                [1000, 1001, (new MRangeArguments())->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with LATEST modifier' => [
                [1000, 1001, (new MRangeArguments())->latest()->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'LATEST', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with FILTER_BY_TS modifier' => [
                [1000, 1001, (new MRangeArguments())->filterByTs(1000, 1001)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'FILTER_BY_TS', 1000, 1001, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with FILTER_BY_VALUE modifier' => [
                [1000, 1001, (new MRangeArguments())->filterByValue(1000, 1001)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'FILTER_BY_VALUE', 1000, 1001, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with WITHLABELS modifier' => [
                [1000, 1001, (new MRangeArguments())->withLabels()->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'WITHLABELS', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with SELECTED_LABELS modifier' => [
                [1000, 1001, (new MRangeArguments())->selectedLabels('label1', 'label2')->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'SELECTED_LABELS', 'label1', 'label2', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with COUNT modifier' => [
                [1000, 1001, (new MRangeArguments())->count(2)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'COUNT', 2, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with AGGREGATION modifier - default arguments' => [
                [1000, 1001, (new MRangeArguments())->aggregation('sum', 2)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'AGGREGATION', 'sum', 2, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with AGGREGATION modifier - with ALIGN' => [
                [1000, 1001, (new MRangeArguments())->aggregation('sum', 2, 2)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'ALIGN', 2, 'AGGREGATION', 'sum', 2, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with AGGREGATION modifier - with BUCKETTIMESTAMP' => [
                [1000, 1001, (new MRangeArguments())->aggregation('sum', 2, 0, 10000)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'AGGREGATION', 'sum', 2, 'BUCKETTIMESTAMP', 10000, 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with AGGREGATION modifier - with EMPTY' => [
                [1000, 1001, (new MRangeArguments())->aggregation('sum', 2, 0, 0, true)->filter('filterExpression1', 'filterExpression2')],
                [1000, 1001, 'AGGREGATION', 'sum', 2, 'EMPTY', 'FILTER', 'filterExpression1', 'filterExpression2'],
            ],
            'with GROUPBY modifier' => [
                [1000, 1001, (new MRangeArguments())->filter('filterExpression1', 'filterExpression2')->groupBy('label', 'reducer')],
                [1000, 1001, 'FILTER', 'filterExpression1', 'filterExpression2', 'GROUPBY', 'label', 'REDUCE', 'reducer'],
            ],
            'with all modifiers' => [
                [1000, 1001, (new MRangeArguments())->latest()->filterByTs(1000, 1001)->filterByValue(1000, 1001)->withLabels()->count(2)->aggregation('sum', 2)->filter('filterExpression1', 'filterExpression2')->groupBy('label', 'reducer'), 'filterExpression1', 'filterExpression2'],
                [1000, 1001, 'LATEST', 'FILTER_BY_TS', 1000, 1001, 'FILTER_BY_VALUE', 1000, 1001, 'WITHLABELS', 'COUNT', 2, 'AGGREGATION', 'sum', 2, 'FILTER', 'filterExpression1', 'filterExpression2', 'GROUPBY', 'label', 'REDUCE', 'reducer'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSQUERYINDEX_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TSQUERYINDEX_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSQUERYINDEX::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSQUERYINDEX';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ["role='test'"];
        $expectedArguments = ["role='test'"];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testQueryReturnsKeysMatchingGivenFilterExpression(): void
    {
        $redis = $this->getClient();

        $arguments = (new CreateArguments())
            ->labels('type', 'temp', 'location', 'TLV');

        $this->assertEquals('OK', $redis->tscreate('temp:TLV', $arguments));

        $anotherArguments = (new CreateArguments())
            ->labels('type', 'temp', 'location', 'JER');

        $this->assertEquals('OK', $redis->tscreate('temp:JER', $anotherArguments));

        $this->assertSame(['temp:TLV'], $redis->tsqueryindex('location=TLV'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnInvalidFilterExpression(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR TSDB: failed parsing labels');

        $redis->tsqueryindex('wrong');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\RangeArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TSRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSRANGE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSRANGE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testReturnsQueriedRangeInForwardDirectionFromGivenTimeSeries(): void
    {
        $redis = $this->getClient();

        $createArguments = (new CreateArguments())->labels('type', 'temp', 'location', 'TLV');
        $this->assertEquals('OK', $redis->tscreate('temp:TLV', $createArguments));

        $this->assertSame(
            [1000, 1010, 1020, 1030],
            $redis->tsmadd('temp:TLV', 1000, 30, 'temp:TLV', 1010, 35, 'temp:TLV', 1020, 9999, 'temp:TLV', 1030, 40)
        );

        $rangeArguments = (new RangeArguments())->filterByValue(-100, 100);
        $this->assertEquals(
            [[1000, '30'], [1010, '35'], [1030, '40']],
            $redis->tsrange('temp:TLV', '-', '+', $rangeArguments)
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR TSDB: the key does not exist');

        $redis->tsrange('non_existing_key', 1000, 1000);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 10000, 10001],
                ['key', 10000, 10001],
            ],
            'with LATEST modifier' => [
                ['key', 10000, 10001, (new RangeArguments())->latest()],
                ['key', 10000, 10001, 'LATEST'],
            ],
            'with FILTER_BY_TS modifier' => [
                ['key', 10000, 10001, (new RangeArguments())->filterByTs(1000, 1001)],
                ['key', 10000, 10001, 'FILTER_BY_TS', 1000, 1001],
            ],
            'with FILTER_BY_VALUE modifier' => [
                ['key', 10000, 10001, (new RangeArguments())->filterByValue(1000, 1001)],
                ['key', 10000, 10001, 'FILTER_BY_VALUE', 1000, 1001],
            ],
            'with COUNT modifier' => [
                ['key', 10000, 10001, (new RangeArguments())->count(100)],
                ['key', 10000, 10001, 'COUNT', 100],
            ],
            'with AGGREGATION modifier - default arguments' => [
                ['key', 10000, 10001, (new RangeArguments())->aggregation('sum', 100)],
                ['key', 10000, 10001, 'AGGREGATION', 'sum', 100],
            ],
            'with AGGREGATION modifier - with ALIGN' => [
                ['key', 10000, 10001, (new RangeArguments())->aggregation('sum', 100, 100)],
                ['key', 10000, 10001, 'ALIGN', 100, 'AGGREGATION', 'sum', 100],
            ],
            'with AGGREGATION modifier - with BUCKETTIMESTAMP' => [
                ['key', 10000, 10001, (new RangeArguments())->aggregation('sum', 100, 0, 1000)],
                ['key', 10000, 10001, 'AGGREGATION', 'sum', 100, 'BUCKETTIMESTAMP', 1000],
            ],
            'with AGGREGATION modifier - with EMPTY' => [
                ['key', 10000, 10001, (new RangeArguments())->aggregation('sum', 100, 0, 0, true)],
                ['key', 10000, 10001, 'AGGREGATION', 'sum', 100, 'EMPTY'],
            ],
            'with all modifiers' => [
                ['key', 10000, 10001, (new RangeArguments())->latest()->filterByTs(1000, 1001)->filterByValue(1000, 1001)->count(100)->aggregation('sum', 100)],
                ['key', 10000, 10001, 'LATEST', 'FILTER_BY_TS', 1000, 1001, 'FILTER_BY_VALUE', 1000, 1001, 'COUNT', 100, 'AGGREGATION', 'sum', 100],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TimeSeries\TSREVRANGE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TimeSeries;

use Predis\Command\Argument\TimeSeries\CreateArguments;
use Predis\Command\Argument\TimeSeries\RangeArguments;
use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TSREVRANGE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TSREVRANGE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TSREVRANGE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testReturnsQueriedRangeInReverseDirectionFromGivenTimeSeries(): void
    {
        $redis = $this->getClient();

        $createArguments = (new CreateArguments())->labels('type', 'temp', 'location', 'TLV');
        $this->assertEquals('OK', $redis->tscreate('temp:TLV', $createArguments));

        $this->assertSame(
            [1000, 1010, 1020, 1030],
            $redis->tsmadd('temp:TLV', 1000, 30, 'temp:TLV', 1010, 35, 'temp:TLV', 1020, 9999, 'temp:TLV', 1030, 40)
        );

        $rangeArguments = (new RangeArguments())->filterByValue(-100, 100);
        $this->assertEquals(
            [[1030, '40'], [1010, '35'], [1000, '30']],
            $redis->tsrevrange('temp:TLV', '-', '+', $rangeArguments)
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisTimeSeriesVersion >= 1.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('ERR TSDB: the key does not exist');

        $redis->tsrevrange('non_existing_key', 1000, 1000);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 10000, 10001],
                ['key', 10000, 10001],
            ],
            'with LATEST modifier' => [
                ['key', 10000, 10001, (new RangeArguments())->latest()],
                ['key', 10000, 10001, 'LATEST'],
            ],
            'with FILTER_BY_TS modifier' => [
                ['key', 10000, 10001, (new RangeArguments())->filterByTs(1000, 1001)],
                ['key', 10000, 10001, 'FILTER_BY_TS', 1000, 1001],
            ],
            'with FILTER_BY_VALUE modifier' => [
                ['key', 10000, 10001, (new RangeArguments())->filterByValue(1000, 1001)],
                ['key', 10000, 10001, 'FILTER_BY_VALUE', 1000, 1001],
            ],
            'with COUNT modifier' => [
                ['key', 10000, 10001, (new RangeArguments())->count(100)],
                ['key', 10000, 10001, 'COUNT', 100],
            ],
            'with AGGREGATION modifier - default arguments' => [
                ['key', 10000, 10001, (new RangeArguments())->aggregation('sum', 100)],
                ['key', 10000, 10001, 'AGGREGATION', 'sum', 100],
            ],
            'with AGGREGATION modifier - with ALIGN' => [
                ['key', 10000, 10001, (new RangeArguments())->aggregation('sum', 100, 100)],
                ['key', 10000, 10001, 'ALIGN', 100, 'AGGREGATION', 'sum', 100],
            ],
            'with AGGREGATION modifier - with BUCKETTIMESTAMP' => [
                ['key', 10000, 10001, (new RangeArguments())->aggregation('sum', 100, 0, 1000)],
                ['key', 10000, 10001, 'AGGREGATION', 'sum', 100, 'BUCKETTIMESTAMP', 1000],
            ],
            'with AGGREGATION modifier - with EMPTY' => [
                ['key', 10000, 10001, (new RangeArguments())->aggregation('sum', 100, 0, 0, true)],
                ['key', 10000, 10001, 'AGGREGATION', 'sum', 100, 'EMPTY'],
            ],
            'with all modifiers' => [
                ['key', 10000, 10001, (new RangeArguments())->latest()->filterByTs(1000, 1001)->filterByValue(1000, 1001)->count(100)->aggregation('sum', 100)],
                ['key', 10000, 10001, 'LATEST', 'FILTER_BY_TS', 1000, 1001, 'FILTER_BY_VALUE', 1000, 1001, 'COUNT', 100, 'AGGREGATION', 'sum', 100],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TopK\TOPKADD_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TOPKADD_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TOPKADD::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TOPKADD';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item1', 'item2'];
        $expectedArguments = ['key', 'item1', 'item2'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider structuresProvider
     * @param  array $reserveArguments
     * @param  array $addArguments
     * @param  array $expectedResponse
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testAddItemsIntoGivenTopKStructure(
        array $reserveArguments,
        array $addArguments,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->topkreserve(...$reserveArguments);

        $actualResponse = $redis->topkadd(...$addArguments);
        $this->assertEquals($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('TopK: key does not exist');

        $redis->topkadd('key', 0, 1);
    }

    public function structuresProvider(): array
    {
        return [
            'without dropped items' => [
                ['key', 4],
                ['key', 0, 1, 2],
                [null, null, null],
            ],
            'with dropped items' => [
                ['key', 2],
                ['key', 0, 1, 2],
                [null, null, '0'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TopK\TOPKINCRBY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TOPKINCRBY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TOPKINCRBY::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TOPKINCRBY';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item1', 1, 'item2', 2];
        $expectedArguments = ['key', 'item1', 1, 'item2', 2];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testIncrementItemsScoreOnGivenAmount(): void
    {
        $redis = $this->getClient();

        $redis->topkreserve('key', 2);
        $this->assertSame([null, null], $redis->topkadd('key', 'item1', 'item2'));

        $actualResponse = $redis->topkincrby('key', 'item1', 1, 'item2', 2, 'item3', 3);

        $this->assertEquals([null, null, 'item1'], $actualResponse);
        $this->assertEquals(['item2' => 3, 'item3' => 3], $redis->topklist('key', true));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('TopK: key does not exist');

        $redis->topkincrby('key', 'item', 1);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TopK\TOPKINFO_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TOPKINFO_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TOPKINFO::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TOPKINFO';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key'];
        $expectedArguments = ['key'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $actualResponse = ['k', 50, 'width', 8, 'depth', 7, 'decay', '0.90000000000000002'];
        $expectedResponse = ['k' => 50, 'width' => 8, 'depth' => 7, 'decay' => '0.90000000000000002'];

        $this->assertSame($expectedResponse, $this->getCommand()->parseResponse($actualResponse));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testReturnsInfoAboutGivenTopKStructure(): void
    {
        $redis = $this->getClient();

        $redis->topkreserve('key', 50);

        $this->assertSameWithPrecision(
            ['k' => 50, 'width' => 8, 'depth' => 7, 'decay' => '0.90000000000000002'],
            $redis->topkinfo('key'),
            1
        );
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('TopK: key does not exist');

        $redis->topkinfo('key');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TopK\TOPKLIST_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TOPKLIST_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TOPKLIST::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TOPKLIST';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     * @dataProvider responsesProvider
     */
    public function testParseResponse(array $arguments, array $actualResponse, array $expectedResponse): void
    {
        $command = $this->getCommand();
        $command->setArguments($arguments);

        $this->assertSame($expectedResponse, $command->parseResponse($actualResponse));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider structureProvider
     * @param  array $reserveArguments
     * @param  array $addArguments
     * @param  array $listArguments
     * @param  array $expectedResponse
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testReturnsListOfItemsWithinTopKStructure(
        array $reserveArguments,
        array $addArguments,
        array $listArguments,
        array $expectedResponse
    ): void {
        $redis = $this->getClient();

        $redis->topkreserve(...$reserveArguments);
        $redis->topkadd(...$addArguments);

        $actualResponse = $redis->topklist(...$listArguments);

        $this->assertEquals($expectedResponse, $actualResponse);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('TopK: key does not exist');

        $redis->topklist('key', true);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default argument' => [
                ['key'],
                ['key'],
            ],
            'with WITHCOUNT modifier equals true' => [
                ['key', true],
                ['key', 'WITHCOUNT'],
            ],
            'with WITHCOUNT modifier equals false' => [
                ['key', false],
                ['key'],
            ],
        ];
    }

    public function responsesProvider(): array
    {
        return [
            'without WITHCOUNT modifier' => [
                ['foo'],
                ['foo', 'bar'],
                ['foo', 'bar'],
            ],
            'with WITHCOUNT modifier' => [
                ['foo', true],
                ['foo', 12, 'bar', 13],
                ['foo' => 12, 'bar' => 13],
            ],
        ];
    }

    public function structureProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 50],
                ['key', 1, 2, 2, 3, 3, 3],
                ['key', false],
                ['3', '2', '1'],
            ],
            'with WITHCOUNT modifier' => [
                ['key', 50],
                ['key', 1, 2, 2, 3, 3, 3],
                ['key', true],
                ['3' => 3, '2' => 2, '1' => 1],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TopK\TOPKQUERY_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TOPKQUERY_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TOPKQUERY::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TOPKQUERY';
    }

    /**
     * @group disconnected
     */
    public function testFilterArguments(): void
    {
        $actualArguments = ['key', 'item1', 'item2'];
        $expectedArguments = ['key', 'item1', 'item2'];

        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testQueryChecksIfItemExistsWithinGivenTopKStructure(): void
    {
        $redis = $this->getClient();

        $redis->topkreserve('key', 50);
        $redis->topkadd('key', 'item1');

        $this->assertSame([1, 0], $redis->topkquery('key', 'item1', 'item2'));
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnNonExistingKey(): void
    {
        $redis = $this->getClient();

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('TopK: key does not exist');

        $redis->topkquery('key', 0, 1);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Redis\TopK\TOPKRESERVE_Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Redis\TopK;

use Predis\Command\Redis\PredisCommandTestCase;
use Predis\Response\ServerException;

/**
 * @group commands
 * @group realm-stack
 */
class TOPKRESERVE_Test extends PredisCommandTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getExpectedCommand(): string
    {
        return TOPKRESERVE::class;
    }

    /**
     * {@inheritDoc}
     */
    protected function getExpectedId(): string
    {
        return 'TOPKRESERVE';
    }

    /**
     * @group disconnected
     * @dataProvider argumentsProvider
     */
    public function testFilterArguments(array $actualArguments, array $expectedArguments): void
    {
        $command = $this->getCommand();
        $command->setArguments($actualArguments);

        $this->assertSameValues($expectedArguments, $command->getArguments());
    }

    /**
     * @group disconnected
     */
    public function testParseResponse(): void
    {
        $this->assertSame(1, $this->getCommand()->parseResponse(1));
    }

    /**
     * @group connected
     * @group relay-resp3
     * @dataProvider structureProvider
     * @param  array  $topKArguments
     * @param  string $key
     * @param  array  $expectedInfoResponse
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testReserveInitializeTopKStructureWithGivenConfiguration(
        array $topKArguments,
        string $key,
        array $expectedInfoResponse
    ): void {
        $redis = $this->getClient();

        $actualResponse = $redis->topkreserve(...$topKArguments);
        $actualInfoResponse = $redis->topkinfo($key);

        $this->assertEquals('OK', $actualResponse);
        $this->assertSameWithPrecision($expectedInfoResponse, $actualInfoResponse, 1);
    }

    /**
     * @group connected
     * @return void
     * @requiresRedisBfVersion >= 2.0.0
     */
    public function testThrowsExceptionOnAlreadyExistingKey(): void
    {
        $redis = $this->getClient();

        $redis->topkreserve('key', 50);

        $this->expectException(ServerException::class);
        $this->expectExceptionMessage('TopK: key already exists');

        $redis->topkreserve('key', 50);
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['key', 10],
                ['key', 10],
            ],
            'with non-default width' => [
                ['key', 10, 5],
                ['key', 10, 5, 7, 0.9],
            ],
            'with non-default depth' => [
                ['key', 10, 8, 9],
                ['key', 10, 8, 9, 0.9],
            ],
            'with non-default decay' => [
                ['key', 10, 8, 7, 0.8],
                ['key', 10, 8, 7, 0.8],
            ],
        ];
    }

    public function structureProvider(): array
    {
        return [
            'with default configuration' => [
                ['key', 50],
                'key',
                ['k' => 50, 'width' => 8, 'depth' => 7, 'decay' => '0.90000000000000002'],
            ],
            'with non-default width' => [
                ['key', 50, 9],
                'key',
                ['k' => 50, 'width' => 9, 'depth' => 7, 'decay' => '0.90000000000000002'],
            ],
            'with non-default depth' => [
                ['key', 50, 8, 9],
                'key',
                ['k' => 50, 'width' => 8, 'depth' => 9, 'decay' => '0.90000000000000002'],
            ],
            'with non-default decay' => [
                ['key', 50, 8, 7, 0.8],
                'key',
                ['k' => 50, 'width' => 8, 'depth' => 7, 'decay' => '0.80000000000000004'],
            ],
            'with all arguments non-default' => [
                ['key', 50, 9, 6, 0.8],
                'key',
                ['k' => 50, 'width' => 9, 'depth' => 6, 'decay' => '0.80000000000000004'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Strategy\SubcommandStrategyResolverTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy;

use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use Predis\Command\Strategy\ContainerCommands\Functions\LoadStrategy;

class SubcommandStrategyResolverTest extends TestCase
{
    /**
     * @group disconnected
     * @return void
     */
    public function testResolveCorrectStrategy(): void
    {
        $resolver = new SubcommandStrategyResolver();
        $expectedStrategy = new LoadStrategy();

        $this->assertEquals($expectedStrategy, $resolver->resolve('functions', 'load'));
    }

    /**
     * @group disconnected
     * @return void
     */
    public function testResolveCorrectlyResolvesStrategyWithGivenWordSeparator(): void
    {
        $resolver = new SubcommandStrategyResolver('_');
        $expectedStrategy = new LoadStrategy();

        $this->assertEquals($expectedStrategy, $resolver->resolve('functions_', 'load_'));
    }

    /**
     * @return void
     */
    public function testResolveThrowsExceptionOnNonExistingStrategy(): void
    {
        $resolver = new SubcommandStrategyResolver();

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Non-existing container command given');

        $resolver->resolve('foo', 'bar');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Strategy\ContainerCommands\Functions\DeleteStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use PredisTestCase;

class DeleteStrategyTest extends PredisTestCase
{
    /**
     * @var DeleteStrategy
     */
    private $strategy;

    protected function setUp(): void
    {
        $this->strategy = new DeleteStrategy();
    }

    public function testProcessArguments(): void
    {
        $this->assertSame(['arg1', 'arg2'], $this->strategy->processArguments(['arg1', 'arg2']));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Strategy\ContainerCommands\Functions\DumpStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use PredisTestCase;

class DumpStrategyTest extends PredisTestCase
{
    /**
     * @var DumpStrategy
     */
    private $strategy;

    protected function setUp(): void
    {
        $this->strategy = new DumpStrategy();
    }

    /**
     * @group disconnected
     * @return void
     */
    public function testProcessArguments(): void
    {
        $this->assertSame(['arg1', 'arg2'], $this->strategy->processArguments(['arg1', 'arg2']));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Strategy\ContainerCommands\Functions\FlushStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use PredisTestCase;

class FlushStrategyTest extends PredisTestCase
{
    /**
     * @var FlushStrategy
     */
    private $strategy;

    protected function setUp(): void
    {
        $this->strategy = new FlushStrategy();
    }

    /**
     * @dataProvider argumentsProvider
     * @group disconnected
     * @param  array $actualArguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testProcessArguments(array $actualArguments, array $expectedResponse): void
    {
        $this->assertSame($expectedResponse, $this->strategy->processArguments($actualArguments));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['FLUSH', null],
                ['FLUSH'],
            ],
            'with mode argument' => [
                ['FLUSH', 'sync'],
                ['FLUSH', 'SYNC'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Strategy\ContainerCommands\Functions\KillStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use PredisTestCase;

class KillStrategyTest extends PredisTestCase
{
    /**
     * @var KillStrategy
     */
    private $strategy;

    protected function setUp(): void
    {
        $this->strategy = new KillStrategy();
    }

    /**
     * @group disconnected
     * @return void
     */
    public function testProcessArguments(): void
    {
        $this->assertSame(['arg1', 'arg2'], $this->strategy->processArguments(['arg1', 'arg2']));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Strategy\ContainerCommands\Functions\ListStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use PredisTestCase;

class ListStrategyTest extends PredisTestCase
{
    /**
     * @var ListStrategy
     */
    private $strategy;

    protected function setUp(): void
    {
        $this->strategy = new ListStrategy();
    }

    /**
     * @dataProvider argumentsProvider
     * @group disconnected
     * @param  array $actualArguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testProcessArguments(array $actualArguments, array $expectedResponse): void
    {
        $this->assertSame($expectedResponse, $this->strategy->processArguments($actualArguments));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['LIST', null, false],
                ['LIST'],
            ],
            'with LIBRARYNAME modifier' => [
                ['LIST', 'libraryname', false],
                ['LIST', 'LIBRARYNAME', 'libraryname'],
            ],
            'with WITHCODE modifier' => [
                ['LIST', null, true],
                ['LIST', 'WITHCODE'],
            ],
            'with all arguments' => [
                ['LIST', 'libraryname', true],
                ['LIST', 'LIBRARYNAME', 'libraryname', 'WITHCODE'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Strategy\ContainerCommands\Functions\LoadStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use PredisTestCase;

class LoadStrategyTest extends PredisTestCase
{
    /**
     * @var LoadStrategy
     */
    private $strategy;

    protected function setUp(): void
    {
        $this->strategy = new LoadStrategy();
    }

    /**
     * @dataProvider argumentsProvider
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testProcessArgumentsReturnsCorrectArguments(
        array $actualArguments,
        array $expectedArguments
    ): void {
        $this->assertSame($expectedArguments, $this->strategy->processArguments($actualArguments));
    }

    public function argumentsProvider(): array
    {
        return [
            'with less then or equal 2 arguments' => [
                ['arg1', 'arg2'],
                ['arg1', 'arg2'],
            ],
            'with last argument equals true' => [
                ['arg1', 'arg2', true],
                ['arg1', 'REPLACE', 'arg2'],
            ],
            'with last argument equals false' => [
                ['arg1', 'arg2', false],
                ['arg1', 'arg2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Strategy\ContainerCommands\Functions\RestoreStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use PredisTestCase;

class RestoreStrategyTest extends PredisTestCase
{
    /**
     * @var RestoreStrategy
     */
    private $strategy;

    protected function setUp(): void
    {
        $this->strategy = new RestoreStrategy();
    }

    /**
     * @dataProvider argumentsProvider
     * @group disconnected
     * @param  array $actualArguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testProcessArguments(array $actualArguments, array $expectedResponse): void
    {
        $this->assertSame($expectedResponse, $this->strategy->processArguments($actualArguments));
    }

    public function argumentsProvider(): array
    {
        return [
            'with default arguments' => [
                ['RESTORE', 'value', null],
                ['RESTORE', 'value'],
            ],
            'with mode argument' => [
                ['RESTORE', 'value', 'append'],
                ['RESTORE', 'value', 'APPEND'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Strategy\ContainerCommands\Functions\StatsStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Strategy\ContainerCommands\Functions;

use PredisTestCase;

class StatsStrategyTest extends PredisTestCase
{
    /**
     * @var StatsStrategy
     */
    private $strategy;

    protected function setUp(): void
    {
        $this->strategy = new StatsStrategy();
    }

    /**
     * @group disconnected
     * @return void
     */
    public function testProcessArguments(): void
    {
        $this->assertSame(['arg1', 'arg2'], $this->strategy->processArguments(['arg1', 'arg2']));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\AggregateTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class AggregateTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        $this->testClass = new class extends RedisCommand {
            use Aggregate;

            public static $aggregateArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$aggregateArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @dataProvider unexpectedValuesProvider
     * @param  array $actualArguments
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(array $actualArguments): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Aggregate argument accepts only: min, max, sum values');

        $this->testClass->setArguments($actualArguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [2, ['argument1'], ['argument1']],
            'aggregate argument first and there is arguments after' => [
                0,
                ['sum', 'second argument', 'third argument'],
                ['AGGREGATE', 'SUM', 'second argument', 'third argument'],
            ],
            'aggregate argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', 'min'],
                ['first argument', 'second argument', 'AGGREGATE', 'MIN'],
            ],
            'aggregate argument not the first and not the last' => [
                1,
                ['first argument', 'max', 'third argument'],
                ['first argument', 'AGGREGATE', 'MAX', 'third argument'],
            ],
            'aggregate argument the only argument' => [
                0,
                ['sum'],
                ['AGGREGATE', 'SUM'],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'with non-string argument' => [[1]],
            'with non enum value' => [['wrong']],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\BitByteTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;

class BitByteTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        $this->testClass = new class extends RedisCommand {
            use BitByte;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(array $actualArguments, array $expectedArguments): void
    {
        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    public function argumentsProvider(): array
    {
        return [
            'with correct enum value' => [
                ['bit'],
                ['BIT'],
            ],
            'with incorrect enum value' => [
                ['value'],
                ['value'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\ByLexByScoreTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use Predis\Command\Traits\By\ByLexByScore;
use PredisTestCase;
use UnexpectedValueException;

class ByLexByScoreTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use ByLexByScore;

            public static $byLexByScoreArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$byLexByScoreArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @dataProvider unexpectedValuesProvider
     * @param  array $actualArguments
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(array $actualArguments): void
    {
        $this->testClass::$byLexByScoreArgumentPositionOffset = 0;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('By argument accepts only "bylex" and "byscore" values');

        $this->testClass->setArguments($actualArguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'by false argument' => [
                0,
                [false, 'second argument', 'third argument'],
                [false, 'second argument', 'third argument'],
            ],
            'by argument first and there is arguments after' => [
                0,
                ['bylex', 'second argument', 'third argument'],
                ['BYLEX', 'second argument', 'third argument'],
            ],
            'by argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', 'byscore'],
                ['first argument', 'second argument', 'BYSCORE'],
            ],
            'by argument not the first and not the last' => [
                1,
                ['first argument', 'byscore', 'third argument'],
                ['first argument', 'BYSCORE', 'third argument'],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'true argument' => [[true]],
            'string argument, not BYLEX/BYSCORE' => [['wrong argument']],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\CountTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class CountTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Count;

            public static $countArgumentPositionOffset = 2;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $arguments
     * @param  bool  $any
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, bool $any, array $arguments, array $expectedResponse): void
    {
        $this->testClass::$countArgumentPositionOffset = $offset;

        $this->testClass->setArguments($arguments, $any);

        $this->assertSameValues($expectedResponse, $this->testClass->getArguments());
    }

    public function testThrowsErrorOnWrongCountValue(): void
    {
        $this->testClass::$countArgumentPositionOffset = 0;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong count argument value or position offset');

        $this->testClass->setArguments([0]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with count argument' => [
                0,
                false,
                [2],
                ['COUNT', 2],
            ],
            'without count argument' => [
                2,
                false,
                ['argument1', 'argument2'],
                ['argument1', 'argument2'],
            ],
            'with count argument equal -1' => [
                0,
                false,
                [-1],
                [false],
            ],
            'with any modifier' => [
                0,
                true,
                [2],
                ['COUNT', 2, 'ANY'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\DbTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class DbTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use DB;

            public static $dbArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $arguments, array $expectedResponse): void
    {
        $this->testClass::$dbArgumentPositionOffset = $offset;

        $this->testClass->setArguments($arguments);

        $this->assertSame($expectedResponse, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsErrorOnUnexpectedValueGiven(): void
    {
        $this->testClass::$dbArgumentPositionOffset = 0;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('DB argument should be a valid numeric value');

        $this->testClass->setArguments(['wrong']);
    }

    public function argumentsProvider(): array
    {
        return [
            'with positive integer db argument' => [
                0,
                [1],
                ['DB', 1],
            ],
            'with wrong offset' => [
                1,
                [1],
                [1],
            ],
            'with negative integer db argument' => [
                1,
                ['argument1', -1],
                ['argument1'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\KeysTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class KeysTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Keys;

            public static $keysArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  bool  $withNumkeys
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(
        int $offset,
        bool $withNumkeys,
        array $actualArguments,
        array $expectedArguments
    ): void {
        $this->testClass::$keysArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments, $withNumkeys);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @dataProvider unexpectedValuesProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(int $offset, array $actualArguments): void
    {
        $this->testClass::$keysArgumentPositionOffset = $offset;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong keys argument type or position offset');

        $this->testClass->setArguments($actualArguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'keys argument first and there is arguments after' => [
                0,
                true,
                [['key1', 'key2'], 'second argument', 'third argument'],
                [2, 'key1', 'key2', 'second argument', 'third argument'],
            ],
            'keys argument last and there is arguments before' => [
                2,
                true,
                ['first argument', 'second argument', ['key1', 'key2']],
                ['first argument', 'second argument', 2, 'key1', 'key2'],
            ],
            'keys argument not the first and not the last' => [
                1,
                true,
                ['first argument', ['key1', 'key2'], 'third argument'],
                ['first argument', 2, 'key1', 'key2', 'third argument'],
            ],
            'keys argument the only argument' => [
                0,
                true,
                [['key1', 'key2']],
                [2, 'key1', 'key2'],
            ],
            'without numkeys modifier' => [
                0,
                false,
                [['key1', 'key2']],
                ['key1', 'key2'],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'keys argument not an array' => [
                0,
                ['key1'],
            ],
            'keys argument position offset higher then arguments quantity' => [
                2,
                [['key1', 'key2']],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\LeftRightTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class LeftRightTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        $this->testClass = new class extends RedisCommand {
            use LeftRight;

            public static $leftRightArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$leftRightArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @dataProvider unexpectedValuesProvider
     * @param  array $actualArguments
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(array $actualArguments): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Left/Right argument accepts only: left, right values');

        $this->testClass->setArguments($actualArguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [2, ['argument1'], ['argument1', 'LEFT']],
            'left/right argument first and there is arguments after' => [
                0,
                ['left', 'second argument', 'third argument'],
                ['LEFT', 'second argument', 'third argument'],
            ],
            'left/right argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', 'right'],
                ['first argument', 'second argument', 'RIGHT'],
            ],
            'left/right argument not the first and not the last' => [
                1,
                ['first argument', 'left', 'third argument'],
                ['first argument', 'LEFT', 'third argument'],
            ],
            'aggregate argument the only argument' => [
                0,
                ['right'],
                ['RIGHT'],
            ],
        ];
    }

    public function unexpectedValuesProvider(): array
    {
        return [
            'with non-string argument' => [[1]],
            'with non enum value' => [['wrong']],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\MinMaxModifierTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class MinMaxModifierTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use MinMaxModifier;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testResolveModifierModifyArrayCorrect(
        int $offset,
        array $actualArguments,
        array $expectedArguments
    ): void {
        $this->testClass->resolveModifier($offset, $actualArguments);
        $this->assertSame($expectedArguments, $actualArguments);
    }

    public function testThrowsExceptionOnWrongModifierValue(): void
    {
        $arguments = ['argument1', 'wrong modifier'];

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong type of modifier given');

        $this->testClass->resolveModifier(1, $arguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'with modifier' => [
                0,
                ['max'],
                ['MAX'],
            ],
            'without modifier' => [
                2,
                ['argument1', 'argument2'],
                ['argument1', 'argument2', 'MIN'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\ReplaceTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;

class ReplaceTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Replace;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(array $arguments, array $expectedResponse): void
    {
        $this->testClass->setArguments($arguments);

        $this->assertSame($expectedResponse, $this->testClass->getArguments());
    }

    public function argumentsProvider(): array
    {
        return [
            'with boolean - true' => [[true], ['REPLACE']],
            'with boolean - false' => [[false], []],
            'with non boolean' => [['string'], ['string']],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\RevTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class RevTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Rev;

            public static $revArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$revArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(): void
    {
        $this->testClass::$revArgumentPositionOffset = 0;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong rev argument type');

        $this->testClass->setArguments(['test']);
    }

    public function argumentsProvider(): array
    {
        return [
            'rev false argument' => [
                0,
                [false, 'second argument', 'third argument'],
                [false, 'second argument', 'third argument'],
            ],
            'rev argument first and there is arguments after' => [
                0,
                [true, 'second argument', 'third argument'],
                ['REV', 'second argument', 'third argument'],
            ],
            'rev argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', true],
                ['first argument', 'second argument', 'REV'],
            ],
            'rev argument not the first and not the last' => [
                1,
                ['first argument', true, 'third argument'],
                ['first argument', 'REV', 'third argument'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\StoredistTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class StoredistTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Storedist;

            public static $storeDistArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$storeDistArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(): void
    {
        $this->testClass::$storeDistArgumentPositionOffset = 0;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong STOREDIST argument type');

        $this->testClass->setArguments(['test']);
    }

    public function argumentsProvider(): array
    {
        return [
            'STOREDIST false argument' => [
                0,
                [false, 'second argument', 'third argument'],
                [false, 'second argument', 'third argument'],
            ],
            'STOREDIST argument first and there is arguments after' => [
                0,
                [true, 'second argument', 'third argument'],
                ['STOREDIST', 'second argument', 'third argument'],
            ],
            'STOREDIST argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', true],
                ['first argument', 'second argument', 'STOREDIST'],
            ],
            'STOREDIST argument not the first and not the last' => [
                1,
                ['first argument', true, 'third argument'],
                ['first argument', 'STOREDIST', 'third argument'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\TimeoutTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class TimeoutTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Timeout;

            public static $timeoutArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $arguments, array $expectedResponse): void
    {
        $this->testClass::$timeoutArgumentPositionOffset = $offset;

        $this->testClass->setArguments($arguments);

        $this->assertSameValues($expectedResponse, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong timeout argument value or position offset');

        $this->testClass->setArguments([0]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with TIMEOUT argument' => [
                0,
                [10],
                ['TIMEOUT', 10],
            ],
            'with wrong offset given' => [
                1,
                [],
                [],
            ],
            'with default value' => [
                0,
                [-1],
                [false],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\WeightsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class WeightsTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        $this->testClass = new class extends RedisCommand {
            use Weights;

            public static $weightsArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$weightsArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $actualArguments = [1];
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong weights argument type');

        $this->testClass->setArguments($actualArguments);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [2, ['argument1'], ['argument1']],
            'weights argument first and there is arguments after' => [
                0,
                [[1, 2], 'second argument', 'third argument'],
                ['WEIGHTS', 1, 2, 'second argument', 'third argument'],
            ],
            'weights argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', [1, 2]],
                ['first argument', 'second argument', 'WEIGHTS', 1, 2],
            ],
            'weights argument not the first and not the last' => [
                1,
                ['first argument', [1, 2], 'third argument'],
                ['first argument', 'WEIGHTS', 1, 2, 'third argument'],
            ],
            'weights argument the only argument' => [
                0,
                [[1, 2]],
                ['WEIGHTS', 1, 2],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\BloomFilters\BucketSizeTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class BucketSizeTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use BucketSize;

            public static $bucketSizeArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $arguments, array $expectedResponse): void
    {
        $this->testClass::$bucketSizeArgumentPositionOffset = $offset;

        $this->testClass->setArguments($arguments);

        $this->assertSameValues($expectedResponse, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsErrorOnUnexpectedValueGiven(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong bucket size argument value or position offset');

        $this->testClass->setArguments([-5]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [
                1,
                [],
                [],
            ],
            'with default argument' => [
                0,
                [-1],
                [false],
            ],
            'with non-default argument' => [
                0,
                [10],
                ['BUCKETSIZE', 10],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\BloomFilters\CapacityTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class CapacityTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Capacity;

            public static $capacityArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $arguments, array $expectedResponse): void
    {
        $this->testClass::$capacityArgumentPositionOffset = $offset;

        $this->testClass->setArguments($arguments);

        $this->assertSameValues($expectedResponse, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsErrorOnUnexpectedValueGiven(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong capacity argument value or position offset');

        $this->testClass->setArguments([-5]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [
                1,
                [],
                [],
            ],
            'with default argument' => [
                0,
                [-1],
                [false],
            ],
            'with non-default argument' => [
                0,
                [10],
                ['CAPACITY', 10],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\BloomFilters\ErrorTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class ErrorTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Error;

            public static $errorArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $arguments, array $expectedResponse): void
    {
        $this->testClass::$errorArgumentPositionOffset = $offset;

        $this->testClass->setArguments($arguments);

        $this->assertSameValues($expectedResponse, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsErrorOnUnexpectedValueGiven(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong error argument value or position offset');

        $this->testClass->setArguments([-5]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [
                1,
                [],
                [],
            ],
            'with default argument' => [
                0,
                [-1],
                [false],
            ],
            'with non-default argument' => [
                0,
                [0.01],
                ['ERROR', 0.01],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\BloomFilters\ExpansionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class ExpansionTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        $this->testClass = new class extends RedisCommand {
            use Expansion;

            public static $expansionArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$expansionArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong expansion argument value or position offset');

        $this->testClass->setArguments([-2]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [2, ['argument1'], ['argument1']],
            'with value equals -1' => [0, [-1], [false]],
            'with correct value' => [0, [1], ['EXPANSION', 1]],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\BloomFilters\ItemsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;

class ItemsTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Items;

            public static $itemsArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $arguments, array $expectedResponse): void
    {
        $this->testClass::$itemsArgumentPositionOffset = $offset;

        $this->testClass->setArguments($arguments);

        $this->assertSameValues($expectedResponse, $this->testClass->getArguments());
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [
                1,
                [],
                [],
            ],
            'with non-default argument' => [
                0,
                ['item1', 'item2'],
                ['ITEMS', 'item1', 'item2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\BloomFilters\MaxIterationsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class MaxIterationsTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use MaxIterations;

            public static $maxIterationsArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $arguments, array $expectedResponse): void
    {
        $this->testClass::$maxIterationsArgumentPositionOffset = $offset;

        $this->testClass->setArguments($arguments);

        $this->assertSameValues($expectedResponse, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsErrorOnUnexpectedValueGiven(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong max iterations argument value or position offset');

        $this->testClass->setArguments([-5]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [
                1,
                [],
                [],
            ],
            'with default argument' => [
                0,
                [-1],
                [false],
            ],
            'with non-default argument' => [
                0,
                [10],
                ['MAXITERATIONS', 10],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\BloomFilters\NoCreateTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\BloomFilters;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class NoCreateTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use NoCreate;

            public static $noCreateArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$noCreateArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(): void
    {
        $this->testClass::$noCreateArgumentPositionOffset = 0;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong NOCREATE argument type');

        $this->testClass->setArguments(['test']);
    }

    public function argumentsProvider(): array
    {
        return [
            'NOCREATE false argument' => [
                0,
                [false, 'second argument', 'third argument'],
                [false, 'second argument', 'third argument'],
            ],
            'NOCREATE argument first and there is arguments after' => [
                0,
                [true, 'second argument', 'third argument'],
                ['NOCREATE', 'second argument', 'third argument'],
            ],
            'NOCREATE argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', true],
                ['first argument', 'second argument', 'NOCREATE'],
            ],
            'NOCREATE argument not the first and not the last' => [
                1,
                ['first argument', true, 'third argument'],
                ['first argument', 'NOCREATE', 'third argument'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\By\ByArgumentTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\By;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;

class ByArgumentTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use ByArgument;

            public static $byArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$byArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [
                1,
                ['key'],
                ['key'],
            ],
            'with null value' => [
                0,
                [null],
                [null],
            ],
            'with any value' => [
                0,
                ['value'],
                ['BY', 'value'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\By\GeoByTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\By;

use InvalidArgumentException;
use Predis\Command\Argument\Geospatial\ByBox;
use Predis\Command\Argument\Geospatial\ByRadius;
use Predis\Command\Command as RedisCommand;
use PredisTestCase;

class GeoByTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use GeoBy;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(array $actualArguments, array $expectedArguments): void
    {
        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Invalid BY argument value given');

        $this->testClass->setArguments(['test']);
    }

    public function argumentsProvider(): array
    {
        return [
            'BYRADIUS argument' => [
                ['first argument', new ByRadius(1, 'km'), 'third argument'],
                ['first argument', 'BYRADIUS', 1, 'km', 'third argument'],
            ],
            'BYBOX argument' => [
                ['first argument', new ByBox(1, 1, 'km'), 'third argument'],
                ['first argument', 'BYBOX', 1, 1, 'km', 'third argument'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\From\GeoFromTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\From;

use InvalidArgumentException;
use Predis\Command\Argument\Geospatial\FromLonLat;
use Predis\Command\Argument\Geospatial\FromMember;
use Predis\Command\Command as RedisCommand;
use PredisTestCase;

class GeoFromTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use GeoFrom;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(array $actualArguments, array $expectedArguments): void
    {
        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Invalid FROM argument value given');

        $this->testClass->setArguments(['test']);
    }

    public function argumentsProvider(): array
    {
        return [
            'FROMLONLAT argument' => [
                ['first argument', new FromLonLat(1.1, 2.2), 'third argument'],
                ['first argument', 'FROMLONLAT', 1.1, 2.2, 'third argument'],
            ],
            'FROMMEMBER argument' => [
                ['first argument', new FromMember('member1'), 'third argument'],
                ['first argument', 'FROMMEMBER', 'member1', 'third argument'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\Get\GetTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Get;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class GetTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Get;

            public static $getArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$getArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong get argument type');

        $this->testClass->setArguments(['wrong']);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [
                1,
                ['value'],
                ['value'],
            ],
            'with single value' => [
                0,
                [['value']],
                ['GET', 'value'],
            ],
            'with multiple values' => [
                0,
                [['value1', 'value2']],
                ['GET', 'value1', 'GET', 'value2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\Json\IndentTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Json;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class IndentTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        $this->testClass = new class extends RedisCommand {
            use Indent;

            public static $indentArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(
        int $offset,
        array $actualArguments,
        array $expectedResponse
    ): void {
        $this->testClass::$indentArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedResponse, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Indent argument value should be a string');

        $this->testClass->setArguments([1]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [
                2,
                ['argument1'],
                ['argument1'],
            ],
            'with default value' => [
                0,
                [''],
                [false],
            ],
            'with correct argument' => [
                0,
                ['\t'],
                ['INDENT', '\t'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\Json\NewlineTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Json;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class NewlineTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        $this->testClass = new class extends RedisCommand {
            use Newline;

            public static $newlineArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(
        int $offset,
        array $actualArguments,
        array $expectedResponse
    ): void {
        $this->testClass::$newlineArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedResponse, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Newline argument value should be a string');

        $this->testClass->setArguments([1]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [
                2,
                ['argument1'],
                ['argument1'],
            ],
            'with default value' => [
                0,
                [''],
                [false],
            ],
            'with correct argument' => [
                0,
                ['\n'],
                ['NEWLINE', '\n'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\Json\NxXxArgumentTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Json;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class NxXxArgumentTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        $this->testClass = new class extends RedisCommand {
            use NxXxArgument;

            public static $nxXxArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(
        int $offset,
        array $actualArguments,
        array $expectedResponse
    ): void {
        $this->testClass::$nxXxArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedResponse, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Argument accepts only: nx, xx values');

        $this->testClass->setArguments(['wrong']);
    }

    public function argumentsProvider(): array
    {
        return [
            'with correct argument - NX' => [
                0,
                ['nx'],
                ['NX'],
            ],
            'with correct argument - XX' => [
                0,
                ['xx'],
                ['XX'],
            ],
            'with wrong offset' => [
                2,
                ['argument1'],
                ['argument1'],
            ],
            'with null argument' => [
                0,
                [null],
                [false],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\Json\SpaceTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Json;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class SpaceTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        $this->testClass = new class extends RedisCommand {
            use Space;

            public static $spaceArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(
        int $offset,
        array $actualArguments,
        array $expectedResponse
    ): void {
        $this->testClass::$spaceArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedResponse, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValueGiven(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Space argument value should be a string');

        $this->testClass->setArguments([1]);
    }

    public function argumentsProvider(): array
    {
        return [
            'with wrong offset' => [
                2,
                ['argument1'],
                ['argument1'],
            ],
            'with default value' => [
                0,
                [''],
                [false],
            ],
            'with correct argument' => [
                0,
                [' '],
                ['SPACE', ' '],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\Limit\LimitObjectTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Limit;

use Predis\Command\Argument\Server\LimitOffsetCount;
use Predis\Command\Command as RedisCommand;
use PredisTestCase;

class LimitObjectTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use LimitObject;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(array $actualArguments, array $expectedArguments): void
    {
        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    public function argumentsProvider(): array
    {
        return [
            'with non-existing LimitInterface' => [
                ['value'],
                ['value'],
            ],
            'with existing LimitInterface' => [
                [new LimitOffsetCount(0, 1)],
                ['LIMIT', 0, 1],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\Limit\LimitTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\Limit;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class LimitTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use Limit;

            public static $limitArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$limitArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(): void
    {
        $this->testClass::$limitArgumentPositionOffset = 0;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong limit argument type');

        $this->testClass->setArguments(['test']);
    }

    public function argumentsProvider(): array
    {
        return [
            'limit false argument first and there is arguments after' => [
                0,
                [false, 'second argument', 'third argument'],
                [],
            ],
            'limit false argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', false],
                ['first argument', 'second argument'],
            ],
            'limit false argument not the first and not the last' => [
                1,
                ['first argument', false, 'third argument'],
                ['first argument'],
            ],
            'limit argument first and there is arguments after' => [
                0,
                [true, 'second argument', 'third argument'],
                ['LIMIT', 'second argument', 'third argument'],
            ],
            'limit argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', true],
                ['first argument', 'second argument', 'LIMIT'],
            ],
            'limit argument not the first and not the last' => [
                1,
                ['first argument', true, 'third argument'],
                ['first argument', 'LIMIT', 'third argument'],
            ],
            'limit argument is integer' => [
                0,
                [1],
                ['LIMIT', 1],
            ],
            'limit argument with wrong offset' => [
                2,
                [1],
                [1],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\To\ServerToTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\To;

use Predis\Command\Argument\Server\To;
use Predis\Command\Command as RedisCommand;
use PredisTestCase;

class ServerToTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use ServerTo;

            public static $toArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $arguments
     * @param  array $expectedResponse
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $arguments, array $expectedResponse): void
    {
        $this->testClass::$toArgumentPositionOffset = $offset;

        $this->testClass->setArguments($arguments);

        $this->assertSameValues($expectedResponse, $this->testClass->getArguments());
    }

    public function argumentsProvider(): array
    {
        return [
            'with TO argument - no FORCE' => [
                0,
                [new To('host', 9999)],
                ['TO', 'host', 9999],
            ],
            'with TO argument - with FORCE' => [
                0,
                [new To('host', 9999, true)],
                ['TO', 'host', 9999, 'FORCE'],
            ],
            'with wrong offset given' => [
                1,
                [],
                [],
            ],
            'with default value' => [
                0,
                [null],
                [false],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\With\WithCoordTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\With;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class WithCoordTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use WithCoord;

            public static $withCoordArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$withCoordArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(): void
    {
        $this->testClass::$withCoordArgumentPositionOffset = 0;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong WITHCOORD argument type');

        $this->testClass->setArguments(['test']);
    }

    public function argumentsProvider(): array
    {
        return [
            'WITHCOORD false argument' => [
                0,
                [false, 'second argument', 'third argument'],
                [false, 'second argument', 'third argument'],
            ],
            'WITHCOORD argument first and there is arguments after' => [
                0,
                [true, 'second argument', 'third argument'],
                ['WITHCOORD', 'second argument', 'third argument'],
            ],
            'WITHCOORD argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', true],
                ['first argument', 'second argument', 'WITHCOORD'],
            ],
            'WITHCOORD argument not the first and not the last' => [
                1,
                ['first argument', true, 'third argument'],
                ['first argument', 'WITHCOORD', 'third argument'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\With\WithDistTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\With;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class WithDistTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use WithDist;

            public static $withDistArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$withDistArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(): void
    {
        $this->testClass::$withDistArgumentPositionOffset = 0;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong WITHDIST argument type');

        $this->testClass->setArguments(['test']);
    }

    public function argumentsProvider(): array
    {
        return [
            'WITHDIST false argument' => [
                0,
                [false, 'second argument', 'third argument'],
                [false, 'second argument', 'third argument'],
            ],
            'WITHDIST argument first and there is arguments after' => [
                0,
                [true, 'second argument', 'third argument'],
                ['WITHDIST', 'second argument', 'third argument'],
            ],
            'WITHDIST argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', true],
                ['first argument', 'second argument', 'WITHDIST'],
            ],
            'WITHDIST argument not the first and not the last' => [
                1,
                ['first argument', true, 'third argument'],
                ['first argument', 'WITHDIST', 'third argument'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\With\WithHashTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\With;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;
use UnexpectedValueException;

class WithHashTest extends PredisTestCase
{
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use WithHash;

            public static $withHashArgumentPositionOffset = 0;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider argumentsProvider
     * @param  int   $offset
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(int $offset, array $actualArguments, array $expectedArguments): void
    {
        $this->testClass::$withHashArgumentPositionOffset = $offset;

        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @return void
     */
    public function testThrowsExceptionOnUnexpectedValue(): void
    {
        $this->testClass::$withHashArgumentPositionOffset = 0;

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Wrong WITHHASH argument type');

        $this->testClass->setArguments(['test']);
    }

    public function argumentsProvider(): array
    {
        return [
            'WITHHASH false argument' => [
                0,
                [false, 'second argument', 'third argument'],
                [false, 'second argument', 'third argument'],
            ],
            'WITHHASH argument first and there is arguments after' => [
                0,
                [true, 'second argument', 'third argument'],
                ['WITHHASH', 'second argument', 'third argument'],
            ],
            'WITHHASH argument last and there is arguments before' => [
                2,
                ['first argument', 'second argument', true],
                ['first argument', 'second argument', 'WITHHASH'],
            ],
            'WITHHASH argument not the first and not the last' => [
                1,
                ['first argument', true, 'third argument'],
                ['first argument', 'WITHHASH', 'third argument'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Command\Traits\With\WithScoresTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Command\Traits\With;

use Predis\Command\Command as RedisCommand;
use PredisTestCase;

class WithScoresTest extends PredisTestCase
{
    /**
     * @var RedisCommand
     */
    private $testClass;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testClass = new class extends RedisCommand {
            use WithScores;

            public function getId()
            {
                return 'test';
            }
        };
    }

    /**
     * @dataProvider valuesProvider
     * @param  array $actualArguments
     * @param  array $expectedArguments
     * @return void
     */
    public function testReturnsCorrectArguments(array $actualArguments, array $expectedArguments): void
    {
        $this->testClass->setArguments($actualArguments);

        $this->assertSame($expectedArguments, $this->testClass->getArguments());
    }

    /**
     * @dataProvider dataProvider
     * @param  array $actualData
     * @param  array $expectedResponse
     * @return void
     */
    public function testParseDataReturnsCorrectResponse(array $actualData, array $expectedResponse): void
    {
        $this->testClass->setArguments($actualData);

        $arguments = $this->testClass->getArguments();

        $this->assertSame($expectedResponse, $this->testClass->parseResponse($arguments));
    }

    public function valuesProvider(): array
    {
        return [
            'with last argument boolean - true' => [['test', 'test1', true], ['test', 'test1', 'WITHSCORES']],
            'with last argument boolean - false' => [['test', 'test1', false], ['test', 'test1']],
            'with last argument non boolean' => [['test', 'test1', 1], ['test', 'test1', 1]],
        ];
    }

    public function dataProvider(): array
    {
        return [
            'with empty arguments' => [[], [null]],
            'without modifier' => [['member1', '1', 'member2', '2'], ['member1', '1', 'member2', '2']],
            'with wrong modifier' => [
                ['member1', '1', 'member2', '2', 'WITHSCOREE'],
                ['member1', '1', 'member2', '2', 'WITHSCOREE'],
            ],
            'with modifier' => [
                ['member1', '1', 'member2', '2', 'WITHSCORES'],
                ['member1' => '1', 'member2' => '2'],
            ],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Configuration\OptionsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration;

use Exception;
use PredisTestCase;
use stdClass;

/**
 * @todo Use mock objects to test the inner workings of the Options class.
 */
class OptionsTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testConstructorWithoutArguments(): void
    {
        $options = new Options();

        $this->assertTrue($options->exceptions);
        $this->assertNull($options->prefix);
        $this->assertNull($options->aggregate);
        $this->assertInstanceOf('Closure', $options->cluster);
        $this->assertInstanceOf('Closure', $options->replication);
        $this->assertInstanceOf('Predis\Command\FactoryInterface', $options->commands);
        $this->assertInstanceOf('Predis\Connection\FactoryInterface', $options->connections);
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithArrayArgument(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->any())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn($connection);

        $options = new Options([
            'exceptions' => false,
            'prefix' => 'prefix:',
            'commands' => $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock(),
            'connections' => $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock(),
            'cluster' => $callable,
            'replication' => $callable,
            'aggregate' => $callable,
        ]);

        $this->assertIsBool($options->exceptions);
        $this->assertInstanceOf('Predis\Command\Processor\ProcessorInterface', $options->prefix);
        $this->assertInstanceOf('Predis\Command\FactoryInterface', $options->commands);
        $this->assertInstanceOf('Predis\Connection\FactoryInterface', $options->connections);

        $this->assertInstanceOf('Closure', $initializer = $options->aggregate);
        $this->assertSame($connection, $initializer($options, []));

        $this->assertInstanceOf('Closure', $initializer = $options->cluster);
        $this->assertSame($connection, $initializer($options, []));

        $this->assertInstanceOf('Closure', $initializer = $options->replication);
        $this->assertSame($connection, $initializer($options, []));
    }

    /**
     * @group disconnected
     */
    public function testSupportsCustomOptions(): void
    {
        $options = new Options([
            'custom' => 'foobar',
        ]);

        $this->assertSame('foobar', $options->custom);
    }

    /**
     * @group disconnected
     */
    public function testUndefinedOptionsReturnNull(): void
    {
        $options = new Options();

        $this->assertFalse($options->defined('unknown'));
        $this->assertFalse(isset($options->unknown));
        $this->assertNull($options->unknown);
    }

    /**
     * @group disconnected
     */
    public function testCanCheckOptionsIfDefinedByUser(): void
    {
        $options = new Options([
            'prefix' => 'prefix:',
            'custom' => 'foobar',
            'void' => null,
        ]);

        $this->assertTrue($options->defined('prefix'));
        $this->assertTrue($options->defined('custom'));
        $this->assertTrue($options->defined('void'));
        $this->assertFalse($options->defined('commands'));
    }

    /**
     * @group disconnected
     */
    public function testIsSetReplicatesPHPBehavior(): void
    {
        $options = new Options([
            'prefix' => 'prefix:',
            'custom' => 'foobar',
            'void' => null,
        ]);

        $this->assertTrue(isset($options->prefix));
        $this->assertTrue(isset($options->custom));
        $this->assertFalse(isset($options->void));
        $this->assertFalse(isset($options->commands));
    }

    /**
     * @group disconnected
     */
    public function testReturnsDefaultValueOfSpecifiedOption(): void
    {
        $options = new Options();

        $this->assertInstanceOf('Predis\Command\FactoryInterface', $options->getDefault('commands'));
    }

    /**
     * @group disconnected
     */
    public function testReturnsNullAsDefaultValueForUndefinedOption(): void
    {
        $options = new Options();

        $this->assertNull($options->getDefault('unknown'));
    }

    /**
     * @group disconnected
     */
    public function testLazilyInitializesOptionValueUsingObjectWithInvokeMagicMethod(): void
    {
        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();

        // NOTE: closure values are covered by this test since they define __invoke().
        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn($commands);

        $options = new Options([
            'commands' => $callable,
        ]);

        $this->assertSame($commands, $options->commands);
        $this->assertSame($commands, $options->commands);
    }

    /**
     * @group disconnected
     */
    public function testLazilyInitializesCustomOptionValueUsingObjectWithInvokeMagicMethod(): void
    {
        $custom = new stdClass();

        // NOTE: closure values are covered by this test since they define __invoke().
        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn($custom);

        $options = new Options([
            'custom' => $callable,
        ]);

        $this->assertSame($custom, $options->custom);
        $this->assertSame($custom, $options->custom);
    }

    /**
     * @group disconnected
     */
    public function testChecksForInvokeMagicMethodDoesNotTriggerAutoloader(): void
    {
        $trigger = $this->getMockBuilder('stdClass')
            ->addMethods(['autoload'])
            ->getMock();
        $trigger
            ->expects($this->never())
            ->method('autoload');

        spl_autoload_register($autoload = function ($class) use ($trigger) {
            $trigger->autoload($class);
        }, true, false);

        try {
            $options = new Options(['custom' => 'value']);
            $pfx = $options->prefix;
        } catch (Exception $_) {
            spl_autoload_unregister($autoload);
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Configuration\Option\AggregateTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Configuration\OptionsInterface;
use PredisTestCase;

class AggregateTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testDefaultOptionValue(): void
    {
        $option = new Aggregate();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertNull($option->getDefault($options));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCallableAsConnectionInitializer(): void
    {
        $option = new Aggregate();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperDoesNotTriggerAggregationByDefault(): void
    {
        $option = new Aggregate();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->never())
            ->method('__get')
            ->with('connections');

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('add');

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperDoesNotTriggerAggregationWhenSecondArgumentIsFalse(): void
    {
        $option = new Aggregate();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->never())
            ->method('__get')
            ->with('connections');

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('add');

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, false));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperTriggersAggregationWhenSecondArgumentIsTrue(): void
    {
        $option = new Aggregate();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->exactly(2))
            ->method('create')
            ->withConsecutive(
                [$parameters[0]],
                [$parameters[1]]
            )
            ->willReturnOnConsecutiveCalls(
                $nodeConnection1 = $this->getMockConnection($parameters[0]),
                $nodeConnection2 = $this->getMockConnection($parameters[1])
            );

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->once())
            ->method('__get')
            ->with('connections')
            ->willReturn($factory);

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')
            ->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('add')
            ->withConsecutive(
                [$nodeConnection1],
                [$nodeConnection2]
            );

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, true));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperDoesNotTriggerAggregationWhenFirstArgumentIsEmptyAndSecondArgumentIsTrue(): void
    {
        $option = new Aggregate();
        $parameters = [];

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->never())
            ->method('__get')
            ->with('connections');

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('add');

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, true));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidReturnTypeOfConnectionInitializer(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessageMatches(
            '/^Predis\\\Configuration\\\Option\\\Aggregate expects the supplied callable to return an instance of Predis\\\Connection\\\AggregateConnectionInterface, but .* was returned$/'
        );

        $option = new Aggregate();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));

        $initializer($parameters);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInstanceOfAggregateConnectionInterface(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Predis\Configuration\Option\Aggregate expects a callable object acting as an aggregate connection initializer');

        $option = new Aggregate();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();

        $option->filter($options, $connection);
    }

    /**
     * @group disconnected
     */
    public function ___AggregateConnectionSkipCreationOnConnectionInstance(): void
    {
        [, $connectionClass] = $this->getMockConnectionClass();

        /** @var ClusterInterface|MockObject */
        $cluster = $this->getMockBuilder('Predis\Connection\Cluster\ClusterInterface')->getMock();
        $cluster
            ->expects($this->exactly(2))
            ->method('add')
            ->with($this->isInstanceOf('Predis\Connection\NodeConnectionInterface'));

        /** @var Factory|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\Factory')
        ->onlyMethods(['create'])
        ->getMock();
        $factory
            ->expects($this->never())
            ->method('create');

        $factory->aggregate($cluster, [new $connectionClass(), new $connectionClass()]);
    }

    /**
     * @group disconnected
     */
    public function ___AggregateConnectionWithMixedParameters(): void
    {
        [, $connectionClass] = $this->getMockConnectionClass();

        /** @var ClusterInterface|MockObject */
        $cluster = $this->getMockBuilder('Predis\Connection\Cluster\ClusterInterface')->getMock();
        $cluster
            ->expects($this->exactly(4))
            ->method('add')
            ->with($this->isInstanceOf('Predis\Connection\NodeConnectionInterface'));

        /** @var Factory|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\Factory')
        ->onlyMethods(['create'])
        ->getMock();
        $factory
            ->expects($this->exactly(3))
            ->method('create')
            ->willReturnCallback(function () use ($connectionClass) {
                return new $connectionClass();
            });

        $factory->aggregate($cluster, [null, 'tcp://127.0.0.1', ['scheme' => 'tcp'], new $connectionClass()]);
    }

    /**
     * @group disconnected
     */
    public function ___AggregateConnectionWithEmptyListOfParameters(): void
    {
        /** @var ClusterInterface|MockObject */
        $cluster = $this->getMockBuilder('Predis\Connection\Cluster\ClusterInterface')->getMock();
        $cluster
            ->expects($this->never())
            ->method('add');

        /** @var Factory|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\Factory')
        ->onlyMethods(['create'])
        ->getMock();
        $factory
            ->expects($this->never())
            ->method('create');

        $factory->aggregate($cluster, []);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Configuration\Option\ClusterTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Configuration\OptionsInterface;
use PredisTestCase;

class ClusterTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testDefaultOptionValue(): void
    {
        $option = new Cluster();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertInstanceOf('closure', $initializer = $option->getDefault($options));
        $this->assertInstanceOf('Predis\Connection\Cluster\PredisCluster', $initializer($parameters = []));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCallableAsConnectionInitializer(): void
    {
        $option = new Cluster();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperTriggersAggregationByDefault(): void
    {
        $option = new Cluster();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->exactly(2))
            ->method('create')
            ->withConsecutive(
                [$parameters[0]],
                [$parameters[1]]
            )
            ->willReturnOnConsecutiveCalls(
                $nodeConnection1 = $this->getMockConnection($parameters[0]),
                $nodeConnection2 = $this->getMockConnection($parameters[1])
            );

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->once())
            ->method('__get')
            ->with('connections')
            ->willReturn($factory);

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('add')
            ->withConsecutive(
                [$nodeConnection1],
                [$nodeConnection2]
            );

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, true));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperDoesNotTriggerAggregationWhenSecondArgumentIsFalse(): void
    {
        $option = new Cluster();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->never())
            ->method('__get')
            ->with('connections');

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('add');

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, false));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperTriggersAggregationWhenSecondArgumentIsTrue(): void
    {
        $option = new Cluster();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->exactly(2))
            ->method('create')
            ->withConsecutive(
                [$parameters[0]],
                [$parameters[1]]
            )
            ->willReturnOnConsecutiveCalls(
                $nodeConnection1 = $this->getMockConnection($parameters[0]),
                $nodeConnection2 = $this->getMockConnection($parameters[1])
            );

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->once())
            ->method('__get')
            ->with('connections')
            ->willReturn($factory);

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('add')
            ->withConsecutive(
                [$nodeConnection1],
                [$nodeConnection2]
            );

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, true));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperDoesNotTriggerAggregationWhenFirstArgumentIsEmptyAndSecondArgumentIsTrue(): void
    {
        $option = new Cluster();
        $parameters = [];

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->never())
            ->method('__get')
            ->with('connections');

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('add');

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, true));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidReturnTypeOfConnectionInitializer(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessageMatches(
            '/^Predis\\\Configuration\\\Option\\\Cluster expects the supplied callable to return an instance of Predis\\\Connection\\\AggregateConnectionInterface, but .* was returned$/'
        );

        $option = new Cluster();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));

        $initializer($parameters);
    }

    /**
     * @group disconnected
     */
    public function testAcceptsShortNameStringPredis(): void
    {
        $option = new Cluster();

        /** @var OptionsInterface|MockObject */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->never())
            ->method('__get')
            ->with('connections');

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, 'predis'));
        $this->assertInstanceOf('Predis\Connection\Cluster\PredisCluster', $initializer($parameters = []));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsShortNameStringRedis(): void
    {
        $option = new Cluster();

        /** @var OptionsInterface|MockObject */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $options
            ->expects($this->exactly(2))
            ->method('__get')
            ->withConsecutive(
                ['connections'],
                ['crc16']
            )
            ->willReturnOnConsecutiveCalls(
                $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock(),
                $this->getMockBuilder('Predis\Cluster\Hash\HashGeneratorInterface')->getMock()
            );

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, 'redis'));
        $this->assertInstanceOf('Predis\Connection\Cluster\RedisCluster', $initializer($parameters = []));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsShortNameStringRedisCluster(): void
    {
        $option = new Cluster();

        /** @var OptionsInterface|MockObject */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $options
            ->expects($this->exactly(2))
            ->method('__get')
            ->withConsecutive(
                ['connections'],
                ['crc16']
            )
            ->willReturnOnConsecutiveCalls(
                $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock(),
                $this->getMockBuilder('Predis\Cluster\Hash\HashGeneratorInterface')->getMock()
            );

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, 'redis-cluster'));
        $this->assertInstanceOf('Predis\Connection\Cluster\RedisCluster', $initializer($parameters = []));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidShortNameString(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage(
            'Predis\Configuration\Option\Cluster expects either `predis`, `redis` or `redis-cluster` as valid string values, `unknown` given'
        );

        $option = new Cluster();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $option->filter($options, 'unknown');
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInstanceOfClusterInterface(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessageMatches(
            '/Predis\\\Configuration\\\Option\\\Cluster expects either a string or a callable value, .* given/'
        );

        $option = new Cluster();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $connection = $this->getMockBuilder('Predis\Connection\Cluster\ClusterInterface')->getMock();

        $option->filter($options, $connection);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Configuration\Option\CommandsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\Processor\KeyPrefixProcessor;
use Predis\Command\RedisFactory;
use Predis\Configuration\OptionsInterface;
use PredisTestCase;
use stdClass;

class CommandsTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testDefaultOptionValue(): void
    {
        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $commands = $option->getDefault($options);

        $this->assertInstanceOf('Predis\Command\FactoryInterface', $commands);
        $this->assertNull($commands->getProcessor());
    }

    /**
     * @group disconnected
     */
    public function testAppliesPrefixOnDefaultOptionValue(): void
    {
        $option = new Commands();

        /** @var OptionsInterface|MockObject */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->once())
            ->method('__isset')
            ->with('prefix')
            ->willReturn(true);
        $options
            ->expects($this->once())
            ->method('__get')
            ->with('prefix')
            ->willReturn(
                new KeyPrefixProcessor('prefix:')
            );

        $commands = $option->getDefault($options);

        $this->assertInstanceOf('Predis\Command\FactoryInterface', $commands);
        $this->assertInstanceOf('Predis\Command\Processor\KeyPrefixProcessor', $commands->getProcessor());
        $this->assertSame('prefix:', $commands->getProcessor()->getPrefix());
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCommandFactoryInstanceAsValue(): void
    {
        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $input = new RedisFactory();

        $commands = $option->filter($options, $input);

        $this->assertSame($commands, $input);
        $this->assertNull($commands->getProcessor());
    }

    /**
     * @group disconnected
     */
    public function testAcceptsDictionaryOfCommandsAsValue(): void
    {
        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $input = [
            'FOO' => 'Predis\Command\RawCommand',
            'BAR' => 'Predis\Command\RawCommand',
        ];

        $commands = $option->filter($options, $input);

        $this->assertInstanceOf('Predis\Command\FactoryInterface', $commands);
        $this->assertSame('Predis\Command\RawCommand', $commands->getCommandClass('FOO'));
        $this->assertSame('Predis\Command\RawCommand', $commands->getCommandClass('BAR'));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsDictionaryOfCommandsWithNullsToUndefineCommandsAsValue(): void
    {
        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $input = [
            'ECHO' => null,
            'EVAL' => null,
            'FOO' => null,
        ];

        $commands = $option->filter($options, $input);

        $this->assertInstanceOf('Predis\Command\FactoryInterface', $commands);
        $this->assertNull($commands->getCommandClass('ECHO'));
        $this->assertNull($commands->getCommandClass('EVAL'));
        $this->assertNull($commands->getCommandClass('FOO'));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCallableReturningCommandFactoryInstance(): void
    {
        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn($commands);

        $this->assertSame($commands, $option->filter($options, $callable));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCallableReturningDictionaryOfCommandsAsValue(): void
    {
        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $dictionary = [
            'FOO' => 'Predis\Command\RawCommand',
            'BAR' => 'Predis\Command\RawCommand',
        ];

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn($dictionary);

        $commands = $option->filter($options, $callable);

        $this->assertInstanceOf('Predis\Command\FactoryInterface', $commands);
        $this->assertSame('Predis\Command\RawCommand', $commands->getCommandClass('FOO'));
        $this->assertSame('Predis\Command\RawCommand', $commands->getCommandClass('BAR'));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsStringPredisAsValue(): void
    {
        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $commands = $option->filter($options, 'predis');

        $this->assertInstanceOf('Predis\Command\FactoryInterface', $commands);
        $this->assertInstanceOf('Predis\Command\RedisFactory', $commands);
    }

    /**
     * @group disconnected
     */
    public function testAcceptsStringRawAsValue(): void
    {
        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $commands = $option->filter($options, 'raw');

        $this->assertInstanceOf('Predis\Command\FactoryInterface', $commands);
        $this->assertInstanceOf('Predis\Command\RawFactory', $commands);
    }

    /**
     * @group disconnected
     */
    public function testAcceptsStringDefaultAsValue(): void
    {
        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $commands = $option->filter($options, 'default');

        $this->assertInstanceOf('Predis\Command\FactoryInterface', $commands);
        $this->assertInstanceOf('Predis\Command\RedisFactory', $commands);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidStringAsValue(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Predis\Configuration\Option\Commands does not recognize `unknown` as a supported configuration string');

        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $option->filter($options, 'unknown');
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidTypeReturnedByCallable(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Predis\Configuration\Option\Commands expects a valid command factory');

        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn(
                new stdClass()
            );

        $option->filter($options, $callable);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidValue(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Predis\Configuration\Option\Commands expects a valid command factory');

        $option = new Commands();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $option->filter($options, new stdClass());
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnPrefixWithRawFactory(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Predis\Command\RawFactory does not support key prefixing');

        $option = new Commands();

        /** @var OptionsInterface|MockObject */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->once())
            ->method('__isset')
            ->with('prefix')
            ->willReturn(true);

        $option->filter($options, 'raw');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Configuration\Option\ConnectionsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use Predis\Configuration\OptionsInterface;
use PredisTestCase;
use stdClass;

class ConnectionsTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testDefaultOptionValue(): void
    {
        $option = new Connections();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertInstanceOf('Predis\Connection\Factory', $option->getDefault($options));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsNamedArrayWithSchemeToConnectionClassMappings(): void
    {
        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $class = get_class($this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock());
        $value = ['tcp' => $class, 'redis' => $class];

        $default = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $default
            ->expects($this->exactly(2))
            ->method('define')
            ->with($this->matchesRegularExpression('/^tcp|redis$/'), $class);

        /** @var \Predis\Configuration\OptionInterface */
        $option = $this->getMockBuilder('Predis\Configuration\Option\Connections')
            ->onlyMethods(['getDefault'])
            ->getMock();
        $option
            ->expects($this->once())
            ->method('getDefault')
            ->with($options)
            ->willReturn($default);

        $this->assertInstanceOf('Predis\Connection\FactoryInterface', $factory = $option->filter($options, $value));
        $this->assertSame($default, $factory);
    }

    /**
     * @group disconnected
     * @dataProvider provideSupportedStringValuesForOption
     */
    public function testAcceptsStringToConfigureRelayBackend($value, $classFQCN)
    {
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $default = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $default
            ->expects($this->exactly(3))
            ->method('define')
            ->with($this->matchesRegularExpression('/^tcp|unix|redis$/'), $classFQCN);

        $option = $this->getMockBuilder('Predis\Configuration\Option\Connections')
        ->setMethods(['getDefault'])
        ->getMock();
        $option
            ->expects($this->once())
            ->method('getDefault')
            ->with($options)
            ->will($this->returnValue($default));

        $factory = $option->filter($options, $value);

        $this->assertInstanceOf('Predis\Connection\FactoryInterface', $factory);
        $this->assertSame($default, $factory);
    }

    /**
     * @group disconnected
     */
    public function testAcceptsStringDefaultToReturnConnectionFactoryWithDefaultConfiguration()
    {
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $default = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $default
            ->expects($this->never())
            ->method('define');

        $option = $this->getMockBuilder('Predis\Configuration\Option\Connections')
        ->setMethods(['getDefault'])
        ->getMock();
        $option
            ->expects($this->once())
            ->method('getDefault')
            ->with($options)
            ->will($this->returnValue($default));

        $factory = $option->filter($options, 'default');

        $this->assertInstanceOf('Predis\Connection\FactoryInterface', $factory);
        $this->assertSame($default, $factory);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnNotSupportedStringValue()
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessageMatches('/^.* does not recognize `unsupported` as a supported configuration string$/');

        $option = new Connections();
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $option->filter($options, 'unsupported');
    }

    /**
     * @group disconnected
     */
    public function testUsesParametersOptionToSetDefaultParameters(): void
    {
        $parameters = ['database' => 5, 'password' => 'mypassword'];

        /** @var OptionsInterface|\PHPUnit\Framework\MockObject\MockObject\MockObject */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->once())
            ->method('defined')
            ->with('parameters')
            ->willReturn(true);
        $options
            ->expects($this->once())
            ->method('__get')
            ->with('parameters')
            ->willReturn($parameters);

        $option = new Connections();
        $factory = $option->getDefault($options);

        $this->assertSame($parameters, $factory->getDefaultParameters());
    }

    /**
     * @group disconnected
     */
    public function testAcceptsConnectionFactoryInstance(): void
    {
        /** @var \Predis\Configuration\OptionInterface */
        $option = $this->getMockBuilder('Predis\Configuration\Option\Connections')
            ->onlyMethods(['getDefault'])
            ->getMock();
        $option
            ->expects($this->never())
            ->method('getDefault');

        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();

        $this->assertSame($factory, $option->filter($options, $factory));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCallableReturningConnectionFactoryInstance(): void
    {
        $option = new Connections();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn(
                $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock()
            );

        $this->assertSame($factory, $option->filter($options, $callable));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidArguments(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Predis\Configuration\Option\Connections expects a valid connection factory');

        $option = new Connections();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $option->filter($options, new stdClass());
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Test provider for string values supported by this client option.
     *
     * @return array
     */
    public function provideSupportedStringValuesForOption()
    {
        return [
            ['phpiredis-stream', 'Predis\Connection\PhpiredisStreamConnection'],
            ['phpiredis-socket', 'Predis\Connection\PhpiredisSocketConnection'],
            ['phpiredis', 'Predis\Connection\PhpiredisStreamConnection'],
            ['relay', \Predis\Connection\RelayConnection::class],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Configuration\Option\CRC16Test.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use Predis\Configuration\OptionsInterface;
use PredisTestCase;

class CRC16Test extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testDefaultOptionValue(): void
    {
        $option = new CRC16();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $hashGenerator = $option->getDefault($options);

        $this->assertInstanceOf('Predis\Cluster\Hash\HashGeneratorInterface', $hashGenerator);

        if (function_exists('phpiredis_utils_crc16')) {
            $this->assertInstanceOf('Predis\Cluster\Hash\PhpiredisCRC16', $hashGenerator);
        } else {
            $this->assertInstanceOf('Predis\Cluster\Hash\CRC16', $hashGenerator);
        }
    }

    /**
     * @group disconnected
     */
    public function testAcceptsHashGeneratorInstance(): void
    {
        $option = new CRC16();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $hashGenerator = $this->getMockBuilder('Predis\Cluster\Hash\HashGeneratorInterface')->getMock();

        $this->assertSame($hashGenerator, $option->filter($options, $hashGenerator));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCallableAsHashGeneratorInitializer(): void
    {
        $option = new CRC16();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $hashGenerator = $this->getMockBuilder('Predis\Cluster\Hash\HashGeneratorInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn($hashGenerator);

        $this->assertSame($hashGenerator, $option->filter($options, $callable));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidReturnTypeOfHashGeneratorInitializer(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Predis\Configuration\Option\CRC16 expects a valid hash generator');

        $option = new CRC16();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $wrongValue = $this->getMockBuilder('stdClass')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn($wrongValue);

        $option->filter($options, $callable);
    }

    /**
     * @group disconnected
     */
    public function testAcceptsShortNameStringPredis(): void
    {
        $option = new CRC16();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertInstanceOf('Predis\Cluster\Hash\CRC16', $option->filter($options, 'predis'));
    }

    /**
     * @group disconnected
     * @group ext-phpiredis
     * @requires extension phpiredis
     * @requires function phpiredis_utils_crc16
     */
    public function testAcceptsShortNameStringPhpiredis(): void
    {
        $option = new CRC16();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertInstanceOf('Predis\Cluster\Hash\PhpiredisCRC16', $option->filter($options, 'phpiredis'));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidShortNameString(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('String value for the crc16 option must be either `predis` or `phpiredis`');

        $option = new CRC16();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $option->filter($options, 'unknown');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Configuration\Option\ExceptionsTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use Predis\Configuration\OptionsInterface;
use PredisTestCase;
use stdClass;

class ExceptionsTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testDefaultOptionValue(): void
    {
        $option = new Exceptions();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertTrue($option->getDefault($options));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsDifferentValuesAndFiltersThemAsBooleans(): void
    {
        $option = new Exceptions();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertFalse($option->filter($options, null));

        $this->assertTrue($option->filter($options, true));
        $this->assertFalse($option->filter($options, false));

        $this->assertTrue($option->filter($options, 1));
        $this->assertFalse($option->filter($options, 0));

        $this->assertTrue($option->filter($options, 'true'));
        $this->assertFalse($option->filter($options, 'false'));

        $this->assertTrue($option->filter($options, 'on'));
        $this->assertFalse($option->filter($options, 'off'));
    }

    /**
     * @group disconnected
     */
    public function testReturnsFalesOnValuesNotParsableAsBooleans(): void
    {
        $option = new Exceptions();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertFalse($option->filter($options, new stdClass()));
        $this->assertFalse($option->filter($options, 'invalid'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Configuration\Option\PrefixTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use Predis\Configuration\OptionsInterface;
use PredisTestCase;

class PrefixTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testDefaultOptionValue(): void
    {
        $option = new Prefix();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertNull($option->getDefault($options));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsStringAndReturnsCommandProcessor(): void
    {
        $option = new Prefix();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $prefix = $option->filter($options, $value = 'prefix:');

        $this->assertInstanceOf('Predis\Command\Processor\ProcessorInterface', $prefix);
        $this->assertInstanceOf('Predis\Command\Processor\KeyPrefixProcessor', $prefix);
        $this->assertSame($value, $prefix->getPrefix());
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCommandProcessorInstance(): void
    {
        $option = new Prefix();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $processor = $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock();

        $prefix = $option->filter($options, $processor);

        $this->assertSame($processor, $prefix);
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCallableReturningProcessorInterface(): void
    {
        $option = new Prefix();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn(
                $processor = $this->getMockBuilder('Predis\Command\Processor\ProcessorInterface')->getMock()
            );

        $prefix = $option->filter($options, $callable);

        $this->assertSame($processor, $prefix);
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCallableReturningStringPrefix(): void
    {
        $option = new Prefix();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($this->isInstanceOf('Predis\Configuration\OptionsInterface'))
            ->willReturn('pfx:');

        $prefix = $option->filter($options, $callable);

        $this->assertInstanceOf('Predis\Command\Processor\ProcessorInterface', $prefix);
        $this->assertInstanceOf('Predis\Command\Processor\KeyPrefixProcessor', $prefix);
        $this->assertSame('pfx:', $prefix->getPrefix());
    }

    /**
     * @group disconnected
     */
    public function testAcceptsObjectAsPrefixAndCastsToString(): void
    {
        $option = new Prefix();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $input = $this->getMockBuilder('stdClass')
            ->addMethods(['__toString'])
            ->getMock();
        $input
            ->expects($this->once())
            ->method('__toString')
            ->willReturn('pfx:');

        $prefix = $option->filter($options, $input);

        $this->assertInstanceOf('Predis\Command\Processor\ProcessorInterface', $prefix);
        $this->assertInstanceOf('Predis\Command\Processor\KeyPrefixProcessor', $prefix);
        $this->assertSame('pfx:', $prefix->getPrefix());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Configuration\Option\ReplicationTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Configuration\Option;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Configuration\OptionsInterface;
use PredisTestCase;
use ReflectionProperty;

class ReplicationTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testDefaultOptionValue(): void
    {
        $option = new Replication();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertInstanceOf('closure', $initializer = $option->getDefault($options));
        $this->assertInstanceOf('Predis\Connection\Replication\MasterSlaveReplication', $initializer($parameters = []));
    }

    /**
     * @group disconnected
     */
    public function testConfiguresAutomaticDiscoveryWhenAutodiscoveryOptionIsPresent(): void
    {
        $option = new Replication();

        $connectionFactory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();

        /** @var OptionsInterface|MockObject */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->exactly(2))
            ->method('__get')
            ->withConsecutive(
                ['autodiscovery'],
                ['connections']
            )
            ->willReturnOnConsecutiveCalls(
                true,
                $connectionFactory
            );

        $this->assertInstanceOf('closure', $initializer = $option->getDefault($options));
        $this->assertInstanceOf('Predis\Connection\Replication\MasterSlaveReplication', $connection = $initializer([]));

        // TODO: I know, I know...
        $reflection = new ReflectionProperty($connection, 'autoDiscovery');
        $reflection->setAccessible(true);

        $this->assertTrue($reflection->getValue($connection));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCallableAsConnectionInitializer(): void
    {
        $option = new Replication();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperTriggersAggregationByDefault(): void
    {
        $option = new Replication();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->exactly(2))
            ->method('create')
            ->withConsecutive(
                [$parameters[0]],
                [$parameters[1]]
            )
            ->willReturnOnConsecutiveCalls(
                $nodeConnection1 = $this->getMockConnection($parameters[0]),
                $nodeConnection2 = $this->getMockConnection($parameters[1])
            );

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->once())
            ->method('__get')
            ->with('connections')
            ->willReturn($factory);

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('add')
            ->withConsecutive(
                [$nodeConnection1],
                [$nodeConnection2]
            );

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, true));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperDoesNotTriggerAggregationWhenSecondArgumentIsFalse(): void
    {
        $option = new Replication();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->never())
            ->method('__get')
            ->with('connections');

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('add');

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, false));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperTriggersAggregationWhenSecondArgumentIsTrue(): void
    {
        $option = new Replication();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->exactly(2))
            ->method('create')
            ->withConsecutive(
                [$parameters[0]],
                [$parameters[1]]
            )
            ->willReturnOnConsecutiveCalls(
                $nodeConnection1 = $this->getMockConnection($parameters[0]),
                $nodeConnection2 = $this->getMockConnection($parameters[1])
            );

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->once())
            ->method('__get')
            ->with('connections')
            ->willReturn($factory);

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('add')
            ->withConsecutive(
                [$nodeConnection1],
                [$nodeConnection2]
            );

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, true));
    }

    /**
     * @group disconnected
     */
    public function testReturnedCallableWrapperDoesNotTriggerAggregationWhenFirstArgumentIsEmptyAndSecondArgumentIsTrue(): void
    {
        $option = new Replication();
        $parameters = [];

        /** @var MockObject|OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->never())
            ->method('__get')
            ->with('connections');

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('add');

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));
        $this->assertSame($connection, $initializer($parameters, true));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidReturnTypeOfConnectionInitializer(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessageMatches(
            '/^Predis\\\Configuration\\\Option\\\Replication expects the supplied callable to return an instance of Predis\\\Connection\\\AggregateConnectionInterface, but .* was returned$/'
        );

        $option = new Replication();
        $parameters = ['127.0.0.1:6379', '127.0.0.1:6380'];

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        $callable = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callable
            ->expects($this->once())
            ->method('__invoke')
            ->with($parameters, $options, $option)
            ->willReturn($connection);

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, $callable));

        $initializer($parameters);
    }

    /**
     * @group disconnected
     */
    public function testAcceptsShortNameStringPredis(): void
    {
        $option = new Replication();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, 'predis'));
        $this->assertInstanceOf('Predis\Connection\Replication\MasterSlaveReplication', $initializer($parameters = []));
    }

    /**
     * @group disconnected
     */
    public function testAcceptsShortNameStringSentinel(): void
    {
        $option = new Replication();

        /** @var OptionsInterface|MockObject */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $options
            ->expects($this->exactly(2))
            ->method('__get')
            ->withConsecutive(
                ['service'],
                ['connections']
            )
            ->willReturnOnConsecutiveCalls(
                'mymaster',
                $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock()
            );

        $parameters = [
            $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock(),
        ];

        $this->assertInstanceOf('closure', $initializer = $option->filter($options, 'sentinel'));
        $this->assertInstanceOf('Predis\Connection\Replication\SentinelReplication', $connection = $initializer($parameters));

        $this->assertSame($parameters[0], $connection->getSentinelConnection());
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidShortNameString(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage(
            'Predis\Configuration\Option\Replication expects either `predis`, `sentinel` or `redis-sentinel` as valid string values, `unknown` given'
        );

        $option = new Replication();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $option->filter($options, 'unknown');
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnBooleanValue(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage(
            'Predis\Configuration\Option\Replication expects either a string or a callable value, boolean given'
        );

        $option = new Replication();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();

        $option->filter($options, true);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInstanceOfReplicationInterface(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessageMatches(
            '/Predis\\\Configuration\\\Option\\\Replication expects either a string or a callable value, .* given/'
        );

        $option = new Replication();

        /** @var OptionsInterface */
        $options = $this->getMockBuilder('Predis\Configuration\OptionsInterface')->getMock();
        $connection = $this->getMockBuilder('Predis\Connection\Cluster\ClusterInterface')->getMock();

        $option->filter($options, $connection);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\CompositeStreamConnectionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\RawCommand;
use Predis\Response\Error as ErrorResponse;

class CompositeStreamConnectionTest extends PredisConnectionTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getConnectionClass(): string
    {
        return 'Predis\Connection\CompositeStreamConnection';
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInitializationCommandFailure(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');
        $this->expectExceptionMessage('`SELECT` failed: ERR invalid DB index [tcp://127.0.0.1:6379]');

        $cmdSelect = RawCommand::create('SELECT', '1000');

        /** @var NodeConnectionInterface|MockObject */
        $connection = $this
            ->getMockBuilder($this->getConnectionClass())
            ->onlyMethods(['executeCommand', 'createResource'])
            ->setConstructorArgs([new Parameters()])
            ->getMock();
        $connection
            ->method('executeCommand')
            ->with($cmdSelect)
            ->willReturn(
                new ErrorResponse('ERR invalid DB index')
            );

        $connection->method('createResource');

        $connection->addConnectCommand($cmdSelect);
        $connection->connect();
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    /**
     * @group connected
     */
    public function testReadsMultibulkResponsesAsIterators(): void
    {
        /** @var CompositeConnectionInterface */
        $connection = $this->createConnection(true);
        $commands = $this->getCommandFactory();

        $connection->getProtocol()->useIterableMultibulk(true);

        $connection->executeCommand($commands->create('rpush', ['metavars', 'foo', 'hoge', 'lol']));
        $connection->writeRequest($commands->create('lrange', ['metavars', 0, -1]));

        $this->assertInstanceOf('Predis\Response\Iterator\MultiBulkIterator', $iterator = $connection->read());
        $this->assertSame(['foo', 'hoge', 'lol'], iterator_to_array($iterator));
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentParameterWithFalseLikeValues(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 0]);
        $this->assertNonPersistentConnection($connection1);

        $connection2 = $this->createConnectionWithParams(['persistent' => false]);
        $this->assertNonPersistentConnection($connection2);

        $connection3 = $this->createConnectionWithParams(['persistent' => '0']);
        $this->assertNonPersistentConnection($connection3);

        $connection4 = $this->createConnectionWithParams(['persistent' => 'false']);
        $this->assertNonPersistentConnection($connection4);
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentParameterWithTrueLikeValues(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 1]);
        $this->assertPersistentConnection($connection1);

        $connection2 = $this->createConnectionWithParams(['persistent' => true]);
        $this->assertPersistentConnection($connection2);

        $connection3 = $this->createConnectionWithParams(['persistent' => '1']);
        $this->assertPersistentConnection($connection3);

        $connection4 = $this->createConnectionWithParams(['persistent' => 'true']);
        $this->assertPersistentConnection($connection4);

        $connection1->disconnect();
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentConnectionsToSameNodeShareResource(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => true]);
        $connection2 = $this->createConnectionWithParams(['persistent' => true]);

        $this->assertPersistentConnection($connection1);
        $this->assertPersistentConnection($connection2);

        $this->assertSame($connection1->getResource(), $connection2->getResource());

        $connection1->disconnect();
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentConnectionsToSameNodeDoNotShareResourceUsingDifferentPersistentID(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 'conn1']);
        $connection2 = $this->createConnectionWithParams(['persistent' => 'conn2']);

        $this->assertPersistentConnection($connection1);
        $this->assertPersistentConnection($connection2);

        $this->assertNotSame($connection1->getResource(), $connection2->getResource());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\ConnectionExceptionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

require_once __DIR__ . '/../CommunicationExceptionTest.php';

use Exception;
use Predis\CommunicationExceptionTest;

class ConnectionExceptionTest extends CommunicationExceptionTest
{
    /**
     * {@inheritdoc}
     */
    protected function getException(
        NodeConnectionInterface $connection,
        string $message,
        int $code = 0,
        ?Exception $inner = null
    ) {
        return new ConnectionException($connection, $message, $code, $inner);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\FactoryTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use Predis\Client;
use Predis\Command\RawCommand;
use PredisTestCase;
use ReflectionObject;
use stdClass;

class FactoryTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testImplementsCorrectInterface(): void
    {
        $factory = new Factory();

        $this->assertInstanceOf('Predis\Connection\FactoryInterface', $factory);
    }

    /**
     * @group disconnected
     */
    public function testSettingDefaultParameters(): void
    {
        $factory = new Factory();

        $factory->setDefaultParameters($defaults = [
            'password' => 'secret',
            'database' => 10,
            'custom' => 'foobar',
        ]);

        $this->assertSame($defaults, $factory->getDefaultParameters());

        $parameters = ['database' => 10, 'persistent' => true];
    }

    /**
     * @group disconnected
     */
    public function testCreateTcpConnection(): void
    {
        $factory = new Factory();

        $parameters = new Parameters(['scheme' => 'tcp']);
        $connection = $factory->create($parameters);

        $this->assertInstanceOf('Predis\Connection\StreamConnection', $connection);
        $this->assertSame($parameters, $connection->getParameters());

        $parameters = new Parameters(['scheme' => 'redis']);
        $connection = $factory->create($parameters);

        $this->assertInstanceOf('Predis\Connection\StreamConnection', $connection);
        $this->assertSame($parameters, $connection->getParameters());
    }

    /**
     * @group disconnected
     */
    public function testCreateSslConnection(): void
    {
        $factory = new Factory();

        $parameters = new Parameters(['scheme' => 'tls']);
        $connection = $factory->create($parameters);

        $this->assertInstanceOf('Predis\Connection\StreamConnection', $connection);
        $this->assertSame($parameters, $connection->getParameters());

        $parameters = new Parameters(['scheme' => 'rediss']);
        $connection = $factory->create($parameters);

        $this->assertInstanceOf('Predis\Connection\StreamConnection', $connection);
        $this->assertSame($parameters, $connection->getParameters());
    }

    /**
     * @group disconnected
     */
    public function testCreateUnixConnection(): void
    {
        $factory = new Factory();

        $parameters = new Parameters(['scheme' => 'unix', 'path' => '/tmp/redis.sock']);
        $connection = $factory->create($parameters);

        $this->assertInstanceOf('Predis\Connection\StreamConnection', $connection);
        $this->assertSame($parameters, $connection->getParameters());
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithParametersInstanceAndDefaultsDoesNotAlterOriginalParameters(): void
    {
        $factory = new Factory();

        $factory->setDefaultParameters($defaultParams = [
            'port' => 7000,
            'password' => 'secret',
            'database' => 10,
            'custom' => 'foobar',
        ]);

        $inputParams = new Parameters([
            'host' => 'localhost',
            'database' => 5,
        ]);

        $connection = $factory->create($inputParams);
        $parameters = $connection->getParameters();

        $this->assertEquals('localhost', $parameters->host);
        $this->assertEquals(6379, $parameters->port);
        $this->assertEquals(5, $parameters->database);

        $this->assertFalse(isset($parameters->password));
        $this->assertNull($parameters->password);

        $this->assertFalse(isset($parameters->custom));
        $this->assertNull($parameters->custom);
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithNullParameters(): void
    {
        $factory = new Factory();
        $connection = $factory->create(null);
        $parameters = $connection->getParameters();

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
        $this->assertEquals('tcp', $parameters->scheme);

        $this->assertFalse(isset($parameters->custom));
        $this->assertNull($parameters->custom);
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithNullParametersAndDefaults(): void
    {
        $factory = new Factory();

        $factory->setDefaultParameters($defaultParams = [
            'port' => 7000,
            'password' => 'secret',
            'custom' => 'foobar',
        ]);

        $connection = $factory->create(null);
        $parameters = $connection->getParameters();

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);

        $this->assertEquals('127.0.0.1', $parameters->host);
        $this->assertEquals($defaultParams['port'], $parameters->port);
        $this->assertEquals($defaultParams['password'], $parameters->password);
        $this->assertEquals($defaultParams['custom'], $parameters->custom);
        $this->assertNull($parameters->path);
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithArrayParameters(): void
    {
        $factory = new Factory();
        $connection = $factory->create(['scheme' => 'tcp', 'custom' => 'foobar']);
        $parameters = $connection->getParameters();

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
        $this->assertEquals('tcp', $parameters->scheme);

        $this->assertTrue(isset($parameters->custom));
        $this->assertSame('foobar', $parameters->custom);
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithArrayParametersAndDefaults(): void
    {
        $factory = new Factory();

        $factory->setDefaultParameters($defaultParams = [
            'port' => 7000,
            'password' => 'secret',
            'custom' => 'foobar',
        ]);

        $connection = $factory->create($inputParams = [
            'host' => 'localhost',
            'port' => 8000,
            'persistent' => true,
        ]);

        $parameters = $connection->getParameters();

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);

        $this->assertEquals($inputParams['host'], $parameters->host);
        $this->assertEquals($inputParams['port'], $parameters->port);
        $this->assertEquals($defaultParams['password'], $parameters->password);
        $this->assertEquals($defaultParams['custom'], $parameters->custom);
        $this->assertEquals($inputParams['persistent'], $parameters->persistent);
        $this->assertNull($parameters->path);
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithStringURI(): void
    {
        $factory = new Factory();
        $connection = $factory->create('tcp://127.0.0.1?custom=foobar');
        $parameters = $connection->getParameters();

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
        $this->assertEquals('tcp', $parameters->scheme);

        $this->assertTrue(isset($parameters->custom));
        $this->assertSame('foobar', $parameters->custom);
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithStrinURIAndDefaults(): void
    {
        $factory = new Factory();

        $factory->setDefaultParameters($defaultParams = [
            'port' => 7000,
            'password' => 'secret',
            'custom' => 'foobar',
        ]);

        $connection = $factory->create('tcp://localhost:8000?persistent=1');
        $parameters = $connection->getParameters();

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);

        $this->assertEquals('localhost', $parameters->host);
        $this->assertEquals('8000', $parameters->port);
        $this->assertEquals($defaultParams['password'], $parameters->password);
        $this->assertEquals($defaultParams['custom'], $parameters->custom);
        $this->assertEquals(true, $parameters->persistent);
        $this->assertNull($parameters->path);
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithoutInitializationCommands(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('addConnectCommand');

        $parameters = new Parameters(['scheme' => 'test']);

        $factory = new Factory();
        $factory->define('test', function ($_parameters, $_factory) use ($connection, $parameters, $factory) {
            $this->assertSame($_parameters, $parameters);
            $this->assertSame($_factory, $factory);

            return $connection;
        });

        $this->assertSame($connection, $factory->create($parameters));
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithInitializationCommands(): void
    {
        $parameters = new Parameters([
            'database' => '0',
            'password' => 'foobar',
        ]);

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('getParameters')
            ->willReturn($parameters);
        $connection
            ->expects($this->exactly(2))
            ->method('addConnectCommand')
            ->withConsecutive(
                [$this->isRedisCommand('AUTH', ['foobar'])],
                [$this->isRedisCommand('SELECT', ['0'])]
            );

        $factory = new Factory();

        // TODO: using reflection to make a protected method accessible :facepalm:
        $reflection = new ReflectionObject($factory);
        $prepareConnection = $reflection->getMethod('prepareConnection');
        $prepareConnection->setAccessible(true);
        $prepareConnection->invoke($factory, $connection);
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithPasswordAndNoUsernameAddsInitializationCommandAuthWithOneArgument()
    {
        $parameters = new Parameters([
            'password' => 'foobar',
        ]);

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection->expects($this->once())
            ->method('getParameters')
            ->will($this->returnValue($parameters));
        $connection->expects($this->once())
            ->method('addConnectCommand')
            ->with($this->isRedisCommand('AUTH', ['foobar']));

        $factory = new Factory();

        // TODO: using reflection to make a protected method accessible :facepalm:
        $reflection = new ReflectionObject($factory);
        $prepareConnection = $reflection->getMethod('prepareConnection');
        $prepareConnection->setAccessible(true);
        $prepareConnection->invoke($factory, $connection);
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithPasswordAndUsernameAddsInitializationCommandAuthWithTwoArguments()
    {
        $parameters = new Parameters([
            'username' => 'myusername',
            'password' => 'foobar',
        ]);

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection->expects($this->once())
            ->method('getParameters')
            ->will($this->returnValue($parameters));
        $connection->expects($this->once())
            ->method('addConnectCommand')
            ->with($this->isRedisCommand('AUTH', ['myusername', 'foobar']));

        $factory = new Factory();

        // TODO: using reflection to make a protected method accessible :facepalm:
        $reflection = new ReflectionObject($factory);
        $prepareConnection = $reflection->getMethod('prepareConnection');
        $prepareConnection->setAccessible(true);
        $prepareConnection->invoke($factory, $connection);
    }

    /**
     * @group disconnected
     */
    public function testCreateConnectionWithUsernameAndNoPasswordDoesNotAddInitializationCommands()
    {
        $parameters = new Parameters([
            'username' => 'myusername',
        ]);

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection->expects($this->once())
            ->method('getParameters')
            ->will($this->returnValue($parameters));
        $connection->expects($this->never())
            ->method('addConnectCommand');

        $factory = new Factory();

        // TODO: using reflection to make a protected method accessible :facepalm:
        $reflection = new ReflectionObject($factory);
        $prepareConnection = $reflection->getMethod('prepareConnection');
        $prepareConnection->setAccessible(true);
        $prepareConnection->invoke($factory, $connection);
    }

    /**
     * @group disconnected
     * @dataProvider provideEmptyParametersForInitializationCommands
     */
    public function testCreateConnectionWithEmptyParametersDoesNotAddInitializationCommands($parameter, $value)
    {
        $parameters = new Parameters([
            $parameter => $value,
        ]);

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection->expects($this->once())
            ->method('getParameters')
            ->will($this->returnValue($parameters));
        $connection->expects($this->never())
            ->method('addConnectCommand');

        $factory = new Factory();

        // TODO: using reflection to make a protected method accessible :facepalm:
        $reflection = new ReflectionObject($factory);
        $prepareConnection = $reflection->getMethod('prepareConnection');
        $prepareConnection->setAccessible(true);
        $prepareConnection->invoke($factory, $connection);
    }

    /**
     * @group disconnected
     */
    public function testCreateUndefinedConnection(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage("Unknown connection scheme: 'unknown'");

        $factory = new Factory();
        $factory->create(new Parameters(['scheme' => 'unknown']));
    }

    /**
     * @group disconnected
     */
    public function testDefineConnectionWithFQN(): void
    {
        [, $connectionClass] = $this->getMockConnectionClass();

        $parameters = new Parameters(['scheme' => 'foobar']);
        $factory = new Factory();

        $factory->define($parameters->scheme, $connectionClass);
        $connection = $factory->create($parameters);

        $this->assertInstanceOf($connectionClass, $connection);
    }

    /**
     * @group disconnected
     */
    public function testDefineConnectionWithCallable(): void
    {
        [, $connectionClass] = $this->getMockConnectionClass();

        $parameters = new Parameters(['scheme' => 'foobar']);
        $factory = new Factory();

        $initializer = function ($parameters) use ($connectionClass) {
            return new $connectionClass($parameters);
        };

        $initializerMock = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $initializerMock
            ->expects($this->exactly(2))
            ->method('__invoke')
            ->with($parameters, $factory)
            ->willReturnCallback($initializer);

        $factory->define($parameters->scheme, $initializerMock);

        $connection1 = $factory->create($parameters);
        $connection2 = $factory->create($parameters);

        $this->assertInstanceOf($connectionClass, $connection1);
        $this->assertInstanceOf($connectionClass, $connection2);
        $this->assertNotSame($connection1, $connection2);
    }

    /**
     * @group disconnected
     */
    public function testDefineConnectionWithInvalidArgument(): void
    {
        $this->expectException('InvalidArgumentException');

        $factory = new Factory();
        $factory->define('foobar', new stdClass());
    }

    /**
     * @group disconnected
     */
    public function testUndefineDefinedConnection(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage("Unknown connection scheme: 'tcp'");

        $factory = new Factory();
        $factory->undefine('tcp');
        $factory->create('tcp://127.0.0.1');
    }

    /**
     * @group disconnected
     */
    public function testUndefineUndefinedConnection(): void
    {
        $factory = new Factory();
        $factory->undefine('unknown');
        $connection = $factory->create('tcp://127.0.0.1');

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testDefineAndUndefineConnection(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage("Unknown connection scheme: 'test'");

        [, $connectionClass] = $this->getMockConnectionClass();

        $factory = new Factory();

        $factory->define('test', $connectionClass);
        $this->assertInstanceOf($connectionClass, $factory->create('test://127.0.0.1'));

        $factory->undefine('test');
        $factory->create('test://127.0.0.1');
    }

    /**
     * @group disconnected
     * @return void
     */
    public function testSetClientNameAndVersionOnConnection(): void
    {
        $parameters = ['client_info' => true];

        $factory = new Factory();
        $connection = $factory->create($parameters);
        $initCommands = $connection->getInitCommands();

        $this->assertInstanceOf(RawCommand::class, $initCommands[0]);
        $this->assertSame('CLIENT', $initCommands[0]->getId());
        $this->assertSame(['SETINFO', 'LIB-NAME', 'predis'], $initCommands[0]->getArguments());

        $this->assertInstanceOf(RawCommand::class, $initCommands[1]);
        $this->assertSame('CLIENT', $initCommands[1]->getId());
        $this->assertSame(['SETINFO', 'LIB-VER', Client::VERSION], $initCommands[1]->getArguments());
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns a mocked Predis\Connection\NodeConnectionInterface.
     *
     * @return array Mock instance of a single node connection and its FQCN
     */
    protected function getMockConnectionClass()
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        return [$connection, get_class($connection)];
    }

    /**
     * Provides empty values for specific parameters.
     *
     * These parameters usually trigger the addition of initialization commands
     * to connection instances like `password` => AUTH and `database` => SELECT,
     * but they should not be added when their values are NULL or empty strings.
     *
     * @return array
     */
    public function provideEmptyParametersForInitializationCommands()
    {
        return [
            // AUTH
            ['username', ''],
            ['username', null],
            ['password', ''],
            ['password', null],

            // SELECT
            ['database', ''],
            ['database', null],
        ];
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\ParametersTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use PredisTestCase;

class ParametersTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testDefaultValues(): void
    {
        $defaults = $this->getDefaultParametersArray();
        $parameters = new Parameters();

        $this->assertEquals($defaults['scheme'], $parameters->scheme);
        $this->assertEquals($defaults['host'], $parameters->host);
        $this->assertEquals($defaults['port'], $parameters->port);
    }

    /**
     * @group disconnected
     */
    public function testIsSet(): void
    {
        $parameters = new Parameters();

        $this->assertTrue(isset($parameters->scheme), 'Parameter `scheme` was expected to be set');
        $this->assertFalse(isset($parameters->notset), 'Parameter `notset` was expected to be not set');
    }

    public function sharedTestsWithArrayParameters(Parameters $parameters): void
    {
        $this->assertTrue(isset($parameters->scheme), 'Parameter `scheme` was expected to be set');
        $this->assertSame('tcp', $parameters->scheme, 'Parameter `scheme` was expected to be set');

        $this->assertTrue(isset($parameters->port), 'Parameter `port` was expected to be set');
        $this->assertSame(7000, $parameters->port, 'Parameter `port` was expected to return 7000');

        $this->assertTrue(isset($parameters->custom), 'Parameter `custom` was expected to be set');
        $this->assertSame('foobar', $parameters->custom, 'Parameter `custom` was expected to return "foobar"');

        $this->assertFalse(isset($parameters->setnull), 'Parameter `setnull` was expected to be not set');
        $this->assertNull($parameters->setnull, 'Parameter `setnull` was expected to return NULL');

        $this->assertFalse(isset($parameters->setemptystring), 'Parameter `setemptystring` was expected to be not set');
        $this->assertNull($parameters->setemptystring, 'Parameter `setemptystring` was expected to return NULL');

        $this->assertFalse(isset($parameters->notset), 'Parameter `notset` was expected to be not set');
        $this->assertNull($parameters->notset, 'Parameter `notset` was expected to return NULL');
    }

    /**
     * @group disconnected
     */
    public function testConstructWithArrayParameters(): void
    {
        $parameters = new Parameters([
            'port' => 7000,
            'custom' => 'foobar',
            'setnull' => null,
            'setemptystring' => '',
        ]);

        $this->sharedTestsWithArrayParameters($parameters);
    }

    /**
     * @group disconnected
     */
    public function testCreateWithArrayParameters(): void
    {
        $parameters = new Parameters([
            'port' => 7000,
            'custom' => 'foobar',
            'setnull' => null,
            'setemptystring' => '',
        ]);

        $this->sharedTestsWithArrayParameters($parameters);
    }

    /**
     * @group disconnected
     */
    public function testCreateWithUriString(): void
    {
        $overrides = [
            'port' => 7000,
            'database' => 5,
            'custom' => 'foobar',
            'setnull' => null,
            'setemptystring' => '',
        ];

        $uriString = $this->getParametersString($overrides);
        $parameters = Parameters::create($uriString);

        $this->sharedTestsWithArrayParameters($parameters);
        $this->assertEquals($overrides['database'], $parameters->database);
    }

    /**
     * @group disconnected
     */
    public function testToArray(): void
    {
        $additional = ['port' => 7000, 'custom' => 'foobar'];
        $parameters = new Parameters($additional);

        $this->assertEquals($this->getParametersArray($additional), $parameters->toArray());
    }

    /**
     * @group disconnected
     */
    public function testSerialization(): void
    {
        $parameters = new Parameters(['port' => 7000, 'custom' => 'foobar']);
        $unserialized = unserialize(serialize($parameters));

        $this->assertEquals($parameters->scheme, $unserialized->scheme);
        $this->assertEquals($parameters->port, $unserialized->port);

        $this->assertTrue(isset($unserialized->custom));
        $this->assertEquals($parameters->custom, $unserialized->custom);

        $this->assertFalse(isset($unserialized->unknown));
        $this->assertNull($unserialized->unknown);
    }

    /**
     * @group disconnected
     */
    public function testParsingURI(): void
    {
        $uri = 'tcp://10.10.10.10:6400?timeout=0.5&persistent=1&database=5&password=secret';

        $expected = [
            'scheme' => 'tcp',
            'host' => '10.10.10.10',
            'port' => 6400,
            'timeout' => '0.5',
            'persistent' => '1',
            'database' => '5',
            'password' => 'secret',
        ];

        $this->assertSame($expected, Parameters::parse($uri));
    }

    /**
     * @group disconnected
     */
    public function testParsingURIWithRedisScheme(): void
    {
        $uri = 'redis://predis:secret@10.10.10.10:6400/5?timeout=0.5&persistent=1';

        $expected = [
            'scheme' => 'redis',
            'host' => '10.10.10.10',
            'port' => 6400,
            'timeout' => '0.5',
            'persistent' => '1',
            'username' => 'predis',
            'password' => 'secret',
            'database' => '5',
        ];

        $parameters = Parameters::parse($uri);

        $this->assertSame($expected, $parameters);
    }

    /**
     * @group disconnected
     */
    public function testRedisSchemeOverridesUsernameAndPasswordInQueryString(): void
    {
        $parameters = Parameters::parse('redis://predis:secret@10.10.10.10/5?username=ignored&password=ignored');

        $this->assertSame('predis', $parameters['username']);
        $this->assertSame('secret', $parameters['password']);
    }

    /**
     * @group disconnected
     */
    public function testRedisSchemeDoesNotOverridesUsernameAndPasswordInQueryStringOnEmptyAuthFragment(): void
    {
        $parameters = Parameters::parse('redis://:@10.10.10.10/5?username=predis&password=secret');

        $this->assertSame('predis', $parameters['username']);
        $this->assertSame('secret', $parameters['password']);
    }

    /**
     * @group disconnected
     */
    public function testRedisSchemeOverridesDatabaseInQueryString(): void
    {
        $parameters = Parameters::parse('redis://10.10.10.10/5?database=10');

        $this->assertSame('5', $parameters['database']);
    }

    /**
     * @group disconnected
     */
    public function testParsingURIWithRedisSchemeMustPreserveRemainderOfPath(): void
    {
        $uri = 'redis://10.10.10.10/5/rest/of/path';

        $expected = [
            'scheme' => 'redis',
            'host' => '10.10.10.10',
            'path' => '/rest/of/path',
            'database' => '5',
        ];

        $parameters = Parameters::parse($uri);

        $this->assertSame($expected, $parameters);
    }

    /**
     * @group disconnected
     */
    public function testParsingURIWithUnixDomainSocket(): void
    {
        $uri = 'unix:///tmp/redis.sock?timeout=0.5&persistent=1';

        $expected = [
            'scheme' => 'unix',
            'path' => '/tmp/redis.sock',
            'timeout' => '0.5',
            'persistent' => '1',
        ];

        $this->assertSame($expected, Parameters::parse($uri));
    }

    /**
     * @group disconnected
     */
    public function testParsingURIWithUnixDomainSocketOldWay(): void
    {
        $uri = 'unix:/tmp/redis.sock?timeout=0.5&persistent=1';

        $expected = [
            'scheme' => 'unix',
            'path' => '/tmp/redis.sock',
            'timeout' => '0.5',
            'persistent' => '1',
        ];

        $this->assertSame($expected, Parameters::parse($uri));
    }

    /**
     * @group disconnected
     */
    public function testParsingURIWithIncompletePairInQueryString(): void
    {
        $uri = 'tcp://10.10.10.10?persistent=1&foo=&bar';

        $expected = [
            'scheme' => 'tcp',
            'host' => '10.10.10.10',
            'persistent' => '1',
            'foo' => '',
            'bar' => '',
        ];

        $this->assertSame($expected, Parameters::parse($uri));
    }

    /**
     * @group disconnected
     */
    public function testParsingURIWithMoreThanOneEqualSignInQueryStringPairValue(): void
    {
        $uri = 'tcp://10.10.10.10?foobar=a=b=c&persistent=1';

        $expected = [
            'scheme' => 'tcp',
            'host' => '10.10.10.10',
            'foobar' => 'a=b=c',
            'persistent' => '1',
        ];

        $this->assertSame($expected, Parameters::parse($uri));
    }

    /**
     * @group disconnected
     */
    public function testParsingURIWhenQueryStringHasBracketsInFieldnames(): void
    {
        $uri = 'tcp://10.10.10.10?persistent=1&metavars[]=foo&metavars[]=hoge';

        $expected = [
            'scheme' => 'tcp',
            'host' => '10.10.10.10',
            'persistent' => '1',
            'metavars' => ['foo', 'hoge'],
        ];

        $this->assertSame($expected, Parameters::parse($uri));
    }

    /**
     * @group disconnected
     */
    public function testParsingURIWithEmbeddedIPV6AddressShouldStripBracketsFromHost(): void
    {
        $expected = ['scheme' => 'tcp', 'host' => '::1', 'port' => 7000];
        $this->assertSame($expected, Parameters::parse('tcp://[::1]:7000'));

        $expected = ['scheme' => 'tcp', 'host' => '2001:db8:0:f101::1', 'port' => 7000];
        $this->assertSame($expected, Parameters::parse('tcp://[2001:db8:0:f101::1]:7000'));
    }

    /**
     * @group disconnected
     */
    public function testParsingURIThrowOnInvalidURI(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Invalid parameters URI: tcp://invalid:uri');

        Parameters::parse('tcp://invalid:uri');
    }

    /**
     * @group disconnected
     */
    public function testToStringWithDefaultParameters(): void
    {
        $parameters = new Parameters();

        $this->assertSame('tcp://127.0.0.1:6379', (string) $parameters);
    }

    /**
     * @group disconnected
     */
    public function testToStringWithUnixScheme(): void
    {
        $uri = 'unix:/path/to/redis.sock';
        $parameters = Parameters::create("$uri?foo=bar");

        $this->assertSame($uri, (string) $parameters);
    }

    /**
     * @group disconnected
     */
    public function testToStringWithIPv4(): void
    {
        $uri = 'tcp://127.0.0.1:6379';
        $parameters = Parameters::create("$uri?foo=bar");

        $this->assertSame($uri, (string) $parameters);
    }

    /**
     * @group disconnected
     */
    public function testToStringWithIPv6(): void
    {
        $uri = 'tcp://[::1]:6379';
        $parameters = Parameters::create("$uri?foo=bar");

        $this->assertSame($uri, (string) $parameters);
    }

    /**
     * @group disconnected
     */
    public function testSettingRelayOptions(): void
    {
        $uri = 'tcp://10.10.10.10?serializer=igbinary&compression=lz4';

        $expected = [
            'scheme' => 'tcp',
            'host' => '10.10.10.10',
            'serializer' => 'igbinary',
            'compression' => 'lz4',
        ];

        $this->assertSame($expected, Parameters::parse($uri));
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns a named array with the default connection parameters and their values.
     *
     * @return array Default connection parameters.
     */
    protected function getDefaultParametersArray(): array
    {
        return [
            'scheme' => 'tcp',
            'host' => '127.0.0.1',
            'port' => 6379,
        ];
    }

    /**
     * Returns an URI string representation of the specified connection parameters.
     *
     * @param array $parameters array of connection parameters.
     *
     * @return string URI string.
     */
    protected function getParametersString(array $parameters): string
    {
        $defaults = $this->getDefaultParametersArray();

        $scheme = $parameters['scheme'] ?? $defaults['scheme'];
        $host = $parameters['host'] ?? $defaults['host'];
        $port = $parameters['port'] ?? $defaults['port'];

        unset($parameters['scheme'], $parameters['host'], $parameters['port']);
        $uriString = "$scheme://$host:$port/?";

        foreach ($parameters as $k => $v) {
            $uriString .= "$k=$v&";
        }

        return $uriString;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\PhpiredisSocketConnectionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\RawCommand;
use Predis\Response\Error as ErrorResponse;

/**
 * @group ext-phpiredis
 * @requires extension phpiredis
 */
class PhpiredisSocketConnectionTest extends PredisConnectionTestCase
{
    /**
     * {@inheritDoc}
     */
    protected function getConnectionClass(): string
    {
        return 'Predis\Connection\PhpiredisSocketConnection';
    }

    /**
     * @group disconnected
     */
    public function testSupportsSchemeTls(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage("Invalid scheme: 'tls'");

        $connection = $this->createConnectionWithParams(['scheme' => 'tls']);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testSupportsSchemeRediss(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage("Invalid scheme: 'rediss'");

        $connection = $this->createConnectionWithParams(['scheme' => 'rediss']);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInitializationCommandFailure(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');
        $this->expectExceptionMessage('`SELECT` failed: ERR invalid DB index [tcp://127.0.0.1:6379]');

        $cmdSelect = RawCommand::create('SELECT', '1000');

        /** @var NodeConnectionInterface|MockObject */
        $connection = $this
            ->getMockBuilder($this->getConnectionClass())
            ->onlyMethods(['executeCommand', 'createResource'])
            ->setConstructorArgs([new Parameters()])
            ->getMock();
        $connection
            ->method('executeCommand')
            ->with($cmdSelect)
            ->willReturn(
                new ErrorResponse('ERR invalid DB index')
            );

        $connection->method('createResource');

        $connection->addConnectCommand($cmdSelect);
        $connection->connect();
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    /**
     * @group connected
     */
    public function testThrowsExceptionOnUnresolvableHostname(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');
        $this->expectExceptionMessage("Cannot resolve the address of 'bogus.tld'");

        $connection = $this->createConnectionWithParams(['host' => 'bogus.tld']);
        $connection->connect();
    }

    /**
     * @medium
     * @group connected
     */
    public function testThrowsExceptionOnProtocolDesynchronizationErrors(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');

        $connection = $this->createConnection();
        $socket = $connection->getResource();

        $connection->writeRequest($this->getCommandFactory()->create('ping'));
        socket_read($socket, 1);

        $connection->read();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\PhpiredisStreamConnectionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\RawCommand;
use Predis\Response\Error as ErrorResponse;

/**
 * @group ext-phpiredis
 * @requires extension phpiredis
 */
class PhpiredisStreamConnectionTest extends PredisConnectionTestCase
{
    /**
     * {@inheritDoc}
     */
    public function getConnectionClass(): string
    {
        return 'Predis\Connection\PhpiredisStreamConnection';
    }

    /**
     * @group disconnected
     */
    public function testSupportsSchemeTls(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('SSL encryption is not supported by this connection backend');

        $connection = $this->createConnectionWithParams(['scheme' => 'tls']);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testSupportsSchemeRediss(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('SSL encryption is not supported by this connection backend');

        $connection = $this->createConnectionWithParams(['scheme' => 'rediss']);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInitializationCommandFailure(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');
        $this->expectExceptionMessage('`SELECT` failed: ERR invalid DB index [tcp://127.0.0.1:6379]');

        $cmdSelect = RawCommand::create('SELECT', '1000');

        /** @var NodeConnectionInterface|MockObject */
        $connection = $this
            ->getMockBuilder($this->getConnectionClass())
            ->onlyMethods(['executeCommand', 'createResource'])
            ->setConstructorArgs([new Parameters()])
            ->getMock();
        $connection
            ->method('executeCommand')
            ->with($cmdSelect)
            ->willReturn(
                new ErrorResponse('ERR invalid DB index')
            );

        $connection->method('createResource');

        $connection->addConnectCommand($cmdSelect);
        $connection->connect();
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    /**
     * @group connected
     * @group slow
     * @requires PHP 5.4
     */
    public function testThrowsExceptionOnReadWriteTimeout(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');

        $connection = $this->createConnectionWithParams([
            'read_write_timeout' => 0.5,
        ], true);

        $connection->executeCommand(
            $this->getCommandFactory()->create('brpop', ['foo', 3])
        );
    }

    /**
     * @medium
     * @group connected
     */
    public function testThrowsExceptionOnProtocolDesynchronizationErrors(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');

        $connection = $this->createConnection();
        $stream = $connection->getResource();

        $connection->writeRequest($this->getCommandFactory()->create('ping'));
        stream_socket_recvfrom($stream, 1);

        $connection->read();
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentParameterWithFalseLikeValues(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 0]);
        $this->assertNonPersistentConnection($connection1);

        $connection2 = $this->createConnectionWithParams(['persistent' => false]);
        $this->assertNonPersistentConnection($connection2);

        $connection3 = $this->createConnectionWithParams(['persistent' => '0']);
        $this->assertNonPersistentConnection($connection3);

        $connection4 = $this->createConnectionWithParams(['persistent' => 'false']);
        $this->assertNonPersistentConnection($connection4);
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentParameterWithTrueLikeValues(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 1]);
        $this->assertPersistentConnection($connection1);

        $connection2 = $this->createConnectionWithParams(['persistent' => true]);
        $this->assertPersistentConnection($connection2);

        $connection3 = $this->createConnectionWithParams(['persistent' => '1']);
        $this->assertPersistentConnection($connection3);

        $connection4 = $this->createConnectionWithParams(['persistent' => 'true']);
        $this->assertPersistentConnection($connection4);

        $connection1->disconnect();
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentConnectionsToSameNodeShareResource(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => true]);
        $connection2 = $this->createConnectionWithParams(['persistent' => true]);

        $this->assertPersistentConnection($connection1);
        $this->assertPersistentConnection($connection2);

        $this->assertSame($connection1->getResource(), $connection2->getResource());

        $connection1->disconnect();
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentConnectionsToSameNodeDoNotShareResourceUsingDifferentPersistentID(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 'conn1']);
        $connection2 = $this->createConnectionWithParams(['persistent' => 'conn2']);

        $this->assertPersistentConnection($connection1);
        $this->assertPersistentConnection($connection2);

        $this->assertNotSame($connection1->getResource(), $connection2->getResource());
    }

    /**
     * @group connected
     */
    public function testTcpNodelayParameterSetsContextFlagWhenTrue()
    {
        $connection = $this->createConnectionWithParams(['tcp_nodelay' => true]);
        $options = stream_context_get_options($connection->getResource());

        $this->assertIsArray($options);
        $this->assertArrayHasKey('socket', $options);
        $this->assertArrayHasKey('tcp_nodelay', $options['socket']);
        $this->assertTrue($options['socket']['tcp_nodelay']);
    }

    /**
     * @group connected
     */
    public function testTcpNodelayParameterDoesNotSetContextFlagWhenFalse()
    {
        $connection = $this->createConnectionWithParams(['tcp_nodelay' => false]);
        $options = stream_context_get_options($connection->getResource());

        $this->assertIsArray($options);
        $this->assertArrayHasKey('socket', $options);
        $this->assertArrayHasKey('tcp_nodelay', $options['socket']);
        $this->assertFalse($options['socket']['tcp_nodelay']);
    }

    /**
     * @group connected
     */
    public function testTcpDelayContextFlagIsNotSetByDefault()
    {
        $connection = $this->createConnectionWithParams([]);
        $options = stream_context_get_options($connection->getResource());

        $this->assertIsArray($options);
        $this->assertArrayHasKey('socket', $options);
        $this->assertArrayHasKey('tcp_nodelay', $options['socket']);
        $this->assertFalse($options['socket']['tcp_nodelay']);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\RelayConnectionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\ClientException;
use Predis\Command\RawCommand;
use Predis\Response\Error as ErrorResponse;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use ReflectionClass;
use Relay\Exception as RelayException;
use Relay\Relay;

/**
 * @group ext-relay
 * @requires extension relay
 */
class RelayConnectionTest extends PredisConnectionTestCase
{
    /**
     * {@inheritDoc}
     */
    public function getConnectionClass(): string
    {
        return RelayConnection::class;
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInitializationCommandFailure(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');
        $this->expectExceptionMessage('`SELECT` failed: ERR invalid DB index [tcp://127.0.0.1:6379]');

        $cmdSelect = RawCommand::create('SELECT', '1000');

        /** @var NodeConnectionInterface|MockObject */
        $connection = $this
            ->getMockBuilder($this->getConnectionClass())
            ->onlyMethods(['executeCommand', 'createResource'])
            ->setConstructorArgs([new Parameters()])
            ->getMock();
        $connection
            ->method('executeCommand')
            ->with($cmdSelect)
            ->willReturn(
                new ErrorResponse('ERR invalid DB index')
            );

        $connection->method('createResource');

        $connection->addConnectCommand($cmdSelect);
        $connection->connect();
    }

    /**
     * @group connected
     */
    public function testGetIdentifierUsesParentGetIdentifier(): void
    {
        $relayMock = $this
            ->getMockBuilder(Relay::class)
            ->onlyMethods(['endpointId'])
            ->getMock();

        $relayMock->method('endpointId')
            ->willThrowException(
                new RelayException('Not Connected')
            );

        /** @var RelayConnection&MockObject $connection */
        $connection = $this
            ->getMockBuilder($this->getConnectionClass())
            ->onlyMethods(['createResource'])
            ->disableOriginalConstructor()
            ->getMock();

        $reflection = new ReflectionClass($connection);
        $propertyClient = $reflection->getProperty('client');
        $propertyClient->setAccessible(true);
        $propertyClient->setValue($connection, $relayMock);
        $propertyParameters = $reflection->getProperty('parameters');
        $propertyParameters->setAccessible(true);
        $propertyParameters->setValue($connection, new Parameters([
            'host' => '127.0.0.1',
            'port' => 6379,
        ]));

        $this->assertEquals('127.0.0.1:6379', $connection->getIdentifier());
    }

    /**
     * @group connected
     */
    public function testGetIdentifierUsesClientEndpointId(): void
    {
        $relayMock = $this
            ->getMockBuilder(Relay::class)
            ->onlyMethods(['endpointId'])
            ->getMock();

        $relayMock->method('endpointId')
            ->willReturn('127.0.0.1:6379');

        /** @var RelayConnection&MockObject $connection */
        $connection = $this
            ->getMockBuilder($this->getConnectionClass())
            ->onlyMethods(['createResource'])
            ->disableOriginalConstructor()
            ->getMock();

        $reflection = new ReflectionClass($connection);
        $propertyClient = $reflection->getProperty('client');
        $propertyClient->setAccessible(true);
        $propertyClient->setValue($connection, $relayMock);

        $this->assertEquals('127.0.0.1:6379', $connection->getIdentifier());
    }

    /**
     * @group connected
     */
    public function testExecuteCommandReturnsErrorResponseWhenItIsThrownByRelay(): void
    {
        $cmdSelect = RawCommand::create('GET', '1');

        $relayMock = $this
            ->getMockBuilder(Relay::class)
            ->onlyMethods(['rawCommand'])
            ->getMock();

        $relayMock->method('rawCommand')
            ->willThrowException(
                new RelayException('RELAY_ERR_REDIS')
            );

        /** @var RelayConnection&MockObject $connection */
        $connection = $this
            ->getMockBuilder($this->getConnectionClass())
            ->onlyMethods(['createResource', 'createClient'])
            ->disableOriginalConstructor()
            ->getMock();

        $reflection = new ReflectionClass($connection);
        $property = $reflection->getProperty('client');
        $property->setAccessible(true);
        $property->setValue($connection, $relayMock);

        $connection->method('createResource');

        $response = $connection->executeCommand($cmdSelect);

        $this->assertInstanceOf(ErrorResponseInterface::class, $response);
    }

    /**
     * @group connected
     */
    public function testExecuteCommandThrowsExceptionWhenThrownByRelayAndItIsNotErrorResponse(): void
    {
        $this->expectException('Predis\ClientException');
        $cmdSelect = RawCommand::create('GET', '1');

        $relayMock = $this
            ->getMockBuilder(Relay::class)
            ->onlyMethods(['rawCommand'])
            ->getMock();

        $relayMock->method('rawCommand')
            ->willThrowException(
                new ClientException('RELAY_ERR_REDIS')
            );

        /** @var RelayConnection&MockObject $connection */
        $connection = $this
            ->getMockBuilder($this->getConnectionClass())
            ->onlyMethods(['createResource', 'createClient'])
            ->disableOriginalConstructor()
            ->getMock();

        $reflection = new ReflectionClass($connection);
        $property = $reflection->getProperty('client');
        $property->setAccessible(true);
        $property->setValue($connection, $relayMock);

        $connection->method('createResource');

        $connection->executeCommand($cmdSelect);
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    /**
     * @group connected
     */
    public function testGetResourceForcesConnection(): void
    {
        $connection = $this->createConnection();

        $this->assertFalse($connection->isConnected());
        $connection->getResource();
        $this->assertTrue($connection->isConnected());
    }

    /**
     * @group connected
     * @group slow
     * @requires PHP 5.4
     */
    public function testThrowsExceptionOnReadWriteTimeout(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');

        $connection = $this->createConnectionWithParams([
            'read_write_timeout' => 0.5,
        ], true);

        $connection->executeCommand(
            $this->getCommandFactory()->create('brpop', ['foo', 3])
        );
    }

    /**
     * @medium
     * @group connected
     * @group relay-incompatible
     */
    public function testThrowsExceptionOnProtocolDesynchronizationErrors(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');

        $connection = $this->createConnection();
        $stream = $connection->getResource();

        $connection->writeRequest($this->getCommandFactory()->create('ping'));
        stream_socket_recvfrom($stream, 1);

        $connection->read();
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requires PHP 5.4
     */
    public function testPersistentParameterWithFalseLikeValues(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 0]);
        $this->assertNonPersistentConnection($connection1);

        $connection2 = $this->createConnectionWithParams(['persistent' => false]);
        $this->assertNonPersistentConnection($connection2);

        $connection3 = $this->createConnectionWithParams(['persistent' => '0']);
        $this->assertNonPersistentConnection($connection3);

        $connection4 = $this->createConnectionWithParams(['persistent' => 'false']);
        $this->assertNonPersistentConnection($connection4);
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requires PHP 5.4
     */
    public function testPersistentParameterWithTrueLikeValues(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 1]);
        $this->assertPersistentConnection($connection1);

        $connection2 = $this->createConnectionWithParams(['persistent' => true]);
        $this->assertPersistentConnection($connection2);

        $connection3 = $this->createConnectionWithParams(['persistent' => '1']);
        $this->assertPersistentConnection($connection3);

        $connection4 = $this->createConnectionWithParams(['persistent' => 'true']);
        $this->assertPersistentConnection($connection4);

        $connection1->disconnect();
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requires PHP 5.4
     */
    public function testPersistentConnectionsToSameNodeShareResource(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => true]);
        $connection2 = $this->createConnectionWithParams(['persistent' => true]);

        $this->assertPersistentConnection($connection1);
        $this->assertPersistentConnection($connection2);

        $this->assertSame($connection1->getResource(), $connection2->getResource());

        $connection1->disconnect();
    }

    /**
     * @group connected
     * @group relay-incompatible
     * @requires PHP 5.4
     */
    public function testPersistentConnectionsToSameNodeDoNotShareResourceUsingDifferentPersistentID(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 'conn1']);
        $connection2 = $this->createConnectionWithParams(['persistent' => 'conn2']);

        $this->assertPersistentConnection($connection1);
        $this->assertPersistentConnection($connection2);

        $this->assertNotSame($connection1->getResource(), $connection2->getResource());
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testTcpNodelayParameterSetsContextFlagWhenTrue()
    {
        $connection = $this->createConnectionWithParams(['tcp_nodelay' => true]);
        $options = stream_context_get_options($connection->getResource());

        $this->assertIsArray($options);
        $this->assertArrayHasKey('socket', $options);
        $this->assertArrayHasKey('tcp_nodelay', $options['socket']);
        $this->assertTrue($options['socket']['tcp_nodelay']);
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testTcpNodelayParameterDoesNotSetContextFlagWhenFalse()
    {
        $connection = $this->createConnectionWithParams(['tcp_nodelay' => false]);
        $options = stream_context_get_options($connection->getResource());

        $this->assertIsArray($options);
        $this->assertArrayHasKey('socket', $options);
        $this->assertArrayHasKey('tcp_nodelay', $options['socket']);
        $this->assertFalse($options['socket']['tcp_nodelay']);
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testTcpDelayContextFlagIsNotSetByDefault()
    {
        $connection = $this->createConnectionWithParams([]);
        $options = stream_context_get_options($connection->getResource());

        $this->assertIsArray($options);
        $this->assertArrayHasKey('socket', $options);
        $this->assertArrayHasKey('tcp_nodelay', $options['socket']);
        $this->assertFalse($options['socket']['tcp_nodelay']);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\StreamConnectionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Client;
use Predis\Command\RawCommand;
use Predis\Response\Error as ErrorResponse;

class StreamConnectionTest extends PredisConnectionTestCase
{
    /**
     * {@inheritDoc}
     */
    public function getConnectionClass(): string
    {
        return 'Predis\Connection\StreamConnection';
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInitializationCommandFailure(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');
        $this->expectExceptionMessage('`SELECT` failed: ERR invalid DB index [tcp://127.0.0.1:6379]');

        $cmdSelect = RawCommand::create('SELECT', '1000');

        /** @var NodeConnectionInterface|MockObject */
        $connection = $this
            ->getMockBuilder($this->getConnectionClass())
            ->onlyMethods(['executeCommand', 'createResource'])
            ->setConstructorArgs([new Parameters()])
            ->getMock();
        $connection
            ->method('executeCommand')
            ->with($cmdSelect)
            ->willReturn(
                new ErrorResponse('ERR invalid DB index')
            );

        $connection->method('createResource');

        $connection->addConnectCommand($cmdSelect);
        $connection->connect();
    }

    /**
     * @group disconnected
     */
    public function testDoesntThrowErrorOnInvalidResource(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');

        $cmdSelect = RawCommand::create('SELECT', '1000');
        $invalidResource = null;

        /** @var NodeConnectionInterface|MockObject */
        $connection = $this
            ->getMockBuilder($this->getConnectionClass())
            ->onlyMethods(['getResource'])
            ->setConstructorArgs([new Parameters()])
            ->getMock();
        $connection
            ->method('getResource')
            ->willReturn($invalidResource);

        $connection->writeRequest($cmdSelect);
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentParameterWithFalseLikeValues(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 0]);
        $this->assertNonPersistentConnection($connection1);

        $connection2 = $this->createConnectionWithParams(['persistent' => false]);
        $this->assertNonPersistentConnection($connection2);

        $connection3 = $this->createConnectionWithParams(['persistent' => '0']);
        $this->assertNonPersistentConnection($connection3);

        $connection4 = $this->createConnectionWithParams(['persistent' => 'false']);
        $this->assertNonPersistentConnection($connection4);
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentParameterWithTrueLikeValues(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 1]);
        $this->assertPersistentConnection($connection1);

        $connection2 = $this->createConnectionWithParams(['persistent' => true]);
        $this->assertPersistentConnection($connection2);

        $connection3 = $this->createConnectionWithParams(['persistent' => '1']);
        $this->assertPersistentConnection($connection3);

        $connection4 = $this->createConnectionWithParams(['persistent' => 'true']);
        $this->assertPersistentConnection($connection4);

        $connection1->disconnect();
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentConnectionsToSameNodeShareResource(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => true]);
        $connection2 = $this->createConnectionWithParams(['persistent' => true]);

        $this->assertPersistentConnection($connection1);
        $this->assertPersistentConnection($connection2);

        $this->assertSame($connection1->getResource(), $connection2->getResource());

        $connection1->disconnect();
    }

    /**
     * @group connected
     * @requires PHP 5.4
     */
    public function testPersistentConnectionsToSameNodeDoNotShareResourceUsingDifferentPersistentID(): void
    {
        $connection1 = $this->createConnectionWithParams(['persistent' => 'conn1']);
        $connection2 = $this->createConnectionWithParams(['persistent' => 'conn2']);

        $this->assertPersistentConnection($connection1);
        $this->assertPersistentConnection($connection2);

        $this->assertNotSame($connection1->getResource(), $connection2->getResource());
    }

    /**
     * @group connected
     */
    public function testTcpNodelayParameterSetsContextFlagWhenTrue()
    {
        $connection = $this->createConnectionWithParams(['tcp_nodelay' => true]);
        $options = stream_context_get_options($connection->getResource());

        $this->assertIsArray($options);
        $this->assertArrayHasKey('socket', $options);
        $this->assertArrayHasKey('tcp_nodelay', $options['socket']);
        $this->assertTrue($options['socket']['tcp_nodelay']);
    }

    /**
     * @group connected
     */
    public function testTcpNodelayParameterDoesNotSetContextFlagWhenFalse()
    {
        $connection = $this->createConnectionWithParams(['tcp_nodelay' => false]);
        $options = stream_context_get_options($connection->getResource());

        $this->assertIsArray($options);
        $this->assertArrayHasKey('socket', $options);
        $this->assertArrayHasKey('tcp_nodelay', $options['socket']);
        $this->assertFalse($options['socket']['tcp_nodelay']);
    }

    /**
     * @group connected
     */
    public function testTcpDelayContextFlagIsNotSetByDefault()
    {
        $connection = $this->createConnectionWithParams([]);
        $options = stream_context_get_options($connection->getResource());

        $this->assertIsArray($options);
        $this->assertArrayHasKey('socket', $options);
        $this->assertArrayHasKey('tcp_nodelay', $options['socket']);
        $this->assertFalse($options['socket']['tcp_nodelay']);
    }

    /**
     * @group connected
     * @requiresRedisVersion < 7.0.0
     */
    public function testConnectDoNotThrowsExceptionOnClientCommandError(): void
    {
        $connection = $this->createConnectionWithParams([]);
        $connection->addConnectCommand(
            new RawCommand('CLIENT', ['SETINFO', 'LIB-NAME', 'predis'])
        );
        $connection->addConnectCommand(
            new RawCommand('CLIENT', ['SETINFO', 'LIB-VER', Client::VERSION])
        );

        $connection->connect();
        $this->assertTrue(true);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\WebdisConnectionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection;

use PredisTestCase;

/**
 * @group ext-curl
 * @group ext-phpiredis
 * @group realm-connection
 * @group realm-webdis
 * @requires extension phpiredis
 * @requires extension curl
 */
class WebdisConnectionTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testIsConnectedAlwaysReturnsTrue(): void
    {
        $connection = $this->createConnection();

        $this->assertTrue($connection->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testSupportsSchemeUnix(): void
    {
        $connection = $this->createConnectionWithParams(['scheme' => 'http']);

        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $connection);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnInvalidScheme(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage("Invalid scheme: 'tcp'");

        $connection = $this->createConnectionWithParams(['scheme' => 'tcp']);
    }

    /**
     * @group disconnected
     */
    public function testWritingCommandsIsNotSupported(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("The method Predis\Connection\WebdisConnection::writeRequest() is not supported");

        $connection = $this->createConnection();
        $connection->writeRequest($this->getCommandFactory()->create('ping'));
    }

    /**
     * @group disconnected
     */
    public function testReadingResponsesIsNotSupported(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("The method Predis\Connection\WebdisConnection::readResponse() is not supported");

        $connection = $this->createConnection();
        $connection->readResponse($this->getCommandFactory()->create('ping'));
    }

    /**
     * @group disconnected
     */
    public function testReadingFromConnectionIsNotSupported(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("The method Predis\Connection\WebdisConnection::read() is not supported");

        $connection = $this->createConnection();
        $connection->read();
    }

    /**
     * @group disconnected
     */
    public function testAddingConnectCommandsIsNotSupported(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("The method Predis\Connection\WebdisConnection::addConnectCommand() is not supported");

        $connection = $this->createConnection();
        $connection->addConnectCommand($this->getCommandFactory()->create('ping'));
    }

    /**
     * @group disconnected
     */
    public function testRejectCommandSelect(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("Command 'SELECT' is not allowed by Webdis");

        $connection = $this->createConnection();
        $connection->executeCommand($this->getCommandFactory()->create('select', [0]));
    }

    /**
     * @group disconnected
     */
    public function testRejectCommandAuth(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("Command 'AUTH' is not allowed by Webdis");

        $connection = $this->createConnection();
        $connection->executeCommand($this->getCommandFactory()->create('auth', ['foobar']));
    }

    /**
     * @group disconnected
     */
    public function testCanBeSerialized(): void
    {
        $parameters = $this->getParameters([
            'alias' => 'redis',
            'read_write_timeout' => 10,
        ]);

        $connection = $this->createConnectionWithParams($parameters);

        $unserialized = unserialize(serialize($connection));

        $this->assertInstanceOf('Predis\Connection\WebdisConnection', $unserialized);
        $this->assertEquals($parameters, $unserialized->getParameters());
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    /**
     * @group connected
     */
    public function testExecutesMultipleCommandsOnServer(): void
    {
        $commands = $this->getCommandFactory();

        $cmdPing = $commands->create('ping');
        $cmdEcho = $commands->create('echo', ['echoed']);
        $cmdGet = $commands->create('get', ['foobar']);
        $cmdRpush = $commands->create('rpush', ['metavars', 'foo', 'hoge', 'lol']);
        $cmdLrange = $commands->create('lrange', ['metavars', 0, -1]);

        $connection = $this->createConnection(true);

        $this->assertEquals('PONG', $connection->executeCommand($cmdPing));
        $this->assertSame('echoed', $connection->executeCommand($cmdEcho));
        $this->assertNull($connection->executeCommand($cmdGet));
        $this->assertSame(3, $connection->executeCommand($cmdRpush));
        $this->assertSame(['foo', 'hoge', 'lol'], $connection->executeCommand($cmdLrange));
    }

    /**
     * @medium
     * @group disconnected
     * @group slow
     */
    public function testThrowExceptionWhenUnableToConnect(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');

        $connection = $this->createConnectionWithParams(['host' => '169.254.10.10']);
        $connection->executeCommand($this->getCommandFactory()->create('ping'));
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns a named array with the default connection parameters and their values.
     *
     * @return array Default connection parameters
     */
    protected function getDefaultParametersArray(): array
    {
        return [
            'scheme' => 'http',
            'host' => constant('WEBDIS_SERVER_HOST'),
            'port' => constant('WEBDIS_SERVER_PORT'),
        ];
    }

    /**
     * {@inheritdoc}
     */
    protected function createConnection(): NodeConnectionInterface
    {
        return $this->createConnectionWithParams([]);
    }

    /**
     * {@inheritdoc}
     */
    protected function createConnectionWithParams($parameters): NodeConnectionInterface
    {
        if (!$parameters instanceof ParametersInterface) {
            $parameters = $this->getParameters($parameters);
        }

        $connection = new WebdisConnection($parameters);
        $connection->executeCommand($this->getCommandFactory()->create('flushdb'));

        return $connection;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\Cluster\PredisClusterTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection\Cluster;

use PredisTestCase;

class PredisClusterTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testExposesCommandHashStrategy(): void
    {
        $cluster = new PredisCluster();
        $this->assertInstanceOf('Predis\Cluster\PredisStrategy', $cluster->getClusterStrategy());
    }

    /**
     * @group disconnected
     */
    public function testAddingConnectionsToCluster(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertCount(2, $cluster);
        $this->assertSame($connection1, $cluster->getConnectionById('127.0.0.1:7001'));
        $this->assertSame($connection2, $cluster->getConnectionById('127.0.0.1:7002'));
    }

    /**
     * @group disconnected
     */
    public function testAddingConnectionsWithAliasParameterToCluster(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001?alias=node01');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002?alias=node02');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertCount(2, $cluster);
        $this->assertSame($connection1, $cluster->getConnectionByAlias('node01'));
        $this->assertSame($connection2, $cluster->getConnectionByAlias('node02'));
    }

    /**
     * @group disconnected
     */
    public function testRemovingConnectionsFromCluster(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001?alias=node01');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:7003');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertTrue($cluster->remove($connection1));
        $this->assertNull($cluster->getConnectionByAlias('node02'));

        $this->assertFalse($cluster->remove($connection3));

        $this->assertCount(1, $cluster);
    }

    /**
     * @group disconnected
     */
    public function testConnectForcesAllConnectionsToConnect(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection1
            ->expects($this->once())
            ->method('connect');

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');
        $connection2
            ->expects($this->once())
            ->method('connect');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $cluster->connect();
    }

    /**
     * @group disconnected
     */
    public function testDisconnectForcesAllConnectionsToDisconnect(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection1
            ->expects($this->once())
            ->method('disconnect');

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');
        $connection2
            ->expects($this->once())
            ->method('disconnect');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $cluster->disconnect();
    }

    /**
     * @group disconnected
     */
    public function testIsConnectedReturnsTrueIfAtLeastOneConnectionIsOpen(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection1
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(false);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');
        $connection2
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(true);

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertTrue($cluster->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testIsConnectedReturnsFalseIfAllConnectionsAreClosed(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection1
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(false);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');
        $connection2
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(false);

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertFalse($cluster->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testCanReturnAnIteratorForConnections(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertInstanceOf('Iterator', $iterator = $cluster->getIterator());
        $connections = iterator_to_array($iterator);

        $this->assertSame([
            '127.0.0.1:7001' => $connection1,
            '127.0.0.1:7002' => $connection2,
        ], iterator_to_array($iterator));
    }

    /**
     * @group disconnected
     */
    public function testReturnsCorrectConnectionUsingSlot(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertSame($connection1, $cluster->getConnectionBySlot(1839357934));
        $this->assertSame($connection2, $cluster->getConnectionBySlot(2146453549));
    }

    /**
     * @group disconnected
     */
    public function testReturnsCorrectConnectionUsingKey(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertSame($connection1, $cluster->getConnectionByKey('node01:5431'));
        $this->assertSame($connection2, $cluster->getConnectionByKey('node02:3212'));
        $this->assertSame($connection1, $cluster->getConnectionByKey('prefix:{node01:5431}'));
        $this->assertSame($connection2, $cluster->getConnectionByKey('prefix:{node02:3212}'));
    }

    /**
     * @group disconnected
     */
    public function testReturnsCorrectConnectionUsingCommandInstance(): void
    {
        $commands = $this->getCommandFactory();

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $set = $commands->create('set', ['node01:5431', 'foobar']);
        $get = $commands->create('get', ['node01:5431']);
        $this->assertSame($connection1, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection1, $cluster->getConnectionByCommand($get));

        $set = $commands->create('set', ['prefix:{node01:5431}', 'foobar']);
        $get = $commands->create('get', ['prefix:{node01:5431}']);
        $this->assertSame($connection1, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection1, $cluster->getConnectionByCommand($get));

        $set = $commands->create('set', ['node02:3212', 'foobar']);
        $get = $commands->create('get', ['node02:3212']);
        $this->assertSame($connection2, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection2, $cluster->getConnectionByCommand($get));

        $set = $commands->create('set', ['prefix:{node02:3212}', 'foobar']);
        $get = $commands->create('get', ['prefix:{node02:3212}']);
        $this->assertSame($connection2, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection2, $cluster->getConnectionByCommand($get));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnNonShardableCommand(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("Cannot use 'PING' over clusters of connections.");

        $ping = $this->getCommandFactory()->create('ping');

        $cluster = new PredisCluster();

        $cluster->add($this->getMockConnection('tcp://127.0.0.1:6379'));

        $cluster->getConnectionByCommand($ping);
    }

    /**
     * @group disconnected
     */
    public function testSupportsKeyHashTags(): void
    {
        $commands = $this->getCommandFactory();

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $set = $commands->create('set', ['{node:1001}:foo', 'foobar']);
        $get = $commands->create('get', ['{node:1001}:foo']);
        $this->assertSame($connection1, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection1, $cluster->getConnectionByCommand($get));

        $set = $commands->create('set', ['{node:1001}:bar', 'foobar']);
        $get = $commands->create('get', ['{node:1001}:bar']);
        $this->assertSame($connection1, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection1, $cluster->getConnectionByCommand($get));
    }

    /**
     * @group disconnected
     */
    public function testWritesCommandToCorrectConnection(): void
    {
        $command = $this->getCommandFactory()->create('get', ['node01:5431']);

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection1
            ->expects($this->once())
            ->method('writeRequest')
            ->with($command);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');
        $connection2
            ->expects($this->never())
            ->method('writeRequest');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $cluster->writeRequest($command);
    }

    /**
     * @group disconnected
     */
    public function testReadsCommandFromCorrectConnection(): void
    {
        $command = $this->getCommandFactory()->create('get', ['node02:3212']);

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection1
            ->expects($this->never())
            ->method('readResponse');

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');
        $connection2
            ->expects($this->once())
            ->method('readResponse')
            ->with($command);

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $cluster->readResponse($command);
    }

    /**
     * @group disconnected
     */
    public function testExecutesCommandOnCorrectConnection(): void
    {
        $command = $this->getCommandFactory()->create('get', ['node01:5431']);

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001');
        $connection1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($command);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002');
        $connection2
            ->expects($this->never())
            ->method('executeCommand');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        $cluster->executeCommand($command);
    }

    /**
     * @group disconnected
     */
    public function testCanBeSerialized(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:7001?alias=first');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:7002?alias=second');

        $cluster = new PredisCluster();

        $cluster->add($connection1);
        $cluster->add($connection2);

        // We use the following line to initialize the underlying hashring.
        $cluster->getConnectionByKey('foo');
        $unserialized = unserialize(serialize($cluster));

        $this->assertEquals($cluster, $unserialized);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\Cluster\RedisClusterTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection\Cluster;

use Iterator;
use PHPUnit\Framework\MockObject\MockObject;
use Predis\Cluster;
use Predis\Command;
use Predis\Connection;
use Predis\Response;
use PredisTestCase;

class RedisClusterTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testAcceptsCustomConnectionFactory(): void
    {
        /** @var Connection\FactoryInterface */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $cluster = new RedisCluster($factory);

        $this->assertSame($factory, $cluster->getConnectionFactory());
    }

    /**
     * @group disconnected
     */
    public function testUsesRedisClusterStrategyByDefault(): void
    {
        $cluster = new RedisCluster(new Connection\Factory());

        $this->assertInstanceOf('Predis\Cluster\RedisStrategy', $cluster->getClusterStrategy());
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCustomClusterStrategy(): void
    {
        /** @var Cluster\StrategyInterface */
        $strategy = $this->getMockBuilder('Predis\Cluster\StrategyInterface')->getMock();

        $cluster = new RedisCluster(new Connection\Factory(), $strategy);

        $this->assertSame($strategy, $cluster->getClusterStrategy());
    }

    /**
     * @group disconnected
     */
    public function testAddingConnectionsToCluster(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertCount(2, $cluster);
        $this->assertSame($connection1, $cluster->getConnectionById('127.0.0.1:6379'));
        $this->assertSame($connection2, $cluster->getConnectionById('127.0.0.1:6380'));
    }

    /**
     * @group disconnected
     */
    public function testRemovingConnectionsFromCluster(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6371');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertTrue($cluster->remove($connection1));
        $this->assertFalse($cluster->remove($connection3));
        $this->assertCount(1, $cluster);
    }

    /**
     * @group disconnected
     */
    public function testRemovingConnectionsFromClusterByAlias(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertTrue($cluster->removeById('127.0.0.1:6380'));
        $this->assertFalse($cluster->removeById('127.0.0.1:6390'));
        $this->assertCount(1, $cluster);
    }

    /**
     * @group disconnected
     */
    public function testCountReturnsNumberOfConnectionsInPool(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6381');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $this->assertCount(3, $cluster);

        $cluster->remove($connection3);

        $this->assertCount(2, $cluster);
    }

    /**
     * @group disconnected
     */
    public function testConnectPicksRandomConnection(): void
    {
        $connect1 = false;
        $connect2 = false;

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->any())
            ->method('connect')
            ->willReturnCallback(function () use (&$connect1) {
                $connect1 = true;
            });
        $connection1
            ->expects($this->any())
            ->method('isConnected')
            ->willReturnCallback(function () use (&$connect1) {
                return $connect1;
            });

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->any())
            ->method('connect')
            ->willReturnCallback(function () use (&$connect2) {
                $connect2 = true;
            });
        $connection2
            ->expects($this->any())
            ->method('isConnected')
            ->willReturnCallback(function () use (&$connect2) {
                return $connect2;
            });

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);

        $cluster->connect();

        $this->assertTrue($cluster->isConnected());

        if ($connect1) {
            $this->assertTrue($connect1);
            $this->assertFalse($connect2);
        } else {
            $this->assertFalse($connect1);
            $this->assertTrue($connect2);
        }
    }

    /**
     * @group disconnected
     */
    public function testDisconnectForcesAllConnectionsToDisconnect(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->once())
            ->method('disconnect');

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->once())
            ->method('disconnect');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);

        $cluster->disconnect();
    }

    /**
     * @group disconnected
     */
    public function testIsConnectedReturnsTrueIfAtLeastOneConnectionIsOpen(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(false);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(true);

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertTrue($cluster->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testIsConnectedReturnsFalseIfAllConnectionsAreClosed(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(false);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(false);

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertFalse($cluster->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testGetIteratorReturnsConnectionsMappedInSlotsMapWhenUseClusterSlotsIsDisabled(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6381?slots=0-5460');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6382?slots=5461-10922');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6383?slots=10923-16383');
        $connection4 = $this->getMockConnection('tcp://127.0.0.1:6384');

        $cluster = new RedisCluster(new Connection\Factory());
        $cluster->useClusterSlots(false);

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);
        $cluster->add($connection4);

        $this->assertInstanceOf('Iterator', $iterator = $cluster->getIterator());
        $connections = iterator_to_array($iterator);

        $this->assertCount(3, $connections);
        $this->assertSame($connection1, $connections[0]);
        $this->assertSame($connection2, $connections[1]);
        $this->assertSame($connection3, $connections[2]);
    }

    /**
     * @group disconnected
     */
    public function testGetIteratorReturnsConnectionsMappedInSlotsMapFetchedFromRedisCluster(): void
    {
        $slotsmap = [
            [0, 5460, ['127.0.0.1', 6381], []],
            [5461, 10922, ['127.0.0.1', 6383], []],
            [10923, 16383, ['127.0.0.1', 6384], []],
        ];

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6381?slots=0-5460');
        $connection1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willReturn($slotsmap);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6382?slots=5461-10922');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6383');
        $connection4 = $this->getMockConnection('tcp://127.0.0.1:6384');

        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->exactly(2))
            ->method('create')
            ->withConsecutive(
                [
                    [
                        'host' => '127.0.0.1',
                        'port' => '6383',
                    ],
                ],
                [
                    [
                        'host' => '127.0.0.1',
                        'port' => '6384',
                    ],
                ]
            )
            ->willReturnOnConsecutiveCalls(
                $connection3,
                $connection4
            );

        // TODO: I'm not sure about mocking a protected method, but it'll do for now
        /** @var RedisCluster|MockObject */
        $cluster = $this->getMockBuilder('Predis\Connection\Cluster\RedisCluster')
            ->onlyMethods(['getRandomConnection'])
            ->setConstructorArgs([$factory])
            ->getMock();
        $cluster
            ->expects($this->once())
            ->method('getRandomConnection')
            ->willReturn($connection1);

        $cluster->add($connection1);
        $cluster->add($connection2);

        $cluster->useClusterSlots(true);

        $this->assertInstanceOf('Iterator', $iterator = $cluster->getIterator());
        $connections = iterator_to_array($iterator);

        $this->assertCount(3, $connections);
        $this->assertSame($connection1, $connections[0]);
        $this->assertSame($connection3, $connections[1]);
        $this->assertSame($connection4, $connections[2]);
    }

    /**
     * @group disconnected
     */
    public function testAddingConnectionResetsSlotsMap(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);

        $slotmap = $cluster->getSlotMap();
        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');

        $this->assertSame(array_fill(0, 5461, '127.0.0.1:6379'), $slotmap->toArray());

        $cluster->add($connection2);

        $this->assertCount(0, $slotmap);
    }

    /**
     * @group disconnected
     */
    public function testRemovingConnectionResetsSlotsMap(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);

        $slotmap = $cluster->getSlotMap();
        $slotmap->setSlots(0, 5460, '127.0.0.1:6379');
        $slotmap->setSlots(5461, 10922, '127.0.0.1:6380');

        $expectedMap = array_merge(
            array_fill(0, 5461, '127.0.0.1:6379'),
            array_fill(5460, 5462, '127.0.0.1:6380')
        );

        $this->assertSame($expectedMap, $slotmap->toArray());

        $cluster->remove($connection1);

        $this->assertCount(0, $slotmap);
    }

    /**
     * @group disconnected
     */
    public function testCanAssignConnectionsToRangeOfSlotsFromParameters(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379?slots=0-5460');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380?slots=5461-10922');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6381?slots=10923-16383');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $cluster->buildSlotMap();

        $expectedMap = array_merge(
            array_fill(0, 5461, '127.0.0.1:6379'),
            array_fill(5461, 5462, '127.0.0.1:6380'),
            array_fill(10923, 5461, '127.0.0.1:6381')
        );

        $actualMap = $cluster->getSlotMap()->toArray();

        ksort($actualMap);

        $this->assertSame($expectedMap, $actualMap);
    }

    /**
     * @group disconnected
     */
    public function testCanAssignConnectionsToSingleSlotOrRangesOfSlotsFromParameters(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379?slots=0-5460,5500-5600,11000');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380?slots=5461-5499,5600-10922');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6381?slots=10923-10999,11001-16383');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $cluster->buildSlotMap();

        $expectedMap = array_merge(
            array_fill(0, 5461, '127.0.0.1:6379'),
            array_fill(5460, 39, '127.0.0.1:6380'),
            array_fill(5499, 101, '127.0.0.1:6379'),
            array_fill(5599, 5322, '127.0.0.1:6380'),
            array_fill(10923, 77, '127.0.0.1:6381'),
            array_fill(11000, 1, '127.0.0.1:6379'),
            array_fill(11000, 5383, '127.0.0.1:6381')
        );

        $actualMap = $cluster->getSlotMap()->toArray();

        ksort($actualMap);

        $this->assertSame($expectedMap, $actualMap);
    }

    /**
     * @group disconnected
     */
    public function testReturnsCorrectConnectionUsingSlotID(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6381');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $this->assertSame($connection1, $cluster->getConnectionBySlot(0));
        $this->assertSame($connection2, $cluster->getConnectionBySlot(5461));
        $this->assertSame($connection3, $cluster->getConnectionBySlot(10923));

        $cluster->getSlotMap()->setSlots(5461, 7096, '127.0.0.1:6380');
        $this->assertSame($connection2, $cluster->getConnectionBySlot(5461));
    }

    /**
     * @group disconnected
     */
    public function testReturnsCorrectConnectionUsingCommandInstance(): void
    {
        $commands = $this->getCommandFactory();

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6381');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $set = $commands->create('set', ['node:1001', 'foobar']);
        $get = $commands->create('get', ['node:1001']);
        $this->assertSame($connection1, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection1, $cluster->getConnectionByCommand($get));

        $set = $commands->create('set', ['node:1048', 'foobar']);
        $get = $commands->create('get', ['node:1048']);
        $this->assertSame($connection2, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection2, $cluster->getConnectionByCommand($get));

        $set = $commands->create('set', ['node:1082', 'foobar']);
        $get = $commands->create('get', ['node:1082']);
        $this->assertSame($connection3, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection3, $cluster->getConnectionByCommand($get));
    }

    /**
     * @group disconnected
     */
    public function testWritesCommandToCorrectConnection(): void
    {
        $command = $this->getCommandFactory()->create('get', ['node:1001']);

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->once())
            ->method('writeRequest')
            ->with($command);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->never())
            ->method('writeRequest');

        $cluster = new RedisCluster(new Connection\Factory());
        $cluster->useClusterSlots(false);

        $cluster->add($connection1);
        $cluster->add($connection2);

        $cluster->writeRequest($command);
    }

    /**
     * @group disconnected
     */
    public function testReadsCommandFromCorrectConnection(): void
    {
        $command = $this->getCommandFactory()->create('get', ['node:1050']);

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->never())
            ->method('readResponse');

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->once())
            ->method('readResponse')
            ->with($command);

        $cluster = new RedisCluster(new Connection\Factory());
        $cluster->useClusterSlots(false);

        $cluster->add($connection1);
        $cluster->add($connection2);

        $cluster->readResponse($command);
    }

    /**
     * @group disconnected
     */
    public function testRetriesExecutingCommandOnConnectionFailureOnlyAfterFetchingNewSlotsMap(): void
    {
        $slotsmap = [
            [0, 5460, ['127.0.0.1', 9381], []],
            [5461, 10922, ['127.0.0.1', 6382], []],
            [10923, 16383, ['127.0.0.1', 6383], []],
        ];

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6381?slots=0-5460');
        $connection1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'GET', ['node:1001']
            ))
            ->willThrowException(
                new Connection\ConnectionException($connection1, 'Unknown connection error [127.0.0.1:6381]')
            );

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6382?slots=5461-10922');
        $connection2
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willReturn($slotsmap);

        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6383?slots=10923-16383');
        $connection3
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willReturn($slotsmap);

        $connection4 = $this->getMockConnection('tcp://127.0.0.1:9381');
        $connection4
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('GET', ['node:1001'])],
                [$this->isRedisCommand('GET', ['node:5001'])]
            )
            ->willReturnOnConsecutiveCalls(
                'value:1001',
                'value:5001'
            );

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '127.0.0.1',
                'port' => '9381',
            ])
            ->willReturn($connection4);

        $cluster = new RedisCluster($factory);

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $this->assertSame('value:1001', $cluster->executeCommand(
            Command\RawCommand::create('get', 'node:1001')
        ));

        $this->assertSame('value:5001', $cluster->executeCommand(
            Command\RawCommand::create('get', 'node:5001')
        ));
    }

    /**
     * @group disconnected
     */
    public function testRetriesExecutingCommandOnConnectionFailureButDoNotAskSlotMapWhenDisabled(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6381?slots=0-5500');
        $connection1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'GET', ['node:1001']
            ))
            ->willThrowException(
                new Connection\ConnectionException($connection1, 'Unknown connection error [127.0.0.1:6381]')
            );

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6382?slots=5501-11000');
        $connection2
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'GET', ['node:1001']
            ))
            ->willReturn(
                new Response\Error('MOVED 1970 127.0.0.1:9381')
            );

        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6383?slots=11101-16383');
        $connection3
            ->expects($this->never())
            ->method('executeCommand');

        $connection4 = $this->getMockConnection('tcp://127.0.0.1:9381');
        $connection4
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'GET', ['node:1001']
            ))
            ->willReturn('value:1001');

        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '127.0.0.1',
                'port' => '9381',
            ])
            ->willReturn($connection4);

        // TODO: I'm not sure about mocking a protected method, but it'll do for now
        /** @var RedisCluster|MockObject */
        $cluster = $this->getMockBuilder('Predis\Connection\Cluster\RedisCluster')
            ->onlyMethods(['getRandomConnection'])
            ->setConstructorArgs([$factory])
            ->getMock();
        $cluster
            ->expects($this->never())
            ->method('getRandomConnection');

        $cluster->useClusterSlots(false);

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $this->assertSame('value:1001', $cluster->executeCommand(
            Command\RawCommand::create('get', 'node:1001')
        ));
    }

    /**
     * @group disconnected
     * @group slow
     */
    public function testThrowsClientExceptionWhenExecutingCommandWithEmptyPool(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('No connections available in the pool');

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->never())
            ->method('create');

        $cluster = new RedisCluster($factory);

        $cluster->executeCommand(
            Command\RawCommand::create('get', 'node:1001')
        );
    }

    /**
     * @group disconnected
     */
    public function testAskSlotMapReturnEmptyArrayOnEmptyConnectionsPool(): void
    {
        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->never())
            ->method('create');

        $cluster = new RedisCluster($factory);
        $cluster->askSlotMap();

        $this->assertCount(0, $cluster->getSlotMap());
    }

    /**
     * @group disconnected
     */
    public function testAskSlotMapRetriesOnDifferentNodeOnConnectionFailure(): void
    {
        $slotsmap = [
            [0, 5460, ['127.0.0.1', 9381], []],
            [5461, 10922, ['127.0.0.1', 6382], []],
            [10923, 16383, ['127.0.0.1', 6383], []],
        ];

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6381?slots=0-5460');
        $connection1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willThrowException(
                new Connection\ConnectionException($connection1, 'Unknown connection error [127.0.0.1:6381]')
            );

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6382?slots=5461-10922');
        $connection2
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willThrowException(
                new Connection\ConnectionException($connection2, 'Unknown connection error [127.0.0.1:6383]')
            );

        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6383?slots=10923-16383');
        $connection3
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willReturn($slotsmap);

        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->never())
            ->method('create');

        // TODO: I'm not sure about mocking a protected method, but it'll do for now
        /** @var RedisCluster|MockObject */
        $cluster = $this->getMockBuilder('Predis\Connection\Cluster\RedisCluster')
            ->onlyMethods(['getRandomConnection'])
            ->setConstructorArgs([$factory])
            ->getMock();
        $cluster
            ->expects($this->exactly(3))
            ->method('getRandomConnection')
            ->willReturnOnConsecutiveCalls($connection1, $connection2, $connection3);

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $cluster->askSlotMap();

        $this->assertCount(16384, $cluster->getSlotMap());
    }

    /**
     * @group disconnected
     */
    public function testAskSlotMapHonorsRetryLimitOnMultipleConnectionFailures(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');
        $this->expectExceptionMessage('Unknown connection error [127.0.0.1:6382]');

        $slotsmap = [
            [0, 5460, ['127.0.0.1', 9381], []],
            [5461, 10922, ['127.0.0.1', 6382], []],
            [10923, 16383, ['127.0.0.1', 6383], []],
        ];

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6381?slots=0-5460');
        $connection1
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willThrowException(
                new Connection\ConnectionException($connection1, 'Unknown connection error [127.0.0.1:6381]')
            );

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6382?slots=5461-10922');
        $connection2
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willThrowException(
                new Connection\ConnectionException($connection2, 'Unknown connection error [127.0.0.1:6382]')
            );

        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6383?slots=10923-16383');
        $connection3
            ->expects($this->never())
            ->method('executeCommand');

        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->never())
            ->method('create');

        // TODO: I'm not sure about mocking a protected method, but it'll do for now
        /** @var RedisCluster|MockObject */
        $cluster = $this->getMockBuilder('Predis\Connection\Cluster\RedisCluster')
            ->onlyMethods(['getRandomConnection'])
            ->setConstructorArgs([$factory])
            ->getMock();
        $cluster
            ->expects($this->exactly(2))
            ->method('getRandomConnection')
            ->willReturnOnConsecutiveCalls($connection1, $connection2);

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $cluster->setRetryLimit(1);

        $cluster->askSlotMap();
    }

    /**
     * @group disconnected
     */
    public function testSupportsKeyHashTags(): void
    {
        $commands = $this->getCommandFactory();

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);

        $set = $commands->create('set', ['{node:1001}:foo', 'foobar']);
        $get = $commands->create('get', ['{node:1001}:foo']);
        $this->assertSame($connection1, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection1, $cluster->getConnectionByCommand($get));

        $set = $commands->create('set', ['{node:1001}:bar', 'foobar']);
        $get = $commands->create('get', ['{node:1001}:bar']);
        $this->assertSame($connection1, $cluster->getConnectionByCommand($set));
        $this->assertSame($connection1, $cluster->getConnectionByCommand($get));
    }

    /**
     * @group disconnected
     */
    public function testAskResponseWithConnectionInPool(): void
    {
        $askResponse = new Response\Error('ASK 1970 127.0.0.1:6380');

        $command = $this->getCommandFactory()->create('get', ['node:1001']);

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->with($command)
            ->willReturnOnConsecutiveCalls($askResponse, 'foobar');

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('ASKING')],
                [$this->isRedisCommand($command)]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Status('OK'),
                'foobar'
            );

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->never())
            ->method('create');

        $cluster = new RedisCluster($factory);
        $cluster->useClusterSlots(false);

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertSame('foobar', $cluster->executeCommand($command));
        $this->assertSame('foobar', $cluster->executeCommand($command));
        $this->assertCount(2, $cluster);
    }

    /**
     * @group disconnected
     */
    public function testAskResponseWithConnectionNotInPool(): void
    {
        $askResponse = new Response\Error('ASK 1970 127.0.0.1:6381');

        $command = $this->getCommandFactory()->create('get', ['node:1001']);

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->with($command)
            ->willReturnOnConsecutiveCalls($askResponse, 'foobar');

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->never())
            ->method('executeCommand');

        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6381');
        $connection3
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('ASKING')],
                [$this->isRedisCommand($command)]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Status('OK'),
                'foobar'
            );

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '127.0.0.1',
                'port' => '6381',
            ])
            ->willReturn($connection3);

        $cluster = new RedisCluster($factory);
        $cluster->useClusterSlots(false);

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertSame('foobar', $cluster->executeCommand($command));
        $this->assertSame('foobar', $cluster->executeCommand($command));
        $this->assertCount(2, $cluster);
    }

    /**
     * @group disconnected
     */
    public function testMovedResponseWithConnectionInPool(): void
    {
        $movedResponse = new Response\Error('MOVED 1970 127.0.0.1:6380');

        $command = $this->getCommandFactory()->create('get', ['node:1001']);

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->exactly(1))
            ->method('executeCommand')
            ->with($command)
            ->willReturn($movedResponse);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->with($command)
            ->willReturnOnConsecutiveCalls('foobar', 'foobar');

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory->expects($this->never())->method('create');

        $cluster = new RedisCluster($factory);
        $cluster->useClusterSlots(false);

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertSame('foobar', $cluster->executeCommand($command));
        $this->assertSame('foobar', $cluster->executeCommand($command));
        $this->assertCount(2, $cluster);
    }

    /**
     * @group disconnected
     */
    public function testMovedResponseWithConnectionNotInPool(): void
    {
        $movedResponse = new Response\Error('MOVED 1970 127.0.0.1:6381');

        $command = $this->getCommandFactory()->create('get', ['node:1001']);

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($command)
            ->willReturn($movedResponse);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->never())
            ->method('executeCommand');

        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6381');
        $connection3
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->with($command)
            ->willReturnOnConsecutiveCalls('foobar', 'foobar');

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '127.0.0.1',
                'port' => '6381',
            ])
            ->willReturn($connection3);

        $cluster = new RedisCluster($factory);
        $cluster->useClusterSlots(false);

        $cluster->add($connection1);
        $cluster->add($connection2);

        $this->assertSame('foobar', $cluster->executeCommand($command));
        $this->assertSame('foobar', $cluster->executeCommand($command));
        $this->assertCount(3, $cluster);
    }

    /**
     * @group disconnected
     */
    public function testParseIPv6AddresseAndPortPairInRedirectionPayload(): void
    {
        $movedResponse = new Response\Error('MOVED 1970 2001:db8:0:f101::2:6379');

        $command = $this->getCommandFactory()->create('get', ['node:1001']);

        $connection1 = $this->getMockConnection('tcp://[2001:db8:0:f101::1]:6379');
        $connection1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($command)
            ->willReturn($movedResponse);

        $connection2 = $this->getMockConnection('tcp://[2001:db8:0:f101::2]:6379');
        $connection2
            ->expects($this->once())
            ->method('executeCommand')
            ->with($command)
            ->willReturn('foobar');

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '2001:db8:0:f101::2',
                'port' => '6379',
            ])
            ->willReturn($connection2);

        $cluster = new RedisCluster($factory);
        $cluster->useClusterSlots(false);

        $cluster->add($connection1);

        $cluster->executeCommand($command);
    }

    /**
     * @group disconnected
     */
    public function testFetchSlotsMapFromClusterWithClusterSlotsCommand(): void
    {
        $response = [
            [12288, 13311, ['10.1.0.51', 6387], ['10.1.0.52', 6387]],
            [3072,  4095, ['10.1.0.52', 6392], ['10.1.0.51', 6392]],
            [6144,  7167, ['', 6384], ['10.1.0.52', 6384]],
            [14336, 15359, ['10.1.0.51', 6388], ['10.1.0.52', 6388]],
            [15360, 16383, ['10.1.0.52', 6398], ['10.1.0.51', 6398]],
            [1024,  2047, ['10.1.0.52', 6391], ['10.1.0.51', 6391]],
            [11264, 12287, ['10.1.0.52', 6396], ['10.1.0.51', 6396]],
            [5120,  6143, ['10.1.0.52', 6393], ['10.1.0.51', 6393]],
            [0,  1023, ['10.1.0.51', 6381], ['10.1.0.52', 6381]],
            [13312, 14335, ['10.1.0.52', 6397], ['10.1.0.51', 6397]],
            [4096,  5119, ['10.1.0.51', 6383], ['10.1.0.52', 6383]],
            [9216, 10239, ['10.1.0.52', 6395], ['10.1.0.51', 6395]],
            [8192,  9215, ['10.1.0.51', 6385], ['10.1.0.52', 6385]],
            [10240, 11263, ['10.1.0.51', 6386], ['10.1.0.52', 6386]],
            [2048,  3071, ['10.1.0.51', 6382], ['10.1.0.52', 6382]],
            [7168,  8191, ['10.1.0.52', 6394], ['10.1.0.51', 6394]],
        ];

        $connection1 = $this->getMockConnection('tcp://10.1.0.51:6384');
        $connection1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willReturn($response);

        /** @var Connection\FactoryInterface */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();

        $cluster = new RedisCluster($factory);

        $cluster->add($connection1);

        $cluster->askSlotMap();

        $this->assertSame($cluster->getConnectionBySlot('6144'), $connection1);
    }

    /**
     * @group disconnected
     * @dataProvider onMovedResponsesDataProvider
     */
    public function testAskSlotMapToRedisClusterOnMovedResponseByDefault(string $movedErrorMessage): void
    {
        $cmdGET = Command\RawCommand::create('GET', 'node:1001');
        $rspMOVED = new Response\Error($movedErrorMessage);
        $rspSlotsArray = [
            [0,  8191, ['127.0.0.1', 6379]],
            [8192, 16383, ['127.0.0.1', 6380]],
        ];

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdGET)
            ->willReturn($rspMOVED);

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $connection2
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('CLUSTER', ['SLOTS'])],
                [$this->isRedisCommand($cmdGET)]
            )
            ->willReturnOnConsecutiveCalls(
                $rspSlotsArray,
                'foobar'
            );

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '127.0.0.1',
                'port' => '6380',
            ])
            ->willReturn($connection2);

        $cluster = new RedisCluster($factory);

        $cluster->add($connection1);

        $this->assertSame('foobar', $cluster->executeCommand($cmdGET));
        $this->assertCount(2, $cluster);
    }

    /**
     * @return Iterator<string, array{movedErrorMessage: string}>
     */
    public function onMovedResponsesDataProvider(): Iterator
    {
        yield 'MOVED 1970 127.0.0.1:6380' => [
            'movedErrorMessage' => 'MOVED 1970 127.0.0.1:6380',
        ];

        yield 'MOVED 1970 127.0.0.1:6380 (relay exception details)' => [
            'movedErrorMessage' => 'MOVED 1970 127.0.0.1:6380 (relay exception details)',
        ];
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnNonSupportedCommand(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("Cannot use 'PING' with redis-cluster");

        $ping = $this->getCommandFactory()->create('ping');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($this->getMockConnection('tcp://127.0.0.1:6379'));

        $cluster->getConnectionByCommand($ping);
    }

    /**
     * @medium
     * @group disconnected
     */
    public function testCanBeSerialized(): void
    {
        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379?slots=0-5460');
        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6380?slots=5461-10922');
        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6381?slots=10923-16383');

        $cluster = new RedisCluster(new Connection\Factory());

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $cluster->buildSlotMap();

        $unserialized = unserialize(serialize($cluster));

        $this->assertEquals($cluster, $unserialized);
    }

    /**
     * @medium
     * @group disconnected
     * @group slow
     */
    public function testRetryCommandSuccessOnClusterDownErrors()
    {
        $clusterDownError = new Response\Error('CLUSTERDOWN');

        $command = Command\RawCommand::create('get', 'node:1001');

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1->expects($this->exactly(3))
                    ->method('executeCommand')
                    ->with($command)
                    ->will($this->onConsecutiveCalls(
                        $clusterDownError,
                        $clusterDownError,
                        'foobar'));

        $cluster = new RedisCluster(new Connection\Factory());
        $cluster->useClusterSlots(false);
        $cluster->setRetryLimit(2);
        $cluster->add($connection1);

        $this->assertSame('foobar', $cluster->executeCommand($command));
    }

    /**
     * @medium
     * @group disconnected
     * @group slow
     */
    public function testRetryCommandFailureOnClusterDownErrors()
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('CLUSTERDOWN');

        $clusterDownError = new Response\Error('CLUSTERDOWN');

        $command = Command\RawCommand::create('get', 'node:1001');

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6379');
        $connection1->expects($this->exactly(3))
                    ->method('executeCommand')
                    ->with($command)
                    ->will($this->onConsecutiveCalls(
                        $clusterDownError,
                        $clusterDownError,
                        $clusterDownError
                    ));

        $cluster = new RedisCluster(new Connection\Factory());
        $cluster->useClusterSlots(false);
        $cluster->setRetryLimit(2);
        $cluster->add($connection1);

        $cluster->executeCommand($command);
    }

    /**
     * @medium
     * @group disconnected
     * @group slow
     */
    public function testQueryClusterNodeForSlotMapPauseDurationOnRetry()
    {
        $slotsmap = [
            [0, 5460, ['127.0.0.1', 9381], []],
            [5461, 10922, ['127.0.0.1', 6382], []],
            [10923, 16383, ['127.0.0.1', 6383], []],
        ];

        $connection1 = $this->getMockConnection('tcp://127.0.0.1:6381?slots=0-5460');
        $connection1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willThrowException(
                new Connection\ConnectionException($connection1, 'Unknown connection error [127.0.0.1:6381]')
            );

        $connection2 = $this->getMockConnection('tcp://127.0.0.1:6382?slots=5461-10922');
        $connection2
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willThrowException(
                new Connection\ConnectionException($connection2, 'Unknown connection error [127.0.0.1:6383]')
            );

        $connection3 = $this->getMockConnection('tcp://127.0.0.1:6383?slots=10923-16383');
        $connection3
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'CLUSTER', ['SLOTS']
            ))
            ->willReturn($slotsmap);

        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->never())
            ->method('create');

        // TODO: I'm not sure about mocking a protected method, but it'll do for now
        /** @var RedisCluster|MockObject */
        $cluster = $this->getMockBuilder('Predis\Connection\Cluster\RedisCluster')
            ->onlyMethods(['getRandomConnection'])
            ->setConstructorArgs([$factory])
            ->getMock();
        $cluster
            ->expects($this->exactly(3))
            ->method('getRandomConnection')
            ->willReturnOnConsecutiveCalls($connection1, $connection2, $connection3);

        $cluster->add($connection1);
        $cluster->add($connection2);
        $cluster->add($connection3);

        $cluster->setRetryInterval(2000);

        $startTime = time();
        $cluster->askSlotMap();
        $endTime = time();
        $totalTime = $endTime - $startTime;
        $t1 = $cluster->getRetryInterval();
        $t2 = $t1 * 2;

        $expectedTime = ($t1 + $t2) / 1000; // expected time for 2 retries (fail 1=wait 2s, fail 2=wait 4s , OK)
        $this->AssertEqualsWithDelta($expectedTime, $totalTime, 1, 'Unexpected execution time');

        $this->assertCount(16384, $cluster->getSlotMap());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\Replication\MasterSlaveReplicationTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection\Replication;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command;
use Predis\Connection;
use Predis\Replication\ReplicationStrategy;
use Predis\Response;
use PredisTestCase;

class MasterSlaveReplicationTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testAddingConnectionsToReplication(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6381?role=slave');

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave1);
        $replication->add($slave2);

        $this->assertSame($master, $replication->getConnectionById('127.0.0.1:6379'));
        $this->assertSame($slave1, $replication->getConnectionById('127.0.0.1:6380'));
        $this->assertSame($slave2, $replication->getConnectionById('127.0.0.1:6381'));

        $this->assertSame($master, $replication->getMaster());
        $this->assertSame([$slave1, $slave2], $replication->getSlaves());
    }

    /**
     * @group disconnected
     */
    public function testAddingConnectionsWithoutRoleParameterDefaultsToSlaveRole(): void
    {
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6381');

        $replication = new MasterSlaveReplication();
        $replication->add($slave1);
        $replication->add($slave2);

        $this->assertSame([$slave1, $slave2], $replication->getSlaves());
    }

    /**
     * @group disconnected
     */
    public function testRemovingConnectionsFromReplication(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6381?role=slave');

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave1);

        $this->assertTrue($replication->remove($slave1));
        $this->assertFalse($replication->remove($slave2));

        $this->assertSame($master, $replication->getMaster());
        $this->assertSame([], $replication->getSlaves());
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByIdOnEmptyReplication(): void
    {
        $replication = new MasterSlaveReplication();

        $this->assertNull($replication->getConnectionById('127.0.0.1:6379'));
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByAlias(): void
    {
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6379?alias=aliased');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6380');

        $replication = new MasterSlaveReplication();
        $replication->add($slave1);
        $replication->add($slave2);

        $this->assertSame($slave1, $replication->getConnectionByAlias('aliased'));
        $this->assertNull($replication->getConnectionByAlias('127.0.0.1:6380'));
        $this->assertNull($replication->getConnectionByAlias('unkswn'));
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByAliasOnEmptyReplication(): void
    {
        $replication = new MasterSlaveReplication();

        $this->assertNull($replication->getConnectionByAlias('unknown'));
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByRole(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave1);

        $this->assertSame($master, $replication->getConnectionByRole('master'));
        $this->assertSame($slave1, $replication->getConnectionByRole('slave'));
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByRoleOnEmptyReplication(): void
    {
        $replication = new MasterSlaveReplication();

        $this->assertNull($replication->getConnectionByRole('master'));
        $this->assertNull($replication->getConnectionByRole('slave'));
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByRoleUnknown(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave1);

        $this->assertNull($replication->getConnectionByRole('unknown'));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnEmptyReplication(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('No available connection for replication');

        $replication = new MasterSlaveReplication();
        $replication->connect();
    }

    /**
     * @group disconnected
     */
    public function testConnectsToOneOfSlaves(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->never())
            ->method('connect');

        $slave = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave
            ->expects($this->once())
            ->method('connect');

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave);

        $replication->connect();
    }

    /**
     * @group disconnected
     */
    public function testConnectsToMasterOnMissingSlaves(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');

        $replication = new MasterSlaveReplication();
        $replication->add($master);

        $replication->connect();
        $this->assertSame($master, $replication->getCurrent());
    }

    /**
     * @group disconnected
     */
    public function testIsConnectedReturnsTrueIfAtLeastOneConnectionIsOpen(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->never())
            ->method('isConnected')
            ->willReturn(false);

        $slave = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(true);

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave);
        $replication->connect();

        $this->assertTrue($replication->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testIsConnectedReturnsFalseIfAllConnectionsAreClosed(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(false);

        $slave = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(false);

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave);

        $this->assertFalse($replication->isConnected());

        $replication->connect();
        $replication->disconnect();

        $this->assertFalse($replication->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testDisconnectForcesCurrentConnectionToDisconnect(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('disconnect');

        $slave = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave
            ->expects($this->once())
            ->method('disconnect');

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave);

        $replication->disconnect();
    }

    /**
     * @group disconnected
     */
    public function testCanSwitchConnection(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave1);

        $this->assertNull($replication->getCurrent());

        $replication->switchTo($master);
        $this->assertSame($master, $replication->getCurrent());

        $replication->switchTo($slave1);
        $this->assertSame($slave1, $replication->getCurrent());
    }

    /**
     * @group disconnected
     */
    public function testThrowsErrorWhenSwitchingToConnectionNotInPool(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Invalid connection or connection not found.');

        $replication = new MasterSlaveReplication();

        $replication->add($this->getMockConnection('tcp://127.0.0.1:6379?role=master'));
        $replication->add($this->getMockConnection('tcp://127.0.0.1:6380?role=slave'));

        $unknown = $this->getMockConnection('tcp://127.0.0.1:6381');

        $replication->switchTo($unknown);
    }

    /**
     * @group disconnected
     */
    public function testCanSwitchConnectionByInstance(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave1);

        $this->assertNull($replication->getCurrent());

        $replication->switchTo($master);
        $this->assertSame($master, $replication->getCurrent());

        $replication->switchTo($slave1);
        $this->assertSame($slave1, $replication->getCurrent());
    }

    /**
     * @group disconnected
     */
    public function testThrowsErrorWhenSwitchingToUnknownConnectionByInstance(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Invalid connection or connection not found.');

        $replication = new MasterSlaveReplication();

        $replication->add($this->getMockConnection('tcp://127.0.0.1:6379?role=master'));
        $replication->add($this->getMockConnection('tcp://127.0.0.1:6380?role=slave'));

        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6381');

        $replication->switchTo($slave2);
    }

    /**
     * @group disconnected
     */
    public function testCanSwitchToMaster(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6381?role=slave');

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($slave2);

        $this->assertNull($replication->getCurrent());

        $replication->switchToMaster();
        $this->assertSame($master, $replication->getCurrent());
    }

    /**
     * @group disconnected
     */
    public function testThrowsErrorOnSwitchToMasterWithNoMasterDefined(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Invalid connection or connection not found.');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');

        $replication = new MasterSlaveReplication();

        $replication->add($slave1);

        $replication->switchToMaster();
    }

    /**
     * @group disconnected
     *
     * @todo We should find a way to test that the slave is indeed randomly selected.
     */
    public function testCanSwitchToRandomSlave(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $this->assertNull($replication->getCurrent());

        $replication->switchToSlave();
        $this->assertSame($slave1, $replication->getCurrent());
    }

    /**
     * @group disconnected
     */
    public function testThrowsErrorOnSwitchToRandomSlaveWithNoSlavesDefined(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Invalid connection or connection not found.');

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');

        $replication = new MasterSlaveReplication();

        $replication->add($master);

        $replication->switchToSlave();
    }

    /**
     * @group disconnected
     */
    public function testUsesSlavesOnReadOnlyCommands(): void
    {
        $commands = $this->getCommandFactory();

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $cmd = $commands->create('exists', ['foo']);
        $this->assertSame($slave1, $replication->getConnectionByCommand($cmd));

        $cmd = $commands->create('get', ['foo']);
        $this->assertSame($slave1, $replication->getConnectionByCommand($cmd));
    }

    /**
     * @group disconnected
     */
    public function testUsesMasterOnWriteRequests(): void
    {
        $commands = $this->getCommandFactory();

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $cmd = $commands->create('set', ['foo', 'bar']);
        $this->assertSame($master, $replication->getConnectionByCommand($cmd));

        $cmd = $commands->create('get', ['foo']);
        $this->assertSame($master, $replication->getConnectionByCommand($cmd));
    }

    /**
     * @group disconnected
     */
    public function testUsesMasterOnReadRequestsWhenNoSlavesAvailable(): void
    {
        $commands = $this->getCommandFactory();

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');

        $replication = new MasterSlaveReplication();

        $replication->add($master);

        $cmd = $commands->create('exists', ['foo']);
        $this->assertSame($master, $replication->getConnectionByCommand($cmd));

        $cmd = $commands->create('set', ['foo', 'bar']);
        $this->assertSame($master, $replication->getConnectionByCommand($cmd));
    }

    /**
     * @group disconnected
     */
    public function testSwitchesFromSlaveToMasterOnWriteRequests(): void
    {
        $commands = $this->getCommandFactory();

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave1');

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $cmd = $commands->create('exists', ['foo']);
        $this->assertSame($slave1, $replication->getConnectionByCommand($cmd));

        $cmd = $commands->create('set', ['foo', 'bar']);
        $this->assertSame($master, $replication->getConnectionByCommand($cmd));

        $cmd = $commands->create('exists', ['foo']);
        $this->assertSame($master, $replication->getConnectionByCommand($cmd));
    }

    /**
     * @group disconnected
     */
    public function testWritesCommandToCorrectConnection(): void
    {
        $commands = $this->getCommandFactory();
        $cmdExists = $commands->create('exists', ['foo']);
        $cmdSet = $commands->create('set', ['foo', 'bar']);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('writeRequest')
            ->with($cmdSet);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->once())
            ->method('writeRequest')
            ->with($cmdExists);

        $replication = new MasterSlaveReplication();
        $replication->add($master);
        $replication->add($slave1);

        $replication->writeRequest($cmdExists);
        $replication->writeRequest($cmdSet);
    }

    /**
     * @group disconnected
     */
    public function testReadsCommandFromCorrectConnection(): void
    {
        $commands = $this->getCommandFactory();
        $cmdExists = $commands->create('exists', ['foo']);
        $cmdSet = $commands->create('set', ['foo', 'bar']);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('readResponse')
            ->with($cmdSet);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->once())
            ->method('readResponse')
            ->with($cmdExists);

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $replication->readResponse($cmdExists);
        $replication->readResponse($cmdSet);
    }

    /**
     * @group disconnected
     */
    public function testExecutesCommandOnCorrectConnection(): void
    {
        $commands = $this->getCommandFactory();
        $cmdExists = $commands->create('exists', ['foo']);
        $cmdSet = $commands->create('set', ['foo', 'bar']);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdSet);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExists);

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $replication->executeCommand($cmdExists);
        $replication->executeCommand($cmdSet);
    }

    /**
     * @group disconnected
     */
    public function testWatchTriggersSwitchToMasterConnection(): void
    {
        $commands = $this->getCommandFactory();
        $cmdWatch = $commands->create('watch', ['foo']);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdWatch);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->never())
            ->method('executeCommand');

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $replication->executeCommand($cmdWatch);
    }

    /**
     * @group disconnected
     */
    public function testMultiTriggersSwitchToMasterConnection(): void
    {
        $commands = $this->getCommandFactory();
        $cmdMulti = $commands->create('multi');

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdMulti);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->never())
            ->method('executeCommand');

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $replication->executeCommand($cmdMulti);
    }

    /**
     * @group disconnected
     */
    public function testEvalTriggersSwitchToMasterConnection(): void
    {
        $commands = $this->getCommandFactory();
        $cmdEval = $commands->create('eval', ["return redis.call('info')"]);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdEval);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->never())
            ->method('executeCommand');

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $replication->executeCommand($cmdEval);
    }

    /**
     * @group disconnected
     */
    public function testDiscardsUnreachableSlaveAndExecutesReadOnlyCommandOnNextSlave(): void
    {
        $commands = $this->getCommandFactory();
        $cmdExists = $commands->create('exists', ['key']);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->never())
            ->method('executeCommand');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave&role=slave');
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExists)
            ->willThrowException(
                new Connection\ConnectionException($slave1)
            );

        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6381?role=slave&alias=slave2');
        $slave2
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExists)
            ->willReturn(1);

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($slave2);

        $replication->switchTo($slave1);

        $response = $replication->executeCommand($cmdExists);

        $this->assertSame(1, $response);
        $this->assertNull($replication->getConnectionByAlias('slave1'));
        $this->assertSame($slave2, $replication->getConnectionByAlias('slave2'));
    }

    /**
     * @group disconnected
     */
    public function testDiscardsUnreachableSlavesAndExecutesReadOnlyCommandOnMaster(): void
    {
        $commands = $this->getCommandFactory();
        $cmdExists = $commands->create('exists', ['key']);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExists)
            ->willReturn(1);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExists)
            ->willThrowException(new Connection\ConnectionException($slave1));

        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6381?role=slave');
        $slave2
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExists)
            ->willThrowException(
                new Connection\ConnectionException($slave2)
            );

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($slave2);

        $replication->switchTo($slave1);

        $response = $replication->executeCommand($cmdExists);

        $this->assertSame(1, $response);
        $this->assertNull($replication->getConnectionById('127.0.0.1:6380'));
        $this->assertNull($replication->getConnectionById('127.0.0.1:6381'));
    }

    /**
     * @group disconnected
     */
    public function testSucceedOnReadOnlyCommandAndNoConnectionSetAsMaster(): void
    {
        $commands = $this->getCommandFactory();
        $cmdExists = $commands->create('exists', ['key']);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6379?role=slave');
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExists)
            ->willReturn(1);

        $replication = new MasterSlaveReplication();

        $replication->add($slave1);

        $response = $replication->executeCommand($cmdExists);

        $this->assertSame(1, $response);
    }

    /**
     * @group disconnected
     */
    public function testFailsOnWriteCommandAndNoConnectionSetAsMaster(): void
    {
        $this->expectException('Predis\Replication\MissingMasterException');
        $this->expectExceptionMessage('No master server available for replication');

        $commands = $this->getCommandFactory();
        $cmdSet = $commands->create('set', ['key', 'value']);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6379?role=slave');
        $slave1
            ->expects($this->never())
            ->method('executeCommand');

        $replication = new MasterSlaveReplication();

        $replication->add($slave1);

        $replication->executeCommand($cmdSet);
    }

    /**
     * @group disconnected
     */
    public function testDiscardsSlaveWhenRespondsLOADINGAndExecutesReadOnlyCommandOnNextSlave(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master->expects($this->never())
            ->method('executeCommand');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'EXISTS', ['key']
            ))
            ->willReturn(
                new Response\Error('LOADING')
            );

        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6381?role=slave');
        $slave2
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'EXISTS', ['key']
            ))
            ->willReturn(1);

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($slave2);

        $replication->switchTo($slave1);

        $response = $replication->executeCommand(
            Command\RawCommand::create('exists', 'key')
        );

        $this->assertSame(1, $response);
        $this->assertNull($replication->getConnectionById('127.0.0.1:6380'));
        $this->assertSame($slave2, $replication->getConnectionById('127.0.0.1:6381'));
    }

    /**
     * @group disconnected
     */
    public function testFailsOnUnreachableMaster(): void
    {
        $this->expectException('Predis\Connection\ConnectionException');

        $commands = $this->getCommandFactory();
        $cmdSet = $commands->create('set', ['key', 'value']);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdSet)
            ->willThrowException(
                new Connection\ConnectionException($master)
            );

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->never())
            ->method('executeCommand');

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $replication->executeCommand($cmdSet);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnNonSupportedCommand(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("The command 'INFO' is not allowed in replication mode.");

        $cmd = $this->getCommandFactory()->create('info');

        $replication = new MasterSlaveReplication();

        $replication->add($this->getMockConnection('tcp://127.0.0.1:6379?role=master'));
        $replication->add($this->getMockConnection('tcp://127.0.0.1:6380?role=slave'));

        $replication->getConnectionByCommand($cmd);
    }

    /**
     * @group disconnected
     */
    public function testCanOverrideReadOnlyFlagForCommands(): void
    {
        $commands = $this->getCommandFactory();
        $cmdSet = $commands->create('set', ['foo', 'bar']);
        $cmdGet = $commands->create('get', ['foo']);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdGet);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdSet);

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $replication->getReplicationStrategy()->setCommandReadOnly($cmdSet->getId(), true);
        $replication->getReplicationStrategy()->setCommandReadOnly($cmdGet->getId(), false);

        $replication->executeCommand($cmdSet);
        $replication->executeCommand($cmdGet);
    }

    /**
     * @group disconnected
     */
    public function testAcceptsCallableToOverrideReadOnlyFlagForCommands(): void
    {
        $commands = $this->getCommandFactory();
        $cmdExistsFoo = $commands->create('exists', ['foo']);
        $cmdExistsBar = $commands->create('exists', ['bar']);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExistsBar);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExistsFoo);

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $replication
            ->getReplicationStrategy()
            ->setCommandReadOnly('exists', function ($cmd) {
                [$arg1] = $cmd->getArguments();

                return $arg1 === 'foo';
            });

        $replication->executeCommand($cmdExistsFoo);
        $replication->executeCommand($cmdExistsBar);
    }

    /**
     * @group disconnected
     */
    public function testCanSetReadOnlyFlagForEvalScripts(): void
    {
        $commands = $this->getCommandFactory();

        $cmdEval = $commands->create('eval', [$script = "return redis.call('info');"]);
        $cmdEvalSha = $commands->create('evalsha', [$scriptSHA1 = sha1($script)]);

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $master
            ->expects($this->never())
            ->method('executeCommand');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');
        $slave1
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand($cmdEval)],
                [$this->isRedisCommand($cmdEvalSha)]
            );

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $replication
            ->getReplicationStrategy()
            ->setScriptReadOnly($script);

        $replication->executeCommand($cmdEval);
        $replication->executeCommand($cmdEvalSha);
    }

    /**
     * @group disconnected
     */
    public function testDiscoveryRequiresConnectionFactory(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('Discovery requires a connection factory');

        $replication = new MasterSlaveReplication();

        $replication->add($this->getMockConnection('tcp://127.0.0.1:6379?role=master'));

        $replication->discover();
    }

    /**
     * @group disconnected
     */
    public function testDiscoversReplicationConfigurationFromMaster(): void
    {
        $connFactory = new Connection\Factory();
        $cmdInfo = Command\RawCommand::create('INFO', 'REPLICATION');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with(
                $this->isRedisCommand($cmdInfo)
            )
            ->willReturn('
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6382,state=online,offset=12979,lag=0
slave1:ip=127.0.0.1,port=6383,state=online,offset=12979,lag=1
master_repl_offset:12979
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2
repl_backlog_histlen:12978
'
            );

        $replication = new MasterSlaveReplication();
        $replication->setConnectionFactory($connFactory);

        $replication->add($master);

        $replication->discover();

        $this->assertCount(2, $slaves = $replication->getSlaves());
        $this->assertContainsOnlyInstancesOf('Predis\Connection\ConnectionInterface', $slaves);

        $this->assertSame('127.0.0.1:6381', (string) $replication->getMaster());
        $this->assertSame('127.0.0.1:6382', (string) $slaves[0]);
        $this->assertSame('127.0.0.1:6383', (string) $slaves[1]);
    }

    /**
     * @group disconnected
     */
    public function testDiscoversReplicationConfigurationFromSlave(): void
    {
        $cmdInfo = $command = Command\RawCommand::create('INFO', 'REPLICATION');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6383?role=slave');

        /** @var Connection\FactoryInterface|MockObject */
        $connFactory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $connFactory
            ->expects($this->exactly(3))
            ->method('create')
            ->withConsecutive(
                // Connection to master node
                [
                    [
                        'host' => '127.0.0.1',
                        'port' => '6381',
                        'role' => 'master',
                    ],
                ],

                // Connection to first slave
                [
                    [
                        'host' => '127.0.0.1',
                        'port' => '6382',
                        'role' => 'slave',
                    ],
                ],

                // Connection to second slave
                [
                    [
                        'host' => '127.0.0.1',
                        'port' => '6383',
                        'role' => 'slave',
                    ],
                ]
            )
            ->willReturnOnConsecutiveCalls(
                $master,
                $slave1,
                $slave2
            );

        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdInfo)
            ->willReturn('
# Replication
role:slave
master_host:127.0.0.1
master_port:6381
master_link_status:up
master_last_io_seconds_ago:8
master_sync_in_progress:0
slave_repl_offset:17715532
slave_priority:100
slave_read_only:1
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
'
            );

        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdInfo)
            ->willReturn('
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6382,state=online,offset=12979,lag=0
slave1:ip=127.0.0.1,port=6383,state=online,offset=12979,lag=1
master_repl_offset:12979
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2
repl_backlog_histlen:12978
'
            );

        $replication = new MasterSlaveReplication();
        $replication->setConnectionFactory($connFactory);

        $replication->add($slave1);

        $replication->discover();

        $this->assertCount(2, $slaves = $replication->getSlaves());
        $this->assertContainsOnlyInstancesOf('Predis\Connection\ConnectionInterface', $slaves);

        $this->assertSame('127.0.0.1:6381', (string) $replication->getMaster());
        $this->assertSame('127.0.0.1:6382', (string) $slaves[0]);
        $this->assertSame('127.0.0.1:6383', (string) $slaves[1]);
    }

    /**
     * @group disconnected
     */
    public function testDiscoversReplicationConfigurationFromSlaveIfMasterFails(): void
    {
        $cmdInfo = $command = Command\RawCommand::create('INFO', 'REPLICATION');

        $masterKO = $this->getMockConnection('tcp://127.0.0.1:7381?role=master');
        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6383?role=slave');

        /** @var Connection\FactoryInterface|MockObject */
        $connFactory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $connFactory
            ->expects($this->exactly(3))
            ->method('create')
            ->withConsecutive(
                // Connection to master node
                [
                    [
                        'host' => '127.0.0.1',
                        'port' => '6381',
                        'role' => 'master',
                    ],
                ],

                // Connection to first slave
                [
                    [
                        'host' => '127.0.0.1',
                        'port' => '6382',
                        'role' => 'slave',
                    ],
                ],

                // Connection to second slave
                [
                    [
                        'host' => '127.0.0.1',
                        'port' => '6383',
                        'role' => 'slave',
                    ],
                ]
            )
            ->willReturnOnConsecutiveCalls(
                $master,
                $slave1,
                $slave2
            );

        $masterKO
            ->expects($this->once())
            ->method('executeCommand')
            ->with(
                $this->isRedisCommand($cmdInfo)
            )
            ->willThrowException(
                new Connection\ConnectionException($masterKO)
            );

        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdInfo)
            ->willReturn('
# Replication
role:slave
master_host:127.0.0.1
master_port:6381
master_link_status:up
master_last_io_seconds_ago:8
master_sync_in_progress:0
slave_repl_offset:17715532
slave_priority:100
slave_read_only:1
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
'
            );

        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with(
                $this->isRedisCommand($cmdInfo)
            )
            ->willReturn('
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6382,state=online,offset=12979,lag=0
slave1:ip=127.0.0.1,port=6383,state=online,offset=12979,lag=1
master_repl_offset:12979
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2
repl_backlog_histlen:12978
'
            );

        $replication = new MasterSlaveReplication();
        $replication->setConnectionFactory($connFactory);

        $replication->add($masterKO);
        $replication->add($slave1);

        $replication->discover();

        $this->assertCount(2, $slaves = $replication->getSlaves());
        $this->assertContainsOnlyInstancesOf('Predis\Connection\ConnectionInterface', $slaves);

        $this->assertSame('127.0.0.1:6381', (string) $replication->getMaster());
        $this->assertSame('127.0.0.1:6382', (string) $slaves[0]);
        $this->assertSame('127.0.0.1:6383', (string) $slaves[1]);
    }

    /**
     * @group disconnected
     */
    public function testAutomaticDiscoveryRequiresConnectionFactory(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('Automatic discovery requires a connection factory');

        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');

        $replication = new MasterSlaveReplication();

        $replication->add($master);

        $replication->setAutoDiscovery(true);
    }

    /**
     * @group disconnected
     */
    public function testAutomaticDiscoveryOnUnreachableServer(): void
    {
        $cmdInfo = $command = Command\RawCommand::create('INFO', 'REPLICATION');
        $cmdExists = $command = Command\RawCommand::create('EXISTS', 'key');

        $slaveKO = $this->getMockConnection('tcp://127.0.0.1:7382?role=slave');
        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');

        /** @var Connection\FactoryInterface|MockObject */
        $connFactory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $connFactory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '127.0.0.1',
                'port' => '6382',
                'role' => 'slave',
            ])
            ->willReturn($slave1);

        $slaveKO
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExists)
            ->willThrowException(
                new Connection\ConnectionException($slaveKO)
            );

        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdExists)
            ->willReturn(1);

        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdInfo)
            ->willReturn('
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6382,state=online,offset=12979,lag=0
master_repl_offset:12979
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2
repl_backlog_histlen:12978
'
            );

        $replication = new MasterSlaveReplication();
        $replication->setConnectionFactory($connFactory);
        $replication->setAutoDiscovery(true);

        $replication->add($master);
        $replication->add($slaveKO);

        $replication->executeCommand($cmdExists);
    }

    /**
     * @group disconnected
     */
    public function testExposesReplicationStrategy(): void
    {
        $replication = new MasterSlaveReplication();
        $this->assertInstanceOf('Predis\Replication\ReplicationStrategy', $replication->getReplicationStrategy());

        $strategy = new ReplicationStrategy();
        $replication = new MasterSlaveReplication($strategy);

        $this->assertSame($strategy, $replication->getReplicationStrategy());
    }

    /**
     * @group disconnected
     */
    public function testCanBeSerialized(): void
    {
        $master = $this->getMockConnection('tcp://127.0.0.1:6379?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6380?role=slave');

        $replication = new MasterSlaveReplication();

        $replication->add($master);
        $replication->add($slave1);

        $unserialized = unserialize(serialize($replication));

        $this->assertEquals($master, $unserialized->getConnectionByRole('master'));
        $this->assertEquals($slave1, $unserialized->getConnectionByRole('slave'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Connection\Replication\SentinelReplicationTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Connection\Replication;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command;
use Predis\Connection;
use Predis\Replication;
use Predis\Response;
use PredisTestCase;
use ReflectionProperty;

class SentinelReplicationTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testMethodGetSentinelConnectionThrowsExceptionOnEmptySentinelsPool(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('No sentinel server available for autodiscovery.');

        $replication = $this->getReplicationConnection('svc', []);
        $replication->getSentinelConnection();
    }

    /**
     * @group disconnected
     */
    public function testParametersForSentinelConnectionShouldUsePasswordForAuthentication(): void
    {
        $replication = $this->getReplicationConnection('svc', [
            'tcp://127.0.0.1:5381?alias=sentinel1&password=secret',
        ]);

        $parameters = $replication->getSentinelConnection()->getParameters()->toArray();

        $this->assertArrayHasKey('password', $parameters, 'Parameter `passwords` was expected to exist in connection parameters');
    }

    /**
     * @group disconnected
     */
    public function testParametersForSentinelConnectionShouldIgnoreDatabaseAndPassword(): void
    {
        $replication = $this->getReplicationConnection('svc', [
            'tcp://127.0.0.1:5381?role=sentinel&database=1&username=myusername',
        ]);

        $parameters = $replication->getSentinelConnection()->getParameters()->toArray();

        $this->assertArrayNotHasKey('database', $parameters, 'Parameter `database` was expected to not exist in connection parameters');
        $this->assertArrayNotHasKey('username', $parameters, 'Parameter `username` was expected to not exist in connection parameters');
        $this->assertArrayNotHasKey('password', $parameters, 'Parameter `password` was expected to not exist in connection parameters');
    }

    /**
     * @group disconnected
     */
    public function testParametersForSentinelConnectionHaveDefaultTimeout(): void
    {
        $replication = $this->getReplicationConnection('svc', [
            'tcp://127.0.0.1:5381?role=sentinel',
        ]);

        $parameters = $replication->getSentinelConnection()->getParameters()->toArray();

        $this->assertArrayHasKey('timeout', $parameters);
        $this->assertSame(0.100, $parameters['timeout']);
    }

    /**
     * @group disconnected
     */
    public function testParametersForSentinelConnectionCanOverrideDefaultTimeout(): void
    {
        $replication = $this->getReplicationConnection('svc', [
            'tcp://127.0.0.1:5381?role=sentinel&timeout=1',
        ]);

        $parameters = $replication
            ->getSentinelConnection()
            ->getParameters()
            ->toArray();

        $this->assertArrayHasKey('timeout', $parameters);
        $this->assertSame('1', $parameters['timeout']);
    }

    /**
     * @group disconnected
     */
    public function testConnectionParametersInstanceForSentinelConnectionIsNotModified(): void
    {
        $originalParameters = Connection\Parameters::create(
            'tcp://127.0.0.1:5381?role=sentinel&database=1&password=secret'
        );

        $replication = $this->getReplicationConnection('svc', [$originalParameters]);

        $parameters = $replication
            ->getSentinelConnection()
            ->getParameters();

        $this->assertSame($originalParameters, $parameters);
        $this->assertNotNull($parameters->password);
        $this->assertNotNull($parameters->database);
    }

    /**
     * @group disconnected
     */
    public function testConnectionParametersInstanceForSentinelConnectionIsNotModifiedEmptyPassword(): void
    {
        $sentinel1 = Connection\Parameters::create('tcp://127.0.0.1:5381?role=sentinel&database=1&password=');
        $sentinel2 = Connection\Parameters::create('tcp://127.0.0.1:5381?role=sentinel&database=1');

        $replication1 = $this->getReplicationConnection('svc', [$sentinel1]);
        $replication2 = $this->getReplicationConnection('svc', [$sentinel2]);

        $parameters1 = $replication1->getSentinelConnection()->getParameters();
        $parameters2 = $replication2->getSentinelConnection()->getParameters();

        $this->assertSame($sentinel1, $parameters1);
        $this->assertSame($sentinel2, $parameters2);

        $this->assertNull($parameters1->password);
        $this->assertNull($parameters2->password);

        $this->assertNotNull($parameters1->database);
        $this->assertNotNull($parameters2->database);
    }

    /**
     * @group disconnected
     */
    public function testMethodGetSentinelConnectionReturnsFirstAvailableSentinel(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel&alias=sentinel1');
        $sentinel2 = $this->getMockSentinelConnection('tcp://127.0.0.1:5382?role=sentinel&alias=sentinel2');
        $sentinel3 = $this->getMockSentinelConnection('tcp://127.0.0.1:5383?role=sentinel&alias=sentinel3');

        $replication = $this->getReplicationConnection('svc', [$sentinel1, $sentinel2, $sentinel3]);

        $this->assertSame($sentinel1, $replication->getSentinelConnection());
    }

    /**
     * @group disconnected
     */
    public function testMethodAddAttachesMasterOrSlaveNodesToReplication(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6383?role=slave');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($slave2);

        $this->assertSame($master, $replication->getConnectionById('127.0.0.1:6381'));
        $this->assertSame($slave1, $replication->getConnectionById('127.0.0.1:6382'));
        $this->assertSame($slave2, $replication->getConnectionById('127.0.0.1:6383'));

        $this->assertSame($master, $replication->getMaster());
        $this->assertSame([$slave1, $slave2], $replication->getSlaves());
    }

    /**
     * @group disconnected
     * @FIXME
     */
    public function testMethodRemoveDismissesMasterOrSlaveNodesFromReplication(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6383?role=slave');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($slave2);

        $this->assertTrue($replication->remove($slave1));
        $this->assertTrue($replication->remove($sentinel1));

        $this->assertSame('127.0.0.1:6381', (string) $replication->getMaster());
        $this->assertCount(1, $slaves = $replication->getSlaves());
        $this->assertSame('127.0.0.1:6383', (string) $slaves[0]);
    }

    /**
     * @group disconnected
     */
    public function testMethodGetConnectionByIdOnEmptyReplication(): void
    {
        $replication = $this->getReplicationConnection('svc', []);

        $this->assertNull($replication->getConnectionById('127.0.0.1:6381'));
    }

    /**
     * @group disconnected
     */
    public function testMethodGetConnectionByRole(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');

        $replication = $this->getReplicationConnection('svc', []);

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($sentinel1);

        $this->assertSame($sentinel1, $replication->getConnectionByRole('sentinel'));
        $this->assertSame($master, $replication->getConnectionByRole('master'));
        $this->assertSame($slave1, $replication->getConnectionByRole('slave'));
    }

    /**
     * @group disconnected
     */
    public function testMethodGetConnectionByRoleOnEmptyReplicationForcesSentinelQueries(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('SENTINEL', ['get-master-addr-by-name', 'svc'])],
                [$this->isRedisCommand('SENTINEL', ['slaves', 'svc'])]
            )
            ->willReturnOnConsecutiveCalls(
                // SENTINEL get-master-addr-by-name svc
                ['127.0.0.1', '6381'],

                // SENTINEL slaves svc
                [
                    [
                        'name', '127.0.0.1:6382',
                        'ip', '127.0.0.1',
                        'port', '6382',
                        'runid', '112cdebd22924a7d962be496f3a1c4c7c9bad93f',
                        'flags', 'slave',
                        'master-host', '127.0.0.1',
                        'master-port', '6381',
                    ],
                ]
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $this->assertSame($sentinel1, $replication->getConnectionByRole('sentinel'));
        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $replication->getConnectionByRole('master'));
        $this->assertInstanceOf('Predis\Connection\NodeConnectionInterface', $replication->getConnectionByRole('slave'));
    }

    /**
     * @group disconnected
     */
    public function testMethodGetConnectionByRoleUnknown(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');

        $replication = $this->getReplicationConnection('svc', []);

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($sentinel1);

        $this->assertNull($replication->getConnectionByRole('unknown'));
    }

    /**
     * @group disconnected
     */
    public function testMethodUpdateSentinelsFetchesSentinelNodes(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['sentinels', 'svc']
            ))
            ->willReturn(
                [
                    [
                        'name', '127.0.0.1:5382',
                        'ip', '127.0.0.1',
                        'port', '5382',
                        'runid', 'a113aa7a0d4870a85bb22b4b605fd26eb93ed40e',
                        'flags', 'sentinel',
                    ],
                    [
                        'name', '127.0.0.1:5383',
                        'ip', '127.0.0.1',
                        'port', '5383',
                        'runid', 'f53b52d281be5cdd4873700c94846af8dbe47209',
                        'flags', 'sentinel',
                    ],
                ]
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);
        $replication->updateSentinels();

        // TODO: sorry for the smell...
        $reflection = new ReflectionProperty($replication, 'sentinels');
        $reflection->setAccessible(true);

        $expected = [
            ['host' => '127.0.0.1', 'port' => '5381'],
            ['host' => '127.0.0.1', 'port' => '5382'],
            ['host' => '127.0.0.1', 'port' => '5383'],
        ];

        $this->assertSame($sentinel1, $replication->getSentinelConnection());
        $this->assertSame($expected, array_intersect_key($expected, $reflection->getValue($replication)));
    }

    /**
     * @group disconnected
     */
    public function testMethodUpdateSentinelsRemovesCurrentSentinelAndRetriesNextOneOnFailure(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel&alias=sentinel1');
        $sentinel1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['sentinels', 'svc']
            ))
            ->willThrowException(
                new Connection\ConnectionException($sentinel1, 'Unknown connection error [127.0.0.1:5381]')
            );

        $sentinel2 = $this->getMockSentinelConnection('tcp://127.0.0.1:5382?role=sentinel&alias=sentinel2');
        $sentinel2
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['sentinels', 'svc']
            ))
            ->willReturn(
                [
                    [
                        'name', '127.0.0.1:5383',
                        'ip', '127.0.0.1',
                        'port', '5383',
                        'runid', 'f53b52d281be5cdd4873700c94846af8dbe47209',
                        'flags', 'sentinel',
                    ],
                ]
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1, $sentinel2]);
        $replication->updateSentinels();

        // TODO: sorry for the smell...
        $reflection = new ReflectionProperty($replication, 'sentinels');
        $reflection->setAccessible(true);

        $expected = [
            ['host' => '127.0.0.1', 'port' => '5382'],
            ['host' => '127.0.0.1', 'port' => '5383'],
        ];

        $this->assertSame($sentinel2, $replication->getSentinelConnection());
        $this->assertSame($expected, array_intersect_key($expected, $reflection->getValue($replication)));
    }

    /**
     * @group disconnected
     */
    public function testMethodUpdateSentinelsThrowsExceptionOnNoAvailableSentinel(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('No sentinel server available for autodiscovery.');

        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['sentinels', 'svc']
            ))
            ->willThrowException(
                new Connection\ConnectionException($sentinel1, 'Unknown connection error [127.0.0.1:5381]')
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);
        $replication->updateSentinels();
    }

    /**
     * @group disconnected
     */
    public function testMethodQuerySentinelFetchesMasterNodeSlaveNodesAndSentinelNodes(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel&alias=sentinel1');
        $sentinel1
            ->expects($this->exactly(3))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('SENTINEL', ['sentinels', 'svc'])],
                [$this->isRedisCommand('SENTINEL', ['get-master-addr-by-name', 'svc'])],
                [$this->isRedisCommand('SENTINEL', ['slaves', 'svc'])]
            )
            ->willReturnOnConsecutiveCalls(
                // SENTINEL sentinels svc
                [
                    [
                        'name', '127.0.0.1:5382',
                        'ip', '127.0.0.1',
                        'port', '5382',
                        'runid', 'a113aa7a0d4870a85bb22b4b605fd26eb93ed40e',
                        'flags', 'sentinel',
                    ],
                ],

                // SENTINEL get-master-addr-by-name svc
                ['127.0.0.1', '6381'],

                // SENTINEL slaves svc
                [
                    [
                        'name', '127.0.0.1:6382',
                        'ip', '127.0.0.1',
                        'port', '6382',
                        'runid', '112cdebd22924a7d962be496f3a1c4c7c9bad93f',
                        'flags', 'slave',
                        'master-host', '127.0.0.1',
                        'master-port', '6381',
                    ],
                    [
                        'name', '127.0.0.1:6383',
                        'ip', '127.0.0.1',
                        'port', '6383',
                        'runid', '1c0bf1291797fbc5608c07a17da394147dc62817',
                        'flags', 'slave',
                        'master-host', '127.0.0.1',
                        'master-port', '6381',
                    ],
                ]
            );

        $sentinel2 = $this->getMockSentinelConnection('tcp://127.0.0.1:5382?role=sentinel&alias=sentinel2');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6383?role=slave');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);
        $replication->querySentinel();

        // TODO: sorry for the smell...
        $reflection = new ReflectionProperty($replication, 'sentinels');
        $reflection->setAccessible(true);

        $sentinels = [
            ['host' => '127.0.0.1', 'port' => '5381'],
            ['host' => '127.0.0.1', 'port' => '5382'],
        ];

        $this->assertSame($sentinel1, $replication->getSentinelConnection());
        $this->assertSame($sentinels, array_intersect_key($sentinels, $reflection->getValue($replication)));

        $master = $replication->getMaster();
        $slaves = $replication->getSlaves();

        $this->assertSame('127.0.0.1:6381', (string) $master);

        $this->assertCount(2, $slaves);
        $this->assertSame('127.0.0.1:6382', (string) $slaves[0]);
        $this->assertSame('127.0.0.1:6383', (string) $slaves[1]);
    }

    /**
     * @group disconnected
     */
    public function testMethodGetMasterAsksSentinelForMasterOnMasterNotSet(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('SENTINEL', ['get-master-addr-by-name', 'svc'])]
            )
            ->willReturnOnConsecutiveCalls(
                ['127.0.0.1', '6381']
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $this->assertSame('127.0.0.1:6381', (string) $replication->getMaster());
    }

    /**
     * @group disconnected
     */
    public function testMethodGetMasterThrowsExceptionOnNoAvailableSentinels(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('No sentinel server available for autodiscovery.');

        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['get-master-addr-by-name', 'svc']
            ))
            ->willThrowException(
                new Connection\ConnectionException($sentinel1, 'Unknown connection error [127.0.0.1:5381]')
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->getMaster();
    }

    /**
     * @group disconnected
     */
    public function testMethodGetSlavesOnEmptySlavePoolAsksSentinelForSlaves(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('SENTINEL', ['slaves', 'svc'])]
            )
            ->willReturnOnConsecutiveCalls(
                [
                    [
                        'name', '127.0.0.1:6382',
                        'ip', '127.0.0.1',
                        'port', '6382',
                        'runid', '112cdebd22924a7d962be496f3a1c4c7c9bad93f',
                        'flags', 'slave',
                        'master-host', '127.0.0.1',
                        'master-port', '6381',
                    ],
                    [
                        'name', '127.0.0.1:6383',
                        'ip', '127.0.0.1',
                        'port', '6383',
                        'runid', '1c0bf1291797fbc5608c07a17da394147dc62817',
                        'flags', 'slave',
                        'master-host', '127.0.0.1',
                        'master-port', '6381',
                    ],
                ]
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $slaves = $replication->getSlaves();

        $this->assertSame('127.0.0.1:6382', (string) $slaves[0]);
        $this->assertSame('127.0.0.1:6383', (string) $slaves[1]);
    }

    /**
     * @group disconnected
     */
    public function testMethodGetSlavesThrowsExceptionOnNoAvailableSentinels(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('No sentinel server available for autodiscovery.');

        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['slaves', 'svc']
            ))
            ->willThrowException(
                new Connection\ConnectionException($sentinel1, 'Unknown connection error [127.0.0.1:5381]')
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->getSlaves();
    }

    /**
     * @group disconnected
     */
    public function testMethodConnectThrowsExceptionOnConnectWithEmptySentinelsPool(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('No sentinel server available for autodiscovery.');

        $replication = $this->getReplicationConnection('svc', []);
        $replication->connect();
    }

    /**
     * @group disconnected
     */
    public function testMethodConnectForcesConnectionToSlave(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->never())
            ->method('connect');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->once())
            ->method('connect');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);

        $replication->connect();
    }

    /**
     * @group disconnected
     */
    public function testMethodConnectOnEmptySlavePoolAsksSentinelForSlavesAndForcesConnectionToSlave(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['slaves', 'svc']
            ))
            ->willReturn(
                [
                    [
                        'name', '127.0.0.1:6382',
                        'ip', '127.0.0.1',
                        'port', '6382',
                        'runid', '112cdebd22924a7d962be496f3a1c4c7c9bad93f',
                        'flags', 'slave',
                        'master-host', '127.0.0.1',
                        'master-port', '6381',
                    ],
                ]
            );

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->never())
            ->method('connect');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->once())
            ->method('connect');

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '127.0.0.1',
                'port' => '6382',
                'role' => 'slave',
            ])
            ->willReturn($slave1);

        $replication = $this->getReplicationConnection('svc', [$sentinel1], $factory);

        $replication->add($master);

        $replication->connect();
    }

    /**
     * @group disconnected
     */
    public function testMethodConnectOnEmptySlavePoolAsksSentinelForSlavesAndForcesConnectionToMasterIfStillEmpty(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('SENTINEL', ['slaves', 'svc'])],
                [$this->isRedisCommand('SENTINEL', ['get-master-addr-by-name', 'svc'])]
            )
            ->willReturnOnConsecutiveCalls(
                [],
                ['127.0.0.1', '6381']
            );

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->once())
            ->method('connect');

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '127.0.0.1',
                'port' => '6381',
                'role' => 'master',
            ])
            ->willReturn($master);

        $replication = $this->getReplicationConnection('svc', [$sentinel1], $factory);

        $replication->connect();
    }

    /**
     * @group disconnected
     */
    public function testMethodDisconnectForcesDisconnectionOnAllConnectionsInPool(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->never())
            ->method('disconnect');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->once())
            ->method('disconnect');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->once())
            ->method('disconnect');

        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6383?role=slave');
        $slave2
            ->expects($this->once())
            ->method('disconnect');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($slave2);

        $replication->disconnect();
    }

    /**
     * @group disconnected
     */
    public function testMethodIsConnectedReturnConnectionStatusOfCurrentConnection(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->exactly(2))
            ->method('isConnected')
            ->willReturnOnConsecutiveCalls(true, false);

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($slave1);

        $this->assertFalse($replication->isConnected());
        $replication->connect();
        $this->assertTrue($replication->isConnected());
        $replication->getConnectionById('127.0.0.1:6382')->disconnect();
        $this->assertFalse($replication->isConnected());
    }

    /**
     * @group disconnected
     */
    public function testMethodGetConnectionByIdReturnsConnectionWhenFound(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);

        $this->assertSame($master, $replication->getConnectionById('127.0.0.1:6381'));
        $this->assertSame($slave1, $replication->getConnectionById('127.0.0.1:6382'));
        $this->assertNull($replication->getConnectionById('127.0.0.1:6383'));
    }

    /**
     * @group disconnected
     */
    public function testMethodSwitchToSelectsCurrentConnection(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->once())
            ->method('connect');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->never())
            ->method('connect');

        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave2
            ->expects($this->once())
            ->method('connect');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($slave2);

        $replication->switchTo($master);
        $this->assertSame($master, $replication->getCurrent());

        $replication->switchTo($slave2);
        $this->assertSame($slave2, $replication->getCurrent());
    }

    /**
     * @group disconnected
     */
    public function testMethodSwitchToThrowsExceptionOnConnectionNotFound(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Invalid connection or connection not found.');

        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6383?role=slave');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);

        $replication->switchTo($slave2);
    }

    /**
     * @group disconnected
     */
    public function testMethodSwitchToMasterSelectsCurrentConnectionToMaster(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->once())
            ->method('connect');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->never())
            ->method('connect');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);

        $replication->switchToMaster();

        $this->assertSame($master, $replication->getCurrent());
    }

    /**
     * @group disconnected
     */
    public function testMethodSwitchToSlaveSelectsCurrentConnectionToRandomSlave(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->never())
            ->method('connect');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->once())
            ->method('connect');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);

        $replication->switchToSlave();

        $this->assertSame($slave1, $replication->getCurrent());
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByCommandReturnsMasterForWriteCommands(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->exactly(2))
            ->method('isConnected')
            ->willReturnOnConsecutiveCalls(false, true);
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('ROLE')]
            )
            ->willReturnOnConsecutiveCalls(
                ['master', 3129659, [['127.0.0.1', 6382, 3129242]]]
            );

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);

        $this->assertSame($master, $replication->getConnectionByCommand(
            Command\RawCommand::create('set', 'key', 'value')
        ));

        $this->assertSame($master, $replication->getConnectionByCommand(
            Command\RawCommand::create('del', 'key')
        ));
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByCommandReturnsSlaveForReadOnlyCommands(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->exactly(2))
            ->method('isConnected')
            ->willReturnOnConsecutiveCalls(false, true);
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('ROLE')]
            )
            ->willReturnOnConsecutiveCalls(
                ['slave', '127.0.0.1', 9000, 'connected', 3167038]
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);

        $this->assertSame($slave1, $replication->getConnectionByCommand(
            Command\RawCommand::create('get', 'key')
        ));

        $this->assertSame($slave1, $replication->getConnectionByCommand(
            Command\RawCommand::create('exists', 'key')
        ));
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByCommandSwitchesToMasterAfterWriteCommand(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->exactly(2))
            ->method('isConnected')
            ->willReturnOnConsecutiveCalls(false, true);
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('ROLE')]
            )
            ->willReturnOnConsecutiveCalls(
                ['master', 3129659, [['127.0.0.1', 6382, 3129242]]]
            );

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->once())
            ->method('isConnected')
            ->willReturnOnConsecutiveCalls(false);
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('ROLE')]
            )
            ->willReturnOnConsecutiveCalls(
                ['slave', '127.0.0.1', 9000, 'connected', 3167038]
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);

        $this->assertSame($slave1, $replication->getConnectionByCommand(
            Command\RawCommand::create('exists', 'key')
        ));

        $this->assertSame($master, $replication->getConnectionByCommand(
            Command\RawCommand::create('set', 'key', 'value')
        ));

        $this->assertSame($master, $replication->getConnectionByCommand(
            Command\RawCommand::create('get', 'key')
        ));
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByCommandThrowsExceptionOnNodeRoleMismatch(): void
    {
        $this->expectException('Predis\Replication\RoleException');
        $this->expectExceptionMessage('Expected master but got slave [127.0.0.1:6381]');

        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(false);
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('ROLE')]
            )
            ->willReturnOnConsecutiveCalls(
                ['slave', '127.0.0.1', 9000, 'connected', 3167038]
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);

        $replication->getConnectionByCommand(Command\RawCommand::create('del', 'key'));
    }

    /**
     * @group disconnected
     */
    public function testGetConnectionByCommandReturnsMasterForReadOnlyOperationsOnUnavailableSlaves(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('SENTINEL', ['slaves', 'svc'])]
            )
            ->willReturnOnConsecutiveCalls(
                [
                    [
                        'name', '127.0.0.1:6382',
                        'ip', '127.0.0.1',
                        'port', '6382',
                        'runid', '1c0bf1291797fbc5608c07a17da394147dc62817',
                        'flags', 'slave,s_down,disconnected',
                        'master-host', '127.0.0.1',
                        'master-port', '6381',
                    ],
                ]
            );

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->once())
            ->method('isConnected')
            ->willReturn(false);
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('ROLE')]
            )
            ->willReturnOnConsecutiveCalls(
                ['master', '0', []]
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);

        $replication->getConnectionByCommand(Command\RawCommand::create('get', 'key'));
    }

    /**
     * @group disconnected
     */
    public function testMethodExecuteCommandSendsCommandToNodeAndReturnsResponse(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $cmdGet = Command\RawCommand::create('get', 'key');
        $cmdGetResponse = 'value';

        $cmdSet = Command\RawCommand::create('set', 'key', 'value');
        $cmdSetResponse = Response\Status::get('OK');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(true);
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('SET', ['key', $cmdGetResponse])]
            )
            ->willReturnOnConsecutiveCalls(
                $cmdSetResponse
            );

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(true);
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('GET', ['key'])]
            )
            ->willReturnOnConsecutiveCalls(
                $cmdGetResponse
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);
        $replication->add($slave1);

        $this->assertSame($cmdGetResponse, $replication->executeCommand($cmdGet));
        $this->assertSame($cmdSetResponse, $replication->executeCommand($cmdSet));
    }

    /**
     * @group disconnected
     */
    public function testMethodExecuteCommandRetriesReadOnlyCommandOnNextSlaveOnFailure(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['slaves', 'svc']
            ))
            ->willReturn(
                [
                    [
                        'name', '127.0.0.1:6383',
                        'ip', '127.0.0.1',
                        'port', '6383',
                        'runid', '1c0bf1291797fbc5608c07a17da394147dc62817',
                        'flags', 'slave',
                        'master-host', '127.0.0.1',
                        'master-port', '6381',
                    ],
                ]
            );

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(true);

        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave1
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(true);
        $slave1
            ->expects($this->once())
            ->method('executeCommand')
            ->with(
                $this->isRedisCommand('GET', ['key'])
            )
            ->willThrowException(
                new Connection\ConnectionException($slave1, 'Unknown connection error [127.0.0.1:6382]')
            );

        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6383?role=slave');
        $slave2
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(true);
        $slave2
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('GET', ['key'])]
            )
            ->willReturnOnConsecutiveCalls(
                'value'
            );

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '127.0.0.1',
                'port' => '6383',
                'role' => 'slave',
            ])
            ->willReturn($slave2);

        $replication = $this->getReplicationConnection('svc', [$sentinel1], $factory);

        $replication->add($master);
        $replication->add($slave1);

        $this->assertSame('value', $replication->executeCommand(
            Command\RawCommand::create('get', 'key')
        ));
    }

    /**
     * @group disconnected
     */
    public function testMethodExecuteCommandRetriesWriteCommandOnNewMasterOnFailure(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['get-master-addr-by-name', 'svc']
            ))
            ->willReturn(
                ['127.0.0.1', '6391']
            );

        $masterOld = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $masterOld
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(true);
        $masterOld
            ->expects($this->once())
            ->method('executeCommand')
            ->with(
                $this->isRedisCommand('DEL', ['key'])
            )
            ->willThrowException(
                new Connection\ConnectionException($masterOld, 'Unknown connection error [127.0.0.1:6381]')
            );

        $masterNew = $this->getMockConnection('tcp://127.0.0.1:6391?role=master');
        $masterNew
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(true);
        $masterNew
            ->expects($this->once())
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('DEL', ['key'])]
            )
            ->willReturnOnConsecutiveCalls(
                1
            );

        /** @var Connection\FactoryInterface|MockObject */
        $factory = $this->getMockBuilder('Predis\Connection\FactoryInterface')->getMock();
        $factory
            ->expects($this->once())
            ->method('create')
            ->with([
                'host' => '127.0.0.1',
                'port' => '6391',
                'role' => 'master',
            ])
            ->willReturn($masterNew);

        $replication = $this->getReplicationConnection('svc', [$sentinel1], $factory);

        $replication->add($masterOld);

        $this->assertSame(1, $replication->executeCommand(
            Command\RawCommand::create('del', 'key')
        ));
    }

    /**
     * @group disconnected
     */
    public function testMethodExecuteCommandThrowsExceptionOnUnknownServiceName(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR No such master with that name');

        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['get-master-addr-by-name', 'svc']
            ))
            ->willReturn(null);

        $masterOld = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $masterOld
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(true);
        $masterOld
            ->expects($this->once())
            ->method('executeCommand')
            ->with(
                $this->isRedisCommand('DEL', ['key'])
            )
            ->willThrowException(
                new Connection\ConnectionException($masterOld, 'Unknown connection error [127.0.0.1:6381]')
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($masterOld);

        $replication->executeCommand(
            Command\RawCommand::create('del', 'key')
        );
    }

    /**
     * @group disconnected
     */
    public function testMethodExecuteCommandThrowsExceptionOnConnectionFailureAndNoAvailableSentinels(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('No sentinel server available for autodiscovery.');

        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');
        $sentinel1
            ->expects($this->any())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['get-master-addr-by-name', 'svc']
            ))
            ->willThrowException(
                new Connection\ConnectionException($sentinel1, 'Unknown connection error [127.0.0.1:5381]')
            );

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $master
            ->expects($this->any())
            ->method('isConnected')
            ->willReturn(true);
        $master
            ->expects($this->once())
            ->method('executeCommand')
            ->with(
                $this->isRedisCommand('DEL', ['key'])
            )
            ->willThrowException(
                new Connection\ConnectionException($master, 'Unknown connection error [127.0.0.1:6381]')
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1]);

        $replication->add($master);

        $replication->executeCommand(
            Command\RawCommand::create('del', 'key')
        );
    }

    /**
     * @group disconnected
     */
    public function testMethodGetReplicationStrategyReturnsInstance(): void
    {
        $strategy = new Replication\ReplicationStrategy();
        $factory = new Connection\Factory();

        $replication = new SentinelReplication(
            'svc', ['tcp://127.0.0.1:5381?role=sentinel'], $factory, $strategy
        );

        $this->assertSame($strategy, $replication->getReplicationStrategy());
    }

    /**
     * @group disconnected
     */
    public function testMethodSerializeCanSerializeWholeObject(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel');

        $master = $this->getMockConnection('tcp://127.0.0.1:6381?role=master');
        $slave1 = $this->getMockConnection('tcp://127.0.0.1:6382?role=slave');
        $slave2 = $this->getMockConnection('tcp://127.0.0.1:6383?role=slave');

        $strategy = new Replication\ReplicationStrategy();
        $factory = new Connection\Factory();

        $replication = new SentinelReplication('svc', [$sentinel1], $factory, $strategy);

        $replication->add($master);
        $replication->add($slave1);
        $replication->add($slave2);

        $unserialized = unserialize(serialize($replication));

        $this->assertEquals($master, $unserialized->getConnectionById('127.0.0.1:6381'));
        $this->assertEquals($slave1, $unserialized->getConnectionById('127.0.0.1:6382'));
        $this->assertEquals($master, $unserialized->getConnectionById('127.0.0.1:6383'));
        $this->assertEquals($strategy, $unserialized->getReplicationStrategy());
    }

    /**
     * @group disconnected
     */
    public function testMethodGetSentinelConnectionAfterSentinelRestart(): void
    {
        $sentinel1 = $this->getMockSentinelConnection('tcp://127.0.0.1:5381?role=sentinel&alias=sentinel1');
        $sentinel1
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['sentinels', 'svc']
            ))
            ->willReturnOnConsecutiveCalls(
                $this->throwException(new Connection\ConnectionException($sentinel1, 'Unknown connection error [127.0.0.1:5381]')),
                [
                    [
                        'name', '127.0.0.1:5382',
                        'ip', '127.0.0.1',
                        'port', '5382',
                        'runid', 'f53b52d281be5cdd4873700c94846af8dbe47209',
                        'flags', 'sentinel',
                    ],
                ]
            );

        $sentinel2 = $this->getMockSentinelConnection('tcp://127.0.0.1:5382?role=sentinel&alias=sentinel2');
        $sentinel2
            ->expects($this->once())
            ->method('executeCommand')
            ->with($this->isRedisCommand(
                'SENTINEL', ['sentinels', 'svc']
            ))
            ->willThrowException(
                new Connection\ConnectionException($sentinel2, 'Unknown connection error [127.0.0.1:5382]')
            );

        $replication = $this->getReplicationConnection('svc', [$sentinel1, $sentinel2]);
        try {
            $replication->updateSentinels();
        } catch (\Predis\ClientException $exception) {
            $this->assertEquals('No sentinel server available for autodiscovery.', $exception->getMessage());
        }

        $replication->updateSentinels();
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Creates a new instance of replication connection.
     *
     * @param string                          $service   Name of the service
     * @param array                           $sentinels Array of sentinels
     * @param ConnectionFactoryInterface|null $factory   Optional connection factory instance
     *
     * @return SentinelReplication
     */
    protected function getReplicationConnection(string $service, array $sentinels, ?Connection\FactoryInterface $factory = null): SentinelReplication
    {
        $factory = $factory ?: new Connection\Factory();

        $replication = new SentinelReplication($service, $sentinels, $factory);
        $replication->setRetryWait(0);

        return $replication;
    }

    /**
     * Returns a base mocked connection from Predis\Connection\NodeConnectionInterface.
     *
     * @param array|string $parameters Optional parameters
     *
     * @return mixed
     */
    protected function getMockSentinelConnection($parameters = null)
    {
        $connection = $this->getMockConnection($parameters);

        return $connection;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Monitor\ConsumerTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Monitor;

use Predis\Client;
use Predis\Monitor\Consumer as MonitorConsumer;
use PredisTestCase;

/**
 * @group realm-monitor
 */
class ConsumerTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testMonitorConsumerRequireMonitorCommand(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("'MONITOR' is not supported by the current command factory.");

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->once())
            ->method('supports')
            ->with('MONITOR')
            ->willReturn(false);

        $client = new Client(null, ['commands' => $commands]);

        new MonitorConsumer($client);
    }

    /**
     * @group disconnected
     */
    public function testMonitorConsumerDoesNotWorkOnClusters(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage('Cannot initialize a monitor consumer over cluster connections');

        $cluster = $this->getMockBuilder('Predis\Connection\Cluster\ClusterInterface')->getMock();
        $client = new Client($cluster);

        new MonitorConsumer($client);
    }

    /**
     * @group disconnected
     */
    public function testConstructorStartsConsumer(): void
    {
        $cmdMonitor = $this->getCommandFactory()->create('monitor');
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['createCommand', 'executeCommand'])
            ->setConstructorArgs([$connection])
            ->getMock();
        $client
            ->expects($this->once())
            ->method('createCommand')
            ->with('MONITOR', [])
            ->willReturn($cmdMonitor);
        $client
            ->expects($this->once())
            ->method('executeCommand')
            ->with($cmdMonitor);

        new MonitorConsumer($client);
    }

    /**
     * @group disconnected
     *
     * @todo Investigate why disconnect() is invoked 2 times in this test, but
     *       the reason is probably that the GC invokes __destruct() on monitor
     *       thus calling disconnect() a second time at the end of the test.
     */
    public function testStoppingConsumerClosesConnection(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['disconnect'])
            ->setConstructorArgs([$connection])
            ->getMock();
        $client
            ->expects($this->exactly(2))
            ->method('disconnect');

        $monitor = new MonitorConsumer($client);

        $monitor->stop();
    }

    /**
     * @group disconnected
     */
    public function testGarbageCollectorRunStopsConsumer(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        /** @var \Predis\ClientInterface */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['disconnect'])
            ->setConstructorArgs([$connection])
            ->getMock();
        $client
            ->expects($this->once())
            ->method('disconnect');

        $monitor = new MonitorConsumer($client);

        unset($monitor);
    }

    /**
     * @group disconnected
     */
    public function testReadsMessageFromConnectionToRedis24(): void
    {
        $message = '1323367530.939137 (db 15) "MONITOR"';

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('read')
            ->willReturn($message);

        $client = new Client($connection);

        $monitor = new MonitorConsumer($client);
        $payload = $monitor->current();

        $this->assertSame(1323367530, (int) $payload->timestamp);
        $this->assertSame(15, $payload->database);
        $this->assertNull($payload->client);
        $this->assertSame('MONITOR', $payload->command);
        $this->assertNull($payload->arguments);
    }

    /**
     * @group disconnected
     */
    public function testReadsMessageFromConnectionToRedis26(): void
    {
        $message = '1323367530.939137 [15 127.0.0.1:37265] "MONITOR"';

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('read')
            ->willReturn($message);

        $client = new Client($connection);

        $monitor = new MonitorConsumer($client);
        $payload = $monitor->current();

        $this->assertSame(1323367530, (int) $payload->timestamp);
        $this->assertSame(15, $payload->database);
        $this->assertSame('127.0.0.1:37265', $payload->client);
        $this->assertSame('MONITOR', $payload->command);
        $this->assertNull($payload->arguments);
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    /**
     * @group connected
     */
    public function testMonitorAgainstRedisServer(): void
    {
        $parameters = [
            'host' => constant('REDIS_SERVER_HOST'),
            'port' => constant('REDIS_SERVER_PORT'),
            'database' => constant('REDIS_SERVER_DBNUM'),
            // Prevents suite from handing on broken test
            'read_write_timeout' => 2,
        ];

        $echoed = [];

        $producer = new Client($parameters);
        $producer->connect();

        $consumer = new Client($parameters);
        $consumer->connect();

        $monitor = new MonitorConsumer($consumer);

        $producer->echo('message1');
        $producer->echo('message2');
        $producer->echo('QUIT');

        foreach ($monitor as $message) {
            if ($message->command == 'ECHO') {
                $echoed[] = $arguments = trim($message->arguments, '"');
                if ($arguments == 'QUIT') {
                    $monitor->stop();
                }
            }
        }

        $this->assertSame(['message1', 'message2', 'QUIT'], $echoed);
        $this->assertFalse($monitor->valid());
        $this->assertEquals('PONG', $consumer->ping());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Pipeline\AtomicTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Pipeline;

use Predis\Client;
use Predis\Response;
use PredisTestCase;

class AtomicTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testPipelineWithSingleConnection(): void
    {
        $pong = new Response\Status('PONG');
        $queued = new Response\Status('QUEUED');

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('MULTI')],
                [$this->isRedisCommand('EXEC')]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Status('OK'),
                [$pong, $pong, $pong]
            );
        $connection
            ->expects($this->exactly(3))
            ->method('writeRequest')
            ->withConsecutive(
                [$this->isRedisCommand('PING')],
                [$this->isRedisCommand('PING')],
                [$this->isRedisCommand('PING')]
            );
        $connection
            ->expects($this->exactly(3))
            ->method('readResponse')
            ->willReturnOnConsecutiveCalls(
                $queued,
                $queued,
                $queued
            );

        $pipeline = new Atomic(new Client($connection));

        $pipeline->ping();
        $pipeline->ping();
        $pipeline->ping();

        $this->assertSame([$pong, $pong, $pong], $pipeline->execute());
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnAbortedTransaction(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('The underlying transaction has been aborted by the server');

        $queued = new Response\Status('QUEUED');

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('MULTI')],
                [$this->isRedisCommand('EXEC')]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Status('OK'),
                null
            );
        $connection
            ->expects($this->exactly(3))
            ->method('writeRequest')
            ->withConsecutive(
                [$this->isRedisCommand('PING')],
                [$this->isRedisCommand('PING')],
                [$this->isRedisCommand('PING')]
            );
        $connection
            ->expects($this->exactly(3))
            ->method('readResponse')
            ->willReturnOnConsecutiveCalls(
                $queued,
                $queued,
                $queued
            );

        $pipeline = new Atomic(new Client($connection));

        $pipeline->ping();
        $pipeline->ping();
        $pipeline->ping();

        $pipeline->execute();
    }

    /**
     * @group disconnected
     */
    public function testPipelineWithErrorInTransaction(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR Test error');

        $queued = new Response\Status('QUEUED');
        $error = new Response\Error('ERR Test error');

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('MULTI')],
                [$this->isRedisCommand('DISCARD')]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Status('OK'),
                new Response\Status('OK')
            );
        $connection
            ->expects($this->exactly(3))
            ->method('writeRequest')
            ->withConsecutive(
                [$this->isRedisCommand('PING')],
                [$this->isRedisCommand('PING')],
                [$this->isRedisCommand('PING')]
            );
        $connection
            ->expects($this->exactly(3))
            ->method('readResponse')
            ->willReturnOnConsecutiveCalls(
                $queued,
                $queued,
                $error
            );

        $pipeline = new Atomic(new Client($connection));

        $pipeline->ping();
        $pipeline->ping();
        $pipeline->ping();

        $pipeline->execute();
    }

    /**
     * @group disconnected
     */
    public function testThrowsServerExceptionOnResponseErrorByDefault(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR Test error');

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('MULTI')],
                [$this->isRedisCommand('DISCARD')]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Status('OK'),
                new Response\Status('OK')
            );
        $connection
            ->expects($this->exactly(2))
            ->method('writeRequest')
            ->withConsecutive(
                [$this->isRedisCommand('PING')],
                [$this->isRedisCommand('PING')]
            );
        $connection
            ->expects($this->once())
            ->method('readResponse')
            ->willReturn(
                new Response\Error('ERR Test error')
            );

        $pipeline = new Atomic(new Client($connection));

        $pipeline->ping();
        $pipeline->ping();

        $pipeline->execute();
    }

    /**
     * @group disconnected
     */
    public function testReturnsResponseErrorWithClientExceptionsSetToFalse(): void
    {
        $pong = new Response\Status('PONG');
        $queued = new Response\Status('QUEUED');
        $error = new Response\Error('ERR Test error');

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('executeCommand')
            ->withConsecutive(
                [$this->isRedisCommand('MULTI')],
                [$this->isRedisCommand('EXEC')]
            )
            ->willReturnOnConsecutiveCalls(
                new Response\Status('OK'),
                [$pong, $pong, $error]
            );
        $connection
            ->expects($this->exactly(3))
            ->method('writeRequest')
            ->withConsecutive(
                [$this->isRedisCommand('PING')],
                [$this->isRedisCommand('PING')],
                [$this->isRedisCommand('PING')]
            );
        $connection
            ->expects($this->exactly(3))
            ->method('readResponse')
            ->willReturnOnConsecutiveCalls(
                $queued,
                $queued,
                $queued
            );

        $pipeline = new Atomic(new Client($connection, ['exceptions' => false]));

        $pipeline->ping();
        $pipeline->ping();
        $pipeline->ping();

        $this->assertSame([$pong, $pong, $error], $pipeline->execute());
    }

    /**
     * @group disconnected
     */
    public function testExecutorWithAggregateConnection(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage("The class 'Predis\Pipeline\Atomic' does not support aggregate connections");

        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();
        $pipeline = new Atomic(new Client($connection));

        $pipeline->ping();

        $pipeline->execute();
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Pipeline\FireAndForgetTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Pipeline;

use Predis\Client;
use PredisTestCase;

class FireAndForgetTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testPipelineWithSingleConnection(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(3))
            ->method('writeRequest');
        $connection
            ->expects($this->never())
            ->method('readResponse');

        $pipeline = new FireAndForget(new Client($connection));

        $pipeline->ping();
        $pipeline->ping();
        $pipeline->ping();

        $this->assertEmpty($pipeline->execute());
    }

    /**
     * @group disconnected
     */
    public function testSwitchesToMasterWithReplicationConnection(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\Replication\ReplicationInterface')
            ->getMock();
        $connection
            ->expects($this->once())
            ->method('switchToMaster');
        $connection
            ->expects($this->exactly(3))
            ->method('writeRequest');
        $connection
            ->expects($this->never())
            ->method('readResponse');

        $pipeline = new FireAndForget(new Client($connection));

        $pipeline->ping();
        $pipeline->ping();
        $pipeline->ping();

        $this->assertEmpty($pipeline->execute());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Pipeline\PipelineTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Pipeline;

use Exception;
use InvalidArgumentException;
use Predis\Client;
use Predis\ClientException;
use Predis\ClientInterface;
use Predis\Command\CommandInterface;
use Predis\Response;
use PredisTestCase;
use stdClass;

class PipelineTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testConstructor(): void
    {
        $client = new Client();
        $pipeline = new Pipeline($client);

        $this->assertSame($client, $pipeline->getClient());
    }

    /**
     * @group disconnected
     */
    public function testCallDoesNotSendCommandsWithoutExecute(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('writeRequest');
        $connection
            ->expects($this->never())
            ->method('readResponse');

        $pipeline = new Pipeline(new Client($connection));

        $pipeline->echo('one');
        $pipeline->echo('two');
        $pipeline->echo('three');
    }

    /**
     * @group disconnected
     */
    public function testCallReturnsPipelineForFluentInterface(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('writeRequest');
        $connection
            ->expects($this->never())
            ->method('readResponse');

        $pipeline = new Pipeline(new Client($connection));

        $this->assertSame($pipeline, $pipeline->echo('one'));
        $this->assertSame($pipeline, $pipeline->echo('one')->echo('two')->echo('three'));
    }

    /**
     * @group disconnected
     */
    public function testDoesNotParseComplexResponseObjects(): void
    {
        $object = $this->getMockBuilder('Predis\Response\ResponseInterface')->getMock();

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('readResponse')
            ->willReturn($object);

        $pipeline = new Pipeline(new Client($connection));

        $pipeline->ping();

        $this->assertSame([$object], $pipeline->execute());
    }

    /**
     * @group disconnected
     */
    public function testThrowsServerExceptionOnResponseErrorByDefault(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR Test error');

        $error = new Response\Error('ERR Test error');

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('readResponse')
            ->willReturn($error);

        $pipeline = new Pipeline(new Client($connection));

        $pipeline->ping();
        $pipeline->ping();

        $pipeline->execute();
    }

    /**
     * @group disconnected
     */
    public function testReturnsResponseErrorWithClientExceptionsSetToFalse(): void
    {
        $error = $this->getMockBuilder('Predis\Response\ErrorInterface')->getMock();

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(2))
            ->method('readResponse')
            ->willReturn($error);

        $client = new Client($connection, ['exceptions' => false]);

        $pipeline = new Pipeline($client);

        $pipeline->ping();
        $pipeline->ping();

        $this->assertSame([$error, $error], $pipeline->execute());
    }

    /**
     * @group disconnected
     */
    public function testExecuteReturnsPipelineForFluentInterface(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $command = $this->getCommandFactory()->create('echo', ['one']);

        $pipeline = new Pipeline(new Client($connection));

        $this->assertSame($pipeline, $pipeline->executeCommand($command));
    }

    /**
     * @group disconnected
     */
    public function testExecuteCommandDoesNotSendCommandsWithoutExecute(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('writeRequest');
        $connection
            ->expects($this->never())
            ->method('readResponse');

        $commands = $this->getCommandFactory();

        $pipeline = new Pipeline(new Client($connection));

        $pipeline->executeCommand($commands->create('echo', ['one']));
        $pipeline->executeCommand($commands->create('echo', ['two']));
        $pipeline->executeCommand($commands->create('echo', ['three']));
    }

    /**
     * @group disconnected
     */
    public function testExecuteWithEmptyBuffer(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('writeRequest');
        $connection
            ->expects($this->never())
            ->method('readResponse');

        $pipeline = new Pipeline(new Client($connection));

        $this->assertSame([], $pipeline->execute());
    }

    /**
     * @group disconnected
     */
    public function testExecuteWithFilledBuffer(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(3))
            ->method('writeRequest');
        $connection
            ->expects($this->exactly(3))
            ->method('readResponse')
            ->willReturnCallback($this->getReadCallback());

        $pipeline = new Pipeline(new Client($connection));

        $pipeline->echo('one');
        $pipeline->echo('two');
        $pipeline->echo('three');

        $pipeline->flushPipeline();

        $this->assertSame(['one', 'two', 'three'], $pipeline->execute());
    }

    /**
     * @group disconnected
     */
    public function testFlushWithFalseArgumentDiscardsBuffer(): void
    {
        $pipeline = new Pipeline(new Client());

        $pipeline->echo('one');
        $pipeline->echo('two');
        $pipeline->echo('three');

        $pipeline->flushPipeline(false);

        $this->assertSame([], $pipeline->execute());
    }

    /**
     * @group disconnected
     */
    public function testFlushHandlesPartialBuffers(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(4))
            ->method('writeRequest');
        $connection
            ->expects($this->exactly(4))
            ->method('readResponse')
            ->willReturnCallback($this->getReadCallback());

        $pipeline = new Pipeline(new Client($connection));

        $pipeline->echo('one');
        $pipeline->echo('two');
        $pipeline->flushPipeline();
        $pipeline->echo('three');
        $pipeline->echo('four');

        $this->assertSame(['one', 'two', 'three', 'four'], $pipeline->execute());
    }

    /**
     * @group disconnected
     */
    public function testSwitchesToMasterWithReplicationConnection(): void
    {
        $pong = new Response\Status('PONG');

        $connection = $this->getMockBuilder('Predis\Connection\Replication\ReplicationInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('switchToMaster');
        $connection
            ->expects($this->exactly(3))
            ->method('writeRequest');
        $connection
            ->expects($this->exactly(3))
            ->method('readResponse')
            ->willReturn($pong);

        $pipeline = new Pipeline(new Client($connection));

        $pipeline->ping();
        $pipeline->ping();
        $pipeline->ping();

        $this->assertSame([$pong, $pong, $pong], $pipeline->execute());
    }

    /**
     * @group disconnected
     */
    public function testExecuteAcceptsCallableArgument(): void
    {
        $test = $this;
        $pipeline = new Pipeline(new Client());

        $callable = function (Pipeline $pipe) use ($test, $pipeline) {
            $test->assertSame($pipeline, $pipe);
            $pipe->flushPipeline(false);
        };

        $pipeline->execute($callable);
    }

    /**
     * @group disconnected
     */
    public function testExecuteDoesNotAcceptNonCallableArgument(): void
    {
        $this->expectException('InvalidArgumentException');

        $noncallable = new stdClass();

        $pipeline = new Pipeline(new Client());
        $pipeline->execute($noncallable);
    }

    /**
     * @group disconnected
     */
    public function testExecuteInsideCallableArgumentThrowsException(): void
    {
        $this->expectException('Predis\ClientException');

        $pipeline = new Pipeline(new Client());

        $pipeline->execute(function (Pipeline $pipe) {
            $pipe->execute();
        });
    }

    /**
     * @group disconnected
     */
    public function testExecuteWithCallableArgumentRunsPipelineInCallable(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->exactly(4))
            ->method('writeRequest');
        $connection
            ->expects($this->exactly(4))
            ->method('readResponse')
            ->willReturnCallback($this->getReadCallback());

        $pipeline = new Pipeline(new Client($connection));

        $responses = $pipeline->execute(function (Pipeline $pipe) {
            $pipe->echo('one');
            $pipe->echo('two');
            $pipe->echo('three');
            $pipe->echo('four');
        });

        $this->assertSame(['one', 'two', 'three', 'four'], $responses);
    }

    /**
     * @group disconnected
     */
    public function testExecuteWithCallableArgumentHandlesExceptions(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->never())
            ->method('writeRequest');
        $connection
            ->expects($this->never())
            ->method('readResponse');

        $exception = null;
        $responses = null;

        $pipeline = new Pipeline(new Client($connection));

        try {
            $responses = $pipeline->execute(function (Pipeline $pipe) {
                $pipe->echo('one');
                $pipe->echo('two');
                throw new ClientException('TEST');
            });
        } catch (Exception $exception) {
            // NOOP
        }

        $this->assertInstanceOf('Predis\ClientException', $exception);
        $this->assertSame('TEST', $exception->getMessage());
        $this->assertNull($responses);
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    /**
     * @group connected
     */
    public function testIntegrationWithFluentInterface(): void
    {
        $pipeline = $this->getClient()->pipeline();

        $results = $pipeline
            ->echo('one')
            ->echo('two')
            ->echo('three')
            ->execute();

        $this->assertSame(['one', 'two', 'three'], $results);
    }

    /**
     * @group connected
     */
    public function testIntegrationWithCallableBlock(): void
    {
        $client = $this->getClient();

        $results = $client->pipeline(function (Pipeline $pipe) {
            $pipe->set('foo', 'bar');
            $pipe->get('foo');
        });

        $this->assertEquals(['OK', 'bar'], $results);
        $this->assertSame(1, $client->exists('foo'));
    }

    /**
     * @group connected
     */
    public function testOutOfBandMessagesInsidePipeline(): void
    {
        $oob = null;
        $client = $this->getClient();

        $results = $client->pipeline(function (Pipeline $pipe) use (&$oob) {
            $pipe->set('foo', 'bar');
            $oob = $pipe->getClient()->echo('oob message');
            $pipe->get('foo');
        });

        $this->assertEquals(['OK', 'bar'], $results);
        $this->assertSame('oob message', $oob);
        $this->assertSame(1, $client->exists('foo'));
    }

    /**
     * @group connected
     */
    public function testIntegrationWithClientExceptionInCallableBlock(): void
    {
        $exception = null;

        $client = $this->getClient();

        try {
            $client->pipeline(function (Pipeline $pipe) {
                $pipe->set('foo', 'bar');
                throw new ClientException('TEST');
            });
        } catch (Exception $exception) {
            // NOOP
        }

        $this->assertInstanceOf('Predis\ClientException', $exception);
        $this->assertSame('TEST', $exception->getMessage());
        $this->assertSame(0, $client->exists('foo'));
    }

    /**
     * @group connected
     */
    public function testIntegrationWithServerExceptionInCallableBlock(): void
    {
        $exception = null;

        $client = $this->getClient();

        try {
            $client->pipeline(function (Pipeline $pipe) {
                $pipe->set('foo', 'bar');
                // LPUSH on a string key fails, but won't stop
                // the pipeline to send the commands.
                $pipe->lpush('foo', 'bar');
                $pipe->set('hoge', 'piyo');
            });
        } catch (Exception $exception) {
            // NOOP
        }

        $this->assertInstanceOf('Predis\Response\ServerException', $exception);
        $this->assertSame(1, $client->exists('foo'));
        $this->assertSame(1, $client->exists('hoge'));
    }

    /**
     * @group connected
     */
    public function testIntegrationWithServerErrorInCallableBlock(): void
    {
        $client = $this->getClient([], ['exceptions' => false]);

        $results = $client->pipeline(function (Pipeline $pipe) {
            $pipe->set('foo', 'bar');
            $pipe->lpush('foo', 'bar'); // LPUSH on a string key fails.
            $pipe->get('foo');
        });

        $this->assertEquals('OK', $results[0]);
        $this->assertInstanceOf('Predis\Response\Error', $results[1]);
        $this->assertSame('bar', $results[2]);
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns a client instance connected to the specified Redis server.
     *
     * @param array $parameters Additional connection parameters
     * @param array $options    Additional client options
     *
     * @return ClientInterface
     */
    protected function getClient(array $parameters = [], array $options = []): ClientInterface
    {
        return $this->createClient($parameters, $options);
    }

    /**
     * Helper method returning a callback used to responses to ECHO command.
     *
     * @return callable
     */
    protected function getReadCallback(): callable
    {
        return function (CommandInterface $command) {
            if (($id = $command->getId()) !== 'ECHO') {
                throw new InvalidArgumentException("Expected ECHO, got {$id}");
            }

            [$echoed] = $command->getArguments();

            return $echoed;
        };
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\ProtocolExceptionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol;

require_once __DIR__ . '/../CommunicationExceptionTest.php';

use Exception;
use Predis\CommunicationException;
use Predis\CommunicationExceptionTest;
use Predis\Connection\NodeConnectionInterface;

class ProtocolExceptionTest extends CommunicationExceptionTest
{
    /**
     * {@inheritdoc}
     */
    protected function getException(
        NodeConnectionInterface $connection,
        string $message,
        int $code = 0,
        ?Exception $inner = null
    ): CommunicationException {
        return new ProtocolException($connection, $message, $code, $inner);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\Text\CompositeProtocolProcessorTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\CommandInterface;
use Predis\Connection\CompositeConnectionInterface;
use Predis\Protocol\RequestSerializerInterface;
use Predis\Protocol\ResponseReaderInterface;
use PredisTestCase;

class CompositeProtocolProcessorTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testConstructor(): void
    {
        $protocol = new CompositeProtocolProcessor();

        $this->assertInstanceOf('Predis\Protocol\Text\RequestSerializer', $protocol->getRequestSerializer());
        $this->assertInstanceOf('Predis\Protocol\Text\ResponseReader', $protocol->getResponseReader());
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithArguments(): void
    {
        /** @var RequestSerializerInterface */
        $serializer = $this->getMockBuilder('Predis\Protocol\RequestSerializerInterface')->getMock();
        /** @var ResponseReaderInterface */
        $reader = $this->getMockBuilder('Predis\Protocol\ResponseReaderInterface')->getMock();

        $protocol = new CompositeProtocolProcessor($serializer, $reader);

        $this->assertSame($serializer, $protocol->getRequestSerializer());
        $this->assertSame($reader, $protocol->getResponseReader());
    }

    /**
     * @group disconnected
     */
    public function testCustomRequestSerializer(): void
    {
        /** @var RequestSerializerInterface */
        $serializer = $this->getMockBuilder('Predis\Protocol\RequestSerializerInterface')->getMock();

        $protocol = new CompositeProtocolProcessor();
        $protocol->setRequestSerializer($serializer);

        $this->assertSame($serializer, $protocol->getRequestSerializer());
    }

    /**
     * @group disconnected
     */
    public function testCustomResponseReader(): void
    {
        /** @var ResponseReaderInterface */
        $reader = $this->getMockBuilder('Predis\Protocol\ResponseReaderInterface')->getMock();

        $protocol = new CompositeProtocolProcessor();
        $protocol->setResponseReader($reader);

        $this->assertSame($reader, $protocol->getResponseReader());
    }

    /**
     * @group disconnected
     */
    public function testConnectionWrite(): void
    {
        $serialized = "*1\r\n$4\r\nPING\r\n";

        /** @var CommandInterface */
        $command = $this->getMockBuilder('Predis\Command\CommandInterface')->getMock();
        /** @var CompositeConnectionInterface|MockObject */
        $connection = $this->getMockBuilder('Predis\Connection\CompositeConnectionInterface')->getMock();
        /** @var RequestSerializerInterface|MockObject */
        $serializer = $this->getMockBuilder('Predis\Protocol\RequestSerializerInterface')->getMock();

        $protocol = new CompositeProtocolProcessor($serializer);

        $connection
            ->expects($this->once())
            ->method('writeBuffer')
            ->with($this->equalTo($serialized));

        $serializer
            ->expects($this->once())
            ->method('serialize')
            ->with($command)
            ->willReturn($serialized);

        $protocol->write($connection, $command);
    }

    /**
     * @group disconnected
     */
    public function testConnectionRead(): void
    {
        /** @var CompositeConnectionInterface */
        $connection = $this->getMockBuilder('Predis\Connection\CompositeConnectionInterface')->getMock();
        /** @var ResponseReaderInterface|MockObject */
        $reader = $this->getMockBuilder('Predis\Protocol\ResponseReaderInterface')->getMock();

        $protocol = new CompositeProtocolProcessor(null, $reader);

        $reader
            ->expects($this->once())
            ->method('read')
            ->with($connection)
            ->willReturn('bulk');

        $this->assertSame('bulk', $protocol->read($connection));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\Text\ProtocolProcessorTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\CommandInterface;
use PredisTestCase;

class ProtocolProcessorTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testConnectionWrite(): void
    {
        $serialized = "*1\r\n$4\r\nPING\r\n";
        $protocol = new ProtocolProcessor();

        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\CommandInterface')->getMock();
        $command
            ->expects($this->once())
            ->method('getId')
            ->willReturn('PING');
        $command
            ->expects($this->once())
            ->method('getArguments')
            ->willReturn([]);

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->once())
            ->method('writeBuffer')
            ->with($this->equalTo($serialized));

        $protocol->write($connection, $command);
    }

    /**
     * @group disconnected
     */
    public function testConnectionRead(): void
    {
        $protocol = new ProtocolProcessor();

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->exactly(5))
            ->method('readLine')
            ->willReturnOnConsecutiveCalls(
                '+OK',
                '-ERR error message',
                ':2',
                '$-1',
                '*-1'
            );

        $this->assertEquals('OK', $protocol->read($connection));
        $this->assertEquals('ERR error message', $protocol->read($connection));
        $this->assertSame(2, $protocol->read($connection));
        $this->assertNull($protocol->read($connection));
        $this->assertNull($protocol->read($connection));
    }

    /**
     * @group disconnected
     */
    public function testIterableMultibulkSupport(): void
    {
        $protocol = new ProtocolProcessor();
        $protocol->useIterableMultibulk(true);

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->once())
            ->method('readLine')
            ->willReturn('*1');

        $this->assertInstanceOf('Predis\Response\Iterator\MultiBulk', $protocol->read($connection));
    }

    /**
     * @group disconnected
     */
    public function testUnknownResponsePrefix(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');
        $this->expectExceptionMessage("Unknown response prefix: '!' [tcp://127.0.0.1:6379]");

        $protocol = new ProtocolProcessor();

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface', 'tcp://127.0.0.1:6379');
        $connection
            ->expects($this->once())
            ->method('readLine')
            ->willReturn('!');

        $protocol->read($connection);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\Text\RequestSerializerTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\CommandInterface;
use PredisTestCase;

class RequestSerializerTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testSerializerIdWithNoArguments(): void
    {
        $serializer = new RequestSerializer();

        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\CommandInterface')->getMock();
        $command
            ->expects($this->once())
            ->method('getId')
            ->willReturn('PING');
        $command
            ->expects($this->once())
            ->method('getArguments')
            ->willReturn([]);

        $result = $serializer->serialize($command);

        $this->assertSame("*1\r\n$4\r\nPING\r\n", $result);
    }

    /**
     * @group disconnected
     */
    public function testSerializerIdWithArguments(): void
    {
        $serializer = new RequestSerializer();

        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\CommandInterface')->getMock();
        $command
            ->expects($this->once())
            ->method('getId')
            ->willReturn('SET');
        $command
            ->expects($this->once())
            ->method('getArguments')
            ->willReturn(['key', 'value']);

        $result = $serializer->serialize($command);

        $this->assertSame("*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n", $result);
    }

    /**
     * @group disconnected
     */
    public function testSerializerDoesNotBreakOnArgumentsWithHoles(): void
    {
        $serializer = new RequestSerializer();

        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\CommandInterface')->getMock();
        $command
            ->expects($this->once())
            ->method('getId')
            ->willReturn('DEL');
        $command
            ->expects($this->once())
            ->method('getArguments')
            ->willReturn([0 => 'key:1', 2 => 'key:2']);

        $result = $serializer->serialize($command);

        $this->assertSame("*3\r\n$3\r\nDEL\r\n$5\r\nkey:1\r\n$5\r\nkey:2\r\n", $result);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\Text\ResponseReaderTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use Predis\Protocol\Text\Handler\ResponseHandlerInterface;
use PredisTestCase;

class ResponseReaderTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testDefaultHandlers(): void
    {
        $reader = new ResponseReader();

        $this->assertInstanceOf('Predis\Protocol\Text\Handler\StatusResponse', $reader->getHandler('+'));
        $this->assertInstanceOf('Predis\Protocol\Text\Handler\ErrorResponse', $reader->getHandler('-'));
        $this->assertInstanceOf('Predis\Protocol\Text\Handler\IntegerResponse', $reader->getHandler(':'));
        $this->assertInstanceOf('Predis\Protocol\Text\Handler\BulkResponse', $reader->getHandler('$'));
        $this->assertInstanceOf('Predis\Protocol\Text\Handler\MultiBulkResponse', $reader->getHandler('*'));

        $this->assertNull($reader->getHandler('!'));
    }

    /**
     * @group disconnected
     */
    public function testReplaceHandler(): void
    {
        /** @var ResponseHandlerInterface */
        $handler = $this->getMockBuilder('Predis\Protocol\Text\Handler\ResponseHandlerInterface')->getMock();

        $reader = new ResponseReader();
        $reader->setHandler('+', $handler);

        $this->assertSame($handler, $reader->getHandler('+'));
    }

    /**
     * @group disconnected
     */
    public function testReadResponse(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->exactly(5))
            ->method('readLine')
            ->willReturnOnConsecutiveCalls(
                '+OK',
                '-ERR error message',
                ':2',
                '$-1',
                '*-1'
            );

        $reader = new ResponseReader();

        $this->assertEquals('OK', $reader->read($connection));
        $this->assertEquals('ERR error message', $reader->read($connection));
        $this->assertSame(2, $reader->read($connection));
        $this->assertNull($reader->read($connection));
        $this->assertNull($reader->read($connection));
    }

    /**
     * @group disconnected
     */
    public function testEmptyResponseHeader(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');
        $this->expectExceptionMessage('Unexpected empty response header [tcp://127.0.0.1:6379]');

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface', 'tcp://127.0.0.1:6379');
        $connection
            ->expects($this->once())
            ->method('readLine')
            ->willReturn('');

        $reader = new ResponseReader();
        $reader->read($connection);
    }

    /**
     * @group disconnected
     */
    public function testUnknownResponsePrefix(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');
        $this->expectExceptionMessage("Unknown response prefix: '!' [tcp://127.0.0.1:6379]");

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface', 'tcp://127.0.0.1:6379');
        $connection
            ->expects($this->once())
            ->method('readLine')
            ->willReturn('!');

        $reader = new ResponseReader();
        $reader->read($connection);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\Text\Handler\BulkResponseTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use PredisTestCase;

class BulkResponseTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testZeroLengthBulk(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->once())
            ->method('readBuffer')
            ->with($this->equalTo(2))
            ->willReturn("\r\n");

        $handler = new Handler\BulkResponse();

        $this->assertSame('', $handler->handle($connection, '0'));
    }

    /**
     * @group disconnected
     */
    public function testBulk(): void
    {
        $bulk = 'This is a bulk string.';
        $bulkLengh = strlen($bulk);

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->once())
            ->method('readBuffer')
            ->with($this->equalTo($bulkLengh + 2))
            ->willReturn("$bulk\r\n");

        $handler = new Handler\BulkResponse();

        $this->assertSame($bulk, $handler->handle($connection, (string) $bulkLengh));
    }

    /**
     * @group disconnected
     */
    public function testNull(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\BulkResponse();

        $this->assertNull($handler->handle($connection, '-1'));
    }

    /**
     * @group disconnected
     */
    public function testInvalidLengthString(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');
        $this->expectExceptionMessage("Cannot parse 'invalid' as a valid length for a bulk response [tcp://127.0.0.1:6379]");

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface', 'tcp://127.0.0.1:6379');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\BulkResponse();

        $handler->handle($connection, 'invalid');
    }

    /**
     * @group disconnected
     */
    public function testInvalidLengthInteger(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');
        $this->expectExceptionMessage("Value '-5' is not a valid length for a bulk response [tcp://127.0.0.1:6379]");

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface', 'tcp://127.0.0.1:6379');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\BulkResponse();

        $handler->handle($connection, '-5');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\Text\Handler\ErrorResponseTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use PredisTestCase;

class ErrorResponseTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testOk(): void
    {
        $message = 'ERR Operation against a key holding the wrong kind of value';

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\ErrorResponse();
        $response = $handler->handle($connection, $message);

        $this->assertInstanceOf('Predis\Response\Error', $response);
        $this->assertSame($message, $response->getMessage());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\Text\Handler\IntegerResponseTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use PredisTestCase;

class IntegerResponseTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testInteger(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\IntegerResponse();

        $this->assertSame(0, $handler->handle($connection, '0'));
        $this->assertSame(1, $handler->handle($connection, '1'));
        $this->assertSame(10, $handler->handle($connection, '10'));
        $this->assertSame(-10, $handler->handle($connection, '-10'));
    }

    /**
     * @group disconnected
     */
    public function testNull(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\IntegerResponse();

        $this->assertNull($handler->handle($connection, 'nil'));
    }

    /**
     * @group disconnected
     */
    public function testInvalid(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');
        $this->expectExceptionMessage("Cannot parse 'invalid' as a valid numeric response [tcp://127.0.0.1:6379]");

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface', 'tcp://127.0.0.1:6379');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\IntegerResponse();

        $handler->handle($connection, 'invalid');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\Text\Handler\MultiBulkResponseTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use PredisTestCase;

class MultiBulkResponseTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testMultiBulk(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->once())
            ->method('getProtocol')
            ->willReturn(
                new CompositeProtocolProcessor()
            );
        $connection
            ->expects($this->exactly(2))
            ->method('readLine')
            ->willReturnOnConsecutiveCalls(
                '$3',
                '$3'
            );
        $connection
            ->expects($this->exactly(2))
            ->method('readBuffer')
            ->willReturnOnConsecutiveCalls(
                "foo\r\n",
                "bar\r\n"
            );

        $handler = new Handler\MultiBulkResponse();

        $this->assertSame(['foo', 'bar'], $handler->handle($connection, '2'));
    }

    /**
     * @group disconnected
     */
    public function testNull(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\MultiBulkResponse();

        $this->assertNull($handler->handle($connection, '-1'));
    }

    /**
     * @group disconnected
     */
    public function testInvalid(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');
        $this->expectExceptionMessage("Cannot parse 'invalid' as a valid length of a multi-bulk response [tcp://127.0.0.1:6379]");

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface', 'tcp://127.0.0.1:6379');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\MultiBulkResponse();

        $handler->handle($connection, 'invalid');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\Text\Handler\StatusResponseTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use PredisTestCase;

class StatusResponseTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testOk(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\StatusResponse();
        $response = $handler->handle($connection, 'OK');

        $this->assertInstanceOf('Predis\Response\Status', $response);
        $this->assertEquals('OK', $response);
    }

    /**
     * @group disconnected
     */
    public function testQueued(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\StatusResponse();
        $response = $handler->handle($connection, 'QUEUED');

        $this->assertInstanceOf('Predis\Response\Status', $response);
        $this->assertEquals('QUEUED', $response);
    }

    /**
     * @group disconnected
     */
    public function testPlainString(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\StatusResponse();
        $response = $handler->handle($connection, 'Background saving started');

        $this->assertInstanceOf('Predis\Response\Status', $response);
        $this->assertEquals('Background saving started', $response);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Protocol\Text\Handler\StreamableMultiBulkResponseTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Protocol\Text;

use PredisTestCase;

class StreamableMultiBulkResponseTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testOk(): void
    {
        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\StreamableMultiBulkResponse();

        $this->assertInstanceOf('Predis\Response\Iterator\MultiBulk', $handler->handle($connection, '1'));
    }

    /**
     * @group disconnected
     */
    public function testInvalid(): void
    {
        $this->expectException('Predis\Protocol\ProtocolException');
        $this->expectExceptionMessage("Cannot parse 'invalid' as a valid length for a multi-bulk response [tcp://127.0.0.1:6379]");

        $connection = $this->getMockConnectionOfType('Predis\Connection\CompositeConnectionInterface', 'tcp://127.0.0.1:6379');
        $connection
            ->expects($this->never())
            ->method('readLine');
        $connection
            ->expects($this->never())
            ->method('readBuffer');

        $handler = new Handler\StreamableMultiBulkResponse();

        $handler->handle($connection, 'invalid');
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\PubSub\ConsumerTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\PubSub;

use Predis\Client;
use Predis\PubSub\Consumer as PubSubConsumer;
use PredisTestCase;

/**
 * @group realm-pubsub
 */
class ConsumerTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testPubSubConsumerRequirePubSubRelatedCommand(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage('PUB/SUB commands are not supported by the current command factory.');

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->any())
            ->method('supports')
            ->willReturn(false);

        $client = new Client(null, ['commands' => $commands]);

        new PubSubConsumer($client);
    }

    /**
     * @group disconnected
     */
    public function testPubSubConsumerDoesNotWorkOnClusters(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage('Cannot initialize a PUB/SUB consumer over cluster connections');

        $cluster = $this->getMockBuilder('Predis\Connection\Cluster\ClusterInterface')->getMock();
        $client = new Client($cluster);

        new PubSubConsumer($client);
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithoutSubscriptionsDoesNotStartConsumer(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        /** @var Client */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['executeCommand'])
            ->setConstructorArgs([$connection])
            ->getMock();

        $client->expects($this->never())
            ->method('executeCommand');

        new PubSubConsumer($client);
    }

    /**
     * @group disconnected
     */
    public function testConstructorWithSubscriptionsStartsConsumer(): void
    {
        $commands = $this->getCommandFactory();

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection->expects($this->exactly(2))->method('writeRequest');

        /** @var Client */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['createCommand'])
            ->addMethods(['writeRequest'])
            ->setConstructorArgs([$connection])
            ->getMock();
        $client
            ->expects($this->exactly(2))
            ->method('createCommand')
            ->with($this->logicalOr($this->equalTo('subscribe'), $this->equalTo('psubscribe')))
            ->willReturnCallback(function ($id, $args) use ($commands) {
                return $commands->create($id, $args);
            });

        $options = ['subscribe' => 'channel:foo', 'psubscribe' => 'channels:*'];

        new PubSubConsumer($client, $options);
    }

    /**
     * @group disconnected
     */
    public function testStoppingConsumerWithTrueClosesConnection(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        /** @var Client */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['disconnect'])
            ->setConstructorArgs([$connection])
            ->getMock();
        $client
            ->expects($this->once())
            ->method('disconnect');

        $pubsub = new PubSubConsumer($client, ['subscribe' => 'channel:foo']);

        $connection->expects($this->never())->method('writeRequest');

        $pubsub->stop(true);
    }

    /**
     * @group disconnected
     */
    public function testStoppingConsumerWithFalseSendsUnsubscriptions(): void
    {
        $commands = $this->getCommandFactory();
        $classUnsubscribe = $commands->getCommandClass('unsubscribe');
        $classPunsubscribe = $commands->getCommandClass('punsubscribe');

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        /** @var Client */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['disconnect'])
            ->setConstructorArgs([$connection])
            ->getMock();

        $options = ['subscribe' => 'channel:foo', 'psubscribe' => 'channels:*'];
        $pubsub = new PubSubConsumer($client, $options);

        $connection
            ->expects($this->exactly(2))
            ->method('writeRequest')
            ->with($this->logicalOr(
                $this->isInstanceOf($classUnsubscribe),
                $this->isInstanceOf($classPunsubscribe)
            ));

        $pubsub->stop(false);
    }

    /**
     * @group disconnected
     */
    public function testIsNotValidWhenNotSubscribed(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        /** @var Client */
        $client = $this->getMockBuilder('Predis\Client')
            ->onlyMethods(['disconnect'])
            ->setConstructorArgs([$connection])
            ->getMock();

        $pubsub = new PubSubConsumer($client);

        $this->assertFalse($pubsub->valid());
        $this->assertNull($pubsub->next());
    }

    /**
     * @group disconnected
     */
    public function testHandlesPongMessages(): void
    {
        $rawmessage = ['pong', ''];

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('read')
            ->willReturn($rawmessage);

        $client = new Client($connection);
        $pubsub = new PubSubConsumer($client, ['subscribe' => 'channel:foo']);

        $message = $pubsub->current();
        $this->assertSame('pong', $message->kind);
        $this->assertSame('', $message->payload);
    }

    /**
     * @group disconnected
     */
    public function testHandlesPongMessagesWithPayload(): void
    {
        $rawmessage = ['pong', 'foobar'];

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('read')
            ->willReturn($rawmessage);

        $client = new Client($connection);
        $pubsub = new PubSubConsumer($client, ['subscribe' => 'channel:foo']);

        $message = $pubsub->current();
        $this->assertSame('pong', $message->kind);
        $this->assertSame('foobar', $message->payload);
    }

    /**
     * @group disconnected
     */
    public function testReadsMessageFromConnection(): void
    {
        $rawmessage = ['message', 'channel:foo', 'message from channel'];

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('read')
            ->willReturn($rawmessage);

        $client = new Client($connection);
        $pubsub = new PubSubConsumer($client, ['subscribe' => 'channel:foo']);

        $message = $pubsub->current();
        $this->assertSame('message', $message->kind);
        $this->assertSame('channel:foo', $message->channel);
        $this->assertSame('message from channel', $message->payload);
    }

    /**
     * @group disconnected
     */
    public function testReadsPmessageFromConnection(): void
    {
        $rawmessage = ['pmessage', 'channel:*', 'channel:foo', 'message from channel'];

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('read')
            ->willReturn($rawmessage);

        $client = new Client($connection);
        $pubsub = new PubSubConsumer($client, ['psubscribe' => 'channel:*']);

        $message = $pubsub->current();
        $this->assertSame('pmessage', $message->kind);
        $this->assertSame('channel:*', $message->pattern);
        $this->assertSame('channel:foo', $message->channel);
        $this->assertSame('message from channel', $message->payload);
    }

    /**
     * @group disconnected
     */
    public function testReadsSubscriptionMessageFromConnection(): void
    {
        $rawmessage = ['subscribe', 'channel:foo', 1];

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('read')
            ->willReturn($rawmessage);

        $client = new Client($connection);
        $pubsub = new PubSubConsumer($client, ['subscribe' => 'channel:foo']);

        $message = $pubsub->current();
        $this->assertSame('subscribe', $message->kind);
        $this->assertSame('channel:foo', $message->channel);
        $this->assertSame(1, $message->payload);
    }

    /**
     * @group disconnected
     */
    public function testReadsUnsubscriptionMessageFromConnection(): void
    {
        $rawmessage = ['unsubscribe', 'channel:foo', 1];

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('read')
            ->willReturn($rawmessage);

        $client = new Client($connection);
        $pubsub = new PubSubConsumer($client, ['subscribe' => 'channel:foo']);

        $message = $pubsub->current();
        $this->assertSame('unsubscribe', $message->kind);
        $this->assertSame('channel:foo', $message->channel);
        $this->assertSame(1, $message->payload);
    }

    /**
     * @group disconnected
     */
    public function testUnsubscriptionMessageWithZeroChannelCountInvalidatesConsumer(): void
    {
        $rawmessage = ['unsubscribe', 'channel:foo', 0];

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->once())
            ->method('read')
            ->willReturn($rawmessage);

        $client = new Client($connection);
        $pubsub = new PubSubConsumer($client, ['subscribe' => 'channel:foo']);

        $this->assertTrue($pubsub->valid());

        $message = $pubsub->current();
        $this->assertSame('unsubscribe', $message->kind);
        $this->assertSame('channel:foo', $message->channel);
        $this->assertSame(0, $message->payload);

        $this->assertFalse($pubsub->valid());
    }

    /**
     * @group disconnected
     */
    public function testGetUnderlyingClientInstance(): void
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        $client = new Client($connection);
        $pubsub = new PubSubConsumer($client);

        $this->assertSame($client, $pubsub->getClient());
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    // NOTE: the following 2 tests fail at random without any apparent reason
    // when executed on our CI environments and these failures are not tied
    // to a particular version of PHP or Redis. It is most likely some weird
    // timing issue on busy systems as it is really rare to get it triggered
    // locally. The chances it is a bug in the library are pretty low so for
    // now we just mark this test skipped on our CI environments (but still
    // enabled for local test runs) and "debug" this issue using a separate
    // branch to avoid having spurious failures on main development branches
    // which is utterly annoying.

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testPubSubAgainstRedisServer(): void
    {
        $this->markTestSkippedOnCIEnvironment(
            'Test temporarily skipped on CI environments, see note in the body of the test' // TODO
        );

        $parameters = [
            'host' => constant('REDIS_SERVER_HOST'),
            'port' => constant('REDIS_SERVER_PORT'),
            'database' => constant('REDIS_SERVER_DBNUM'),
            // Prevents suite from handing on broken test
            'read_write_timeout' => 2,
        ];

        $messages = [];

        $producer = new Client($parameters);
        $producer->connect();

        $consumer = new Client($parameters);
        $consumer->connect();

        $pubsub = new PubSubConsumer($consumer);
        $pubsub->subscribe('channel:foo');

        $producer->publish('channel:foo', 'message1');
        $producer->publish('channel:foo', 'message2');
        $producer->publish('channel:foo', 'QUIT');

        foreach ($pubsub as $message) {
            if ($message->kind !== 'message') {
                continue;
            }
            $messages[] = ($payload = $message->payload);
            if ($payload === 'QUIT') {
                $pubsub->stop();
            }
        }

        $this->assertSame(['message1', 'message2', 'QUIT'], $messages);
        $this->assertFalse($pubsub->valid());
        $this->assertEquals('ECHO', $consumer->echo('ECHO'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     * @requires extension pcntl
     */
    public function testPubSubAgainstRedisServerBlocking(): void
    {
        $this->markTestSkippedOnCIEnvironment(
            'Test temporarily skipped on CI environments, see note in the body of the test' // TODO
        );

        $parameters = [
            'host' => constant('REDIS_SERVER_HOST'),
            'port' => constant('REDIS_SERVER_PORT'),
            'database' => constant('REDIS_SERVER_DBNUM'),
            'read_write_timeout' => -1, // -1 to set blocking reads
        ];

        // create consumer before forking so the child can disconnect it
        $consumer = new Client($parameters);
        $consumer->connect();

        /*
         * fork
         *  parent: consumer
         *  child: producer
         */
        if ($childPID = pcntl_fork()) {
            $messages = [];

            $pubsub = new PubSubConsumer($consumer);
            $pubsub->subscribe('channel:foo');

            foreach ($pubsub as $message) {
                if ($message->kind !== 'message') {
                    continue;
                }
                $messages[] = ($payload = $message->payload);
                if ($payload === 'QUIT') {
                    $pubsub->stop();
                }
            }

            $this->assertSame(['message1', 'message2', 'QUIT'], $messages);
            $this->assertFalse($pubsub->valid());
            $this->assertEquals('ECHO', $consumer->echo('ECHO'));

            // kill the child
            posix_kill($childPID, SIGKILL);
        } else {
            // create producer, read_write_timeout = 2 because it doesn't do blocking reads anyway
            $producer = new Client(array_replace($parameters, ['read_write_timeout' => 2]));
            $producer->connect();

            $producer->publish('channel:foo', 'message1');
            $producer->publish('channel:foo', 'message2');

            $producer->publish('channel:foo', 'QUIT');

            // sleep, giving the consumer a chance to respond to the QUIT message
            sleep(1);

            // disconnect the consumer because otherwise it could remain stuck in blocking read
            //  if it failed to respond to the QUIT message
            $consumer->disconnect();

            // exit child
            exit(0);
        }
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\PubSub\DispatcherLoopTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\PubSub;

use Predis\Client;
use PredisTestCase;

/**
 * @group realm-pubsub
 */
class DispatcherLoopTest extends PredisTestCase
{
    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    // NOTE: the following 2 tests fail at random without any apparent reason
    // when executed on our CI environments and these failures are not tied
    // to a particular version of PHP or Redis. It is most likely some weird
    // timing issue on busy systems as it is really rare to get it triggered
    // locally. The chances it is a bug in the library are pretty low so for
    // now we just mark this test skipped on our CI environments (but still
    // enabled for local test runs) and "debug" this issue using a separate
    // branch to avoid having spurious failures on main development branches
    // which is utterly annoying.

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testDispatcherLoopAgainstRedisServer(): void
    {
        $this->markTestSkippedOnCIEnvironment(
            'Test temporarily skipped on CI environments, see note in the body of the test' // TODO
        );

        $parameters = [
            'host' => constant('REDIS_SERVER_HOST'),
            'port' => constant('REDIS_SERVER_PORT'),
            'database' => constant('REDIS_SERVER_DBNUM'),
            // Prevents suite from hanging on broken test
            'read_write_timeout' => 2,
        ];

        $producer = new Client($parameters);
        $producer->connect();

        $consumer = new Client($parameters);
        $consumer->connect();

        $pubsub = new Consumer($consumer);
        $dispatcher = new DispatcherLoop($pubsub);

        $function01 = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $function01
            ->expects($this->exactly(2))
            ->method('__invoke')
            ->with($this->logicalOr(
                $this->equalTo('01:argument'),
                $this->equalTo('01:quit')
            ), $dispatcher)
            ->willReturnCallback(function ($arg, $dispatcher) {
                if ($arg === '01:quit') {
                    $dispatcher->stop();
                }
            });

        $function02 = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $function02
            ->expects($this->once())
            ->method('__invoke')
            ->with('02:argument');

        $function03 = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $function03
            ->expects($this->never())
            ->method('__invoke');

        $dispatcher->attachCallback('function:01', $function01);
        $dispatcher->attachCallback('function:02', $function02);
        $dispatcher->attachCallback('function:03', $function03);

        $producer->publish('function:01', '01:argument');
        $producer->publish('function:02', '02:argument');
        $producer->publish('function:01', '01:quit');

        $dispatcher->run();

        $this->assertEquals('PONG', $consumer->ping());
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testDispatcherLoopAgainstRedisServerWithPrefix(): void
    {
        $this->markTestSkippedOnCIEnvironment(
            'Test temporarily skipped on CI environments, see note in the body of the test' // TODO
        );

        $parameters = [
            'host' => constant('REDIS_SERVER_HOST'),
            'port' => constant('REDIS_SERVER_PORT'),
            'database' => constant('REDIS_SERVER_DBNUM'),
            // Prevents suite from handing on broken test
            'read_write_timeout' => 2,
        ];

        $producerNonPfx = new Client($parameters);
        $producerNonPfx->connect();

        $producerPfx = new Client($parameters, ['prefix' => 'foobar']);
        $producerPfx->connect();

        $consumer = new Client($parameters, ['prefix' => 'foobar']);

        $pubsub = new Consumer($consumer);
        $dispatcher = new DispatcherLoop($pubsub);

        $callback = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $callback
            ->expects($this->exactly(1))
            ->method('__invoke')
            ->with($this->equalTo('arg:prefixed'), $dispatcher)
            ->willReturnCallback(function ($arg, $dispatcher) {
                $dispatcher->stop();
            });

        $dispatcher->attachCallback('callback', $callback);

        $producerNonPfx->publish('callback', 'arg:non-prefixed');
        $producerPfx->publish('callback', 'arg:prefixed');

        $dispatcher->run();

        $this->assertEquals('PONG', $consumer->ping());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Replication\ReplicationStrategyTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Replication;

use PHPUnit\Framework\MockObject\MockObject;
use Predis\Command\CommandInterface;
use PredisTestCase;

class ReplicationStrategyTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testLoadBalancing(): void
    {
        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        $command = $commands->create('GET', ['key']);

        $this->assertTrue(
            $strategy->isReadOperation($command),
            'GET is expected to be a read operation.'
        );

        $strategy->disableLoadBalancing();

        $this->assertFalse(
            $strategy->isReadOperation($command),
            'GET is expected to be a write operation.'
        );
    }

    /**
     * @group disconnected
     */
    public function testReadCommands(): void
    {
        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        foreach ($this->getExpectedCommands('read') as $commandId) {
            $command = $commands->create($commandId);

            $this->assertTrue(
                $strategy->isReadOperation($command),
                "$commandId is expected to be a read operation."
            );
        }
    }

    /**
     * @group disconnected
     */
    public function testWriteRequests(): void
    {
        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        foreach ($this->getExpectedCommands('write') as $commandId) {
            $command = $commands->create($commandId);

            $this->assertFalse(
                $strategy->isReadOperation($command),
                "$commandId is expected to be a write operation."
            );
        }
    }

    /**
     * @group disconnected
     */
    public function testDisallowedCommands(): void
    {
        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        foreach ($this->getExpectedCommands('disallowed') as $commandId) {
            $command = $commands->create($commandId);

            $this->assertTrue(
                $strategy->isDisallowedOperation($command),
                "$commandId is expected to be a disallowed operation."
            );
        }
    }

    /**
     * @group disconnected
     */
    public function testSortCommand(): void
    {
        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        $cmdReturnSort = $commands->create('SORT', ['key:list']);
        $this->assertFalse(
            $strategy->isReadOperation($cmdReturnSort),
            'SORT is expected to be a write operation.'
        );

        $cmdStoreSort = $commands->create('SORT', ['key:list', ['store' => 'key:stored']]);
        $this->assertFalse(
            $strategy->isReadOperation($cmdStoreSort),
            'SORT with STORE is expected to be a write operation.'
        );
    }

    /**
     * @group disconnected
     */
    public function testBitFieldCommand(): void
    {
        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        $command = $commands->create('BITFIELD', ['key']);
        $this->assertTrue(
            $strategy->isReadOperation($command),
            'BITFIELD with no modifiers is expected to be a read operation.'
        );

        $command = $commands->create('BITFIELD', ['key', 'GET', 'u4', '0']);
        $this->assertTrue(
            $strategy->isReadOperation($command),
            'BITFIELD with GET only is expected to be a read operation.'
        );

        $command = $commands->create('BITFIELD', ['key', 'SET', 'u4', '0', 1]);
        $this->assertFalse(
            $strategy->isReadOperation($command),
            'BITFIELD with SET is expected to be a write operation.'
        );

        $command = $commands->create('BITFIELD', ['key', 'INCRBY', 'u4', '0', 1]);
        $this->assertFalse(
            $strategy->isReadOperation($command),
            'BITFIELD with INCRBY is expected to be a write operation.'
        );

        $command = $commands->create('BITFIELD', ['key', 'GET', 'u4', '0', 'INCRBY', 'u4', '0', 1]);
        $this->assertFalse(
            $strategy->isReadOperation($command),
            'BITFIELD with GET and INCRBY is expected to be a write operation.'
        );

        $command = $commands->create('BITFIELD', ['key', 'GET', 'u4', '0', 'SET', 'u4', '0', 1]);
        $this->assertFalse(
            $strategy->isReadOperation($command),
            'BITFIELD with GET and SET is expected to be a write operation.'
        );
    }

    /**
     * @group disconnected
     */
    public function testGeoradiusCommand(): void
    {
        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        $command = $commands->create('GEORADIUS', ['key:geo', 15, 37, 200, 'km']);
        $this->assertTrue(
            $strategy->isReadOperation($command),
            'GEORADIUS is expected to be a read operation.'
        );

        $command = $commands->create('GEORADIUS', ['key:geo', 15, 37, 200, 'km', 'store', 'key:store']);
        $this->assertFalse(
            $strategy->isReadOperation($command),
            'GEORADIUS with STORE is expected to be a write operation.'
        );

        $command = $commands->create('GEORADIUS', ['key:geo', 15, 37, 200, 'km', 'storedist', 'key:storedist']);
        $this->assertFalse(
            $strategy->isReadOperation($command),
            'GEORADIUS with STOREDIST is expected to be a write operation.'
        );
    }

    /**
     * @group disconnected
     */
    public function testGeoradiusByMemberCommand(): void
    {
        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        $command = $commands->create('GEORADIUSBYMEMBER', ['key:geo', 15, 37, 200, 'km']);
        $this->assertTrue(
            $strategy->isReadOperation($command),
            'GEORADIUSBYMEMBER is expected to be a read operation.'
        );

        $command = $commands->create('GEORADIUSBYMEMBER', ['key:geo', 15, 37, 200, 'km', 'store', 'key:store']);
        $this->assertFalse(
            $strategy->isReadOperation($command),
            'GEORADIUSBYMEMBER with STORE is expected to be a write operation.'
        );

        $command = $commands->create('GEORADIUSBYMEMBER', ['key:geo', 15, 37, 200, 'km', 'storedist', 'key:storedist']);
        $this->assertFalse(
            $strategy->isReadOperation($command),
            'GEORADIUSBYMEMBER with STOREDIST is expected to be a write operation.'
        );
    }

    /**
     * @group disconnected
     */
    public function testUsingDisallowedCommandThrowsException(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage("The command 'INFO' is not allowed in replication mode");

        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        $command = $commands->create('INFO');
        $strategy->isReadOperation($command);
    }

    /**
     * @group disconnected
     */
    public function testDefaultIsWriteOperation(): void
    {
        $strategy = new ReplicationStrategy();

        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\CommandInterface')->getMock();
        $command
            ->expects($this->any())
            ->method('getId')
            ->willReturn('CMDTEST');

        $this->assertFalse($strategy->isReadOperation($command));
    }

    /**
     * @group disconnected
     */
    public function testCanSetCommandAsReadOperation(): void
    {
        $strategy = new ReplicationStrategy();

        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\CommandInterface')->getMock();
        $command
            ->expects($this->any())
            ->method('getId')
            ->willReturn('CMDTEST');

        $strategy->setCommandReadOnly('CMDTEST', true);
        $this->assertTrue($strategy->isReadOperation($command));
    }

    /**
     * @group disconnected
     */
    public function testCanSetCommandAsWriteOperation(): void
    {
        $strategy = new ReplicationStrategy();

        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\CommandInterface')->getMock();
        $command
            ->expects($this->any())
            ->method('getId')
            ->willReturn('CMDTEST');

        $strategy->setCommandReadOnly('CMDTEST', false);
        $this->assertFalse($strategy->isReadOperation($command));

        $strategy->setCommandReadOnly('GET', false);
        $this->assertFalse($strategy->isReadOperation($command));
    }

    /**
     * @group disconnected
     */
    public function testCanUseCallableToCheckCommand(): void
    {
        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        $strategy->setCommandReadOnly('SET', function (CommandInterface $command) {
            return $command->getArgument(1) === true;
        });

        $command = $commands->create('SET', ['trigger', false]);
        $this->assertFalse($strategy->isReadOperation($command));

        $command = $commands->create('SET', ['trigger', true]);
        $this->assertTrue($strategy->isReadOperation($command));
    }

    /**
     * @group disconnected
     */
    public function testSetLuaScriptAsReadOperation(): void
    {
        $commands = $this->getCommandFactory();
        $strategy = new ReplicationStrategy();

        $writeScript = 'redis.call("set", "foo", "bar")';
        $readScript = 'return true';

        $strategy->setScriptReadOnly($readScript, true);

        $cmdEval = $commands->create('EVAL', [$writeScript]);
        $cmdEvalSHA = $commands->create('EVALSHA', [sha1($writeScript)]);
        $this->assertFalse($strategy->isReadOperation($cmdEval));
        $this->assertFalse($strategy->isReadOperation($cmdEvalSHA));

        $cmdEval = $commands->create('EVAL', [$readScript]);
        $cmdEvalSHA = $commands->create('EVALSHA', [sha1($readScript)]);
        $this->assertTrue($strategy->isReadOperation($cmdEval));
        $this->assertTrue($strategy->isReadOperation($cmdEvalSHA));
    }

    /**
     * @group disconnected
     */
    public function testSetLuaScriptAsReadOperationWorksWithScriptCommand(): void
    {
        $strategy = new ReplicationStrategy();

        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript'])
            ->getMock();
        $command
            ->expects($this->any())
            ->method('getScript')
            ->willReturn($script = 'return true');

        $strategy->setScriptReadOnly($script, function (CommandInterface $command) {
            return $command->getArgument(2) === true;
        });

        $command->setArguments([false]);
        $this->assertFalse($strategy->isReadOperation($command));

        $command->setArguments([true]);
        $this->assertTrue($strategy->isReadOperation($command));
    }

    /**
     * @group disconnected
     */
    public function testSetLuaScriptAsReadOperationWorksWithScriptCommandAndCallableCheck(): void
    {
        $strategy = new ReplicationStrategy();

        /** @var CommandInterface|MockObject */
        $command = $this->getMockBuilder('Predis\Command\ScriptCommand')
            ->onlyMethods(['getScript'])
            ->getMock(['getScript']);
        $command
            ->expects($this->any())
            ->method('getScript')
            ->willReturn($script = 'return true');

        $command->setArguments(['trigger', false]);

        $strategy->setScriptReadOnly($script, true);

        $this->assertTrue($strategy->isReadOperation($command));
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns the list of expected supported commands.
     *
     * @param ?string $type Optional type of command (based on its keys)
     *
     * @return array
     */
    protected function getExpectedCommands(?string $type = null): array
    {
        $commands = [
            /* commands operating on the connection */
            'AUTH' => 'read',
            'SELECT' => 'read',
            'ECHO' => 'read',
            'QUIT' => 'read',
            'OBJECT' => 'read',
            'TIME' => 'read',
            'SHUTDOWN' => 'disallowed',
            'INFO' => 'disallowed',
            'DBSIZE' => 'disallowed',
            'LASTSAVE' => 'disallowed',
            'CONFIG' => 'disallowed',
            'MONITOR' => 'disallowed',
            'SLAVEOF' => 'disallowed',
            'SAVE' => 'disallowed',
            'BGSAVE' => 'disallowed',
            'BGREWRITEAOF' => 'disallowed',
            'SLOWLOG' => 'disallowed',

            /* commands operating on the key space */
            'EXISTS' => 'read',
            'DEL' => 'write',
            'TYPE' => 'read',
            'EXPIRE' => 'write',
            'EXPIREAT' => 'write',
            'PERSIST' => 'write',
            'PEXPIRE' => 'write',
            'PEXPIREAT' => 'write',
            'TTL' => 'read',
            'PTTL' => 'write',
            'SORT' => 'variable',
            'KEYS' => 'read',
            'SCAN' => 'read',
            'RANDOMKEY' => 'read',

            /* commands operating on string values */
            'APPEND' => 'write',
            'DECR' => 'write',
            'DECRBY' => 'write',
            'GET' => 'read',
            'GETBIT' => 'read',
            'BITCOUNT' => 'read',
            'BITPOS' => 'read',
            'BITOP' => 'write',
            'MGET' => 'read',
            'SET' => 'write',
            'GETRANGE' => 'read',
            'GETSET' => 'write',
            'INCR' => 'write',
            'INCRBY' => 'write',
            'INCRBYFLOAT' => 'write',
            'SETBIT' => 'write',
            'SETEX' => 'write',
            'MSET' => 'write',
            'MSETNX' => 'write',
            'SETNX' => 'write',
            'SETRANGE' => 'write',
            'STRLEN' => 'read',
            'SUBSTR' => 'read',
            'BITFIELD' => 'variable',

            /* commands operating on lists */
            'LINSERT' => 'write',
            'LINDEX' => 'read',
            'LLEN' => 'read',
            'LPOP' => 'write',
            'RPOP' => 'write',
            'BLPOP' => 'write',
            'BRPOP' => 'write',
            'LPUSH' => 'write',
            'LPUSHX' => 'write',
            'RPUSH' => 'write',
            'RPUSHX' => 'write',
            'LRANGE' => 'read',
            'LREM' => 'write',
            'LSET' => 'write',
            'LTRIM' => 'write',

            /* commands operating on sets */
            'SADD' => 'write',
            'SCARD' => 'read',
            'SISMEMBER' => 'read',
            'SMEMBERS' => 'read',
            'SSCAN' => 'read',
            'SRANDMEMBER' => 'read',
            'SPOP' => 'write',
            'SREM' => 'write',
            'SINTER' => 'read',
            'SUNION' => 'read',
            'SDIFF' => 'read',

            /* commands operating on sorted sets */
            'ZADD' => 'write',
            'ZCARD' => 'read',
            'ZCOUNT' => 'read',
            'ZINCRBY' => 'write',
            'ZRANGE' => 'read',
            'ZRANGEBYSCORE' => 'read',
            'ZRANK' => 'read',
            'ZREM' => 'write',
            'ZREMRANGEBYRANK' => 'write',
            'ZREMRANGEBYSCORE' => 'write',
            'ZREVRANGE' => 'read',
            'ZREVRANGEBYSCORE' => 'read',
            'ZREVRANK' => 'read',
            'ZSCORE' => 'read',
            'ZSCAN' => 'read',
            'ZLEXCOUNT' => 'read',
            'ZRANGEBYLEX' => 'read',
            'ZREMRANGEBYLEX' => 'write',
            'ZREVRANGEBYLEX' => 'read',

            /* commands operating on hashes */
            'HDEL' => 'write',
            'HEXISTS' => 'read',
            'HGET' => 'read',
            'HGETALL' => 'read',
            'HMGET' => 'read',
            'HINCRBY' => 'write',
            'HINCRBYFLOAT' => 'write',
            'HKEYS' => 'read',
            'HLEN' => 'read',
            'HSET' => 'write',
            'HSETNX' => 'write',
            'HVALS' => 'read',
            'HSCAN' => 'read',
            'HSTRLEN' => 'read',

            /* commands operating on HyperLogLog */
            'PFADD' => 'write',
            'PFMERGE' => 'write',
            'PFCOUNT' => 'read',

            /* scripting */
            'EVAL' => 'write',
            'EVALSHA' => 'write',

            /* commands performing geospatial operations */
            'GEOADD' => 'write',
            'GEOHASH' => 'read',
            'GEOPOS' => 'read',
            'GEODIST' => 'read',
            'GEORADIUS' => 'variable',
            'GEORADIUSBYMEMBER' => 'variable',
        ];

        if (isset($type)) {
            $commands = array_filter($commands, function (string $expectedType) use ($type) {
                return $expectedType === $type;
            });
        }

        return array_keys($commands);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Response\ErrorTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response;

use PredisTestCase;

class ErrorTest extends PredisTestCase
{
    public const ERR_WRONG_KEY_TYPE = 'ERR Operation against a key holding the wrong kind of value';

    /**
     * @group disconnected
     */
    public function testResponseErrorClass(): void
    {
        $error = new Error(self::ERR_WRONG_KEY_TYPE);

        $this->assertInstanceOf('Predis\Response\ErrorInterface', $error);
        $this->assertInstanceOf('Predis\Response\ResponseInterface', $error);
    }

    /**
     * @group disconnected
     */
    public function testErrorMessage(): void
    {
        $error = new Error(self::ERR_WRONG_KEY_TYPE);

        $this->assertEquals(self::ERR_WRONG_KEY_TYPE, $error->getMessage());
    }

    /**
     * @group disconnected
     */
    public function testErrorType(): void
    {
        $exception = new Error(self::ERR_WRONG_KEY_TYPE);

        $this->assertEquals('ERR', $exception->getErrorType());
    }

    /**
     * @group disconnected
     */
    public function testToString(): void
    {
        $error = new Error(self::ERR_WRONG_KEY_TYPE);

        $this->assertEquals(self::ERR_WRONG_KEY_TYPE, (string) $error);
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Response\ServerExceptionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response;

use PredisTestCase;

class ServerExceptionTest extends PredisTestCase
{
    public const ERR_WRONG_KEY_TYPE = 'ERR Operation against a key holding the wrong kind of value';

    /**
     * @group disconnected
     */
    public function testExceptionMessage(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage(self::ERR_WRONG_KEY_TYPE);

        throw new ServerException(self::ERR_WRONG_KEY_TYPE);
    }

    /**
     * @group disconnected
     */
    public function testExceptionClass(): void
    {
        $exception = new ServerException(self::ERR_WRONG_KEY_TYPE);

        $this->assertInstanceOf('Predis\Response\ServerException', $exception);
        $this->assertInstanceOf('Predis\Response\ErrorInterface', $exception);
        $this->assertInstanceOf('Predis\Response\ResponseInterface', $exception);
        $this->assertInstanceOf('Predis\PredisException', $exception);
    }

    /**
     * @group disconnected
     */
    public function testErrorType(): void
    {
        $exception = new ServerException(self::ERR_WRONG_KEY_TYPE);

        $this->assertEquals('ERR', $exception->getErrorType());
    }

    /**
     * @group disconnected
     */
    public function testToErrorResponse(): void
    {
        $exception = new ServerException(self::ERR_WRONG_KEY_TYPE);
        $error = $exception->toErrorResponse();

        $this->assertInstanceOf('Predis\Response\Error', $error);

        $this->assertEquals($exception->getMessage(), $error->getMessage());
        $this->assertEquals($exception->getErrorType(), $error->getErrorType());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Response\StatusTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response;

use PredisTestCase;

class StatusTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testStatusResponse(): void
    {
        $status = new Status('OK');

        $this->assertInstanceOf('Predis\Response\ResponseInterface', $status);
        $this->assertSame('OK', $status->getPayload());
    }

    /**
     * @group disconnected
     */
    public function testStatusToString(): void
    {
        $queued = new Status('OK');

        $this->assertSame('OK', (string) $queued);
        $this->assertEquals('OK', $queued);
    }

    /**
     * @group disconnected
     */
    public function testStaticGetMethod(): void
    {
        $this->assertInstanceOf('Predis\Response\Status', $response = Status::get('OK'));
        $this->assertEquals('OK', $response);

        $this->assertInstanceOf('Predis\Response\Status', $response = Status::get('QUEUED'));
        $this->assertEquals('QUEUED', $response);

        $this->assertInstanceOf('Predis\Response\Status', $response = Status::get('PONG'));
        $this->assertEquals('PONG', $response);
    }

    /**
     * @group disconnected
     */
    public function testStaticGetMethodCachesOnlyCommonStatuses(): void
    {
        $response = Status::get('OK');
        $this->assertSame($response, Status::get('OK'));

        $response = Status::get('QUEUED');
        $this->assertSame($response, Status::get('QUEUED'));

        $response = Status::get('PONG');
        $this->assertNotSame($response, Status::get('PONG'));
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Response\Iterator\MultiBulkTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response\Iterator;

use Predis\Client;
use Predis\ClientInterface;
use Predis\Connection\CompositeStreamConnection;
use Predis\Protocol\Text\ProtocolProcessor as TextProtocolProcessor;
use PredisTestCase;

/**
 * @group realm-iterators
 */
class MultiBulkTest extends PredisTestCase
{
    /**
     * @group connected
     */
    public function testIterableMultibulk(): void
    {
        $client = $this->getClient();
        $client->rpush('metavars', 'foo', 'hoge', 'lol');

        /* @var MultiBulkIterator */
        $this->assertInstanceOf('Iterator', $iterator = $client->lrange('metavars', 0, -1));
        $this->assertInstanceOf('Predis\Response\Iterator\MultiBulk', $iterator);

        $iterator->valid();
        $this->assertSame(3, $iterator->count());

        $this->assertSame('foo', $iterator->current());
        $iterator->next();
        $this->assertTrue($iterator->valid());

        $this->assertSame('hoge', $iterator->current());
        $iterator->next();
        $this->assertTrue($iterator->valid());

        $this->assertSame('lol', $iterator->current());
        $iterator->next();
        $this->assertFalse($iterator->valid());

        $this->assertEquals('PONG', $client->ping());
    }

    /**
     * @group connected
     */
    public function testDropWithFalseConsumesResponseFromUnderlyingConnection(): void
    {
        $client = $this->getClient();
        $client->rpush('metavars', 'foo', 'hoge', 'lol');

        /** @var MultiBulkIterMultiBulkator */
        $iterator = $client->lrange('metavars', 0, -1);
        $iterator->drop(false);

        $this->assertTrue($client->isConnected());
        $this->assertEquals('PONG', $client->ping());
    }

    /**
     * @group connected
     */
    public function testDropWithTrueDropsUnderlyingConnection(): void
    {
        $client = $this->getClient();
        $client->rpush('metavars', 'foo', 'hoge', 'lol');

        /** @var MultiBulk */
        $iterator = $client->lrange('metavars', 0, -1);
        $iterator->drop(true);

        $this->assertFalse($client->isConnected());
        $this->assertEquals('PONG', $client->ping());
    }

    /**
     * @group connected
     */
    public function testGarbageCollectorDropsUnderlyingConnection(): void
    {
        $client = $this->getClient();
        $client->rpush('metavars', 'foo', 'hoge', 'lol');

        /** @var MultiBulkIterator */
        $iterator = $client->lrange('metavars', 0, -1);

        unset($iterator);

        $this->assertFalse($client->isConnected());
        $this->assertEquals('PONG', $client->ping());
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns a new client instance.
     *
     * @return ClientInterface
     */
    protected function getClient(): ClientInterface
    {
        $parameters = $this->getParameters(['read_write_timeout' => 2]);

        $protocol = new TextProtocolProcessor();
        $protocol->useIterableMultibulk(true);

        $connection = new CompositeStreamConnection($parameters, $protocol);

        $client = new Client($connection);
        $client->connect();
        $client->flushdb();

        return $client;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Response\Iterator\MultiBulkTupleTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Response\Iterator;

use Predis\Client;
use Predis\ClientInterface;
use Predis\Connection\CompositeStreamConnection;
use Predis\Connection\NodeConnectionInterface;
use Predis\Protocol\Text\ProtocolProcessor as TextProtocolProcessor;
use PredisTestCase;

/**
 * @group realm-iterators
 */
class MultiBulkTupleTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testInitiatedMultiBulkIteratorsAreNotValid(): void
    {
        $this->expectException('InvalidArgumentException');
        $this->expectExceptionMessage('Cannot initialize a tuple iterator using an already initiated iterator');

        /** @var NodeConnectionInterface */
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        $iterator = new MultiBulk($connection, 2);
        $iterator->next();

        new MultiBulkTuple($iterator);
    }

    /**
     * @group disconnected
     */
    public function testMultiBulkWithOddSizesAreInvalid(): void
    {
        $this->expectException('UnexpectedValueException');
        $this->expectExceptionMessage('Invalid response size for a tuple iterator');

        /** @var NodeConnectionInterface */
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();

        $iterator = new MultiBulk($connection, 3);

        new MultiBulkTuple($iterator);
    }

    /**
     * @group connected
     */
    public function testIterableMultibulk(): void
    {
        $client = $this->getClient();
        $client->zadd('metavars', 1, 'foo', 2, 'hoge', 3, 'lol');

        /** @var MultiBulkIterator */
        $multibulk = $client->zrange('metavars', '0', '-1', 'withscores');
        $iterator = new MultiBulkTuple($multibulk);

        $this->assertInstanceOf('OuterIterator', $iterator);
        $this->assertInstanceOf('Predis\Response\Iterator\MultiBulkTuple', $iterator);
        $this->assertInstanceOf('Predis\Response\Iterator\MultiBulk', $iterator->getInnerIterator());
        $this->assertTrue($iterator->valid());
        $this->assertSame(3, $iterator->count());

        $this->assertSame(['foo', '1'], $iterator->current());
        $iterator->next();
        $this->assertTrue($iterator->valid());

        $this->assertSame(['hoge', '2'], $iterator->current());
        $iterator->next();
        $this->assertTrue($iterator->valid());

        $this->assertSame(['lol', '3'], $iterator->current());
        $iterator->next();
        $this->assertFalse($iterator->valid());

        $this->assertEquals('PONG', $client->ping());
    }

    /**
     * @group connected
     */
    public function testGarbageCollectorDropsUnderlyingConnection(): void
    {
        $client = $this->getClient();
        $client->zadd('metavars', 1, 'foo', 2, 'hoge', 3, 'lol');

        /** @var MultiBulkIterator */
        $multibulk = $client->zrange('metavars', '0', '-1', 'withscores');
        $iterator = new MultiBulkTuple($multibulk);

        unset($iterator);

        $this->assertFalse($client->isConnected());
        $this->assertEquals('PONG', $client->ping());
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns a new client instance.
     *
     * @return ClientInterface
     */
    protected function getClient(): ClientInterface
    {
        $parameters = $this->getParameters(['read_write_timeout' => 2]);

        $protocol = new TextProtocolProcessor();
        $protocol->useIterableMultibulk(true);

        $connection = new CompositeStreamConnection($parameters, $protocol);

        $client = new Client($connection);
        $client->connect();
        $client->flushdb();

        return $client;
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Transaction\AbortedMultiExecExceptionTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Transaction;

use Predis\Client;
use PredisTestCase;

class AbortedMultiExecExceptionTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testExceptionClass(): void
    {
        $client = new Client();
        $transaction = new MultiExec($client);
        $exception = new AbortedMultiExecException($transaction, 'ABORTED');

        $this->assertInstanceOf('Predis\PredisException', $exception);
        $this->assertSame('ABORTED', $exception->getMessage());
        $this->assertSame($transaction, $exception->getTransaction());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Transaction\MultiExecStateTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Transaction;

use PredisTestCase;

/**
 * @group realm-transaction
 */
class MultiExecStateTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testFlagsValues(): void
    {
        $this->assertSame(1, MultiExecState::INITIALIZED);
        $this->assertSame(2, MultiExecState::INSIDEBLOCK);
        $this->assertSame(4, MultiExecState::DISCARDED);
        $this->assertSame(8, MultiExecState::CAS);
        $this->assertSame(16, MultiExecState::WATCH);
    }

    /**
     * @group disconnected
     */
    public function testStateConstructorStartsWithResetState(): void
    {
        $state = new MultiExecState();

        $this->assertSame(0, $state->get());
        $this->assertTrue($state->isReset());
    }

    /**
     * @group disconnected
     */
    public function testCanCheckOneOrMoreStateFlags(): void
    {
        $flags = MultiExecState::INITIALIZED | MultiExecState::CAS;
        $state = new MultiExecState();
        $state->set($flags);

        $this->assertSame($flags, $state->get());

        $this->assertFalse($state->check(MultiExecState::INSIDEBLOCK));
        $this->assertTrue($state->check(MultiExecState::INITIALIZED));
        $this->assertTrue($state->check(MultiExecState::CAS));

        $this->assertTrue($state->check($flags));
        $this->assertFalse($state->check($flags | MultiExecState::INSIDEBLOCK));
    }

    /**
     * @group disconnected
     */
    public function testSettingAndGettingWholeFlags(): void
    {
        $flags = MultiExecState::INITIALIZED | MultiExecState::CAS;
        $state = new MultiExecState();
        $state->set($flags);

        $this->assertFalse($state->check(MultiExecState::INSIDEBLOCK));
        $this->assertTrue($state->check(MultiExecState::INITIALIZED));
        $this->assertTrue($state->check(MultiExecState::CAS));
        $this->assertSame($flags, $state->get());
    }

    /**
     * @group disconnected
     */
    public function testCanFlagSingleStates(): void
    {
        $flags = MultiExecState::INITIALIZED | MultiExecState::CAS;
        $state = new MultiExecState();

        $state->flag(MultiExecState::INITIALIZED);
        $this->assertTrue($state->check(MultiExecState::INITIALIZED));
        $this->assertFalse($state->check(MultiExecState::CAS));

        $state->flag(MultiExecState::CAS);
        $this->assertTrue($state->check(MultiExecState::INITIALIZED));
        $this->assertTrue($state->check(MultiExecState::CAS));

        $this->assertSame($flags, $state->get());
    }

    /**
     * @group disconnected
     */
    public function testCanUnflagSingleStates(): void
    {
        $state = new MultiExecState();
        $state->set(MultiExecState::INITIALIZED | MultiExecState::CAS);

        $this->assertTrue($state->check(MultiExecState::INITIALIZED));
        $this->assertTrue($state->check(MultiExecState::CAS));

        $state->unflag(MultiExecState::CAS);
        $this->assertTrue($state->check(MultiExecState::INITIALIZED));
        $this->assertFalse($state->check(MultiExecState::CAS));

        $state->unflag(MultiExecState::INITIALIZED);
        $this->assertFalse($state->check(MultiExecState::INITIALIZED));
        $this->assertFalse($state->check(MultiExecState::CAS));

        $this->assertTrue($state->isReset());
    }

    /**
     * @group disconnected
     */
    public function testIsInitializedMethod(): void
    {
        $state = new MultiExecState();

        $this->assertFalse($state->isInitialized());

        $state->set(MultiExecState::INITIALIZED);
        $this->assertTrue($state->isInitialized());
    }

    /**
     * @group disconnected
     */
    public function testIsExecuting(): void
    {
        $state = new MultiExecState();

        $this->assertFalse($state->isExecuting());

        $state->set(MultiExecState::INSIDEBLOCK);
        $this->assertTrue($state->isExecuting());
    }

    /**
     * @group disconnected
     */
    public function testIsCAS(): void
    {
        $state = new MultiExecState();

        $this->assertFalse($state->isCAS());

        $state->set(MultiExecState::CAS);
        $this->assertTrue($state->isCAS());
    }

    /**
     * @group disconnected
     */
    public function testIsWatchAllowed(): void
    {
        $state = new MultiExecState();

        $this->assertFalse($state->isWatchAllowed());

        $state->flag(MultiExecState::INITIALIZED);
        $this->assertTrue($state->isWatchAllowed());

        $state->flag(MultiExecState::CAS);
        $this->assertFalse($state->isWatchAllowed());

        $state->unflag(MultiExecState::CAS);
        $this->assertTrue($state->isWatchAllowed());
    }

    /**
     * @group disconnected
     */
    public function testIsWatching(): void
    {
        $state = new MultiExecState();

        $this->assertFalse($state->isWatching());

        $state->set(MultiExecState::WATCH);
        $this->assertTrue($state->isWatching());
    }

    /**
     * @group disconnected
     */
    public function testIsDiscarded(): void
    {
        $state = new MultiExecState();

        $this->assertFalse($state->isDiscarded());

        $state->set(MultiExecState::DISCARDED);
        $this->assertTrue($state->isDiscarded());
    }
}


================================================================================
Arquivo: C:\Users\alexa\OneDrive\Área de Trabalho\sistema-noticias\vendor\predis\predis\tests\Predis\Transaction\MultiExecTest.php
================================================================================

<?php

/*
 * This file is part of the Predis package.
 *
 * (c) 2009-2020 Daniele Alessandri
 * (c) 2021-2024 Till Krüss
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Predis\Transaction;

use Exception;
use PHPUnit\Framework\MockObject\MockObject;
use Predis\Client;
use Predis\ClientInterface;
use Predis\Command\CommandInterface;
use Predis\Connection\NodeConnectionInterface;
use Predis\Response;
use PredisTestCase;
use RuntimeException;

/**
 * @group realm-transaction
 */
class MultiExecTest extends PredisTestCase
{
    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnUnsupportedMultiExecInCommandFactory(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage('MULTI, EXEC and DISCARD are not supported by the current command factory.');

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->once())
            ->method('supports')
            ->with('MULTI', 'EXEC', 'DISCARD')
            ->willReturn(false);

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $client = new Client($connection, ['commands' => $commands]);

        new MultiExec($client);
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnUnsupportedWatchInCommandFactory(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage('WATCH is not supported by the current command factory.');

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->exactly(2))
            ->method('supports')
            ->withConsecutive(
                ['MULTI', 'EXEC', 'DISCARD'],
                ['WATCH']
            )
            ->willReturnOnConsecutiveCalls(
                true,
                false
            );

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $client = new Client($connection, ['commands' => $commands]);

        $tx = new MultiExec($client, ['options' => 'cas']);
        $tx->watch('foo');
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnUnsupportedUnwatchInCommandFactory(): void
    {
        $this->expectException('Predis\NotSupportedException');
        $this->expectExceptionMessage('UNWATCH is not supported by the current command factory.');

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();

        $commands = $this->getMockBuilder('Predis\Command\FactoryInterface')->getMock();
        $commands
            ->expects($this->exactly(2))
            ->method('supports')
            ->withConsecutive(
                ['MULTI', 'EXEC', 'DISCARD'],
                ['UNWATCH']
            )
            ->willReturnOnConsecutiveCalls(
                true,
                false
            );

        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $client = new Client($connection, ['commands' => $commands]);

        $tx = new MultiExec($client, ['options' => 'cas']);

        $tx->unwatch('foo');
    }

    /**
     * @group disconnected
     */
    public function testExecutionWithFluentInterface(): void
    {
        $commands = [];
        $expected = ['one', 'two', 'three'];

        $callback = $this->getExecuteCallback($expected, $commands);
        $tx = $this->getMockedTransaction($callback);

        $this->assertSame($expected, $tx->echo('one')->echo('two')->echo('three')->execute());
        $this->assertSame(['MULTI', 'ECHO', 'ECHO', 'ECHO', 'EXEC'], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testExecutionWithCallable(): void
    {
        $commands = [];
        $expected = ['one', 'two', 'three'];

        $callback = $this->getExecuteCallback($expected, $commands);
        $tx = $this->getMockedTransaction($callback);

        $responses = $tx->execute(function ($tx) {
            $tx->echo('one');
            $tx->echo('two');
            $tx->echo('three');
        });

        $this->assertSame($expected, $responses);
        $this->assertSame(['MULTI', 'ECHO', 'ECHO', 'ECHO', 'EXEC'], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testCannotMixExecutionWithFluentInterfaceAndCallable(): void
    {
        $commands = [];

        $callback = $this->getExecuteCallback(null, $commands);
        $tx = $this->getMockedTransaction($callback);

        $exception = null;

        try {
            $tx->echo('foo')->execute(function ($tx) {
                $tx->echo('bar');
            });
        } catch (Exception $ex) {
            $exception = $ex;
        }

        $this->assertInstanceOf('Predis\ClientException', $exception);
        $this->assertSame(['MULTI', 'ECHO', 'DISCARD'], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testEmptyTransactionDoesNotSendMultiExecCommands(): void
    {
        $commands = [];

        $callback = $this->getExecuteCallback(null, $commands);
        $tx = $this->getMockedTransaction($callback);

        $responses = $tx->execute(function ($tx) {
            // NOOP
        });

        $this->assertNull($responses);
        $this->assertSame([], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnExecInsideTransactionBlock(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('Cannot invoke "execute" or "exec" inside an active transaction context');

        $commands = [];

        $callback = $this->getExecuteCallback(null, $commands);
        $tx = $this->getMockedTransaction($callback);

        $responses = $tx->execute(function ($tx) {
            $tx->exec();
        });

        $this->assertNull($responses);
        $this->assertSame([], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testEmptyTransactionIgnoresDiscard(): void
    {
        $commands = [];

        $callback = $this->getExecuteCallback(null, $commands);
        $tx = $this->getMockedTransaction($callback);

        $responses = $tx->execute(function ($tx) {
            $tx->discard();
        });

        $this->assertNull($responses);
        $this->assertSame([], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testTransactionWithCommandsSendsDiscard(): void
    {
        $commands = [];

        $callback = $this->getExecuteCallback(null, $commands);
        $tx = $this->getMockedTransaction($callback);

        $responses = $tx->execute(function ($tx) {
            $tx->set('foo', 'bar');
            $tx->get('foo');
            $tx->discard();
        });

        $this->assertNull($responses);
        $this->assertSame(['MULTI', 'SET', 'GET', 'DISCARD'], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testSendMultiOnCommandsFollowingDiscard(): void
    {
        $commands = [];
        $expected = ['after DISCARD'];

        $callback = $this->getExecuteCallback($expected, $commands);
        $tx = $this->getMockedTransaction($callback);

        $responses = $tx->execute(function ($tx) {
            $tx->echo('before DISCARD');
            $tx->discard();
            $tx->echo('after DISCARD');
        });

        $this->assertSame($responses, $expected);
        $this->assertSame(['MULTI', 'ECHO', 'DISCARD', 'MULTI', 'ECHO', 'EXEC'], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnWatchInsideMulti(): void
    {
        $this->expectException('Predis\ClientException');

        $callback = $this->getExecuteCallback();
        $tx = $this->getMockedTransaction($callback);

        $tx->echo('foobar')->watch('foo')->execute();
    }

    /**
     * @group disconnected
     */
    public function testUnwatchInsideMulti(): void
    {
        $commands = [];
        $expected = ['foobar', true];

        $callback = $this->getExecuteCallback($expected, $commands);
        $tx = $this->getMockedTransaction($callback);

        $responses = $tx->echo('foobar')->unwatch('foo')->execute();

        $this->assertSame($responses, $expected);
        $this->assertSame(['MULTI', 'ECHO', 'UNWATCH', 'EXEC'], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testAutomaticWatchInOptions(): void
    {
        $txCommands = $casCommands = [];
        $expected = ['bar', 'piyo'];
        $options = ['watch' => ['foo', 'hoge']];

        $callback = $this->getExecuteCallback($expected, $txCommands, $casCommands);
        $tx = $this->getMockedTransaction($callback, $options);

        $responses = $tx->execute(function ($tx) {
            $tx->get('foo');
            $tx->get('hoge');
        });

        $this->assertSame($responses, $expected);
        $this->assertSame(['WATCH'], self::commandsToIDs($casCommands));
        $this->assertSame(['foo', 'hoge'], $casCommands[0]->getArguments());
        $this->assertSame(['MULTI', 'GET', 'GET', 'EXEC'], self::commandsToIDs($txCommands));
    }

    /**
     * @group disconnected
     */
    public function testCheckAndSetWithFluentInterface(): void
    {
        $txCommands = $casCommands = [];
        $expected = ['bar', 'piyo'];
        $options = ['cas' => true, 'watch' => ['foo', 'hoge']];

        $callback = $this->getExecuteCallback($expected, $txCommands, $casCommands);
        $tx = $this->getMockedTransaction($callback, $options);

        $tx->watch('foobar');
        $this->assertSame('DUMMY_RESPONSE', $tx->get('foo'));
        $this->assertSame('DUMMY_RESPONSE', $tx->get('hoge'));

        $responses = $tx
            ->multi()
            ->get('foo')
            ->get('hoge')
            ->execute();

        $this->assertSame($responses, $expected);
        $this->assertSame(['WATCH', 'WATCH', 'GET', 'GET'], self::commandsToIDs($casCommands));
        $this->assertSame(['MULTI', 'GET', 'GET', 'EXEC'], self::commandsToIDs($txCommands));
    }

    /**
     * @group disconnected
     */
    public function testCheckAndSetWithBlock(): void
    {
        $txCommands = $casCommands = [];
        $expected = ['bar', 'piyo'];
        $options = ['cas' => true, 'watch' => ['foo', 'hoge']];

        $callback = $this->getExecuteCallback($expected, $txCommands, $casCommands);
        $tx = $this->getMockedTransaction($callback, $options);

        $test = $this;
        $responses = $tx->execute(function ($tx) use ($test) {
            $tx->watch('foobar');

            $response1 = $tx->get('foo');
            $response2 = $tx->get('hoge');

            $test->assertSame('DUMMY_RESPONSE', $response1);
            $test->assertSame('DUMMY_RESPONSE', $response2);

            $tx->multi();

            $tx->get('foo');
            $tx->get('hoge');
        });

        $this->assertSame($responses, $expected);
        $this->assertSame(['WATCH', 'WATCH', 'GET', 'GET'], self::commandsToIDs($casCommands));
        $this->assertSame(['MULTI', 'GET', 'GET', 'EXEC'], self::commandsToIDs($txCommands));
    }

    /**
     * @group disconnected
     */
    public function testCheckAndSetWithEmptyBlock(): void
    {
        $txCommands = $casCommands = [];
        $options = ['cas' => true];

        $callback = $this->getExecuteCallback([], $txCommands, $casCommands);
        $tx = $this->getMockedTransaction($callback, $options);

        $tx->execute(function ($tx) {
            $tx->multi();
        });

        $this->assertSame([], self::commandsToIDs($casCommands));
        $this->assertSame([], self::commandsToIDs($txCommands));
    }

    /**
     * @group disconnected
     */
    public function testCheckAndSetWithoutExec(): void
    {
        $txCommands = $casCommands = [];
        $options = ['cas' => true];

        $callback = $this->getExecuteCallback([], $txCommands, $casCommands);
        $tx = $this->getMockedTransaction($callback, $options);

        $tx->execute(function ($tx) {
            $tx->get('foo');
            $tx->set('hoge', 'piyo');
        });

        $this->assertSame(['GET', 'SET'], self::commandsToIDs($casCommands));
        $this->assertSame([], self::commandsToIDs($txCommands));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnAutomaticRetriesWithFluentInterface(): void
    {
        $this->expectException('Predis\ClientException');
        $this->expectExceptionMessage('Automatic retries are supported only when a callable block is provided');

        $options = ['retry' => 1];

        $callback = $this->getExecuteCallback();
        $tx = $this->getMockedTransaction($callback, $options);

        $tx->echo('message')->execute();
    }

    /**
     * @group disconnected
     */
    public function testAutomaticRetryOnServerSideTransactionAbort(): void
    {
        $casCommands = $txCommands = [];
        $expected = ['bar'];
        $options = ['watch' => ['foo', 'bar'], 'retry' => ($attempts = 2) + 1];

        $signal = $this->getMockBuilder('stdClass')
            ->addMethods(['__invoke'])
            ->getMock();
        $signal
            ->expects($this->exactly($attempts))
            ->method('__invoke');

        $callback = $this->getExecuteCallback($expected, $txCommands, $casCommands);
        $tx = $this->getMockedTransaction($callback, $options);

        $responses = $tx->execute(function (MultiExec $tx) use ($signal, &$attempts) {
            $tx->get('foo');

            if ($attempts > 0) {
                $attempts--;
                $signal();

                $tx->echo('!!ABORT!!');
            }
        });

        $this->assertSame($responses, $expected);
        $this->assertSame(['WATCH'], self::commandsToIDs($casCommands));
        $this->assertSame(['foo', 'bar'], $casCommands[0]->getArguments());
        $this->assertSame(['MULTI', 'GET', 'EXEC'], self::commandsToIDs($txCommands));
    }

    /**
     * @group disconnected
     */
    public function testThrowsExceptionOnServerSideTransactionAbort(): void
    {
        $this->expectException('Predis\Transaction\AbortedMultiExecException');

        $callback = $this->getExecuteCallback();
        $tx = $this->getMockedTransaction($callback);

        $tx->execute(function ($tx) {
            $tx->echo('!!ABORT!!');
        });
    }

    /**
     * @group disconnected
     */
    public function testHandlesStandardExceptionsInBlock(): void
    {
        $commands = [];
        $expected = ['foobar', true];

        $callback = $this->getExecuteCallback($expected, $commands);
        $tx = $this->getMockedTransaction($callback);

        $responses = null;

        try {
            $responses = $tx->execute(function (MultiExec $tx) {
                $tx->set('foo', 'bar');
                $tx->get('foo');

                throw new RuntimeException('TEST');
            });
        } catch (Exception $ex) {
            // NOOP
        }

        $this->assertNull($responses);
        $this->assertIsArray($expected);
        $this->assertSame(['MULTI', 'SET', 'GET', 'DISCARD'], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testHandlesServerExceptionsInBlock(): void
    {
        $commands = [];
        $expected = ['foobar', true];

        $callback = $this->getExecuteCallback($expected, $commands);
        $tx = $this->getMockedTransaction($callback);

        $responses = null;

        try {
            $responses = $tx->execute(function (MultiExec $tx) {
                $tx->set('foo', 'bar');
                $tx->echo('ERR Invalid operation');
                $tx->get('foo');
            });
        } catch (Response\ServerException $ex) {
            $tx->discard();
        }

        $this->assertNull($responses);
        $this->assertSame(['MULTI', 'SET', 'ECHO', 'DISCARD'], self::commandsToIDs($commands));
    }

    /**
     * @group disconnected
     */
    public function testProperlyDiscardsTransactionAfterServerExceptionInBlock(): void
    {
        $connection = $this->getMockedConnection(function (CommandInterface $command) {
            switch ($command->getId()) {
                case 'MULTI':
                    return true;

                case 'ECHO':
                    return new Response\Error('ERR simulated failure on ECHO');

                case 'EXEC':
                    return new Response\Error('EXECABORT Transaction discarded because of previous errors.');

                default:
                    return new Response\Status('QUEUED');
            }
        });

        $client = new Client($connection);

        // First attempt
        $tx = new MultiExec($client);

        try {
            $tx->multi()->set('foo', 'bar')->echo('simulated failure')->exec();
        } catch (Exception $exception) {
            $this->assertInstanceOf('Predis\Transaction\AbortedMultiExecException', $exception);
            $this->assertSame('ERR simulated failure on ECHO', $exception->getMessage());
        }

        // Second attempt
        $tx = new MultiExec($client);

        try {
            $tx->multi()->set('foo', 'bar')->echo('simulated failure')->exec();
        } catch (Exception $exception) {
            $this->assertInstanceOf('Predis\Transaction\AbortedMultiExecException', $exception);
            $this->assertSame('ERR simulated failure on ECHO', $exception->getMessage());
        }
    }

    /**
     * @group disconnected
     */
    public function testExceptionsOptionTakesPrecedenceOverClientOptionsWhenFalse(): void
    {
        $expected = ['before', new Response\Error('ERR simulated error'), 'after'];

        $connection = $this->getMockedConnection(function (CommandInterface $command) use ($expected) {
            switch ($command->getId()) {
                case 'MULTI':
                    return true;

                case 'EXEC':
                    return $expected;

                default:
                    return new Response\Status('QUEUED');
            }
        });

        $client = new Client($connection, ['exceptions' => true]);
        $tx = new MultiExec($client, ['exceptions' => false]);

        $result = $tx
            ->multi()
            ->echo('before')
            ->echo('ERROR PLEASE!')
            ->echo('after')
            ->exec();

        $this->assertSame($expected, $result);
    }

    /**
     * @group disconnected
     */
    public function testExceptionsOptionTakesPrecedenceOverClientOptionsWhenTrue(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR simulated error');

        $expected = ['before', new Response\Error('ERR simulated error'), 'after'];

        $connection = $this->getMockedConnection(function (CommandInterface $command) use ($expected) {
            switch ($command->getId()) {
                case 'MULTI':
                    return true;

                case 'EXEC':
                    return $expected;

                default:
                    return new Response\Status('QUEUED');
            }
        });

        $client = new Client($connection, ['exceptions' => false]);
        $tx = new MultiExec($client, ['exceptions' => true]);

        $tx->multi()->echo('before')->echo('ERROR PLEASE!')->echo('after')->exec();
    }

    /**
     * @group disconnected
     */
    public function testExceptionsOptionDoesNotAffectTransactionControlCommands(): void
    {
        $this->expectException('Predis\Response\ServerException');
        $this->expectExceptionMessage('ERR simulated failure on EXEC');

        $connection = $this->getMockedConnection(function (CommandInterface $command) {
            switch ($command->getId()) {
                case 'MULTI':
                    return true;

                case 'EXEC':
                    return new Response\Error('ERR simulated failure on EXEC');

                default:
                    return new Response\Status('QUEUED');
            }
        });

        $client = new Client($connection, ['exceptions' => false]);
        $tx = new MultiExec($client);

        $tx->multi()->echo('test')->exec();
    }

    // ******************************************************************** //
    // ---- INTEGRATION TESTS --------------------------------------------- //
    // ******************************************************************** //

    /**
     * @group connected
     */
    public function testIntegrationHandlesStandardExceptionsInBlock(): void
    {
        $client = $this->getClient();
        $exception = null;

        try {
            $client->transaction(function (MultiExec $tx) {
                $tx->set('foo', 'bar');
                throw new RuntimeException('TEST');
            });
        } catch (Exception $ex) {
            $exception = $ex;
        }

        $this->assertInstanceOf('RuntimeException', $exception);
        $this->assertSame(0, $client->exists('foo'));
    }

    /**
     * @group connected
     */
    public function testIntegrationThrowsExceptionOnRedisErrorInBlock(): void
    {
        $client = $this->getClient();
        $exception = null;
        $value = (string) rand();

        try {
            $client->transaction(function (MultiExec $tx) use ($value) {
                $tx->set('foo', 'bar');
                $tx->lpush('foo', 'bar');
                $tx->set('foo', $value);
            });
        } catch (Response\ServerException $ex) {
            $exception = $ex;
        }

        $this->assertInstanceOf('Predis\Response\ErrorInterface', $exception);
        $this->assertSame($value, $client->get('foo'));
    }

    /**
     * @group connected
     * @group relay-incompatible
     */
    public function testIntegrationReturnsErrorObjectOnRedisErrorInBlock(): void
    {
        $client = $this->getClient([], ['exceptions' => false]);

        $responses = $client->transaction(function (MultiExec $tx) {
            $tx->set('foo', 'bar');
            $tx->lpush('foo', 'bar');
            $tx->echo('foobar');
        });

        $this->assertInstanceOf('Predis\Response\Status', $responses[0]);
        $this->assertInstanceOf('Predis\Response\Error', $responses[1]);
        $this->assertSame('foobar', $responses[2]);
    }

    /**
     * @group connected
     * @group ext-relay
     */
    public function testIntegrationReturnsErrorObjectOnRedisErrorInBlockWhenUsingRelay(): void
    {
        $client = $this->getClient([], ['exceptions' => false]);

        $responses = $client->transaction(function (MultiExec $tx) {
            $tx->set('foo', 'bar');
            $tx->lpush('foo', 'bar');
            $tx->echo('foobar');
        });

        $this->assertSame('OK', $responses[0]);
        $this->assertInstanceOf('Predis\Response\Error', $responses[1]);
        $this->assertSame('foobar', $responses[2]);
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.0.0
     */
    public function testIntegrationSendMultiOnCommandsAfterDiscard(): void
    {
        $client = $this->getClient();

        $responses = $client->transaction(function (MultiExec $tx) {
            $tx->set('foo', 'bar');
            $tx->discard();
            $tx->set('hoge', 'piyo');
        });

        $this->assertCount(1, $responses);
        $this->assertSame(0, $client->exists('foo'));
        $this->assertSame(1, $client->exists('hoge'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testIntegrationWritesOnWatchedKeysAbortTransaction(): void
    {
        $exception = null;
        $client1 = $this->getClient();
        $client2 = $this->getClient();

        try {
            $client1->transaction(['watch' => 'sentinel'], function ($tx) use ($client2) {
                $tx->set('sentinel', 'client1');
                $tx->get('sentinel');
                $client2->set('sentinel', 'client2');
            });
        } catch (AbortedMultiExecException $ex) {
            $exception = $ex;
        }

        $this->assertInstanceOf('Predis\Transaction\AbortedMultiExecException', $exception);
        $this->assertSame('client2', $client1->get('sentinel'));
    }

    /**
     * @group connected
     * @requiresRedisVersion >= 2.2.0
     */
    public function testIntegrationCheckAndSetWithDiscardAndRetry(): void
    {
        $client = $this->getClient();

        $client->set('foo', 'bar');
        $options = ['watch' => 'foo', 'cas' => true];

        $responses = $client->transaction($options, function ($tx) {
            $tx->watch('foobar');
            $foo = $tx->get('foo');

            $tx->multi();
            $tx->set('foobar', $foo);
            $tx->discard();
            $tx->mget('foo', 'foobar');
        });

        $this->assertIsArray($responses);
        $this->assertSame([['bar', null]], $responses);

        $hijack = true;
        $client2 = $this->getClient();
        $client->set('foo', 'bar');

        $options = ['watch' => 'foo', 'cas' => true, 'retry' => 1];
        $responses = $client->transaction($options, function ($tx) use ($client2, &$hijack) {
            $foo = $tx->get('foo');
            $tx->multi();

            $tx->set('foobar', $foo);
            $tx->discard();

            if ($hijack) {
                $hijack = false;
                $client2->set('foo', 'hijacked!');
            }

            $tx->mget('foo', 'foobar');
        });

        $this->assertIsArray($responses);
        $this->assertSame([['hijacked!', null]], $responses);
    }

    // ******************************************************************** //
    // ---- HELPER METHODS ------------------------------------------------ //
    // ******************************************************************** //

    /**
     * Returns a mocked instance of Predis\Connection\NodeConnectionInterface
     * using the specified callback to return values from executeCommand().
     *
     * @param callable $executeCallback
     *
     * @return NodeConnectionInterface|MockObject
     */
    protected function getMockedConnection(callable $executeCallback)
    {
        $connection = $this->getMockBuilder('Predis\Connection\NodeConnectionInterface')->getMock();
        $connection
            ->expects($this->any())
            ->method('executeCommand')
            ->willReturnCallback($executeCallback);

        return $connection;
    }

    /**
     * Returns a mocked instance of Predis\Transaction\MultiExec using
     * the specified callback to return values from the executeCommand method
     * of the underlying connection.
     *
     * @param callable $executeCallback
     * @param array    $txOpts
     * @param array    $clientOpts
     *
     * @return MultiExec
     */
    protected function getMockedTransaction($executeCallback, $txOpts = null, $clientOpts = null): MultiExec
    {
        $connection = $this->getMockedConnection($executeCallback);
        $client = new Client($connection, $clientOpts ?: []);
        $transaction = new MultiExec($client, $txOpts ?: []);

        return $transaction;
    }

    /**
     * Returns a callback emulating a server-side MULTI/EXEC context.
     *
     * @param ?array $expected List of expected responses
     * @param ?array $commands Reference to an array storing the whole flow of commands
     * @param ?array $cas      Reference to an array storing CAS operations performed by the transaction
     *
     * @return callable
     */
    protected function getExecuteCallback(
        ?array $expected = [],
        ?array &$commands = [],
        ?array &$cas = []
    ): callable {
        $multi = $watch = $abort = false;

        return function (CommandInterface $command) use (&$expected, &$commands, &$cas, &$multi, &$watch, &$abort) {
            $cmd = $command->getId();

            if ($multi || $cmd === 'MULTI') {
                $commands[] = $command;
            } else {
                $cas[] = $command;
            }

            switch ($cmd) {
                case 'WATCH':
                    if ($multi) {
                        return new Response\Error("ERR $cmd inside MULTI is not allowed");
                    }

                    return $watch = true;

                case 'MULTI':
                    if ($multi) {
                        return new Response\Error('ERR MULTI calls can not be nested');
                    }

                    return $multi = true;

                case 'EXEC':
                    if (!$multi) {
                        return new Response\Error("ERR $cmd without MULTI");
                    }

                    $watch = $multi = false;

                    if ($abort) {
                        $commands = $cas = [];
                        $abort = false;

                        return;
                    }

                    return $expected;

                case 'DISCARD':
                    if (!$multi) {
                        return new Response\Error("ERR $cmd without MULTI");
                    }

                    $watch = $multi = false;

                    return true;

                case 'ECHO':
                    @[$trigger] = $command->getArguments();
                    if (strpos($trigger, 'ERR ') === 0) {
                        throw new Response\ServerException($trigger);
                    }

                    if ($trigger === '!!ABORT!!' && $multi) {
                        $abort = true;
                    }

                    return new Response\Status('QUEUED');

                case 'UNWATCH':
                    $watch = false;
                    // no break

                default:
                    return $multi ? new Response\Status('QUEUED') : 'DUMMY_RESPONSE';
            }
        };
    }

    /**
     * Converts an array of command instances to an array of command IDs.
     *
     * @param CommandInterface[] $commands List of commands instances
     *
     * @return array
     */
    protected static function commandsToIDs(array $commands): array
    {
        return array_map(function ($cmd) { return $cmd->getId(); }, $commands);
    }

    /**
     * Returns a client instance connected to the specified Redis
     * server instance to perform integration tests.
     *
     * @param array $parameters Additional connection parameters
     * @param array $options    Additional client options
     *
     * @return ClientInterface
     */
    protected function getClient(array $parameters = [], array $options = []): ClientInterface
    {
        return $this->createClient($parameters, $options);
    }
}


